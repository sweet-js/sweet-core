define("sweet", [], function() { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.compile = compile;

	var _sweet = __webpack_require__(2);

	var _storeLoader = __webpack_require__(4);

	var _storeLoader2 = _interopRequireDefault(_storeLoader);

	var _store = __webpack_require__(72);

	var _store2 = _interopRequireDefault(_store);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class BrowserStoreLoader extends _storeLoader2.default {

	  constructor(baseDir, store) {
	    super(baseDir, store, true);
	  }

	  fetch({ name, address }) {
	    if (this.store.has(address.path)) {
	      return this.store.get(address.path);
	    }
	    throw new Error(`The module ${ name } is not in the debug store: addr.path is ${ address.path }`);
	  }

	  freshStore() {
	    return new _store2.default({});
	  }

	  eval(source, store) {
	    return (0, eval)(source);
	  }
	}

	function compile(source) {
	  let s = new Map();
	  s.set('main.js', source);
	  let loader = new BrowserStoreLoader('.', s);
	  return (0, _sweet.compile)('main.js', loader);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9icm93c2VyLXN3ZWV0LmpzIl0sIm5hbWVzIjpbImNvbXBpbGUiLCJCcm93c2VyU3RvcmVMb2FkZXIiLCJjb25zdHJ1Y3RvciIsImJhc2VEaXIiLCJzdG9yZSIsImZldGNoIiwibmFtZSIsImFkZHJlc3MiLCJoYXMiLCJwYXRoIiwiZ2V0IiwiRXJyb3IiLCJmcmVzaFN0b3JlIiwiZXZhbCIsInNvdXJjZSIsInMiLCJNYXAiLCJzZXQiLCJsb2FkZXIiXSwibWFwcGluZ3MiOiI7Ozs7O1FBMkJnQkEsTyxHQUFBQSxPOztBQTNCaEI7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUMsa0JBQU4sK0JBQTZDOztBQUczQ0MsY0FBWUMsT0FBWixFQUE2QkMsS0FBN0IsRUFBeUQ7QUFDdkQsVUFBTUQsT0FBTixFQUFlQyxLQUFmLEVBQXNCLElBQXRCO0FBQ0Q7O0FBRURDLFFBQU0sRUFBRUMsSUFBRixFQUFRQyxPQUFSLEVBQU4sRUFBd0Q7QUFDdEQsUUFBSSxLQUFLSCxLQUFMLENBQVdJLEdBQVgsQ0FBZUQsUUFBUUUsSUFBdkIsQ0FBSixFQUFrQztBQUNoQyxhQUFPLEtBQUtMLEtBQUwsQ0FBV00sR0FBWCxDQUFlSCxRQUFRRSxJQUF2QixDQUFQO0FBQ0Q7QUFDRCxVQUFNLElBQUlFLEtBQUosQ0FBVyxlQUFhTCxJQUFLLDhDQUEyQ0MsUUFBUUUsSUFBSyxHQUFyRixDQUFOO0FBQ0Q7O0FBRURHLGVBQWE7QUFDWCxXQUFPLG9CQUFVLEVBQVYsQ0FBUDtBQUNEOztBQUVEQyxPQUFLQyxNQUFMLEVBQXFCVixLQUFyQixFQUFtQztBQUNqQyxXQUFPLENBQUMsR0FBR1MsSUFBSixFQUFVQyxNQUFWLENBQVA7QUFDRDtBQXBCMEM7O0FBdUJ0QyxTQUFTZCxPQUFULENBQWlCYyxNQUFqQixFQUF5QjtBQUM5QixNQUFJQyxJQUFJLElBQUlDLEdBQUosRUFBUjtBQUNBRCxJQUFFRSxHQUFGLENBQU0sU0FBTixFQUFpQkgsTUFBakI7QUFDQSxNQUFJSSxTQUFTLElBQUlqQixrQkFBSixDQUF1QixHQUF2QixFQUE0QmMsQ0FBNUIsQ0FBYjtBQUNBLFNBQU8sb0JBQWEsU0FBYixFQUF3QkcsTUFBeEIsQ0FBUDtBQUNEIiwiZmlsZSI6ImJyb3dzZXItc3dlZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21waWxlIGFzIHN3ZWV0Q29tcGlsZSB9IGZyb20gJy4vc3dlZXQnO1xuaW1wb3J0IFN0b3JlTG9hZGVyIGZyb20gJy4vc3RvcmUtbG9hZGVyJztcbmltcG9ydCBTdG9yZSBmcm9tICcuL3N0b3JlJztcblxuY2xhc3MgQnJvd3NlclN0b3JlTG9hZGVyIGV4dGVuZHMgU3RvcmVMb2FkZXIge1xuICBzdG9yZTogTWFwPHN0cmluZywgc3RyaW5nPjtcblxuICBjb25zdHJ1Y3RvcihiYXNlRGlyOiBzdHJpbmcsIHN0b3JlOiBNYXA8c3RyaW5nLCBzdHJpbmc+KSB7XG4gICAgc3VwZXIoYmFzZURpciwgc3RvcmUsIHRydWUpO1xuICB9XG5cbiAgZmV0Y2goeyBuYW1lLCBhZGRyZXNzIH06IHsgbmFtZTogc3RyaW5nLCBhZGRyZXNzOiBhbnl9KSB7XG4gICAgaWYgKHRoaXMuc3RvcmUuaGFzKGFkZHJlc3MucGF0aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldChhZGRyZXNzLnBhdGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtb2R1bGUgJHtuYW1lfSBpcyBub3QgaW4gdGhlIGRlYnVnIHN0b3JlOiBhZGRyLnBhdGggaXMgJHthZGRyZXNzLnBhdGh9YCk7XG4gIH1cblxuICBmcmVzaFN0b3JlKCkge1xuICAgIHJldHVybiBuZXcgU3RvcmUoe30pO1xuICB9XG4gIFxuICBldmFsKHNvdXJjZTogc3RyaW5nLCBzdG9yZTogU3RvcmUpIHtcbiAgICByZXR1cm4gKDAsIGV2YWwpKHNvdXJjZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUoc291cmNlKSB7XG4gIGxldCBzID0gbmV3IE1hcCgpO1xuICBzLnNldCgnbWFpbi5qcycsIHNvdXJjZSk7XG4gIGxldCBsb2FkZXIgPSBuZXcgQnJvd3NlclN0b3JlTG9hZGVyKCcuJywgcyk7XG4gIHJldHVybiBzd2VldENvbXBpbGUoJ21haW4uanMnLCBsb2FkZXIpO1xufSJdfQ==

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;
	exports.compile = compile;

	var _babelCore = __webpack_require__(3);

	function compileModule(entryPath, loader, refererName) {
	  return loader.compile(entryPath, refererName);
	}

	function parse(entryPath, loader, options) {
	  let refererName;
	  if (options != null) {
	    refererName = options.refererName;
	  }
	  return compileModule(entryPath, loader, refererName).parse();
	}

	function compile(entryPath, loader, options) {
	  let refererName,
	      noBabel = true;
	  if (options != null) {
	    refererName = options.refererName;
	    noBabel = options.noBabel;
	  }
	  let code = compileModule(entryPath, loader, refererName).codegen();
	  if (noBabel) {
	    return {
	      code
	    };
	  }
	  return (0, _babelCore.transform)(code, {
	    babelrc: true
	  });
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zd2VldC5qcyJdLCJuYW1lcyI6WyJwYXJzZSIsImNvbXBpbGUiLCJjb21waWxlTW9kdWxlIiwiZW50cnlQYXRoIiwibG9hZGVyIiwicmVmZXJlck5hbWUiLCJvcHRpb25zIiwibm9CYWJlbCIsImNvZGUiLCJjb2RlZ2VuIiwiYmFiZWxyYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFlZ0JBLEssR0FBQUEsSztRQVFBQyxPLEdBQUFBLE87O0FBckJoQjs7QUFTQSxTQUFTQyxhQUFULENBQXVCQyxTQUF2QixFQUEwQ0MsTUFBMUMsRUFBK0RDLFdBQS9ELEVBQXFGO0FBQ25GLFNBQU9ELE9BQU9ILE9BQVAsQ0FBZUUsU0FBZixFQUEwQkUsV0FBMUIsQ0FBUDtBQUNEOztBQUVNLFNBQVNMLEtBQVQsQ0FBZUcsU0FBZixFQUFrQ0MsTUFBbEMsRUFBdURFLE9BQXZELEVBQWlGO0FBQ3RGLE1BQUlELFdBQUo7QUFDQSxNQUFJQyxXQUFXLElBQWYsRUFBcUI7QUFDbkJELGtCQUFjQyxRQUFRRCxXQUF0QjtBQUNEO0FBQ0QsU0FBT0gsY0FBY0MsU0FBZCxFQUF5QkMsTUFBekIsRUFBaUNDLFdBQWpDLEVBQThDTCxLQUE5QyxFQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsT0FBVCxDQUFpQkUsU0FBakIsRUFBb0NDLE1BQXBDLEVBQXlERSxPQUF6RCxFQUFtRjtBQUN4RixNQUFJRCxXQUFKO0FBQUEsTUFBaUJFLFVBQVUsSUFBM0I7QUFDQSxNQUFJRCxXQUFXLElBQWYsRUFBcUI7QUFDbkJELGtCQUFjQyxRQUFRRCxXQUF0QjtBQUNBRSxjQUFVRCxRQUFRQyxPQUFsQjtBQUNEO0FBQ0QsTUFBSUMsT0FBT04sY0FBY0MsU0FBZCxFQUF5QkMsTUFBekIsRUFBaUNDLFdBQWpDLEVBQThDSSxPQUE5QyxFQUFYO0FBQ0EsTUFBSUYsT0FBSixFQUFhO0FBQ1gsV0FBTztBQUNMQztBQURLLEtBQVA7QUFHRDtBQUNELFNBQU8sMEJBQU1BLElBQU4sRUFBWTtBQUNqQkUsYUFBUztBQURRLEdBQVosQ0FBUDtBQUdEIiwiZmlsZSI6InN3ZWV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIFN3ZWV0TG9hZGVyIGZyb20gJy4vc3dlZXQtbG9hZGVyJztcbmltcG9ydCB7IHRyYW5zZm9ybSBhcyBiYWJlbCB9IGZyb20gJ2JhYmVsLWNvcmUnO1xuXG50eXBlIENvbXBpbGVPcHRpb25zID0ge1xuICByZWZlcmVyTmFtZT86IHN0cmluZztcbiAgZGVidWdTdG9yZT86IE1hcDxzdHJpbmcsIHN0cmluZz47XG4gIG5vQmFiZWw/OiBib29sZWFuO1xuICBsb2FkZXI6IFN3ZWV0TG9hZGVyO1xufVxuXG5mdW5jdGlvbiBjb21waWxlTW9kdWxlKGVudHJ5UGF0aDogc3RyaW5nLCBsb2FkZXI6IFN3ZWV0TG9hZGVyLCByZWZlcmVyTmFtZT86IHN0cmluZykge1xuICByZXR1cm4gbG9hZGVyLmNvbXBpbGUoZW50cnlQYXRoLCByZWZlcmVyTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShlbnRyeVBhdGg6IHN0cmluZywgbG9hZGVyOiBTd2VldExvYWRlciwgb3B0aW9ucz86IENvbXBpbGVPcHRpb25zKSB7XG4gIGxldCByZWZlcmVyTmFtZTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHJlZmVyZXJOYW1lID0gb3B0aW9ucy5yZWZlcmVyTmFtZTsgXG4gIH1cbiAgcmV0dXJuIGNvbXBpbGVNb2R1bGUoZW50cnlQYXRoLCBsb2FkZXIsIHJlZmVyZXJOYW1lKS5wYXJzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZShlbnRyeVBhdGg6IHN0cmluZywgbG9hZGVyOiBTd2VldExvYWRlciwgb3B0aW9ucz86IENvbXBpbGVPcHRpb25zKSB7XG4gIGxldCByZWZlcmVyTmFtZSwgbm9CYWJlbCA9IHRydWU7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICByZWZlcmVyTmFtZSA9IG9wdGlvbnMucmVmZXJlck5hbWU7IFxuICAgIG5vQmFiZWwgPSBvcHRpb25zLm5vQmFiZWw7XG4gIH1cbiAgbGV0IGNvZGUgPSBjb21waWxlTW9kdWxlKGVudHJ5UGF0aCwgbG9hZGVyLCByZWZlcmVyTmFtZSkuY29kZWdlbigpXG4gIGlmIChub0JhYmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGVcbiAgICB9O1xuICB9XG4gIHJldHVybiBiYWJlbChjb2RlLCB7XG4gICAgYmFiZWxyYzogdHJ1ZVxuICB9KTtcbn0iXX0=

/***/ },
/* 3 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sweetLoader = __webpack_require__(5);

	var _sweetLoader2 = _interopRequireDefault(_sweetLoader);

	var _vm = __webpack_require__(73);

	var _vm2 = _interopRequireDefault(_vm);

	var _store = __webpack_require__(72);

	var _store2 = _interopRequireDefault(_store);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = class extends _sweetLoader2.default {

	  constructor(baseDir, store, noBabel = false) {
	    super(baseDir, noBabel);
	    this.store = store;
	  }

	  fetch({ name, address }) {
	    if (this.store.has(address.path)) {
	      return this.store.get(address.path);
	    }
	    throw new Error(`The module ${ name } is not in the debug store: addr.path is ${ address.path }`);
	  }

	  freshStore() {
	    return new _store2.default(_vm2.default.createContext());
	  }

	  eval(source, store) {
	    return _vm2.default.runInContext(source, store.getBackingObject());
	  }
	};
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZS1sb2FkZXIuanMiXSwibmFtZXMiOlsiY29uc3RydWN0b3IiLCJiYXNlRGlyIiwic3RvcmUiLCJub0JhYmVsIiwiZmV0Y2giLCJuYW1lIiwiYWRkcmVzcyIsImhhcyIsInBhdGgiLCJnZXQiLCJFcnJvciIsImZyZXNoU3RvcmUiLCJjcmVhdGVDb250ZXh0IiwiZXZhbCIsInNvdXJjZSIsInJ1bkluQ29udGV4dCIsImdldEJhY2tpbmdPYmplY3QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O2tCQUdlLG9DQUEwQjs7QUFHdkNBLGNBQVlDLE9BQVosRUFBNkJDLEtBQTdCLEVBQXlEQyxVQUFtQixLQUE1RSxFQUFtRjtBQUNqRixVQUFNRixPQUFOLEVBQWVFLE9BQWY7QUFDQSxTQUFLRCxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7QUFFREUsUUFBTSxFQUFFQyxJQUFGLEVBQVFDLE9BQVIsRUFBTixFQUF3RDtBQUN0RCxRQUFJLEtBQUtKLEtBQUwsQ0FBV0ssR0FBWCxDQUFlRCxRQUFRRSxJQUF2QixDQUFKLEVBQWtDO0FBQ2hDLGFBQU8sS0FBS04sS0FBTCxDQUFXTyxHQUFYLENBQWVILFFBQVFFLElBQXZCLENBQVA7QUFDRDtBQUNELFVBQU0sSUFBSUUsS0FBSixDQUFXLGVBQWFMLElBQUssOENBQTJDQyxRQUFRRSxJQUFLLEdBQXJGLENBQU47QUFDRDs7QUFFREcsZUFBYTtBQUNYLFdBQU8sb0JBQVUsYUFBR0MsYUFBSCxFQUFWLENBQVA7QUFDRDs7QUFFREMsT0FBS0MsTUFBTCxFQUFxQlosS0FBckIsRUFBbUM7QUFDakMsV0FBTyxhQUFHYSxZQUFILENBQWdCRCxNQUFoQixFQUF3QlosTUFBTWMsZ0JBQU4sRUFBeEIsQ0FBUDtBQUNEO0FBckJzQyxDIiwiZmlsZSI6InN0b3JlLWxvYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgU3dlZXRMb2FkZXIgZnJvbSAnLi9zd2VldC1sb2FkZXInO1xuaW1wb3J0IHZtIGZyb20gJ3ZtJztcbmltcG9ydCBTdG9yZSBmcm9tICcuL3N0b3JlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFN3ZWV0TG9hZGVyIHtcbiAgc3RvcmU6IE1hcDxzdHJpbmcsIHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IoYmFzZURpcjogc3RyaW5nLCBzdG9yZTogTWFwPHN0cmluZywgc3RyaW5nPiwgbm9CYWJlbDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoYmFzZURpciwgbm9CYWJlbCk7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICB9XG5cbiAgZmV0Y2goeyBuYW1lLCBhZGRyZXNzIH06IHsgbmFtZTogc3RyaW5nLCBhZGRyZXNzOiBhbnl9KSB7XG4gICAgaWYgKHRoaXMuc3RvcmUuaGFzKGFkZHJlc3MucGF0aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldChhZGRyZXNzLnBhdGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtb2R1bGUgJHtuYW1lfSBpcyBub3QgaW4gdGhlIGRlYnVnIHN0b3JlOiBhZGRyLnBhdGggaXMgJHthZGRyZXNzLnBhdGh9YCk7XG4gIH1cblxuICBmcmVzaFN0b3JlKCkge1xuICAgIHJldHVybiBuZXcgU3RvcmUodm0uY3JlYXRlQ29udGV4dCgpKTtcbiAgfVxuICBcbiAgZXZhbChzb3VyY2U6IHN0cmluZywgc3RvcmU6IFN0b3JlKSB7XG4gICAgcmV0dXJuIHZtLnJ1bkluQ29udGV4dChzb3VyY2UsIHN0b3JlLmdldEJhY2tpbmdPYmplY3QoKSk7XG4gIH1cbn0iXX0=

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.phaseInModulePathRegexp = undefined;

	var _tokenReader = __webpack_require__(6);

	var _tokenReader2 = _interopRequireDefault(_tokenReader);

	var _scope = __webpack_require__(42);

	var _env = __webpack_require__(44);

	var _env2 = _interopRequireDefault(_env);

	var _immutable = __webpack_require__(10);

	var _compiler = __webpack_require__(46);

	var _compiler2 = _interopRequireDefault(_compiler);

	var _syntax = __webpack_require__(38);

	var _bindingMap = __webpack_require__(40);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _sweetSpec = __webpack_require__(41);

	var _sweetSpec2 = _interopRequireDefault(_sweetSpec);

	var _sweetModule = __webpack_require__(70);

	var _sweetModule2 = _interopRequireDefault(_sweetModule);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _scopeReducer = __webpack_require__(50);

	var _scopeReducer2 = _interopRequireDefault(_scopeReducer);

	var _macroContext = __webpack_require__(64);

	var _babelCore = __webpack_require__(3);

	var _store = __webpack_require__(72);

	var _store2 = _interopRequireDefault(_store);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const phaseInModulePathRegexp = exports.phaseInModulePathRegexp = /(.*):(\d+)\s*$/;

	class SweetLoader {

	  constructor(baseDir, noBabel = false) {
	    this.sourceCache = new Map();
	    this.compiledCache = new Map();
	    this.baseDir = baseDir;

	    let bindings = new _bindingMap2.default();
	    let templateMap = new Map();
	    let tempIdent = 0;
	    this.context = {
	      bindings,
	      templateMap,
	      getTemplateIdentifier: () => ++tempIdent,
	      loader: this,
	      transform: c => {
	        if (noBabel) {
	          return {
	            code: c
	          };
	        }
	        return (0, _babelCore.transform)(c, {
	          babelrc: true
	        });
	      }
	    };
	  }

	  normalize(name, refererName, refererAddress) {
	    // takes `..path/to/source.js:<phase>`
	    // gives `/abs/path/to/source.js:<phase>`
	    // missing phases are turned into 0
	    if (!phaseInModulePathRegexp.test(name)) {
	      return `${ name }:0`;
	    }
	    return name;
	  }

	  locate({ name, metadata }) {
	    // takes `/abs/path/to/source.js:<phase>`
	    // gives { path: '/abs/path/to/source.js', phase: <phase> }
	    let match = name.match(phaseInModulePathRegexp);
	    if (match && match.length >= 3) {
	      return {
	        path: match[1],
	        phase: parseInt(match[2], 10)
	      };
	    }
	    throw new Error(`Module ${ name } is missing phase information`);
	  }

	  fetch({ name, address, metadata }) {
	    throw new Error('No default fetch defined');
	  }

	  translate({ name, address, source, metadata }) {
	    let src = this.compiledCache.get(address.path);
	    if (src != null) {
	      return src;
	    }
	    let compiledModule = this.compileSource(source);
	    this.compiledCache.set(address.path, compiledModule);
	    return compiledModule;
	  }

	  instantiate({ name, address, source, metadata }) {
	    throw new Error('Not implemented yet');
	  }

	  eval(source) {
	    return (0, eval)(source);
	  }

	  load(entryPath) {
	    let metadata = {};
	    let name = this.normalize(entryPath);
	    let address = this.locate({ name, metadata });
	    let source = this.fetch({ name, address, metadata });
	    source = this.translate({ name, address, source, metadata });
	    return this.instantiate({ name, address, source, metadata });
	  }

	  // skip instantiate
	  compile(entryPath, refererName) {
	    let metadata = {};
	    let name = this.normalize(entryPath, refererName);
	    let address = this.locate({ name, metadata });
	    let source = this.fetch({ name, address, metadata });
	    return this.translate({ name, address, source, metadata });
	  }

	  get(entryPath, entryPhase) {
	    return this.compile(`${ entryPath }:${ entryPhase }`);
	  }

	  read(source) {
	    return (0, _macroContext.wrapInTerms)((0, _tokenReader2.default)(source));
	  }

	  freshStore() {
	    return new _store2.default({});
	  }

	  compileSource(source) {
	    let stxl = this.read(source);
	    let outScope = (0, _scope.freshScope)('outsideEdge');
	    let inScope = (0, _scope.freshScope)('insideEdge0');
	    // the compiler starts at phase 0, with an empty environment and store
	    let compiler = new _compiler2.default(0, new _env2.default(), this.freshStore(), _.merge(this.context, {
	      currentScope: [outScope, inScope]
	    }));
	    return new _sweetModule2.default(compiler.compile(stxl.map(s => s.reduce(new _scopeReducer2.default([{ scope: outScope, phase: _syntax.ALL_PHASES, flip: false }, { scope: inScope, phase: 0, flip: false }], this.context.bindings)))));
	  }
	}
	exports.default = SweetLoader;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zd2VldC1sb2FkZXIuanMiXSwibmFtZXMiOlsiXyIsInBoYXNlSW5Nb2R1bGVQYXRoUmVnZXhwIiwiU3dlZXRMb2FkZXIiLCJjb25zdHJ1Y3RvciIsImJhc2VEaXIiLCJub0JhYmVsIiwic291cmNlQ2FjaGUiLCJNYXAiLCJjb21waWxlZENhY2hlIiwiYmluZGluZ3MiLCJ0ZW1wbGF0ZU1hcCIsInRlbXBJZGVudCIsImNvbnRleHQiLCJnZXRUZW1wbGF0ZUlkZW50aWZpZXIiLCJsb2FkZXIiLCJ0cmFuc2Zvcm0iLCJjIiwiY29kZSIsImJhYmVscmMiLCJub3JtYWxpemUiLCJuYW1lIiwicmVmZXJlck5hbWUiLCJyZWZlcmVyQWRkcmVzcyIsInRlc3QiLCJsb2NhdGUiLCJtZXRhZGF0YSIsIm1hdGNoIiwibGVuZ3RoIiwicGF0aCIsInBoYXNlIiwicGFyc2VJbnQiLCJFcnJvciIsImZldGNoIiwiYWRkcmVzcyIsInRyYW5zbGF0ZSIsInNvdXJjZSIsInNyYyIsImdldCIsImNvbXBpbGVkTW9kdWxlIiwiY29tcGlsZVNvdXJjZSIsInNldCIsImluc3RhbnRpYXRlIiwiZXZhbCIsImxvYWQiLCJlbnRyeVBhdGgiLCJjb21waWxlIiwiZW50cnlQaGFzZSIsInJlYWQiLCJmcmVzaFN0b3JlIiwic3R4bCIsIm91dFNjb3BlIiwiaW5TY29wZSIsImNvbXBpbGVyIiwibWVyZ2UiLCJjdXJyZW50U2NvcGUiLCJtYXAiLCJzIiwicmVkdWNlIiwic2NvcGUiLCJmbGlwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlBLEM7O0FBQ1o7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFTyxNQUFNQyw0REFBMEIsZ0JBQWhDOztBQVVRLE1BQU1DLFdBQU4sQ0FBa0I7O0FBTS9CQyxjQUFZQyxPQUFaLEVBQTZCQyxVQUFtQixL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QStDaEQsRUFBRXFELEtBQUYsQ0FBUSxLQUFLekMsT0FBYixFQUFzQjtBQUNsRjBDLG9CQUFjLENBQUNKLFFBQUQsRUFBV0MsT0FBWDtBQURvRSxLQUF0QixDQUEvQyxDQUFmO0FBR0EsV0FBTywwQkFBZ0JDLFNBQVNQLE9BQVQsQ0FBaUJJLEtBQUtNLEdBQUwsQ0FBU0MsS0FBS0EsRUFBRUMsTUFBRixDQUFTLDJCQUFpQixDQUM5RSxFQUFFQyxPQUFPUixRQUFULEVBQW1CckIseUJBQW5CLEVBQXNDOEIsTUFBTSxLQUE1QyxFQUQ4RSxFQUU5RSxFQUFFRCxPQUFPUCxPQUFULEVBQWtCdEIsT0FBTyxDQUF6QixFQUE0QjhCLE1BQU0sS0FBbEMsRUFGOEUsQ0FBakIsRUFHN0QsS0FBSy9DLE9BQUwsQ0FBYUgsUUFIZ0QsQ0FBVCxDQUFkLENBQWpCLENBQWhCLENBQVA7QUFLRDtBQXhIOEI7a0JBQVpQLFciLCJmaWxlIjoic3dlZXQtbG9hZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCByZWFkIGZyb20gJy4vcmVhZGVyL3Rva2VuLXJlYWRlcic7XG5pbXBvcnQgeyBmcmVzaFNjb3BlIH0gZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgRW52IGZyb20gJy4vZW52JztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IENvbXBpbGVyIGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgQUxMX1BIQVNFUyB9IGZyb20gJy4vc3ludGF4JztcbmltcG9ydCBCaW5kaW5nTWFwIGZyb20gJy4vYmluZGluZy1tYXAuanMnO1xuaW1wb3J0IFRlcm0gZnJvbSAnc3dlZXQtc3BlYyc7XG5pbXBvcnQgU3dlZXRNb2R1bGUgZnJvbSAnLi9zd2VldC1tb2R1bGUnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdyYW1kYSc7XG5pbXBvcnQgU2NvcGVSZWR1Y2VyIGZyb20gJy4vc2NvcGUtcmVkdWNlcic7XG5pbXBvcnQgeyB3cmFwSW5UZXJtcyB9IGZyb20gJy4vbWFjcm8tY29udGV4dCc7XG5pbXBvcnQgeyB0cmFuc2Zvcm0gYXMgYmFiZWwgfSBmcm9tICdiYWJlbC1jb3JlJztcbmltcG9ydCBTdG9yZSBmcm9tICcuL3N0b3JlJztcblxuZXhwb3J0IGNvbnN0IHBoYXNlSW5Nb2R1bGVQYXRoUmVnZXhwID0gLyguKik6KFxcZCspXFxzKiQvO1xuXG5leHBvcnQgdHlwZSBDb250ZXh0ID0ge1xuICBiaW5kaW5nczogYW55O1xuICB0ZW1wbGF0ZU1hcDogYW55O1xuICBnZXRUZW1wbGF0ZUlkZW50aWZpZXI6IGFueTtcbiAgbG9hZGVyOiBhbnk7XG4gIHRyYW5zZm9ybTogYW55O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2VldExvYWRlciB7XG4gIHNvdXJjZUNhY2hlOiBNYXA8c3RyaW5nLCBzdHJpbmc+O1xuICBjb21waWxlZENhY2hlOiBNYXA8c3RyaW5nLCBTd2VldE1vZHVsZT47XG4gIGNvbnRleHQ6IENvbnRleHQ7XG4gIGJhc2VEaXI6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihiYXNlRGlyOiBzdHJpbmcsIG5vQmFiZWw6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIHRoaXMuc291cmNlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb21waWxlZENhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYmFzZURpciA9IGJhc2VEaXI7XG5cbiAgICBsZXQgYmluZGluZ3MgPSBuZXcgQmluZGluZ01hcCgpO1xuICAgIGxldCB0ZW1wbGF0ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGVtcElkZW50ID0gMDtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBiaW5kaW5ncyxcbiAgICAgIHRlbXBsYXRlTWFwLFxuICAgICAgZ2V0VGVtcGxhdGVJZGVudGlmaWVyOiAoKSA9PiArK3RlbXBJZGVudCxcbiAgICAgIGxvYWRlcjogdGhpcyxcbiAgICAgIHRyYW5zZm9ybTogYyA9PiB7XG4gICAgICAgIGlmIChub0JhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYWJlbChjLCB7XG4gICAgICAgICAgYmFiZWxyYzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgbm9ybWFsaXplKG5hbWU6IHN0cmluZywgcmVmZXJlck5hbWU/OiBzdHJpbmcsIHJlZmVyZXJBZGRyZXNzPzogc3RyaW5nKSB7XG4gICAgLy8gdGFrZXMgYC4ucGF0aC90by9zb3VyY2UuanM6PHBoYXNlPmBcbiAgICAvLyBnaXZlcyBgL2Ficy9wYXRoL3RvL3NvdXJjZS5qczo8cGhhc2U+YFxuICAgIC8vIG1pc3NpbmcgcGhhc2VzIGFyZSB0dXJuZWQgaW50byAwXG4gICAgaWYgKCFwaGFzZUluTW9kdWxlUGF0aFJlZ2V4cC50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX06MGA7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgbG9jYXRlKHtuYW1lLCBtZXRhZGF0YX06IHtuYW1lOiBzdHJpbmcsIG1ldGFkYXRhOiB7fX0pIHtcbiAgICAvLyB0YWtlcyBgL2Ficy9wYXRoL3RvL3NvdXJjZS5qczo8cGhhc2U+YFxuICAgIC8vIGdpdmVzIHsgcGF0aDogJy9hYnMvcGF0aC90by9zb3VyY2UuanMnLCBwaGFzZTogPHBoYXNlPiB9XG4gICAgbGV0IG1hdGNoID0gbmFtZS5tYXRjaChwaGFzZUluTW9kdWxlUGF0aFJlZ2V4cCk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSAzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBtYXRjaFsxXSxcbiAgICAgICAgcGhhc2U6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlICR7bmFtZX0gaXMgbWlzc2luZyBwaGFzZSBpbmZvcm1hdGlvbmApO1xuICB9XG5cbiAgZmV0Y2goe25hbWUsIGFkZHJlc3MsIG1ldGFkYXRhfToge25hbWU6IHN0cmluZywgYWRkcmVzczoge3BhdGg6IHN0cmluZywgcGhhc2U6IG51bWJlcn0sIG1ldGFkYXRhOiB7fX0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRlZmF1bHQgZmV0Y2ggZGVmaW5lZCcpO1xuICB9XG5cbiAgdHJhbnNsYXRlKHtuYW1lLCBhZGRyZXNzLCBzb3VyY2UsIG1ldGFkYXRhfToge25hbWU6IHN0cmluZywgYWRkcmVzczoge3BhdGg6IHN0cmluZywgcGhhc2U6IG51bWJlcn0sIHNvdXJjZTogc3RyaW5nLCBtZXRhZGF0YToge319KSB7XG4gICAgbGV0IHNyYyA9IHRoaXMuY29tcGlsZWRDYWNoZS5nZXQoYWRkcmVzcy5wYXRoKVxuICAgIGlmIChzcmMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgbGV0IGNvbXBpbGVkTW9kdWxlID0gdGhpcy5jb21waWxlU291cmNlKHNvdXJjZSk7XG4gICAgdGhpcy5jb21waWxlZENhY2hlLnNldChhZGRyZXNzLnBhdGgsIGNvbXBpbGVkTW9kdWxlKTtcbiAgICByZXR1cm4gY29tcGlsZWRNb2R1bGU7XG4gIH1cblxuICBpbnN0YW50aWF0ZSh7bmFtZSwgYWRkcmVzcywgc291cmNlLCBtZXRhZGF0YX06IHtuYW1lOiBzdHJpbmcsIGFkZHJlc3M6IHtwYXRoOiBzdHJpbmcsIHBoYXNlOiBudW1iZXJ9LCBzb3VyY2U6IFN3ZWV0TW9kdWxlLCBtZXRhZGF0YToge319KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gIH1cblxuICBldmFsKHNvdXJjZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuICgwLCBldmFsKShzb3VyY2UpO1xuICB9XG5cbiAgbG9hZChlbnRyeVBhdGg6IHN0cmluZykge1xuICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgIGxldCBuYW1lID0gdGhpcy5ub3JtYWxpemUoZW50cnlQYXRoKTtcbiAgICBsZXQgYWRkcmVzcyA9IHRoaXMubG9jYXRlKHsgbmFtZSwgbWV0YWRhdGEgfSk7XG4gICAgbGV0IHNvdXJjZSA9IHRoaXMuZmV0Y2goeyBuYW1lLCBhZGRyZXNzLCBtZXRhZGF0YSB9KTtcbiAgICBzb3VyY2UgPSB0aGlzLnRyYW5zbGF0ZSh7IG5hbWUsIGFkZHJlc3MsIHNvdXJjZSwgbWV0YWRhdGEgfSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGUoeyBuYW1lLCBhZGRyZXNzLCBzb3VyY2UsIG1ldGFkYXRhIH0pO1xuICB9XG5cbiAgLy8gc2tpcCBpbnN0YW50aWF0ZVxuICBjb21waWxlKGVudHJ5UGF0aDogc3RyaW5nLCByZWZlcmVyTmFtZT86IHN0cmluZykge1xuICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgIGxldCBuYW1lID0gdGhpcy5ub3JtYWxpemUoZW50cnlQYXRoLCByZWZlcmVyTmFtZSk7XG4gICAgbGV0IGFkZHJlc3MgPSB0aGlzLmxvY2F0ZSh7IG5hbWUsIG1ldGFkYXRhIH0pO1xuICAgIGxldCBzb3VyY2UgPSB0aGlzLmZldGNoKHsgbmFtZSwgYWRkcmVzcywgbWV0YWRhdGEgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKHsgbmFtZSwgYWRkcmVzcywgc291cmNlLCBtZXRhZGF0YSB9KTtcbiAgfVxuXG4gIGdldChlbnRyeVBhdGg6IHN0cmluZywgZW50cnlQaGFzZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZShgJHtlbnRyeVBhdGh9OiR7ZW50cnlQaGFzZX1gKTtcbiAgfVxuXG4gIHJlYWQoc291cmNlOiBzdHJpbmcpOiBMaXN0PFRlcm0+IHtcbiAgICByZXR1cm4gd3JhcEluVGVybXMocmVhZChzb3VyY2UpKTtcbiAgfVxuXG4gIGZyZXNoU3RvcmUoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yZSh7fSk7XG4gIH1cblxuICBjb21waWxlU291cmNlKHNvdXJjZTogc3RyaW5nKSB7XG4gICAgbGV0IHN0eGwgPSB0aGlzLnJlYWQoc291cmNlKTtcbiAgICBsZXQgb3V0U2NvcGUgPSBmcmVzaFNjb3BlKCdvdXRzaWRlRWRnZScpO1xuICAgIGxldCBpblNjb3BlID0gZnJlc2hTY29wZSgnaW5zaWRlRWRnZTAnKTtcbiAgICAvLyB0aGUgY29tcGlsZXIgc3RhcnRzIGF0IHBoYXNlIDAsIHdpdGggYW4gZW1wdHkgZW52aXJvbm1lbnQgYW5kIHN0b3JlXG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKDAsIG5ldyBFbnYoKSwgdGhpcy5mcmVzaFN0b3JlKCksICBfLm1lcmdlKHRoaXMuY29udGV4dCwge1xuICAgICAgY3VycmVudFNjb3BlOiBbb3V0U2NvcGUsIGluU2NvcGVdLFxuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IFN3ZWV0TW9kdWxlKGNvbXBpbGVyLmNvbXBpbGUoc3R4bC5tYXAocyA9PiBzLnJlZHVjZShuZXcgU2NvcGVSZWR1Y2VyKFtcbiAgICAgIHsgc2NvcGU6IG91dFNjb3BlLCBwaGFzZTogQUxMX1BIQVNFUywgZmxpcDogZmFsc2UgfSxcbiAgICAgIHsgc2NvcGU6IGluU2NvcGUsIHBoYXNlOiAwLCBmbGlwOiBmYWxzZSB9XSxcbiAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncylcbiAgICApKSkpO1xuICB9XG59XG4iXX0=

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getSlice = getSlice;
	exports.default = read;

	var _reader = __webpack_require__(7);

	var _reader2 = _interopRequireDefault(_reader);

	var _defaultReadtable = __webpack_require__(9);

	var _defaultReadtable2 = _interopRequireDefault(_defaultReadtable);

	var _immutable = __webpack_require__(10);

	var _charStream = __webpack_require__(8);

	var _charStream2 = _interopRequireDefault(_charStream);

	var _tokens = __webpack_require__(30);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _reader.setCurrentReadtable)(_defaultReadtable2.default);

	function getSlice(stream, startLocation) {
	  return {
	    text: stream.getSlice(startLocation.position),
	    start: startLocation.position,
	    startLocation,
	    end: stream.sourceInfo.position
	  };
	}

	const streams = new WeakMap();

	class ReadError extends Error {
	  constructor({ index, line, column, message }) {
	    super(message);
	    this.index = index;
	    this.line = line;
	    this.column = column;
	    this.message = `[${ line }:${ column }] ${ message }`;
	  }
	}

	class TokenReader extends _reader2.default {
	  constructor(stream, context) {
	    super();
	    this.context = context;
	    streams.set(this, stream);
	    this.locationInfo = {
	      line: 1,
	      column: 1
	    };
	  }

	  createError(msg) {
	    let message = msg.replace(/\{(\d+)\}/g, (_, n) => JSON.stringify(arguments[+n + 1]));
	    // $FlowFixMe: decide on how to handle possible nullability
	    return new ReadError({ message, index: streams.get(this).sourceInfo.position, line: this.locationInfo.line, column: this.locationInfo.column });
	  }

	  createILLEGAL(char) {
	    return !(0, _charStream.isEOS)(char) ? this.createError('Unexpected {0}', char) : this.createError('Unexpected end of input');
	  }

	  readToken(stream, prefix, exprAllowed) {
	    const startLocation = Object.assign({}, this.locationInfo, stream.sourceInfo);
	    const result = super.read(stream, prefix, exprAllowed);

	    if (startLocation.column === this.locationInfo.column && startLocation.line === this.locationInfo.line) {
	      this.locationInfo.column += stream.sourceInfo.position - startLocation.position;
	    }

	    if (result === _tokens.EmptyToken) return result;

	    if (!_immutable.List.isList(result)) result.slice = getSlice(stream, startLocation);

	    return new _syntax2.default(result, this.context);
	  }

	  incrementLine() {
	    this.locationInfo.line += 1;
	    this.locationInfo.column = 1;
	  }
	}

	function read(source, context) {
	  const stream = typeof source === 'string' ? new _charStream2.default(source) : source;
	  const reader = new TokenReader(stream, context);
	  const entry = (0, _reader.getCurrentReadtable)().getEntry('');

	  return entry.action.call(reader, stream, (0, _immutable.List)(), false);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvdG9rZW4tcmVhZGVyLmpzIl0sIm5hbWVzIjpbImdldFNsaWNlIiwicmVhZCIsInN0cmVhbSIsInN0YXJ0TG9jYXRpb24iLCJ0ZXh0IiwicG9zaXRpb24iLCJzdGFydCIsImVuZCIsInNvdXJjZUluZm8iLCJzdHJlYW1zIiwiV2Vha01hcCIsIlJlYWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJpbmRleCIsImxpbmUiLCJjb2x1bW4iLCJtZXNzYWdlIiwiVG9rZW5SZWFkZXIiLCJjb250ZXh0Iiwic2V0IiwibG9jYXRpb25JbmZvIiwiY3JlYXRlRXJyb3IiLCJtc2ciLCJyZXBsYWNlIiwiXyIsIm4iLCJKU09OIiwic3RyaW5naWZ5IiwiYXJndW1lbnRzIiwiZ2V0IiwiY3JlYXRlSUxMRUdBTCIsImNoYXIiLCJyZWFkVG9rZW4iLCJwcmVmaXgiLCJleHByQWxsb3dlZCIsIk9iamVjdCIsImFzc2lnbiIsInJlc3VsdCIsImlzTGlzdCIsInNsaWNlIiwiaW5jcmVtZW50TGluZSIsInNvdXJjZSIsInJlYWRlciIsImVudHJ5IiwiZ2V0RW50cnkiLCJhY3Rpb24iLCJjYWxsIl0sIm1hcHBpbmdzIjoiOzs7OztRQXVCZ0JBLFEsR0FBQUEsUTtrQkF1RVFDLEk7O0FBNUZ4Qjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O0FBSUE7O0FBWU8sU0FBU0QsUUFBVCxDQUFrQkUsTUFBbEIsRUFBc0NDLGFBQXRDLEVBQTJFO0FBQ2hGLFNBQU87QUFDTEMsVUFBTUYsT0FBT0YsUUFBUCxDQUFnQkcsY0FBY0UsUUFBOUIsQ0FERDtBQUVMQyxXQUFPSCxjQUFjRSxRQUZoQjtBQUdMRixpQkFISztBQUlMSSxTQUFLTCxPQUFPTSxVQUFQLENBQWtCSDtBQUpsQixHQUFQO0FBTUQ7O0FBRUQsTUFBTUksVUFBVSxJQUFJQyxPQUFKLEVBQWhCOztBQUVBLE1BQU1DLFNBQU4sU0FBd0JDLEtBQXhCLENBQThCO0FB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aEIsTUFBaEIsRUFBd0JpQixPQUF4QixDQUFmO0FBQ0EsUUFBTXlCLFFBQVEsbUNBQXNCQyxRQUF0QixDQUErQixFQUEvQixDQUFkOztBQUVBLFNBQU9ELE1BQU1FLE1BQU4sQ0FBYUMsSUFBYixDQUFrQkosTUFBbEIsRUFBMEJ6QyxNQUExQixFQUFrQyxzQkFBbEMsRUFBMEMsS0FBMUMsQ0FBUDtBQUNEIiwiZmlsZSI6InRva2VuLXJlYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBSZWFkZXIsIHsgZ2V0Q3VycmVudFJlYWR0YWJsZSwgc2V0Q3VycmVudFJlYWR0YWJsZSB9IGZyb20gJy4vcmVhZGVyJztcbmltcG9ydCBkZWZhdWx0UmVhZHRhYmxlIGZyb20gJy4vZGVmYXVsdC1yZWFkdGFibGUnO1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgQ2hhclN0cmVhbSwgeyBpc0VPUyB9IGZyb20gJy4vY2hhci1zdHJlYW0nO1xuaW1wb3J0IHsgRW1wdHlUb2tlbiB9IGZyb20gJy4uL3Rva2Vucyc7XG5pbXBvcnQgU3ludGF4IGZyb20gJy4uL3N5bnRheCc7XG5cbmltcG9ydCB0eXBlIHsgU3RhcnRMb2NhdGlvbiwgU2xpY2UgfSBmcm9tICcuLi90b2tlbnMnO1xuXG5zZXRDdXJyZW50UmVhZHRhYmxlKGRlZmF1bHRSZWFkdGFibGUpO1xuXG5leHBvcnQgdHlwZSBMb2NhdGlvbkluZm8gPSB7XG4gIGxpbmU6IG51bWJlcixcbiAgY29sdW1uOiBudW1iZXJcbn07XG5cbnR5cGUgQ29udGV4dCA9IHtcbiAgYmluZGluZ3M6IGFueSxcbiAgc2NvcGVzZXRzOiBhbnlcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTbGljZShzdHJlYW06IENoYXJTdHJlYW0sIHN0YXJ0TG9jYXRpb246IFN0YXJ0TG9jYXRpb24pOiBTbGljZSB7XG4gIHJldHVybiB7XG4gICAgdGV4dDogc3RyZWFtLmdldFNsaWNlKHN0YXJ0TG9jYXRpb24ucG9zaXRpb24pLFxuICAgIHN0YXJ0OiBzdGFydExvY2F0aW9uLnBvc2l0aW9uLFxuICAgIHN0YXJ0TG9jYXRpb24sXG4gICAgZW5kOiBzdHJlYW0uc291cmNlSW5mby5wb3NpdGlvblxuICB9O1xufVxuXG5jb25zdCBzdHJlYW1zID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgUmVhZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBpbmRleDogbnVtYmVyO1xuICBsaW5lOiBudW1iZXI7XG4gIGNvbHVtbjogbnVtYmVyO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHsgaW5kZXgsIGxpbmUsIGNvbHVtbiwgbWVzc2FnZSB9OiB7IGluZGV4OiBudW1iZXIsIGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5tZXNzYWdlID0gYFske2xpbmV9OiR7Y29sdW1ufV0gJHttZXNzYWdlfWA7XG4gIH1cbn1cblxuY2xhc3MgVG9rZW5SZWFkZXIgZXh0ZW5kcyBSZWFkZXIge1xuICBsb2NhdGlvbkluZm86IExvY2F0aW9uSW5mbztcbiAgY29udGV4dDogP0NvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbTogQ2hhclN0cmVhbSwgY29udGV4dD86IENvbnRleHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgc3RyZWFtcy5zZXQodGhpcywgc3RyZWFtKTtcbiAgICB0aGlzLmxvY2F0aW9uSW5mbyA9IHtcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDFcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRXJyb3IobXNnOiBzdHJpbmcpOiBSZWFkRXJyb3Ige1xuICAgIGxldCBtZXNzYWdlID0gbXNnLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCAoXywgbikgPT4gSlNPTi5zdHJpbmdpZnkoYXJndW1lbnRzWytuICsgMV0pKTtcbiAgICAvLyAkRmxvd0ZpeE1lOiBkZWNpZGUgb24gaG93IHRvIGhhbmRsZSBwb3NzaWJsZSBudWxsYWJpbGl0eVxuICAgIHJldHVybiBuZXcgUmVhZEVycm9yKHsgbWVzc2FnZSwgaW5kZXg6IHN0cmVhbXMuZ2V0KHRoaXMpLnNvdXJjZUluZm8ucG9zaXRpb24sIGxpbmU6IHRoaXMubG9jYXRpb25JbmZvLmxpbmUsIGNvbHVtbjogdGhpcy5sb2NhdGlvbkluZm8uY29sdW1uIH0pO1xuICB9XG5cbiAgY3JlYXRlSUxMRUdBTChjaGFyKSB7XG4gICAgcmV0dXJuICFpc0VPUyhjaGFyKVxuICAgICAgPyB0aGlzLmNyZWF0ZUVycm9yKCdVbmV4cGVjdGVkIHswfScsIGNoYXIpXG4gICAgOiB0aGlzLmNyZWF0ZUVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgcmVhZFRva2VuKHN0cmVhbTogQ2hhclN0cmVhbSwgcHJlZml4OiBMaXN0PFN5bnRheD4sIGV4cHJBbGxvd2VkOiBib29sZWFuKTogU3ludGF4IHtcbiAgICBjb25zdCBzdGFydExvY2F0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2NhdGlvbkluZm8sIHN0cmVhbS5zb3VyY2VJbmZvKTtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5yZWFkKHN0cmVhbSwgcHJlZml4LCBleHByQWxsb3dlZCk7XG5cbiAgICBpZiAoc3RhcnRMb2NhdGlvbi5jb2x1bW4gPT09IHRoaXMubG9jYXRpb25JbmZvLmNvbHVtbiAmJiBzdGFydExvY2F0aW9uLmxpbmUgPT09IHRoaXMubG9jYXRpb25JbmZvLmxpbmUpIHtcbiAgICAgIHRoaXMubG9jYXRpb25JbmZvLmNvbHVtbiArPSBzdHJlYW0uc291cmNlSW5mby5wb3NpdGlvbiAtIHN0YXJ0TG9jYXRpb24ucG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gRW1wdHlUb2tlbikgcmV0dXJuIHJlc3VsdDtcblxuICAgIGlmICghTGlzdC5pc0xpc3QocmVzdWx0KSkgcmVzdWx0LnNsaWNlID0gZ2V0U2xpY2Uoc3RyZWFtLCBzdGFydExvY2F0aW9uKTtcblxuICAgIHJldHVybiBuZXcgU3ludGF4KHJlc3VsdCwgdGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIGluY3JlbWVudExpbmUoKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhdGlvbkluZm8ubGluZSArPSAxO1xuICAgIHRoaXMubG9jYXRpb25JbmZvLmNvbHVtbiA9IDE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZChzb3VyY2U6IHN0cmluZyB8IENoYXJTdHJlYW0sIGNvbnRleHQ/OiBDb250ZXh0KTogTGlzdDxTeW50YXg+IHtcbiAgY29uc3Qgc3RyZWFtID0gKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSA/IG5ldyBDaGFyU3RyZWFtKHNvdXJjZSkgOiBzb3VyY2U7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBUb2tlblJlYWRlcihzdHJlYW0sIGNvbnRleHQpO1xuICBjb25zdCBlbnRyeSA9IGdldEN1cnJlbnRSZWFkdGFibGUoKS5nZXRFbnRyeSgnJyk7XG5cbiAgcmV0dXJuIGVudHJ5LmFjdGlvbi5jYWxsKHJlYWRlciwgc3RyZWFtLCBMaXN0KCksIGZhbHNlKTtcbn1cbiJdfQ==

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setCurrentReadtable = setCurrentReadtable;
	exports.getCurrentReadtable = getCurrentReadtable;

	var _charStream = __webpack_require__(8);

	let currentReadtable;

	class Reader {
	  read(stream, ...rest) {
	    let char = stream.peek();
	    if (!(0, _charStream.isEOS)(char)) {
	      const entry = currentReadtable.getEntry(char);
	      const result = entry.action.call(this, stream, ...rest);
	      return result;
	    }
	    throw Error('Unexpected end of input');
	  }
	}

	exports.default = Reader;
	function setCurrentReadtable(readtable) {
	  currentReadtable = readtable;
	}

	function getCurrentReadtable() {
	  return currentReadtable;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZGVyLmpzIl0sIm5hbWVzIjpbInNldEN1cnJlbnRSZWFkdGFibGUiLCJnZXRDdXJyZW50UmVhZHRhYmxlIiwiY3VycmVudFJlYWR0YWJsZSIsIlJlYWRlciIsInJlYWQiLCJzdHJlYW0iLCJyZXN0IiwiY2hhciIsInBlZWsiLCJlbnRyeSIsImdldEVudHJ5IiwicmVzdWx0IiwiYWN0aW9uIiwiY2FsbCIsIkVycm9yIiwicmVhZHRhYmxlIl0sIm1hcHBpbmdzIjoiOzs7OztRQXFCZ0JBLG1CLEdBQUFBLG1CO1FBSUFDLG1CLEdBQUFBLG1COztBQXBCaEI7O0FBRUEsSUFBSUMsZ0JBQUo7O0FBRWUsTUFBTUMsTUFBTixDQUFhO0FBQzFCQyxPQUFLQyxNQUFMLEVBQXlCLEdBQUdDLElBQTVCLEVBQW9EO0FBQ2xELFFBQUlDLE9BQU9GLE9BQU9HLElBQVAsRUFBWDtBQUNBLFFBQUksQ0FBQyx1QkFBTUQsSUFBTixDQUFMLEVBQWtCO0FBQ2hCLFlBQU1FLFFBQVFQLGlCQUFpQlEsUUFBakIsQ0FBMEJILElBQTFCLENBQWQ7QUFDQSxZQUFNSSxTQUFTRixNQUFNRyxNQUFOLENBQWFDLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0JSLE1BQXhCLEVBQWdDLEdBQUdDLElBQW5DLENBQWY7QUFDQSxhQUFPSyxNQUFQO0FBQ0Q7QUFDRCxVQUFNRyxNQUFNLHlCQUFOLENBQU47QUFDRDtBQVR5Qjs7a0JBQVBYLE07QUFZZCxTQUFTSCxtQkFBVCxDQUE2QmUsU0FBN0IsRUFBeUQ7QUFDOURiLHFCQUFtQmEsU0FBbkI7QUFDRDs7QUFFTSxTQUFTZCxtQkFBVCxHQUEwQztBQUMvQyxTQUFPQyxnQkFBUDtBQUNEIiwiZmlsZSI6InJlYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIFJlYWR0YWJsZSBmcm9tICcuL3JlYWR0YWJsZSc7XG5pbXBvcnQgdHlwZSBDaGFyU3RyZWFtIGZyb20gJy4vY2hhci1zdHJlYW0nO1xuXG5pbXBvcnQgeyBpc0VPUyB9IGZyb20gJy4vY2hhci1zdHJlYW0nO1xuXG5sZXQgY3VycmVudFJlYWR0YWJsZTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhZGVyIHtcbiAgcmVhZChzdHJlYW06IENoYXJTdHJlYW0sIC4uLnJlc3Q/OiBBcnJheTxhbnk+KTogYW55IHtcbiAgICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKCFpc0VPUyhjaGFyKSkge1xuICAgICAgY29uc3QgZW50cnkgPSBjdXJyZW50UmVhZHRhYmxlLmdldEVudHJ5KGNoYXIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW50cnkuYWN0aW9uLmNhbGwodGhpcywgc3RyZWFtLCAuLi5yZXN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXJyZW50UmVhZHRhYmxlKHJlYWR0YWJsZTogUmVhZHRhYmxlKTogdm9pZCB7XG4gIGN1cnJlbnRSZWFkdGFibGUgPSByZWFkdGFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50UmVhZHRhYmxlKCk6IFJlYWR0YWJsZSB7XG4gIHJldHVybiBjdXJyZW50UmVhZHRhYmxlO1xufVxuIl19

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isEOS = isEOS;


	const sourceInfo = new WeakMap();
	class CharStream {
	  constructor(source, filename = '') {
	    sourceInfo.set(this, {
	      source,
	      filename,
	      position: 0
	    });
	  }

	  get sourceInfo() {
	    // $FlowFixMe: decide on how to handle possible nullability
	    const { filename, position /*, source*/ } = sourceInfo.get(this);
	    return { filename, position /*, source*/ };
	  }

	  // returns the Unicode character charsToSkip ahead.
	  peek(charsToSkip = 0) {
	    // $FlowFixMe: decide on how to handle possible nullability
	    const { source, position } = sourceInfo.get(this);
	    if (position + charsToSkip >= source.length) return '';
	    return source[position + charsToSkip];
	  }

	  // returns a string containing the next numChars characters.
	  readString(numChars = 1) {
	    const info = sourceInfo.get(this);
	    // $FlowFixMe: decide on how to handle possible nullability
	    const { source, position } = info;
	    const str = source.slice(position, position + numChars);
	    // $FlowFixMe: decide on how to handle possible nullability
	    info.position += str.length;
	    return str;
	  }

	  getSlice(start) {
	    // $FlowFixMe: decide on how to handle possible nullability
	    const { source, position } = sourceInfo.get(this);
	    return source.slice(start, position);
	  }
	}

	exports.default = CharStream;
	function isEOS(char) {
	  return char === '';
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvY2hhci1zdHJlYW0uanMiXSwibmFtZXMiOlsiaXNFT1MiLCJzb3VyY2VJbmZvIiwiV2Vha01hcCIsIkNoYXJTdHJlYW0iLCJjb25zdHJ1Y3RvciIsInNvdXJjZSIsImZpbGVuYW1lIiwic2V0IiwicG9zaXRpb24iLCJnZXQiLCJwZWVrIiwiY2hhcnNUb1NraXAiLCJsZW5ndGgiLCJyZWFkU3RyaW5nIiwibnVtQ2hhcnMiLCJpbmZvIiwic3RyIiwic2xpY2UiLCJnZXRTbGljZSIsInN0YXJ0IiwiY2hhciJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFpRGdCQSxLLEdBQUFBLEs7OztBQTNDaEIsTUFBTUMsYUFBYSxJQUFJQyxPQUFKLEVBQW5CO0FBRWUsTUFBTUMsVUFBTixDQUFpQjtBQUM5QkMsY0FBWUMsTUFBWixFQUE0QkMsV0FBbUIsRUFBL0MsRUFBbUQ7QUFDakRMLGVBQVdNLEdBQVgsQ0FBZSxJQUFmLEVBQXFCO0FBQ25CRixZQURtQjtBQUVuQkMsY0FGbUI7QUFHbkJFLGdCQUFVO0FBSFMsS0FBckI7QUFLRDs7QUFFRCxNQUFJUCxVQUFKLEdBQTZCO0FBQzNCO0FBQ0EsVUFBTSxFQUFFSyxRQUFGLEVBQVlFLFFBQVosQ0FBb0IsWUFBcEIsS0FBcUNQLFdBQVdRLEdBQVgsQ0FBZSxJQUFmLENBQTNDO0FBQ0EsV0FBTyxFQUFFSCxRQUFGLEVBQVlFLFFBQVosQ0FBb0IsWUFBcEIsRUFBUDtBQUNEOztBQUVEO0FBQ0FFLE9BQUtDLGNBQXNCLENBQTNCLEVBQXNDO0FBQ3BDO0FBQ0EsVUFBTSxFQUFFTixNQUFGLEVBQVVHLFFBQVYsS0FBdUJQLFdBQVdRLEdBQVgsQ0FBZSxJQUFmLENBQTdCO0FBQ0EsUUFBSUQsV0FBV0csV0FBWCxJQUEwQk4sT0FBT08sTUFBckMsRUFBNkMsT0FBTyxFQUFQO0FBQzdDLFdBQU9QLE9BQU9HLFdBQVdHLFdBQWxCLENBQVA7QUFDRDs7QUFFRDtBQUNBRSxhQUFXQyxXQUFtQixDQUE5QixFQUF5QztBQUN2QyxVQUFNQyxPQUFPZCxXQUFXUSxHQUFYLENBQWUsSUFBZixDQUFiO0FBQ0E7QUFDQSxVQUFNLEVBQUVKLE1BQUYsRUFBVUcsUUFBVixLQUF1Qk8sSUFBN0I7QUFDQSxVQUFNQyxNQUFNWCxPQUFPWSxLQUFQLENBQWFULFFBQWIsRUFBdUJBLFdBQVdNLFFBQWxDLENBQVo7QUFDQTtBQUNBQyxTQUFLUCxRQUFMLElBQWlCUSxJQUFJSixNQUFyQjtBQUNBLFdBQU9JLEdBQVA7QUFDRDs7QUFFREUsV0FBU0MsS0FBVCxFQUFnQztBQUM5QjtBQUNBLFVBQU0sRUFBRWQsTUFBRixFQUFVRyxRQUFWLEtBQXVCUCxXQUFXUSxHQUFYLENBQWUsSUFBZixDQUE3QjtBQUNBLFdBQU9KLE9BQU9ZLEtBQVAsQ0FBYUUsS0FBYixFQUFvQlgsUUFBcEIsQ0FBUDtBQUNEO0FBdEM2Qjs7a0JBQVhMLFU7QUF5Q2QsU0FBU0gsS0FBVCxDQUFlb0IsSUFBZixFQUFzQztBQUMzQyxTQUFPQSxTQUFTLEVBQWhCO0FBQ0QiLCJmaWxlIjoiY2hhci1zdHJlYW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuZXhwb3J0IHR5cGUgU291cmNlSW5mbyA9IHtcbiAgZmlsZW5hbWU6IHN0cmluZyxcbiAgcG9zaXRpb246IG51bWJlclxufTtcblxuY29uc3Qgc291cmNlSW5mbyA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyA9ICcnKSB7XG4gICAgc291cmNlSW5mby5zZXQodGhpcywge1xuICAgICAgc291cmNlLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHNvdXJjZUluZm8oKTogU291cmNlSW5mbyB7XG4gICAgLy8gJEZsb3dGaXhNZTogZGVjaWRlIG9uIGhvdyB0byBoYW5kbGUgcG9zc2libGUgbnVsbGFiaWxpdHlcbiAgICBjb25zdCB7IGZpbGVuYW1lLCBwb3NpdGlvbi8qLCBzb3VyY2UqLyB9ID0gc291cmNlSW5mby5nZXQodGhpcyk7XG4gICAgcmV0dXJuIHsgZmlsZW5hbWUsIHBvc2l0aW9uLyosIHNvdXJjZSovIH07XG4gIH1cblxuICAvLyByZXR1cm5zIHRoZSBVbmljb2RlIGNoYXJhY3RlciBjaGFyc1RvU2tpcCBhaGVhZC5cbiAgcGVlayhjaGFyc1RvU2tpcDogbnVtYmVyID0gMCk6IHN0cmluZyB7XG4gICAgLy8gJEZsb3dGaXhNZTogZGVjaWRlIG9uIGhvdyB0byBoYW5kbGUgcG9zc2libGUgbnVsbGFiaWxpdHlcbiAgICBjb25zdCB7IHNvdXJjZSwgcG9zaXRpb24gfSA9IHNvdXJjZUluZm8uZ2V0KHRoaXMpO1xuICAgIGlmIChwb3NpdGlvbiArIGNoYXJzVG9Ta2lwID49IHNvdXJjZS5sZW5ndGgpIHJldHVybiAnJztcbiAgICByZXR1cm4gc291cmNlW3Bvc2l0aW9uICsgY2hhcnNUb1NraXBdO1xuICB9XG5cbiAgLy8gcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBuZXh0IG51bUNoYXJzIGNoYXJhY3RlcnMuXG4gIHJlYWRTdHJpbmcobnVtQ2hhcnM6IG51bWJlciA9IDEpOiBzdHJpbmcge1xuICAgIGNvbnN0IGluZm8gPSBzb3VyY2VJbmZvLmdldCh0aGlzKTtcbiAgICAvLyAkRmxvd0ZpeE1lOiBkZWNpZGUgb24gaG93IHRvIGhhbmRsZSBwb3NzaWJsZSBudWxsYWJpbGl0eVxuICAgIGNvbnN0IHsgc291cmNlLCBwb3NpdGlvbiB9ID0gaW5mbztcbiAgICBjb25zdCBzdHIgPSBzb3VyY2Uuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbnVtQ2hhcnMpO1xuICAgIC8vICRGbG93Rml4TWU6IGRlY2lkZSBvbiBob3cgdG8gaGFuZGxlIHBvc3NpYmxlIG51bGxhYmlsaXR5XG4gICAgaW5mby5wb3NpdGlvbiArPSBzdHIubGVuZ3RoO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBnZXRTbGljZShzdGFydDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBkZWNpZGUgb24gaG93IHRvIGhhbmRsZSBwb3NzaWJsZSBudWxsYWJpbGl0eVxuICAgIGNvbnN0IHsgc291cmNlLCBwb3NpdGlvbiB9ID0gc291cmNlSW5mby5nZXQodGhpcyk7XG4gICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgcG9zaXRpb24pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VPUyhjaGFyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGNoYXIgPT09ICcnO1xufVxuIl19

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(10);

	var _readtable = __webpack_require__(11);

	var _reader = __webpack_require__(7);

	var _readIdentifier = __webpack_require__(12);

	var _readIdentifier2 = _interopRequireDefault(_readIdentifier);

	var _readNumeric = __webpack_require__(31);

	var _readNumeric2 = _interopRequireDefault(_readNumeric);

	var _readString = __webpack_require__(32);

	var _readString2 = _interopRequireDefault(_readString);

	var _readTemplate = __webpack_require__(33);

	var _readTemplate2 = _interopRequireDefault(_readTemplate);

	var _readDelimiter = __webpack_require__(34);

	var _readDelimiter2 = _interopRequireDefault(_readDelimiter);

	var _readRegexp = __webpack_require__(35);

	var _readRegexp2 = _interopRequireDefault(_readRegexp);

	var _readComment = __webpack_require__(36);

	var _readComment2 = _interopRequireDefault(_readComment);

	var _readDispatch = __webpack_require__(37);

	var _readDispatch2 = _interopRequireDefault(_readDispatch);

	var _tokens = __webpack_require__(30);

	var _utils = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// use https://github.com/mathiasbynens/regenerate to generate the Unicode code points when implementing modes

	function eatWhitespace(stream) {
	  stream.readString();
	  return _tokens.EmptyToken;
	}

	const punctuatorTable = Object.keys(_tokens.punctuatorTable).reduce(_utils.insertSequence, {});

	function readPunctuator(stream) {
	  const len = (0, _utils.retrieveSequenceLength)(punctuatorTable, stream, 0);
	  if (len > 0) {
	    return new _tokens.PunctuatorToken({
	      value: stream.readString(len)
	    });
	  }
	  throw Error('Unknown punctuator');
	}

	const punctuatorEntries = Object.keys(punctuatorTable).map(p => ({
	  key: p,
	  action: readPunctuator
	}));

	const whiteSpaceTable = [0x20, 0x09, 0x0B, 0x0C, 0xA0, 0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

	const whiteSpaceEntries = whiteSpaceTable.map(w => ({
	  key: w,
	  action: eatWhitespace
	}));

	const lineTerminatorTable = [0x0A, 0x0D, 0x2028, 0x2029];

	const lineTerminatorEntries = lineTerminatorTable.map(lt => ({
	  key: lt,
	  action: function readLineTerminator(stream) {
	    this.incrementLine();
	    return eatWhitespace(stream);
	  }
	}));

	const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

	const numericEntries = digits.map(d => ({
	  key: d,
	  action: _readNumeric2.default
	}));

	const quotes = ['\'', '"'];

	const stringEntries = quotes.map(q => ({
	  key: q,
	  action: _readString2.default
	}));

	const identifierEntry = {
	  action: _readIdentifier2.default
	};

	const templateEntry = {
	  key: '`',
	  action: _readTemplate2.default
	};

	const primitiveReadtable = _readtable.EmptyReadtable.extendReadtable(...[identifierEntry, ...whiteSpaceEntries, templateEntry, ...punctuatorEntries, ...lineTerminatorEntries, ...numericEntries, ...stringEntries]);

	function readFromReadtable(reader, readtable, stream) {
	  const currentReadtable = (0, _reader.getCurrentReadtable)();
	  (0, _reader.setCurrentReadtable)(readtable);
	  const result = reader.readToken(stream);
	  (0, _reader.setCurrentReadtable)(currentReadtable);
	  return result;
	}

	const dotEntry = {
	  key: '.',
	  action: function readDot(stream, ...rest) {
	    const nxt = stream.peek(1).charCodeAt(0);
	    if ((0, _utils.isDecimalDigit)(nxt)) {
	      return (0, _readNumeric2.default)(stream, ...rest);
	    }
	    return readFromReadtable(this, primitiveReadtable, stream).token;
	  }
	};

	const keywordTable = Object.keys(_tokens.keywordTable).reduce(_utils.insertSequence, {});

	const keywordEntries = Object.keys(keywordTable).map(k => ({
	  key: k,
	  action: function readKeyword(stream) {
	    const len = (0, _utils.retrieveSequenceLength)(keywordTable, stream, 0);
	    if (len > 0 && !(0, _utils.isIdentifierPart)(stream.peek(len).charCodeAt(0))) {
	      return new _tokens.KeywordToken({
	        value: stream.readString(len)
	      });
	    }
	    return readFromReadtable(this, primitiveReadtable, stream).token;
	  }
	}));

	const topLevelEntry = {
	  key: '',
	  action: function readTopLevel(stream) {
	    return _readDelimiter2.default.call(this, '', stream, (0, _immutable.List)(), false);
	  }
	};

	const delimiterPairs = [['[', ']'], ['(', ')']];

	function readDelimiters(opening, closing, stream, prefix, b) {
	  const currentReadtable = (0, _reader.getCurrentReadtable)();
	  (0, _reader.setCurrentReadtable)(primitiveReadtable);

	  let results = _immutable.List.of(this.readToken(stream, (0, _immutable.List)(), b));

	  (0, _reader.setCurrentReadtable)(currentReadtable);
	  results = results.concat(_readDelimiter2.default.call(this, closing, stream, results, b));

	  results = results.push(this.readToken(stream, results, b));
	  return results;
	}

	const delimiterEntries = delimiterPairs.map(p => ({
	  key: p[0],
	  action: function readDefaultDelimiters(stream, prefix, b) {
	    return readDelimiters.call(this, p[0], p[1], stream, prefix, true);
	  }
	}));

	const bracesEntry = {
	  key: '{',
	  action: function readBraces(stream, prefix, b) {
	    const line = this.locationInfo.line;
	    const innerB = (0, _utils.isExprPrefix)(line, b)(prefix);
	    return readDelimiters.call(this, '{', '}', stream, prefix, innerB);
	  }
	};

	function readClosingDelimiter(opening, closing, stream, prefix, b) {
	  if (prefix.first().token.value !== opening) {
	    throw Error('Unmatched delimiter:', closing);
	  }
	  return readFromReadtable(this, primitiveReadtable, stream).token;
	}

	const unmatchedDelimiterEntries = [['{', '}'], ['[', ']'], ['(', ')']].map(p => ({
	  key: p[1],
	  action: function readClosingDelimiters(stream, prefix, b) {
	    return readClosingDelimiter.call(this, ...p, stream, prefix, b);
	  }
	}));

	const divEntry = {
	  key: '/',
	  action: function readDiv(stream, prefix, b) {
	    let nxt = stream.peek(1);
	    if (nxt === '/' || nxt === '*') {
	      const result = _readComment2.default.call(this, stream);
	      return result;
	    }
	    if ((0, _utils.isRegexPrefix)(b)(prefix)) {
	      return _readRegexp2.default.call(this, stream, prefix, b);
	    }
	    return readFromReadtable(this, primitiveReadtable, stream).token;
	  }
	};

	const dispatchEntry = {
	  key: '#',
	  action: function readHash(stream, prefix, b) {
	    const nxt = stream.peek(1).charCodeAt(0);
	    if ((0, _utils.isWhiteSpace)(nxt) || (0, _utils.isLineTerminator)(nxt)) {
	      return new _tokens.IdentifierToken({ value: stream.readString() });
	    }
	    return _readDispatch2.default.call(this, stream, prefix, b);
	  }
	};

	const atEntry = {
	  key: '@',
	  action: function readAt(stream, prefix) {
	    const nxt = stream.peek(1).charCodeAt(0);
	    if ((0, _utils.isWhiteSpace)(nxt) || (0, _utils.isLineTerminator)(nxt)) {
	      return new _tokens.IdentifierToken({ value: stream.readString() });
	    }
	    throw new SyntaxError('Invalid or unexpected token');
	  }
	};

	const defaultReadtable = primitiveReadtable.extendReadtable(...[topLevelEntry, dotEntry, ...delimiterEntries, ...unmatchedDelimiterEntries, bracesEntry, divEntry, ...keywordEntries, dispatchEntry, atEntry]);

	exports.default = defaultReadtable;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvZGVmYXVsdC1yZWFkdGFibGUuanMiXSwibmFtZXMiOlsiZWF0V2hpdGVzcGFjZSIsInN0cmVhbSIsInJlYWRTdHJpbmciLCJwdW5jdHVhdG9yVGFibGUiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicmVhZFB1bmN0dWF0b3IiLCJsZW4iLCJ2YWx1ZSIsIkVycm9yIiwicHVuY3R1YXRvckVudHJpZXMiLCJtYXAiLCJwIiwia2V5IiwiYWN0aW9uIiwid2hpdGVTcGFjZVRhYmxlIiwid2hpdGVTcGFjZUVudHJpZXMiLCJ3IiwibGluZVRlcm1pbmF0b3JUYWJsZSIsImxpbmVUZXJtaW5hdG9yRW50cmllcyIsImx0IiwicmVhZExpbmVUZXJtaW5hdG9yIiwiaW5jcmVtZW50TGluZSIsImRpZ2l0cyIsIm51bWVyaWNFbnRyaWVzIiwiZCIsInF1b3RlcyIsInN0cmluZ0VudHJpZXMiLCJxIiwiaWRlbnRpZmllckVudHJ5IiwidGVtcGxhdGVFbnRyeSIsInByaW1pdGl2ZVJlYWR0YWJsZSIsImV4dGVuZFJlYWR0YWJsZSIsInJlYWRGcm9tUmVhZHRhYmxlIiwicmVhZGVyIiwicmVhZHRhYmxlIiwiY3VycmVudFJlYWR0YWJsZSIsInJlc3VsdCIsInJlYWRUb2tlbiIsImRvdEVudHJ5IiwicmVhZERvdCIsInJlc3QiLCJueHQiLCJwZWVrIiwiY2hhckNvZGVBdCIsInRva2VuIiwia2V5d29yZFRhYmxlIiwia2V5d29yZEVudHJpZXMiLCJrIiwicmVhZEtleXdvcmQiLCJ0b3BMZXZlbEVudHJ5IiwicmVhZFRvcExldmVsIiwiY2FsbCIsImRlbGltaXRlclBhaXJzIiwicmVhZERlbGltaXRlcnMiLCJvcGVuaW5nIiwiY2xvc2luZyIsInByZWZpeCIsImIiLCJyZXN1bHRzIiwib2YiLCJjb25jYXQiLCJwdXNoIiwiZGVsaW1pdGVyRW50cmllcyIsInJlYWREZWZhdWx0RGVsaW1pdGVycyIsImJyYWNlc0VudHJ5IiwicmVhZEJyYWNlcyIsImxpbmUiLCJsb2NhdGlvbkluZm8iLCJpbm5lckIiLCJyZWFkQ2xvc2luZ0RlbGltaXRlciIsImZpcnN0IiwidW5tYXRjaGVkRGVsaW1pdGVyRW50cmllcyIsInJlYWRDbG9zaW5nRGVsaW1pdGVycyIsImRpdkVudHJ5IiwicmVhZERpdiIsImRpc3BhdGNoRW50cnkiLCJyZWFkSGFzaCIsImF0RW50cnkiLCJyZWFkQXQiLCJTeW50YXhFcnJvciIsImRlZmF1bHRSZWFkdGFibGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBLFNBQVNBLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQTJDO0FBQ3pDQSxTQUFPQyxVQUFQO0FBQ0E7QUFDRDs7QUFFRCxNQUFNQyxrQkFBa0JDLE9BQU9DLElBQVAsMEJBQStCQyxNQUEvQix3QkFBc0QsRUFBdEQsQ0FBeEI7O0FBRUEsU0FBU0MsY0FBVCxDQUF3Qk4sTUFBeEIsRUFBZ0M7QUFDOUIsUUFBTU8sTUFBTSxtQ0FBdUJMLGVBQXZCLEVBQXdDRixNQUF4QyxFQUFnRCxDQUFoRCxDQUFaO0FBQ0EsTUFBSU8sTUFBTSxDQUFWLEVBQWE7QUFDWCxXQUFPLDRCQUFvQjtBQUN6QkMsYUFBT1IsT0FBT0MsVUFBUCxDQUFrQk0sR0FBbEI7QUFEa0IsS0FBcEIsQ0FBUDtBQUdEO0FBQ0QsUUFBTUUsTUFBTSxvQkFBTixDQUFOO0FBQ0Q7O0FBRUQsTUFBTUMsb0JBQW9CUCxPQUFPQyxJQUFQLENBQVlGLGVBQVosRUFBNkJTLEdBQTdCLENBQWlDQyxNQUFNO0FBQy9EQyxPQUFLRCxDQUQwRDtBQUUvREUsVUFBUVI7QUFGdUQsQ0FBTixDQUFqQyxDQUExQjs7QUFLQSxNQUFNUyxrQkFBa0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsTUFB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LFVBQVAsRUFBVCxFQUFwQixDQUFQO0FBQ0Q7QUFDRCxVQUFNLElBQUkrRSxXQUFKLENBQWdCLDZCQUFoQixDQUFOO0FBQ0Q7QUFSYSxDQUFoQjs7QUFXQSxNQUFNQyxtQkFBbUJsRCxtQkFBbUJDLGVBQW5CLENBQ3ZCLEdBQUcsQ0FBQ2tCLGFBQUQsRUFDRFgsUUFEQyxFQUVELEdBQUd3QixnQkFGRixFQUdELEdBQUdTLHlCQUhGLEVBSURQLFdBSkMsRUFLRFMsUUFMQyxFQU1ELEdBQUczQixjQU5GLEVBT0Q2QixhQVBDLEVBUURFLE9BUkMsQ0FEb0IsQ0FBekI7O2tCQVdlRyxnQiIsImZpbGUiOiJkZWZhdWx0LXJlYWR0YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgRW1wdHlSZWFkdGFibGUgfSBmcm9tICcuL3JlYWR0YWJsZSc7XG5pbXBvcnQgeyBnZXRDdXJyZW50UmVhZHRhYmxlLCBzZXRDdXJyZW50UmVhZHRhYmxlIH0gZnJvbSAnLi9yZWFkZXInO1xuaW1wb3J0IHJlYWRJZGVudGlmaWVyIGZyb20gJy4vcmVhZC1pZGVudGlmaWVyJztcbmltcG9ydCByZWFkTnVtZXJpY0xpdGVyYWwgZnJvbSAnLi9yZWFkLW51bWVyaWMnO1xuaW1wb3J0IHJlYWRTdHJpbmdMaXRlcmFsIGZyb20gJy4vcmVhZC1zdHJpbmcnO1xuaW1wb3J0IHJlYWRUZW1wbGF0ZUxpdGVyYWwgZnJvbSAnLi9yZWFkLXRlbXBsYXRlJztcbmltcG9ydCByZWFkRGVsaW1pdGVyIGZyb20gJy4vcmVhZC1kZWxpbWl0ZXInO1xuaW1wb3J0IHJlYWRSZWdFeHAgZnJvbSAnLi9yZWFkLXJlZ2V4cC5qcyc7XG5pbXBvcnQgcmVhZENvbW1lbnQgZnJvbSAnLi9yZWFkLWNvbW1lbnQnO1xuaW1wb3J0IHJlYWREaXNwYXRjaCBmcm9tICcuL3JlYWQtZGlzcGF0Y2gnO1xuaW1wb3J0IHsgcHVuY3R1YXRvclRhYmxlIGFzIHB1bmN0dWF0b3JNYXBwaW5nLCBrZXl3b3JkVGFibGUgYXMga2V5d29yZE1hcHBpbmcsXG4gICAgICAgICBLZXl3b3JkVG9rZW4sIFB1bmN0dWF0b3JUb2tlbiwgRW1wdHlUb2tlbiwgSWRlbnRpZmllclRva2VuIH0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IGluc2VydFNlcXVlbmNlLCByZXRyaWV2ZVNlcXVlbmNlTGVuZ3RoLCBpc0V4cHJQcmVmaXgsIGlzUmVnZXhQcmVmaXgsIGlzSWRlbnRpZmllclBhcnQsIGlzV2hpdGVTcGFjZSwgaXNMaW5lVGVybWluYXRvciwgaXNEZWNpbWFsRGlnaXQgfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHR5cGUgQ2hhclN0cmVhbSBmcm9tICcuL2NoYXItc3RyZWFtJztcblxuLy8gdXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGUgdG8gZ2VuZXJhdGUgdGhlIFVuaWNvZGUgY29kZSBwb2ludHMgd2hlbiBpbXBsZW1lbnRpbmcgbW9kZXNcblxuZnVuY3Rpb24gZWF0V2hpdGVzcGFjZShzdHJlYW06IENoYXJTdHJlYW0pIHtcbiAgc3RyZWFtLnJlYWRTdHJpbmcoKTtcbiAgcmV0dXJuIEVtcHR5VG9rZW47XG59XG5cbmNvbnN0IHB1bmN0dWF0b3JUYWJsZSA9IE9iamVjdC5rZXlzKHB1bmN0dWF0b3JNYXBwaW5nKS5yZWR1Y2UoaW5zZXJ0U2VxdWVuY2UsIHt9KTtcblxuZnVuY3Rpb24gcmVhZFB1bmN0dWF0b3Ioc3RyZWFtKSB7XG4gIGNvbnN0IGxlbiA9IHJldHJpZXZlU2VxdWVuY2VMZW5ndGgocHVuY3R1YXRvclRhYmxlLCBzdHJlYW0sIDApO1xuICBpZiAobGVuID4gMCkge1xuICAgIHJldHVybiBuZXcgUHVuY3R1YXRvclRva2VuKHtcbiAgICAgIHZhbHVlOiBzdHJlYW0ucmVhZFN0cmluZyhsZW4pXG4gICAgfSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vua25vd24gcHVuY3R1YXRvcicpO1xufVxuXG5jb25zdCBwdW5jdHVhdG9yRW50cmllcyA9IE9iamVjdC5rZXlzKHB1bmN0dWF0b3JUYWJsZSkubWFwKHAgPT4gKHtcbiAga2V5OiBwLFxuICBhY3Rpb246IHJlYWRQdW5jdHVhdG9yXG59KSk7XG5cbmNvbnN0IHdoaXRlU3BhY2VUYWJsZSA9IFsweDIwLCAweDA5LCAweDBCLCAweDBDLCAweEEwLCAweDE2ODAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXTtcblxuY29uc3Qgd2hpdGVTcGFjZUVudHJpZXMgPSB3aGl0ZVNwYWNlVGFibGUubWFwKHcgPT4gKHtcbiAga2V5OiB3LFxuICBhY3Rpb246IGVhdFdoaXRlc3BhY2Vcbn0pKTtcblxuY29uc3QgbGluZVRlcm1pbmF0b3JUYWJsZSA9IFsweDBBLCAweDBELCAweDIwMjgsIDB4MjAyOV07XG5cbmNvbnN0IGxpbmVUZXJtaW5hdG9yRW50cmllcyA9IGxpbmVUZXJtaW5hdG9yVGFibGUubWFwKGx0ID0+ICh7XG4gIGtleTogbHQsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZExpbmVUZXJtaW5hdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuaW5jcmVtZW50TGluZSgpO1xuICAgIHJldHVybiBlYXRXaGl0ZXNwYWNlKHN0cmVhbSk7XG4gIH1cbn0pKTtcblxuY29uc3QgZGlnaXRzID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5J107XG5cbmNvbnN0IG51bWVyaWNFbnRyaWVzID0gZGlnaXRzLm1hcChkID0+ICh7XG4gIGtleTogZCxcbiAgYWN0aW9uOiByZWFkTnVtZXJpY0xpdGVyYWxcbn0pKTtcblxuY29uc3QgcXVvdGVzID0gWydcXCcnLCAnXCInXTtcblxuY29uc3Qgc3RyaW5nRW50cmllcyA9IHF1b3Rlcy5tYXAocSA9PiAoe1xuICBrZXk6IHEsXG4gIGFjdGlvbjogcmVhZFN0cmluZ0xpdGVyYWxcbn0pKTtcblxuY29uc3QgaWRlbnRpZmllckVudHJ5ID0ge1xuICBhY3Rpb246IHJlYWRJZGVudGlmaWVyXG59O1xuXG5jb25zdCB0ZW1wbGF0ZUVudHJ5ID0ge1xuICBrZXk6ICdgJyxcbiAgYWN0aW9uOiByZWFkVGVtcGxhdGVMaXRlcmFsXG59O1xuXG5jb25zdCBwcmltaXRpdmVSZWFkdGFibGUgPSBFbXB0eVJlYWR0YWJsZS5leHRlbmRSZWFkdGFibGUoXG4gICAgLi4uW2lkZW50aWZpZXJFbnRyeSxcbiAgICAgICAgLi4ud2hpdGVTcGFjZUVudHJpZXMsXG4gICAgICAgIHRlbXBsYXRlRW50cnksXG4gICAgICAgIC4uLnB1bmN0dWF0b3JFbnRyaWVzLFxuICAgICAgICAuLi5saW5lVGVybWluYXRvckVudHJpZXMsXG4gICAgICAgIC4uLm51bWVyaWNFbnRyaWVzLFxuICAgICAgICAuLi5zdHJpbmdFbnRyaWVzXSk7XG5cbmZ1bmN0aW9uIHJlYWRGcm9tUmVhZHRhYmxlKHJlYWRlciwgcmVhZHRhYmxlLCBzdHJlYW0pIHtcbiAgY29uc3QgY3VycmVudFJlYWR0YWJsZSA9IGdldEN1cnJlbnRSZWFkdGFibGUoKTtcbiAgc2V0Q3VycmVudFJlYWR0YWJsZShyZWFkdGFibGUpO1xuICBjb25zdCByZXN1bHQgPSByZWFkZXIucmVhZFRva2VuKHN0cmVhbSk7XG4gIHNldEN1cnJlbnRSZWFkdGFibGUoY3VycmVudFJlYWR0YWJsZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGRvdEVudHJ5ID0ge1xuICBrZXk6ICcuJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkRG90KHN0cmVhbSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG54dCA9IHN0cmVhbS5wZWVrKDEpLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KG54dCkpIHtcbiAgICAgIHJldHVybiByZWFkTnVtZXJpY0xpdGVyYWwoc3RyZWFtLCAuLi5yZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRGcm9tUmVhZHRhYmxlKHRoaXMsIHByaW1pdGl2ZVJlYWR0YWJsZSwgc3RyZWFtKS50b2tlbjtcbiAgfVxufVxuXG5jb25zdCBrZXl3b3JkVGFibGUgPSBPYmplY3Qua2V5cyhrZXl3b3JkTWFwcGluZykucmVkdWNlKGluc2VydFNlcXVlbmNlLCB7fSk7XG5cbmNvbnN0IGtleXdvcmRFbnRyaWVzID0gT2JqZWN0LmtleXMoa2V5d29yZFRhYmxlKS5tYXAoayA9PiAoe1xuICBrZXk6IGssXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZEtleXdvcmQoc3RyZWFtKSB7XG4gICAgY29uc3QgbGVuID0gcmV0cmlldmVTZXF1ZW5jZUxlbmd0aChrZXl3b3JkVGFibGUsIHN0cmVhbSwgMCk7XG4gICAgaWYgKGxlbiA+IDAgJiYgIWlzSWRlbnRpZmllclBhcnQoc3RyZWFtLnBlZWsobGVuKS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgcmV0dXJuIG5ldyBLZXl3b3JkVG9rZW4oe1xuICAgICAgICB2YWx1ZTogc3RyZWFtLnJlYWRTdHJpbmcobGVuKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZWFkRnJvbVJlYWR0YWJsZSh0aGlzLCBwcmltaXRpdmVSZWFkdGFibGUsIHN0cmVhbSkudG9rZW47XG4gIH1cbn0pKTtcblxuY29uc3QgdG9wTGV2ZWxFbnRyeSA9IHtcbiAga2V5OiAnJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkVG9wTGV2ZWwoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHJlYWREZWxpbWl0ZXIuY2FsbCh0aGlzLCAnJywgc3RyZWFtLCBMaXN0KCksIGZhbHNlKTtcbiAgfVxufTtcblxuY29uc3QgZGVsaW1pdGVyUGFpcnMgPSBbWydbJywnXSddLCBbJygnLCcpJ11dO1xuXG5mdW5jdGlvbiByZWFkRGVsaW1pdGVycyhvcGVuaW5nLCBjbG9zaW5nLCBzdHJlYW0sIHByZWZpeCwgYikge1xuICBjb25zdCBjdXJyZW50UmVhZHRhYmxlID0gZ2V0Q3VycmVudFJlYWR0YWJsZSgpO1xuICBzZXRDdXJyZW50UmVhZHRhYmxlKHByaW1pdGl2ZVJlYWR0YWJsZSk7XG5cbiAgbGV0IHJlc3VsdHMgPSBMaXN0Lm9mKHRoaXMucmVhZFRva2VuKHN0cmVhbSwgTGlzdCgpLCBiKSk7XG5cbiAgc2V0Q3VycmVudFJlYWR0YWJsZShjdXJyZW50UmVhZHRhYmxlKTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlYWREZWxpbWl0ZXIuY2FsbCh0aGlzLCBjbG9zaW5nLCBzdHJlYW0sIHJlc3VsdHMsIGIpKTtcblxuICByZXN1bHRzID0gcmVzdWx0cy5wdXNoKHRoaXMucmVhZFRva2VuKHN0cmVhbSwgcmVzdWx0cywgYikpO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuY29uc3QgZGVsaW1pdGVyRW50cmllcyA9IGRlbGltaXRlclBhaXJzLm1hcChwID0+ICh7XG4gIGtleTogcFswXSxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkRGVmYXVsdERlbGltaXRlcnMoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICByZXR1cm4gcmVhZERlbGltaXRlcnMuY2FsbCh0aGlzLCBwWzBdLCBwWzFdLCBzdHJlYW0sIHByZWZpeCwgdHJ1ZSk7XG4gIH1cbn0pKTtcblxuY29uc3QgYnJhY2VzRW50cnkgPSB7XG4gIGtleTogJ3snLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWRCcmFjZXMoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICBjb25zdCBsaW5lID0gdGhpcy5sb2NhdGlvbkluZm8ubGluZTtcbiAgICBjb25zdCBpbm5lckIgPSBpc0V4cHJQcmVmaXgobGluZSwgYikocHJlZml4KTtcbiAgICByZXR1cm4gcmVhZERlbGltaXRlcnMuY2FsbCh0aGlzLCAneycsICd9Jywgc3RyZWFtLCBwcmVmaXgsIGlubmVyQik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlYWRDbG9zaW5nRGVsaW1pdGVyKG9wZW5pbmcsIGNsb3NpbmcsIHN0cmVhbSwgcHJlZml4LCBiKSB7XG4gIGlmIChwcmVmaXguZmlyc3QoKS50b2tlbi52YWx1ZSAhPT0gb3BlbmluZykge1xuICAgIHRocm93IEVycm9yKCdVbm1hdGNoZWQgZGVsaW1pdGVyOicsIGNsb3NpbmcpO1xuICB9XG4gIHJldHVybiByZWFkRnJvbVJlYWR0YWJsZSh0aGlzLCBwcmltaXRpdmVSZWFkdGFibGUsIHN0cmVhbSkudG9rZW47XG59XG5cbmNvbnN0IHVubWF0Y2hlZERlbGltaXRlckVudHJpZXMgPSBbWyd7JywnfSddLCBbJ1snLCddJ10sIFsnKCcsJyknXV0ubWFwKHAgPT4gKHtcbiAga2V5OiBwWzFdLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWRDbG9zaW5nRGVsaW1pdGVycyhzdHJlYW0sIHByZWZpeCwgYikge1xuICAgIHJldHVybiByZWFkQ2xvc2luZ0RlbGltaXRlci5jYWxsKHRoaXMsIC4uLnAsIHN0cmVhbSwgcHJlZml4LCBiKTtcbiAgfVxufSkpO1xuXG5jb25zdCBkaXZFbnRyeSA9IHtcbiAga2V5OiAnLycsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZERpdihzdHJlYW0sIHByZWZpeCwgYikge1xuICAgIGxldCBueHQgPSBzdHJlYW0ucGVlaygxKTtcbiAgICBpZiAobnh0ID09PSAnLycgfHwgbnh0ID09PSAnKicpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRDb21tZW50LmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChpc1JlZ2V4UHJlZml4KGIpKHByZWZpeCkpIHtcbiAgICAgIHJldHVybiByZWFkUmVnRXhwLmNhbGwodGhpcywgc3RyZWFtLCBwcmVmaXgsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVhZEZyb21SZWFkdGFibGUodGhpcywgcHJpbWl0aXZlUmVhZHRhYmxlLCBzdHJlYW0pLnRva2VuO1xuICB9XG59O1xuXG5jb25zdCBkaXNwYXRjaEVudHJ5ID0ge1xuICBrZXk6ICcjJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkSGFzaChzdHJlYW0sIHByZWZpeCwgYikge1xuICAgIGNvbnN0IG54dCA9IHN0cmVhbS5wZWVrKDEpLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGlzV2hpdGVTcGFjZShueHQpIHx8IGlzTGluZVRlcm1pbmF0b3Iobnh0KSkge1xuICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyVG9rZW4oeyB2YWx1ZTogc3RyZWFtLnJlYWRTdHJpbmcoKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWREaXNwYXRjaC5jYWxsKHRoaXMsIHN0cmVhbSwgcHJlZml4LCBiKTtcbiAgfVxufTtcblxuY29uc3QgYXRFbnRyeSA9IHtcbiAga2V5OiAnQCcsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZEF0KHN0cmVhbSwgcHJlZml4KSB7XG4gICAgY29uc3Qgbnh0ID0gc3RyZWFtLnBlZWsoMSkuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoaXNXaGl0ZVNwYWNlKG54dCkgfHwgaXNMaW5lVGVybWluYXRvcihueHQpKSB7XG4gICAgICByZXR1cm4gbmV3IElkZW50aWZpZXJUb2tlbih7IHZhbHVlOiBzdHJlYW0ucmVhZFN0cmluZygpIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgb3IgdW5leHBlY3RlZCB0b2tlbicpO1xuICB9XG59O1xuXG5jb25zdCBkZWZhdWx0UmVhZHRhYmxlID0gcHJpbWl0aXZlUmVhZHRhYmxlLmV4dGVuZFJlYWR0YWJsZShcbiAgLi4uW3RvcExldmVsRW50cnksXG4gICAgZG90RW50cnksXG4gICAgLi4uZGVsaW1pdGVyRW50cmllcyxcbiAgICAuLi51bm1hdGNoZWREZWxpbWl0ZXJFbnRyaWVzLFxuICAgIGJyYWNlc0VudHJ5LFxuICAgIGRpdkVudHJ5LFxuICAgIC4uLmtleXdvcmRFbnRyaWVzLFxuICAgIGRpc3BhdGNoRW50cnksXG4gICAgYXRFbnRyeV0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0UmVhZHRhYmxlO1xuIl19

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});


	/*
	 * Note: these are possible features for future enhancements. 
	 * extendReadtable features:
	 * 1. { key, mode: TerminatingMacro, action } - creates a delimiter must return an Array/List
	 * 2. { key, mode: NonTerminatingMacro, action } - must return a Token or null/undefined. null/undefined simply consumes the read charstream.
	 * 3. { key, mode: DispatchMacro, action } - triggered by reading #. otherwise like 2
	 * 4. { key, delegateKey, delegateReadtable } - delegates to likeChar entry in readtable. Can be implemented
	 *    by getEntry(delegateReadtable, delegateKey), adding key and passing to extendReadtable
	 * 5. { key: null, mode: NonTerminatingMacro, action } - sets the default behavior for unmatched characters (identifiers/numbers)
	 */

	class Readtable {
	  constructor(entries = []) {
	    this._entries = entries;
	  }

	  getEntry(key) {
	    if (!isValidKey(key)) throw Error('Invalid key type:', key);
	    return this._entries[convertKey(key)] || this._entries[0];
	  }

	  extendReadtable(...entries) {
	    const newTable = this._entries.slice();
	    return new Readtable(entries.reduce(addEntry, newTable));
	  }
	}

	exports.default = Readtable;
	function addEntry(table, { key, action }) {
	  if (!isValidKey(key)) throw Error('Invalid key type:', key);
	  if (!isValidEntry({ key, action })) throw Error('Invalid readtable entry:', { key, action });

	  // null/undefined key is the default and will be converted to 0
	  // chars will be converted via codePointAt
	  // numbers are...numbers
	  // to accommodate default (null) 1 will be added to all and default will be at 0
	  table[convertKey(key)] = { action };

	  // if is a dispatch macro, we have to convert the key and bump it up by 0x110000
	  // Note: The above depends on a primitive implementation of dispatch macros.
	  //       I'm considering another implementation which will just use the current capabilities.
	  return table;
	}

	const EmptyReadtable = exports.EmptyReadtable = new Readtable();

	// Note: This was an experiment. IF the mode flags are included here, they can just be string constants.
	// Symbol.for creates cross-realm Symbols
	// export const TerminatingMacro = Symbol.for('readtable.terminating-macro-mode');
	// export const NonTerminatingMacro = Symbol.for('readtable.non-terminating-macro-mode');
	// export const DispatchMacro = Symbol.for('readtable.dispatch-macro-mode');

	function isValidKey(key) {
	  return key == null || typeof key === 'number' && key <= 0x10FFFF || typeof key === 'string' && key.length >= 0 && key.length <= 2;
	}

	// function isValidMode(mode: Symbol): boolean {
	//   return mode === TerminatingMacro || mode === NonTerminatingMacro || mode === DispatchMacro;
	// }

	function isValidAction(action) {
	  return typeof action === 'function';
	}

	function isValidEntry(entry) {
	  return entry && isValidKey(entry.key) && /*isValidMode(entry.mode) &&*/isValidAction(entry.action);
	}

	function convertKey(key) {
	  return key == null ? 0 : (typeof key === 'number' ? key : key.codePointAt(0)) + 1;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZHRhYmxlLmpzIl0sIm5hbWVzIjpbIlJlYWR0YWJsZSIsImNvbnN0cnVjdG9yIiwiZW50cmllcyIsIl9lbnRyaWVzIiwiZ2V0RW50cnkiLCJrZXkiLCJpc1ZhbGlkS2V5IiwiRXJyb3IiLCJjb252ZXJ0S2V5IiwiZXh0ZW5kUmVhZHRhYmxlIiwibmV3VGFibGUiLCJzbGljZSIsInJlZHVjZSIsImFkZEVudHJ5IiwidGFibGUiLCJhY3Rpb24iLCJpc1ZhbGlkRW50cnkiLCJFbXB0eVJlYWR0YWJsZSIsImxlbmd0aCIsImlzVmFsaWRBY3Rpb24iLCJlbnRyeSIsImNvZGVQb2ludEF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7O0FBV2UsTUFBTUEsU0FBTixDQUFnQjtBQUU3QkMsY0FBWUMsVUFBaUMsRUFBN0MsRUFBaUQ7QUFDL0MsU0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDRDs7QUFFREUsV0FBU0MsR0FBVCxFQUE2QztBQUMzQyxRQUFJLENBQUNDLFdBQVdELEdBQVgsQ0FBTCxFQUFzQixNQUFNRSxNQUFNLG1CQUFOLEVBQTJCRixHQUEzQixDQUFOO0FBQ3RCLFdBQU8sS0FBS0YsUUFBTCxDQUFjSyxXQUFXSCxHQUFYLENBQWQsS0FBa0MsS0FBS0YsUUFBTCxDQUFjLENBQWQsQ0FBekM7QUFDRDs7QUFFRE0sa0JBQWdCLEdBQUdQLE9BQW5CLEVBQThEO0FBQzVELFVBQU1RLFdBQVcsS0FBS1AsUUFBTCxDQUFjUSxLQUFkLEVBQWpCO0FBQ0EsV0FBTyxJQUFJWCxTQUFKLENBQWNFLFFBQVFVLE1BQVIsQ0FBZUMsUUFBZixFQUF5QkgsUUFBekIsQ0FBZCxDQUFQO0FBQ0Q7QUFkNEI7O2tCQUFWVixTO0FBaUJyQixTQUFTYSxRQUFULENBQWtCQyxLQUFsQixFQUFnRCxFQUFFVCxHQUFGLEVBQU9VLE1BQVAsRUFBaEQsRUFBd0c7QUFDdEcsTUFBSSxDQUFDVCxXQUFXRCxHQUFYLENBQUwsRUFBc0IsTUFBTUUsTUFBTSxtQkFBTixFQUEyQkYsR0FBM0IsQ0FBTjtBQUN0QixNQUFJLENBQUNXLGFBQWEsRUFBQ1gsR0FBRCxFQUFNVSxNQUFOLEVBQWIsQ0FBTCxFQUFrQyxNQUFNUixNQUFNLDBCQUFOLEVBQWtDLEVBQUNGLEdBQUQsRUFBTVUsTUFBTixFQUFsQyxDQUFOOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBRCxRQUFNTixXQUFXSCxHQUFYLENBQU4sSUFBeUIsRUFBRVUsTUFBRixFQUF6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFPRCxLQUFQO0FBQ0Q7O0FBRU0sTUFBTUcsMENBQWlCLElBQUlqQixTQUFKLEVBQXZCOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU00sVUFBVCxDQUFvQkQsR0FBcEIsRUFBeUI7QUFDdkIsU0FBT0EsT0FBTyxJQUFQLElBQ0osT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLE9BQU8sUUFEOUIsSUFFSixPQUFPQSxHQUFQLEtBQWUsUUFBZixJQUE0QkEsSUFBSWEsTUFBSixJQUFjLENBQWQsSUFBbUJiLElBQUlhLE1BQUosSUFBYyxDQUZoRTtBQUdEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQyxhQUFULENBQXVCSixNQUF2QixFQUErQjtBQUM3QixTQUFPLE9BQU9BLE1BQVAsS0FBa0IsVUFBekI7QUFDRDs7QUFXRCxTQUFTQyxZQUFULENBQXNCSSxLQUF0QixFQUE2QjtBQUMzQixTQUFPQSxTQUFTZCxXQUFXYyxNQUFNZixHQUFqQixDQUFULElBQWtDLDhCQUErQmMsY0FBY0MsTUFBTUwsTUFBcEIsQ0FBeEU7QUFDRDs7QUFFRCxTQUFTUCxVQUFULENBQW9CSCxHQUFwQixFQUFnRDtBQUM5QyxTQUFPQSxPQUFPLElBQVAsR0FBYyxDQUFkLEdBQWtCLENBQUMsT0FBT0EsR0FBUCxLQUFlLFFBQWYsR0FBMEJBLEdBQTFCLEdBQWdDQSxJQUFJZ0IsV0FBSixDQUFnQixDQUFoQixDQUFqQyxJQUF1RCxDQUFoRjtBQUNEIiwiZmlsZSI6InJlYWR0YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIENoYXJTdHJlYW0gZnJvbSAnLi9jaGFyLXN0cmVhbSc7XG5cbi8qXG4gKiBOb3RlOiB0aGVzZSBhcmUgcG9zc2libGUgZmVhdHVyZXMgZm9yIGZ1dHVyZSBlbmhhbmNlbWVudHMuIFxuICogZXh0ZW5kUmVhZHRhYmxlIGZlYXR1cmVzOlxuICogMS4geyBrZXksIG1vZGU6IFRlcm1pbmF0aW5nTWFjcm8sIGFjdGlvbiB9IC0gY3JlYXRlcyBhIGRlbGltaXRlciBtdXN0IHJldHVybiBhbiBBcnJheS9MaXN0XG4gKiAyLiB7IGtleSwgbW9kZTogTm9uVGVybWluYXRpbmdNYWNybywgYWN0aW9uIH0gLSBtdXN0IHJldHVybiBhIFRva2VuIG9yIG51bGwvdW5kZWZpbmVkLiBudWxsL3VuZGVmaW5lZCBzaW1wbHkgY29uc3VtZXMgdGhlIHJlYWQgY2hhcnN0cmVhbS5cbiAqIDMuIHsga2V5LCBtb2RlOiBEaXNwYXRjaE1hY3JvLCBhY3Rpb24gfSAtIHRyaWdnZXJlZCBieSByZWFkaW5nICMuIG90aGVyd2lzZSBsaWtlIDJcbiAqIDQuIHsga2V5LCBkZWxlZ2F0ZUtleSwgZGVsZWdhdGVSZWFkdGFibGUgfSAtIGRlbGVnYXRlcyB0byBsaWtlQ2hhciBlbnRyeSBpbiByZWFkdGFibGUuIENhbiBiZSBpbXBsZW1lbnRlZFxuICogICAgYnkgZ2V0RW50cnkoZGVsZWdhdGVSZWFkdGFibGUsIGRlbGVnYXRlS2V5KSwgYWRkaW5nIGtleSBhbmQgcGFzc2luZyB0byBleHRlbmRSZWFkdGFibGVcbiAqIDUuIHsga2V5OiBudWxsLCBtb2RlOiBOb25UZXJtaW5hdGluZ01hY3JvLCBhY3Rpb24gfSAtIHNldHMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHVubWF0Y2hlZCBjaGFyYWN0ZXJzIChpZGVudGlmaWVycy9udW1iZXJzKVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWR0YWJsZSB7XG4gIF9lbnRyaWVzOiBBcnJheTxSZWFkdGFibGVFbnRyeT47XG4gIGNvbnN0cnVjdG9yKGVudHJpZXM6IEFycmF5PFJlYWR0YWJsZUVudHJ5PiA9IFtdKSB7XG4gICAgdGhpcy5fZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBnZXRFbnRyeShrZXk/OiBSZWFkdGFibGVLZXkpOiBSZWFkdGFibGVFbnRyeSB7XG4gICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHRocm93IEVycm9yKCdJbnZhbGlkIGtleSB0eXBlOicsIGtleSk7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJpZXNbY29udmVydEtleShrZXkpXSB8fCB0aGlzLl9lbnRyaWVzWzBdO1xuICB9XG5cbiAgZXh0ZW5kUmVhZHRhYmxlKC4uLmVudHJpZXM6IEFycmF5PFJlYWR0YWJsZUVudHJ5Pik6IFJlYWR0YWJsZSB7XG4gICAgY29uc3QgbmV3VGFibGUgPSB0aGlzLl9lbnRyaWVzLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBSZWFkdGFibGUoZW50cmllcy5yZWR1Y2UoYWRkRW50cnksIG5ld1RhYmxlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRW50cnkodGFibGU6IEFycmF5PFJlYWR0YWJsZUVudHJ5PiwgeyBrZXksIGFjdGlvbiB9OiBSZWFkdGFibGVFbnRyeSk6IEFycmF5PFJlYWR0YWJsZUVudHJ5PiB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB0aHJvdyBFcnJvcignSW52YWxpZCBrZXkgdHlwZTonLCBrZXkpO1xuICBpZiAoIWlzVmFsaWRFbnRyeSh7a2V5LCBhY3Rpb259KSkgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVhZHRhYmxlIGVudHJ5OicsIHtrZXksIGFjdGlvbn0pO1xuXG4gIC8vIG51bGwvdW5kZWZpbmVkIGtleSBpcyB0aGUgZGVmYXVsdCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gMFxuICAvLyBjaGFycyB3aWxsIGJlIGNvbnZlcnRlZCB2aWEgY29kZVBvaW50QXRcbiAgLy8gbnVtYmVycyBhcmUuLi5udW1iZXJzXG4gIC8vIHRvIGFjY29tbW9kYXRlIGRlZmF1bHQgKG51bGwpIDEgd2lsbCBiZSBhZGRlZCB0byBhbGwgYW5kIGRlZmF1bHQgd2lsbCBiZSBhdCAwXG4gIHRhYmxlW2NvbnZlcnRLZXkoa2V5KV0gPSB7IGFjdGlvbiB9O1xuXG4gIC8vIGlmIGlzIGEgZGlzcGF0Y2ggbWFjcm8sIHdlIGhhdmUgdG8gY29udmVydCB0aGUga2V5IGFuZCBidW1wIGl0IHVwIGJ5IDB4MTEwMDAwXG4gIC8vIE5vdGU6IFRoZSBhYm92ZSBkZXBlbmRzIG9uIGEgcHJpbWl0aXZlIGltcGxlbWVudGF0aW9uIG9mIGRpc3BhdGNoIG1hY3Jvcy5cbiAgLy8gICAgICAgSSdtIGNvbnNpZGVyaW5nIGFub3RoZXIgaW1wbGVtZW50YXRpb24gd2hpY2ggd2lsbCBqdXN0IHVzZSB0aGUgY3VycmVudCBjYXBhYmlsaXRpZXMuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuZXhwb3J0IGNvbnN0IEVtcHR5UmVhZHRhYmxlID0gbmV3IFJlYWR0YWJsZSgpO1xuXG4vLyBOb3RlOiBUaGlzIHdhcyBhbiBleHBlcmltZW50LiBJRiB0aGUgbW9kZSBmbGFncyBhcmUgaW5jbHVkZWQgaGVyZSwgdGhleSBjYW4ganVzdCBiZSBzdHJpbmcgY29uc3RhbnRzLlxuLy8gU3ltYm9sLmZvciBjcmVhdGVzIGNyb3NzLXJlYWxtIFN5bWJvbHNcbi8vIGV4cG9ydCBjb25zdCBUZXJtaW5hdGluZ01hY3JvID0gU3ltYm9sLmZvcigncmVhZHRhYmxlLnRlcm1pbmF0aW5nLW1hY3JvLW1vZGUnKTtcbi8vIGV4cG9ydCBjb25zdCBOb25UZXJtaW5hdGluZ01hY3JvID0gU3ltYm9sLmZvcigncmVhZHRhYmxlLm5vbi10ZXJtaW5hdGluZy1tYWNyby1tb2RlJyk7XG4vLyBleHBvcnQgY29uc3QgRGlzcGF0Y2hNYWNybyA9IFN5bWJvbC5mb3IoJ3JlYWR0YWJsZS5kaXNwYXRjaC1tYWNyby1tb2RlJyk7XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgPT0gbnVsbCB8fFxuICAgICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiBrZXkgPD0gMHgxMEZGRkYpIHx8XG4gICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIChrZXkubGVuZ3RoID49IDAgJiYga2V5Lmxlbmd0aCA8PSAyKSk7XG59XG5cbi8vIGZ1bmN0aW9uIGlzVmFsaWRNb2RlKG1vZGU6IFN5bWJvbCk6IGJvb2xlYW4ge1xuLy8gICByZXR1cm4gbW9kZSA9PT0gVGVybWluYXRpbmdNYWNybyB8fCBtb2RlID09PSBOb25UZXJtaW5hdGluZ01hY3JvIHx8IG1vZGUgPT09IERpc3BhdGNoTWFjcm87XG4vLyB9XG5cbmZ1bmN0aW9uIGlzVmFsaWRBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nO1xufVxuXG50eXBlIFJlYWR0YWJsZUtleSA9IHN0cmluZyB8IG51bWJlciB8IG51bGw7XG5cbnR5cGUgQWN0aW9uID0gKHN0cmVhbTogQ2hhclN0cmVhbSwgLi4ucmVzdDogQXJyYXk8YW55PikgPT4gYW55O1xuXG5leHBvcnQgdHlwZSBSZWFkdGFibGVFbnRyeSA9IHtcbiAga2V5PzogP1JlYWR0YWJsZUtleSxcbiAgYWN0aW9uOiBBY3Rpb25cbn07XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRyeShlbnRyeSkge1xuICByZXR1cm4gZW50cnkgJiYgaXNWYWxpZEtleShlbnRyeS5rZXkpICYmIC8qaXNWYWxpZE1vZGUoZW50cnkubW9kZSkgJiYqLyBpc1ZhbGlkQWN0aW9uKGVudHJ5LmFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRLZXkoa2V5PzogUmVhZHRhYmxlS2V5KTogbnVtYmVyIHtcbiAgcmV0dXJuIGtleSA9PSBudWxsID8gMCA6ICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyA/IGtleSA6IGtleS5jb2RlUG9pbnRBdCgwKSkgKyAxO1xufVxuIl19

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readIdentifier;

	var _utils = __webpack_require__(13);

	var _charStream = __webpack_require__(8);

	var _tokens = __webpack_require__(30);

	function readIdentifier(stream) {
	  let char = stream.peek();
	  let code;
	  let check = _utils.isIdentifierStart;
	  let idx = 0;
	  while (!(0, _charStream.isEOS)(char)) {
	    code = char.charCodeAt(0);
	    if (char === '\\' || 0xD800 <= code && code <= 0xDBFF) {
	      return new _tokens.IdentifierToken({
	        value: getEscapedIdentifier.call(this, stream)
	      });
	    }
	    if (!check(code)) {
	      return new _tokens.IdentifierToken({
	        value: stream.readString(idx)
	      });
	    }
	    char = stream.peek(++idx);
	    check = _utils.isIdentifierPart;
	  }
	  return new _tokens.IdentifierToken({
	    value: stream.readString(idx)
	  });
	}

	function getEscapedIdentifier(stream) {
	  const sPeek = stream.peek.bind(stream);
	  let id = '';
	  let check = _utils.isIdentifierStart;
	  let char = sPeek();
	  let code = char.charCodeAt(0);
	  while (!(0, _charStream.isEOS)(char)) {
	    let streamRead = false;
	    if (char === '\\') {
	      let nxt = sPeek(1);
	      if ((0, _charStream.isEOS)(nxt)) {
	        throw this.createILLEGAL(char);
	      }
	      if (nxt !== 'u') {
	        throw this.createILLEGAL(char);
	      }
	      code = (0, _utils.scanUnicode)(stream, 2);
	      streamRead = true;
	      if (code < 0) {
	        throw this.createILLEGAL(char);
	      }
	    } else if (0xD800 <= code && code <= 0xDBFF) {
	      if ((0, _charStream.isEOS)(char)) {
	        throw this.createILLEGAL(char);
	      }
	      let lowSurrogateCode = sPeek(1).charCodeAt(0);
	      if (0xDC00 > lowSurrogateCode || lowSurrogateCode > 0xDFFF) {
	        throw this.createILLEGAL(char);
	      }
	      stream.readString(2);
	      code = decodeUtf16(code, lowSurrogateCode);
	    }
	    if (!check(code)) {
	      if (id.length < 1) {
	        throw this.createILLEGAL(char);
	      }
	      return id;
	    }

	    if (!streamRead) stream.readString();

	    id += String.fromCodePoint(code);
	    char = sPeek();
	    code = char.charCodeAt(0);
	    check = _utils.isIdentifierPart;
	  }
	  return id;
	}

	function decodeUtf16(lead, trail) {
	  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1pZGVudGlmaWVyLmpzIl0sIm5hbWVzIjpbInJlYWRJZGVudGlmaWVyIiwic3RyZWFtIiwiY2hhciIsInBlZWsiLCJjb2RlIiwiY2hlY2siLCJpZHgiLCJjaGFyQ29kZUF0IiwidmFsdWUiLCJnZXRFc2NhcGVkSWRlbnRpZmllciIsImNhbGwiLCJyZWFkU3RyaW5nIiwic1BlZWsiLCJiaW5kIiwiaWQiLCJzdHJlYW1SZWFkIiwibnh0IiwiY3JlYXRlSUxMRUdBTCIsImxvd1N1cnJvZ2F0ZUNvZGUiLCJkZWNvZGVVdGYxNiIsImxlbmd0aCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJsZWFkIiwidHJhaWwiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQVl3QkEsYzs7QUFWeEI7O0FBRUE7O0FBR0E7O0FBS2UsU0FBU0EsY0FBVCxDQUF3QkMsTUFBeEIsRUFBNEM7QUFDekQsTUFBSUMsT0FBT0QsT0FBT0UsSUFBUCxFQUFYO0FBQ0EsTUFBSUMsSUFBSjtBQUNBLE1BQUlDLGdDQUFKO0FBQ0EsTUFBSUMsTUFBTSxDQUFWO0FBQ0EsU0FBTSxDQUFDLHVCQUFNSixJQUFOLENBQVAsRUFBb0I7QUFDbEJFLFdBQU9GLEtBQUtLLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBUDtBQUNBLFFBQUlMLFNBQVMsSUFBVCxJQUFpQixVQUFVRSxJQUFWLElBQWtCQSxRQUFRLE1BQS9DLEVBQXVEO0FBQ3JELGFBQU8sNEJBQW9CO0FBQ3pCSSxlQUFPQyxxQkFBcUJDLElBQXJCLENBQTBCLElBQTFCLEVBQWdDVCxNQUFoQztBQURrQixPQUFwQixDQUFQO0FBR0Q7QUFDRCxRQUFJLENBQUNJLE1BQU1ELElBQU4sQ0FBTCxFQUFrQjtBQUNoQixhQUFPLDRCQUFvQjtBQUN6QkksZUFBT1AsT0FBT1UsVUFBUCxDQUFrQkwsR0FBbEI7QUFEa0IsT0FBcEIsQ0FBUDtBQUdEO0FBQ0RKLFdBQU9ELE9BQU9FLElBQVAsQ0FBWSxFQUFFRyxHQUFkLENBQVA7QUFDQUQ7QUFDRDtBQUNELFNBQU8sNEJBQW9CO0FBQ3pCRyxXQUFPUCxPQUFPVSxVQUFQLENBQWtCTCxHQUFsQjtBQURrQixHQUFwQixDQUFQO0FBR0Q7O0FBRUQsU0FBU0csb0JBQVQsQ0FBOEJSLE1BQTlCLEVBQXNDO0FBQ3BDLFFBQU1XLFFBQVFYLE9BQU9FLElBQVAsQ0FBWVUsSUFBWixDQUFpQlosTUFBakIsQ0FBZDtBQUNBLE1BQUlhLEtBQUssRUFBVDtBQUNBLE1BQUlULGdDQUFKO0FBQ0EsTUFBSUgsT0FBT1UsT0FBWDtBQUNBLE1BQUlSLE9BQU9GLEtBQUtLLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBWDtBQUNBLFNBQU8sQ0FBQyx1QkFBTUwsSUFBTixDQUFSLEVBQXFCO0FBQ25CLFFBQUlhLGFBQWEsS0FBakI7QUFDQSxRQUFJYixTQUFTLElBQWIsRUFBbUI7QUFDakIsVUFBSWMsTUFBTUosTUFBTSxDQUFOLENBQVY7QUFDQSxVQUFJLHVCQUFNSSxHQUFOLENBQUosRUFBZ0I7QUFDZCxjQUFNLEtBQUtDLGFBQUwsQ0FBbUJmLElBQW5CLENBQU47QUFDRDtBQUNELFVBQUljLFFBQVEsR0FBWixFQUFpQjtBQUNmLGNBQU0sS0FBS0MsYUFBTCxDQUFtQmYsSUFBbkIsQ0FBTjtBQUNEO0FBQ0RFLGFBQU8sd0JBQVlILE1BQVosRUFBb0IsQ0FBcEIsQ0FBUDtBQUNBYyxtQkFBYSxJQUFiO0FBQ0EsVUFBSVgsT0FBTyxDQUFYLEVBQWM7QUFDWixjQUFNLEtBQUthLGFBQUwsQ0FBbUJmLElBQW5CLENBQU47QUFDRDtBQUNGLEtBYkQsTUFhTyxJQUFJLFVBQVVFLElBQVYsSUFBa0JBLFFBQVEsTUFBOUIsRUFBc0M7QUFDM0MsVUFBSSx1QkFBTUYsSUFBTixDQUFKLEVBQWlCO0FBQ2YsY0FBTSxLQUFLZSxhQUFMLENBQW1CZixJQUFuQixDQUFOO0FBQ0Q7QUFDRCxVQUFJZ0IsbUJBQW1CTixNQUFNLENBQU4sRUFBU0wsVUFBVCxDQUFvQixDQUFwQixDQUF2QjtBQUNBLFVBQUksU0FBU1csZ0JBQVQsSUFBNkJBLG1CQUFtQixNQUFwRCxFQUE0RDtBQUMxRCxjQUFNLEtBQUtELGFBQUwsQ0FBbUJmLElBQW5CLENBQU47QUFDRDtBQUNERCxhQUFPVSxVQUFQLENBQWtCLENBQWxCO0FBQ0FQLGFBQU9lLFlBQVlmLElBQVosRUFBa0JjLGdCQUFsQixDQUFQO0FBQ0Q7QUFDRCxRQUFJLENBQUNiLE1BQU1ELElBQU4sQ0FBTCxFQUFrQjtBQUNoQixVQUFJVSxHQUFHTSxNQUFILEdBQVksQ0FBaEIsRUFBbUI7QUFDakIsY0FBTSxLQUFLSCxhQUFMLENBQW1CZixJQUFuQixDQUFOO0FBQ0Q7QUFDRCxhQUFPWSxFQUFQO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDQyxVQUFMLEVBQWlCZCxPQUFPVSxVQUFQOztBQUVqQkcsVUFBTU8sT0FBT0MsYUFBUCxDQUFxQmxCLElBQXJCLENBQU47QUFDQUYsV0FBT1UsT0FBUDtBQUNBUixXQUFPRixLQUFLSyxVQUFMLENBQWdCLENBQWhCLENBQVA7QUFDQUY7QUFDRDtBQUNELFNBQU9TLEVBQVA7QUFDRDs7QUFFRCxTQUFTSyxXQUFULENBQXFCSSxJQUFyQixFQUEyQkMsS0FBM0IsRUFBa0M7QUFDaEMsU0FBTyxDQUFDRCxPQUFPLE1BQVIsSUFBa0IsS0FBbEIsSUFBMkJDLFFBQVEsTUFBbkMsSUFBNkMsT0FBcEQ7QUFDRCIsImZpbGUiOiJyZWFkLWlkZW50aWZpZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgeyBzY2FuVW5pY29kZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQgeyBpc0VPUyB9IGZyb20gJy4vY2hhci1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgQ2hhclN0cmVhbSBmcm9tICcuL2NoYXItc3RyZWFtJztcblxuaW1wb3J0IHsgSWRlbnRpZmllclRva2VuIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuaW1wb3J0IHsgaXNJZGVudGlmaWVyUGFydCwgaXNJZGVudGlmaWVyU3RhcnQgfSBmcm9tICcuL3V0aWxzJztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkSWRlbnRpZmllcihzdHJlYW06IENoYXJTdHJlYW0pIHtcbiAgbGV0IGNoYXIgPSBzdHJlYW0ucGVlaygpO1xuICBsZXQgY29kZTtcbiAgbGV0IGNoZWNrID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gIGxldCBpZHggPSAwO1xuICB3aGlsZSghaXNFT1MoY2hhcikpIHtcbiAgICBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyID09PSAnXFxcXCcgfHwgMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllclRva2VuKHtcbiAgICAgICAgdmFsdWU6IGdldEVzY2FwZWRJZGVudGlmaWVyLmNhbGwodGhpcywgc3RyZWFtKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghY2hlY2soY29kZSkpIHtcbiAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllclRva2VuKHtcbiAgICAgICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKGlkeClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgIGNoZWNrID0gaXNJZGVudGlmaWVyUGFydDtcbiAgfVxuICByZXR1cm4gbmV3IElkZW50aWZpZXJUb2tlbih7XG4gICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKGlkeClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKHN0cmVhbSkge1xuICBjb25zdCBzUGVlayA9IHN0cmVhbS5wZWVrLmJpbmQoc3RyZWFtKTtcbiAgbGV0IGlkID0gJyc7XG4gIGxldCBjaGVjayA9IGlzSWRlbnRpZmllclN0YXJ0O1xuICBsZXQgY2hhciA9IHNQZWVrKCk7XG4gIGxldCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgbGV0IHN0cmVhbVJlYWQgPSBmYWxzZTtcbiAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICBsZXQgbnh0ID0gc1BlZWsoMSk7XG4gICAgICBpZiAoaXNFT1Mobnh0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgICB9XG4gICAgICBpZiAobnh0ICE9PSAndScpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICAgICAgfVxuICAgICAgY29kZSA9IHNjYW5Vbmljb2RlKHN0cmVhbSwgMik7XG4gICAgICBzdHJlYW1SZWFkID0gdHJ1ZTtcbiAgICAgIGlmIChjb2RlIDwgMCkge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikge1xuICAgICAgaWYgKGlzRU9TKGNoYXIpKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICAgIH1cbiAgICAgIGxldCBsb3dTdXJyb2dhdGVDb2RlID0gc1BlZWsoMSkuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmICgweERDMDAgPiBsb3dTdXJyb2dhdGVDb2RlIHx8IGxvd1N1cnJvZ2F0ZUNvZGUgPiAweERGRkYpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnJlYWRTdHJpbmcoMik7XG4gICAgICBjb2RlID0gZGVjb2RlVXRmMTYoY29kZSwgbG93U3Vycm9nYXRlQ29kZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2soY29kZSkpIHtcbiAgICAgIGlmIChpZC5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBpZiAoIXN0cmVhbVJlYWQpIHN0cmVhbS5yZWFkU3RyaW5nKCk7XG5cbiAgICBpZCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICBjaGFyID0gc1BlZWsoKTtcbiAgICBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICAgIGNoZWNrID0gaXNJZGVudGlmaWVyUGFydDtcbiAgfVxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjE2KGxlYWQsIHRyYWlsKSB7XG4gIHJldHVybiAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xufVxuXG4iXX0=

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isRegexPrefix = exports.isExprPrefix = exports.isIdentifierPart = exports.isIdentifierStart = exports.isDecimalDigit = exports.isWhiteSpace = exports.isLineTerminator = exports.RSYNTAX = exports.LSYNTAX = undefined;
	exports.getHexValue = getHexValue;
	exports.skipSingleLineComment = skipSingleLineComment;
	exports.scanUnicode = scanUnicode;
	exports.readStringEscape = readStringEscape;
	exports.insertSequence = insertSequence;
	exports.retrieveSequenceLength = retrieveSequenceLength;

	var _charStream = __webpack_require__(8);

	var _esutils = __webpack_require__(14);

	var _ramda = __webpack_require__(18);

	var R = _interopRequireWildcard(_ramda);

	var _ramdaFantasy = __webpack_require__(19);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	const { isLineTerminator,
	  isWhiteSpace,
	  isDecimalDigit,
	  isIdentifierPartES6: isIdentifierPart,
	  isIdentifierStartES6: isIdentifierStart } = _esutils.code;

	const Just = _ramdaFantasy.Maybe.Just;
	const Nothing = _ramdaFantasy.Maybe.Nothing;

	const LSYNTAX = exports.LSYNTAX = { name: 'left-syntax' };
	const RSYNTAX = exports.RSYNTAX = { name: 'right-syntax' };

	// TODO: also, need to handle contextual yield
	const literalKeywords = ['this', 'null', 'true', 'false'];

	exports.isLineTerminator = isLineTerminator;
	exports.isWhiteSpace = isWhiteSpace;
	exports.isDecimalDigit = isDecimalDigit;
	exports.isIdentifierStart = isIdentifierStart;
	exports.isIdentifierPart = isIdentifierPart;
	function getHexValue(rune) {
	  if ('0' <= rune && rune <= '9') {
	    return rune.charCodeAt(0) - 48;
	  }
	  if ('a' <= rune && rune <= 'f') {
	    return rune.charCodeAt(0) - 87;
	  }
	  if ('A' <= rune && rune <= 'F') {
	    return rune.charCodeAt(0) - 55;
	  }
	  return -1;
	}

	function skipSingleLineComment(stream) {
	  let idx = 0;
	  let char = stream.peek(idx);
	  while (!(0, _charStream.isEOS)(char)) {
	    let chCode = char.charCodeAt(0);
	    if (isLineTerminator(chCode)) {
	      ++idx;
	      if (chCode === 0xD /* "\r" */ && stream.peek(idx).charCodeAt(0) === 0xA /*"\n" */) {
	          ++idx;
	        }
	      this.incrementLine();
	      break;
	    }
	    ++idx;
	    char = stream.peek(idx);
	  }
	  stream.readString(idx);
	}

	function scanUnicode(stream, start) {
	  const sPeek = stream.peek.bind(stream);
	  let idx = start;
	  let hexDigits = 0;
	  if (sPeek(idx) === '{') {
	    //\u{HexDigits}
	    ++idx;
	    let char = sPeek(idx);
	    while (!(0, _charStream.isEOS)(char)) {
	      let hex = getHexValue(char);
	      if (hex === -1) break;
	      hexDigits = hexDigits << 4 | hex;
	      if (hexDigits > 0x10FFFF) {
	        throw this.createILLEGAL(char);
	      }
	      char = sPeek(++idx);
	    }
	    if (char !== '}') {
	      throw this.createILLEGAL(char);
	    }
	    if (idx === start + 1) {
	      throw this.createILLEGAL(stream.peek(idx + 1));
	    }
	    ++idx;
	  } else {
	    //\uHex4Digits
	    if ((0, _charStream.isEOS)(sPeek(idx + 3))) return -1;
	    let r;
	    for (; idx < start + 4; ++idx) {
	      r = getHexValue(sPeek(idx));
	      if (r === -1) return -1;
	      hexDigits = hexDigits << 4 | r;
	    }
	  }
	  stream.readString(idx);

	  return hexDigits;
	}

	function readStringEscape(str, stream, start, octal) {
	  let idx = start + 1,
	      char = stream.peek(idx),
	      lineStart;
	  if ((0, _charStream.isEOS)(char)) throw this.createILLEGAL(char);

	  if (!isLineTerminator(char.charCodeAt(0))) {
	    switch (char) {
	      case 'b':
	        str += '\b';++idx;break;
	      case 'f':
	        str += '\f';++idx;break;
	      case 'n':
	        str += '\n';++idx;break;
	      case 'r':
	        str += '\r';++idx;break;
	      case 't':
	        str += '\t';++idx;break;
	      case 'v':
	        str += '\u000B';++idx;break;
	      case 'u':
	      case 'x':
	        {
	          let unescaped;
	          ++idx;
	          let nxt = stream.peek(idx);
	          if ((0, _charStream.isEOS)(nxt)) {
	            throw this.createILLEGAL(nxt);
	          }
	          unescaped = char === 'u' ? scanUnicode.call(this, stream, idx) : scanHexEscape2.call(this, stream);
	          if (unescaped === -1) throw this.createILLEGAL(char);
	          idx = 0; // stream is read in scanUnicode and scanHexEscape2

	          str += String.fromCodePoint(unescaped);
	          break;
	        }
	      default:
	        {
	          if ('0' <= char && char <= '7') {
	            [str, idx, octal] = scanOctal.call(this, str, stream, char, idx, octal);
	          } else if (char === '8' || char === '9') {
	            throw this.createILLEGAL(char);
	          } else {
	            str += char;
	            ++idx;
	          }
	        }
	    }
	  } else {
	    if (char === '\r' && stream.peek(idx + 1) === '\n') {
	      ++idx;
	    }
	    ++idx;
	    this.incrementLine();
	    lineStart = idx;
	  }
	  return [str, idx, octal, lineStart];
	}

	function scanOctal(str, stream, char, start, octal) {
	  let len = 1,
	      idx = start;
	  if ('0' <= char && char <= '3') {
	    len = 0;
	  }
	  let code = 0;

	  while (len < 3 && '0' <= char && char <= '7') {
	    ++idx;
	    if (len > 0 || char !== '0') {
	      if (octal == null) octal = '';
	      octal += char;
	    }
	    code *= 8;
	    code += +char; //coersion
	    ++len;
	    char = stream.peek(idx);
	    if ((0, _charStream.isEOS)(char)) {
	      throw this.createILLEGAL(char);
	    }
	  }
	  str += String.fromCharCode(code);
	  return [str, idx, octal];
	}

	function scanHexEscape2(stream, idx) {
	  let char = stream.peek(idx);

	  if ((0, _charStream.isEOS)(char)) return -1;

	  let r1 = getHexValue(stream.peek());
	  if (r1 === -1) return r1;

	  let r2 = getHexValue(stream.peek(1));
	  if (r2 === -1) return r2;

	  stream.readString(2);
	  return r1 << 4 | r2;
	}

	function insertSequence(coll, seq) {
	  const char = seq[0];
	  if (!coll[char]) {
	    coll[char] = {};
	  }
	  if (seq.length === 1) {
	    coll[char].isValue = true;
	    return coll;
	  } else {
	    coll[char] = insertSequence(coll[char], seq.slice(1));
	    return coll;
	  }
	}

	function retrieveSequenceLength(table, stream, idx) {
	  const char = stream.peek(idx);
	  if (!table[char]) {
	    if (table.isValue) return idx;
	    return -1;
	  } else {
	    return retrieveSequenceLength(table[char], stream, ++idx);
	  }
	}

	// const isEOS = R.whereEq({ type: TokenType.EOS });

	// const isHash = R.whereEq({ type: TokenType.IDENTIFIER, value: '#'});

	const assignOps = ['=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ','];

	const binaryOps = ['+', '-', '*', '/', '%', '<<', '>>', '>>>', '&', '|', '^', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!==', 'instanceof'];

	const unaryOps = ['++', '--', '~', '!', 'delete', 'void', 'typeof', 'yield', 'throw', 'new'];

	// List -> Boolean
	const isEmpty = R.whereEq({ size: 0 });

	// Syntax -> Boolean
	const isPunctuator = s => s.match('punctuator');
	const isKeyword = s => s.match('keyword');
	const isParens = s => s.match('parens');
	const isBraces = s => s.match('braces');
	const isIdentifier = s => s.match('identifier');

	// Any -> Syntax -> Boolean
	const isVal = R.curry((v, s) => s.val() === v);

	// Syntax -> Boolean
	const isDot = R.allPass([isPunctuator, isVal('.')]);
	const isColon = R.allPass([isPunctuator, isVal(':')]);
	const isFunctionKeyword = R.allPass([isKeyword, isVal('function')]);
	const isOperator = s => (s.match('punctuator') || s.match('keyword')) && R.any(R.equals(s.val()), assignOps.concat(binaryOps).concat(unaryOps));
	const isNonLiteralKeyword = R.allPass([isKeyword, s => R.none(R.equals(s.val()), literalKeywords)]);
	const isKeywordExprPrefix = R.allPass([isKeyword, s => R.any(R.equals(s.val()), ['instanceof', 'typeof', 'delete', 'void', 'yield', 'throw', 'new', 'case'])]);
	// List a -> a?
	let last = p => p.last();
	// List a -> Maybe a
	let safeLast = R.pipe(R.cond([[isEmpty, R.always(Nothing())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last)]]));

	// TODO: better name (areTrue & areFalse)?
	// List -> Boolean -> Maybe List
	let stuffTrue = R.curry((p, b) => b ? Just(p) : Nothing());
	let stuffFalse = R.curry((p, b) => !b ? Just(p) : Nothing());

	// List a -> Boolean
	let isTopColon = R.pipe(safeLast, R.map(isColon), _ramdaFantasy.Maybe.maybe(false, R.identity));
	// List a -> Boolean
	let isTopPunctuator = R.pipe(safeLast, R.map(isPunctuator), _ramdaFantasy.Maybe.maybe(false, R.identity));

	// Number -> List -> Boolean
	let isExprReturn = R.curry((l, p) => {
	  let retKwd = safeLast(p);
	  let maybeDot = pop(p).chain(safeLast);

	  if (maybeDot.map(isDot).getOrElse(false)) {
	    return true;
	  }
	  return retKwd.map(s => {
	    return s.match('keyword') && s.val() === 'return' && s.lineNumber() === l;
	  }).getOrElse(false);
	});

	const isTopOperator = R.pipe(safeLast, R.map(isOperator), _ramdaFantasy.Maybe.maybe(false, R.identity));

	const isTopKeywordExprPrefix = R.pipe(safeLast, R.map(isKeywordExprPrefix), _ramdaFantasy.Maybe.maybe(false, R.identity));

	// Number -> Boolean -> List -> Boolean
	let isExprPrefix = exports.isExprPrefix = R.curry((l, b) => R.cond([
	// ... ({x: 42} /r/i)
	[isEmpty, R.always(b)],
	// ... ({x: {x: 42} /r/i })
	[isTopColon, R.always(b)],
	// ... throw {x: 42} /r/i
	[isTopKeywordExprPrefix, R.T],
	// ... 42 + {x: 42} /r/i
	[isTopOperator, R.T],
	// ... for ( ; {x: 42}/r/i)
	[isTopPunctuator, R.always(b)],
	// ... return {x: 42} /r /i
	// ... return\n{x: 42} /r /i
	[isExprReturn(l), R.T], [R.T, R.F]]));

	// List a -> Maybe List a
	let curly = p => safeLast(p).map(isBraces).chain(stuffTrue(p));
	let paren = p => safeLast(p).map(isParens).chain(stuffTrue(p));
	let func = p => safeLast(p).map(isFunctionKeyword).chain(stuffTrue(p));
	let ident = p => safeLast(p).map(isIdentifier).chain(stuffTrue(p));
	let nonLiteralKeyword = p => safeLast(p).map(isNonLiteralKeyword).chain(stuffTrue(p));

	let opt = R.curry((a, b, p) => {
	  let result = R.pipeK(a, b)(_ramdaFantasy.Maybe.of(p));
	  return _ramdaFantasy.Maybe.isJust(result) ? result : _ramdaFantasy.Maybe.of(p);
	});

	let notDot = R.ifElse(R.whereEq({ size: 0 }), Just, p => safeLast(p).map(s => !(s.match('punctuator') && s.val() === '.')).chain(stuffTrue(p)));

	// List a -> Maybe List a
	let pop = R.compose(Just, p => p.pop());

	// Maybe List a -> Maybe List a
	const functionPrefix = R.pipeK(curly, pop, paren, pop, opt(ident, pop), func);

	// Boolean -> List a -> Boolean
	const isRegexPrefix = exports.isRegexPrefix = exprAllowed => R.anyPass([
	// 
	isEmpty,
	// P . t   where t  Punctuator
	isTopPunctuator,
	// P . t . t'  where t \not = "." and t'  (Keyword \setminus  LiteralKeyword)
	R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
	// P . t . t' . (T)  where t \not = "." and t'  (Keyword \setminus LiteralKeyword)
	R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren, pop, nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
	// P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false
	R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, R.chain(p => {
	  return safeLast(p).map(s => s.lineNumber()).chain(fnLine => {
	    return pop(p).map(isExprPrefix(fnLine, exprAllowed));
	  }).chain(stuffFalse(p));
	}), _ramdaFantasy.Maybe.isJust),
	// P . {T}^l  where isExprPrefix(P, b, l) = false
	p => {
	  let alreadyCheckedFunction = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, _ramdaFantasy.Maybe.isJust)(p);
	  if (alreadyCheckedFunction) {
	    return false;
	  }
	  return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly), R.chain(p => {
	    return safeLast(p).map(s => s.lineNumber()).chain(curlyLine => {
	      return pop(p).map(isExprPrefix(curlyLine, exprAllowed));
	    }).chain(stuffFalse(p));
	  }), _ramdaFantasy.Maybe.isJust)(p);
	}]);
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvdXRpbHMuanMiXSwibmFtZXMiOlsiZ2V0SGV4VmFsdWUiLCJza2lwU2luZ2xlTGluZUNvbW1lbnQiLCJzY2FuVW5pY29kZSIsInJlYWRTdHJpbmdFc2NhcGUiLCJpbnNlcnRTZXF1ZW5jZSIsInJldHJpZXZlU2VxdWVuY2VMZW5ndGgiLCJSIiwiaXNMaW5lVGVybWluYXRvciIsImlzV2hpdGVTcGFjZSIsImlzRGVjaW1hbERpZ2l0IiwiaXNJZGVudGlmaWVyUGFydEVTNiIsImlzSWRlbnRpZmllclBhcnQiLCJpc0lkZW50aWZpZXJTdGFydEVTNiIsImlzSWRlbnRpZmllclN0YXJ0IiwiSnVzdCIsIk5vdGhpbmciLCJMU1lOVEFYIiwibmFtZSIsIlJTWU5UQVgiLCJsaXRlcmFsS2V5d29yZHMiLCJydW5lIiwiY2hhckNvZGVBdCIsInN0cmVhbSIsImlkeCIsImNoYXIiLCJwZWVrIiwiY2hDb2RlIiwiaW5jcmVtZW50TGluZSIsInJlYWRTdHJpbmciLCJzdGFydCIsInNQZWVrIiwiYmluZCIsImhleERpZ2l0cyIsImhleCIsImNyZWF0ZUlMTEVHQUwiLCJyIiwic3RyIiwib2N0YWwiLCJsaW5lU3RhcnQiLCJ1bmVzY2FwZWQiLCJueHQiLCJjYWxsIiwic2NhbkhleEVzY2FwZTIiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwic2Nhbk9jdGFsIiwibGVuIiwiY29kZSIsImZyb21DaGFyQ29kZSIsInIxIiwicjIiLCJjb2xsIiwic2VxIiwibGVuZ3RoIiwiaXNWYWx1ZSIsInNsaWNlIiwidGFibGUiLCJhc3NpZ25PcHMiLCJiaW5hcnlPcHMiLCJ1bmFyeU9wcyIsImlzRW1wdHkiLCJ3aGVyZUVxIiwic2l6ZSIsImlzUHVuY3R1YXRvciIsInMiLCJtYXRjaCIsImlzS2V5d29yZCIsImlzUGFyZW5zIiwiaXNCcmFjZXMiLCJpc0lkZW50aWZpZXIiLCJpc1ZhbCIsImN1cnJ5IiwidiIsInZhbCIsImlzRG90IiwiYWxsUGFzcyIsImlzQ29sb24iLCJpc0Z1bmN0aW9uS2V5d29yZCIsImlzT3BlcmF0b3IiLCJhbnkiLCJlcXVhbHMiLCJjb25jYXQiLCJpc05vbkxpdGVyYWxLZXl3b3JkIiwibm9uZSIsImlzS2V5d29yZEV4cHJQcmVmaXgiLCJsYXN0IiwicCIsInNhZmVMYXN0IiwicGlwZSIsImNvbmQiLCJhbHdheXMiLCJUIiwiY29tcG9zZSIsIm9mIiwic3R1ZmZUcnVlIiwiYiIsInN0dWZmRmFsc2UiLCJpc1RvcENvbG9uIiwibWFwIiwibWF5YmUiLCJpZGVudGl0eSIsImlzVG9wUHVuY3R1YXRvciIsImlzRXhwclJldHVybiIsImwiLCJyZXRLd2QiLCJtYXliZURvdCIsInBvcCIsImNoYWluIiwiZ2V0T3JFbHNlIiwibGluZU51bWJlciIsImlzVG9wT3BlcmF0b3IiLCJpc1RvcEtleXdvcmRFeHByUHJlZml4IiwiaXNFeHByUHJlZml4IiwiRiIsImN1cmx5IiwicGFyZW4iLCJmdW5jIiwiaWRlbnQiLCJub25MaXRlcmFsS2V5d29yZCIsIm9wdCIsImEiLCJyZXN1bHQiLCJwaXBlSyIsImlzSnVzdCIsIm5vdERvdCIsImlmRWxzZSIsImZ1bmN0aW9uUHJlZml4IiwiaXNSZWdleFByZWZpeCIsImV4cHJBbGxvd2VkIiwiYW55UGFzcyIsImZuTGluZSIsImFscmVhZHlDaGVja2VkRnVuY3Rpb24iLCJjdXJseUxpbmUiXSwibWFwcGluZ3MiOiI7Ozs7OztRQTBCZ0JBLFcsR0FBQUEsVztRQWFBQyxxQixHQUFBQSxxQjtRQW1CQUMsVyxHQUFBQSxXO1FBdUNBQyxnQixHQUFBQSxnQjtRQTJGQUMsYyxHQUFBQSxjO1FBY0FDLHNCLEdBQUFBLHNCOztBQXhNaEI7O0FBSUE7O0FBT0E7O0lBQVlDLEM7O0FBQ1o7Ozs7QUFQQSxNQUFNLEVBQUVDLGdCQUFGO0FBQ0VDLGNBREY7QUFFRUMsZ0JBRkY7QUFHRUMsdUJBQXFCQyxnQkFIdkI7QUFJRUMsd0JBQXNCQyxpQkFKeEIsa0JBQU47O0FBUUEsTUFBTUMsT0FBTyxvQkFBTUEsSUFBbkI7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QjtBQUtBLE1BQUk2QyxzQkFBSixFQUE0QjtBQUMxQixXQUFPLEtBQVA7QUFDRDtBQUNELFNBQU83SCxFQUFFa0YsSUFBRixDQUNMLG9CQUFNSyxFQURELEVBRUx2RixFQUFFcUcsS0FBRixDQUFRTyxLQUFSLENBRkssRUFHTDVHLEVBQUVxRyxLQUFGLENBQVFyQixLQUFLO0FBQ1gsV0FBT0MsU0FBU0QsQ0FBVCxFQUNOWSxHQURNLENBQ0ZsQyxLQUFLQSxFQUFFNkMsVUFBRixFQURILEVBRU5GLEtBRk0sQ0FFQXlCLGFBQWE7QUFDbEIsYUFBTzFCLElBQUlwQixDQUFKLEVBQU9ZLEdBQVAsQ0FBV2MsYUFBYW9CLFNBQWIsRUFBd0JKLFdBQXhCLENBQVgsQ0FBUDtBQUNELEtBSk0sRUFLTnJCLEtBTE0sQ0FLQVgsV0FBV1YsQ0FBWCxDQUxBLENBQVA7QUFNRCxHQVBELENBSEssRUFXTCxvQkFBTXFDLE1BWEQsRUFZTHJDLENBWkssQ0FBUDtBQWFELENBakU4RCxDQUFWLENBQWhEIiwiZmlsZSI6InV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHsgaXNFT1MgfSBmcm9tICcuL2NoYXItc3RyZWFtJztcblxuaW1wb3J0IHR5cGUgQ2hhclN0cmVhbSBmcm9tICcuL2NoYXItc3RyZWFtJztcblxuaW1wb3J0IHsgY29kZSAgfSBmcm9tICdlc3V0aWxzJztcbmNvbnN0IHsgaXNMaW5lVGVybWluYXRvcixcbiAgICAgICAgaXNXaGl0ZVNwYWNlLFxuICAgICAgICBpc0RlY2ltYWxEaWdpdCxcbiAgICAgICAgaXNJZGVudGlmaWVyUGFydEVTNjogaXNJZGVudGlmaWVyUGFydCxcbiAgICAgICAgaXNJZGVudGlmaWVyU3RhcnRFUzY6IGlzSWRlbnRpZmllclN0YXJ0IH0gPSBjb2RlO1xuXG5pbXBvcnQgKiBhcyBSIGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAncmFtZGEtZmFudGFzeSc7XG5jb25zdCBKdXN0ID0gTWF5YmUuSnVzdDtcbmNvbnN0IE5vdGhpbmcgPSBNYXliZS5Ob3RoaW5nO1xuXG5leHBvcnQgY29uc3QgTFNZTlRBWCA9IHsgbmFtZTogJ2xlZnQtc3ludGF4JyB9O1xuZXhwb3J0IGNvbnN0IFJTWU5UQVggPSB7IG5hbWU6ICdyaWdodC1zeW50YXgnIH07XG5cbi8vIFRPRE86IGFsc28sIG5lZWQgdG8gaGFuZGxlIGNvbnRleHR1YWwgeWllbGRcbmNvbnN0IGxpdGVyYWxLZXl3b3JkcyA9IFsndGhpcycsICdudWxsJywgJ3RydWUnLCAnZmFsc2UnXTtcblxuZXhwb3J0IHsgaXNMaW5lVGVybWluYXRvciwgaXNXaGl0ZVNwYWNlLCBpc0RlY2ltYWxEaWdpdCwgaXNJZGVudGlmaWVyU3RhcnQsIGlzSWRlbnRpZmllclBhcnQgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhleFZhbHVlKHJ1bmU6IHN0cmluZykge1xuICBpZiAoJzAnIDw9IHJ1bmUgJiYgcnVuZSA8PSAnOScpIHtcbiAgICByZXR1cm4gcnVuZS5jaGFyQ29kZUF0KDApIC0gNDg7XG4gIH1cbiAgaWYgKCdhJyA8PSBydW5lICYmIHJ1bmUgPD0gJ2YnKSB7XG4gICAgcmV0dXJuIHJ1bmUuY2hhckNvZGVBdCgwKSAtIDg3O1xuICB9XG4gIGlmICgnQScgPD0gcnVuZSAmJiBydW5lIDw9ICdGJykge1xuICAgIHJldHVybiBydW5lLmNoYXJDb2RlQXQoMCkgLSA1NTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQoc3RyZWFtOiBDaGFyU3RyZWFtKTogdm9pZCB7XG4gIGxldCBpZHggPSAwO1xuICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIHdoaWxlICghaXNFT1MoY2hhcikpIHtcbiAgICBsZXQgY2hDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoQ29kZSkpIHtcbiAgICAgICsraWR4O1xuICAgICAgaWYgKGNoQ29kZSA9PT0gMHhEIC8qIFwiXFxyXCIgKi8gJiYgc3RyZWFtLnBlZWsoaWR4KS5jaGFyQ29kZUF0KDApID09PSAweEEgLypcIlxcblwiICovKSB7XG4gICAgICAgICsraWR4O1xuICAgICAgfVxuICAgICAgdGhpcy5pbmNyZW1lbnRMaW5lKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytpZHg7XG4gICAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIH1cbiAgc3RyZWFtLnJlYWRTdHJpbmcoaWR4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Vbmljb2RlKHN0cmVhbTogQ2hhclN0cmVhbSwgc3RhcnQ6IG51bWJlcikge1xuICBjb25zdCBzUGVlayA9IHN0cmVhbS5wZWVrLmJpbmQoc3RyZWFtKTtcbiAgbGV0IGlkeCA9IHN0YXJ0O1xuICBsZXQgaGV4RGlnaXRzID0gMDtcbiAgaWYgKHNQZWVrKGlkeCkgPT09ICd7Jykge1xuICAgIC8vXFx1e0hleERpZ2l0c31cbiAgICArK2lkeDtcbiAgICBsZXQgY2hhciA9IHNQZWVrKGlkeCk7XG4gICAgd2hpbGUgKCFpc0VPUyhjaGFyKSkge1xuICAgICAgbGV0IGhleCA9IGdldEhleFZhbHVlKGNoYXIpO1xuICAgICAgaWYgKGhleCA9PT0gLTEpIGJyZWFrO1xuICAgICAgaGV4RGlnaXRzID0gKGhleERpZ2l0cyA8PCA0KSB8IGhleDtcbiAgICAgIGlmIChoZXhEaWdpdHMgPiAweDEwRkZGRikge1xuICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgICB9XG4gICAgICBjaGFyID0gc1BlZWsoKytpZHgpO1xuICAgIH1cbiAgICBpZiAoY2hhciAhPT0gJ30nKSB7XG4gICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgfVxuICAgIGlmIChpZHggPT09IHN0YXJ0ICsgMSkge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKHN0cmVhbS5wZWVrKGlkeCsxKSk7XG4gICAgfVxuICAgICsraWR4O1xuICB9IGVsc2Uge1xuICAgIC8vXFx1SGV4NERpZ2l0c1xuICAgIGlmIChpc0VPUyhzUGVlayhpZHggKyAzKSkpIHJldHVybiAtMTtcbiAgICBsZXQgcjtcbiAgICBmb3IgKDsgaWR4IDwgc3RhcnQgKyA0OyArK2lkeCkge1xuICAgICAgciA9IGdldEhleFZhbHVlKHNQZWVrKGlkeCkpO1xuICAgICAgaWYgKHIgPT09IC0xKSByZXR1cm4gLTE7XG4gICAgICBoZXhEaWdpdHMgPSAoaGV4RGlnaXRzIDw8IDQpIHwgcjtcbiAgICB9XG4gIH1cbiAgc3RyZWFtLnJlYWRTdHJpbmcoaWR4KTtcblxuICByZXR1cm4gaGV4RGlnaXRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmluZ0VzY2FwZShzdHI6IHN0cmluZywgc3RyZWFtOiBDaGFyU3RyZWFtLCBzdGFydDogbnVtYmVyLCBvY3RhbDogP3N0cmluZykge1xuICBsZXQgaWR4ID0gc3RhcnQgKyAxLFxuICAgICAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCksXG4gICAgICBsaW5lU3RhcnQ7XG4gIGlmIChpc0VPUyhjaGFyKSkgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuXG4gIGlmICghaXNMaW5lVGVybWluYXRvcihjaGFyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlICdiJzogc3RyICs9ICdcXGInOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICdmJzogc3RyICs9ICdcXGYnOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICduJzogc3RyICs9ICdcXG4nOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICdyJzogc3RyICs9ICdcXHInOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICd0Jzogc3RyICs9ICdcXHQnOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICd2Jzogc3RyICs9ICdcXHUwMDBCJzsgKytpZHg7IGJyZWFrO1xuICAgICAgY2FzZSAndSc6XG4gICAgICBjYXNlICd4Jzoge1xuICAgICAgICBsZXQgdW5lc2NhcGVkO1xuICAgICAgICArK2lkeDtcbiAgICAgICAgbGV0IG54dCA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gICAgICAgIGlmIChpc0VPUyhueHQpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKG54dCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5lc2NhcGVkID0gY2hhciA9PT0gJ3UnID8gc2NhblVuaWNvZGUuY2FsbCh0aGlzLCBzdHJlYW0sIGlkeCkgOiBzY2FuSGV4RXNjYXBlMi5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgIGlmICh1bmVzY2FwZWQgPT09IC0xKSB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgICAgIGlkeCA9IDA7IC8vIHN0cmVhbSBpcyByZWFkIGluIHNjYW5Vbmljb2RlIGFuZCBzY2FuSGV4RXNjYXBlMlxuXG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh1bmVzY2FwZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzcnKSB7XG4gICAgICAgICAgW3N0ciwgaWR4LCBvY3RhbF0gPSBzY2FuT2N0YWwuY2FsbCh0aGlzLCBzdHIsIHN0cmVhbSwgY2hhciwgaWR4LCBvY3RhbCk7XG4gICAgICAgIH0gZWxzZSBpZihjaGFyID09PSAnOCcgfHwgY2hhciA9PT0gJzknKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBjaGFyO1xuICAgICAgICAgICsraWR4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChjaGFyID09PSAnXFxyJyAmJiBzdHJlYW0ucGVlayhpZHggKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICsraWR4O1xuICAgIH1cbiAgICArK2lkeDtcbiAgICB0aGlzLmluY3JlbWVudExpbmUoKTtcbiAgICBsaW5lU3RhcnQgPSBpZHg7XG4gIH1cbiAgcmV0dXJuIFtzdHIsIGlkeCwgb2N0YWwsIGxpbmVTdGFydF07XG59XG5cbmZ1bmN0aW9uIHNjYW5PY3RhbChzdHIsIHN0cmVhbSwgY2hhciwgc3RhcnQsIG9jdGFsKSB7XG4gIGxldCBsZW4gPSAxLCBpZHggPSBzdGFydDtcbiAgaWYgKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzMnKSB7XG4gICAgbGVuID0gMDtcbiAgfVxuICBsZXQgY29kZSA9IDA7XG5cbiAgd2hpbGUgKGxlbiA8IDMgJiYgJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnNycpIHtcbiAgICArK2lkeDtcbiAgICBpZiAobGVuID4gMCB8fCBjaGFyICE9PSAnMCcpIHtcbiAgICAgIGlmIChvY3RhbCA9PSBudWxsKSBvY3RhbCA9ICcnO1xuICAgICAgb2N0YWwgKz0gY2hhcjtcbiAgICB9XG4gICAgY29kZSAqPSA4O1xuICAgIGNvZGUgKz0gK2NoYXI7IC8vY29lcnNpb25cbiAgICArK2xlbjtcbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgICBpZiAoaXNFT1MoY2hhcikpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICB9XG4gIH1cbiAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIHJldHVybiBbc3RyLCBpZHgsIG9jdGFsXTtcbn1cblxuZnVuY3Rpb24gc2NhbkhleEVzY2FwZTIoc3RyZWFtLCBpZHgpIHtcbiAgbGV0IGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuXG4gIGlmIChpc0VPUyhjaGFyKSkgcmV0dXJuIC0xO1xuXG4gIGxldCByMSA9IGdldEhleFZhbHVlKHN0cmVhbS5wZWVrKCkpO1xuICBpZiAocjEgPT09IC0xKSByZXR1cm4gcjE7XG5cbiAgbGV0IHIyID0gZ2V0SGV4VmFsdWUoc3RyZWFtLnBlZWsoMSkpO1xuICBpZiAocjIgPT09IC0xKSByZXR1cm4gcjI7XG5cbiAgc3RyZWFtLnJlYWRTdHJpbmcoMik7XG4gIHJldHVybiByMSA8PCA0IHwgcjI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRTZXF1ZW5jZShjb2xsOiBPYmplY3QsIHNlcTogc3RyaW5nKSB7XG4gIGNvbnN0IGNoYXIgPSBzZXFbMF07XG4gIGlmICghY29sbFtjaGFyXSkge1xuICAgIGNvbGxbY2hhcl0gPSB7fTtcbiAgfVxuICBpZiAoc2VxLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbGxbY2hhcl0uaXNWYWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIGNvbGw7XG4gIH0gZWxzZSB7XG4gICAgY29sbFtjaGFyXSA9IGluc2VydFNlcXVlbmNlKGNvbGxbY2hhcl0sIHNlcS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIGNvbGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlU2VxdWVuY2VMZW5ndGgodGFibGU6IE9iamVjdCwgc3RyZWFtOiBDaGFyU3RyZWFtLCBpZHg6IG51bWJlcikge1xuICBjb25zdCBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgaWYgKCF0YWJsZVtjaGFyXSkge1xuICAgIGlmICh0YWJsZS5pc1ZhbHVlKSByZXR1cm4gaWR4O1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0cmlldmVTZXF1ZW5jZUxlbmd0aCh0YWJsZVtjaGFyXSwgc3RyZWFtLCArK2lkeCk7XG4gIH1cbn1cblxuLy8gY29uc3QgaXNFT1MgPSBSLndoZXJlRXEoeyB0eXBlOiBUb2tlblR5cGUuRU9TIH0pO1xuXG4vLyBjb25zdCBpc0hhc2ggPSBSLndoZXJlRXEoeyB0eXBlOiBUb2tlblR5cGUuSURFTlRJRklFUiwgdmFsdWU6ICcjJ30pO1xuXG5jb25zdCBhc3NpZ25PcHMgPSAgWyc9JywgJys9JywgJy09JywgJyo9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCddO1xuXG5jb25zdCBiaW5hcnlPcHMgPSBbJysnLCAnLScsICcqJywgJy8nLCAnJScsJzw8JywgJz4+JywgJz4+PicsICcmJywgJ3wnLCAnXicsXG4gICAgICAgICAgICAgICAgICcmJicsICd8fCcsICc/JywgJzonLFxuICAgICAgICAgICAgICAgICAnPT09JywgJz09JywgJz49JywgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nLCAnaW5zdGFuY2VvZiddO1xuXG5jb25zdCB1bmFyeU9wcyA9IFsnKysnLCAnLS0nLCAnficsICchJywgJ2RlbGV0ZScsICd2b2lkJywgJ3R5cGVvZicsICd5aWVsZCcsICd0aHJvdycsICduZXcnXTtcblxuLy8gTGlzdCAtPiBCb29sZWFuXG5jb25zdCBpc0VtcHR5ID0gUi53aGVyZUVxKHtzaXplOiAwfSk7XG5cbi8vIFN5bnRheCAtPiBCb29sZWFuXG5jb25zdCBpc1B1bmN0dWF0b3IgPSBzID0+IHMubWF0Y2goJ3B1bmN0dWF0b3InKTtcbmNvbnN0IGlzS2V5d29yZCA9IHMgPT4gcy5tYXRjaCgna2V5d29yZCcpO1xuY29uc3QgaXNQYXJlbnMgPSBzID0+IHMubWF0Y2goJ3BhcmVucycpO1xuY29uc3QgaXNCcmFjZXMgPSBzID0+IHMubWF0Y2goJ2JyYWNlcycpO1xuY29uc3QgaXNJZGVudGlmaWVyID0gcyA9PiBzLm1hdGNoKCdpZGVudGlmaWVyJyk7XG5cbi8vIEFueSAtPiBTeW50YXggLT4gQm9vbGVhblxuY29uc3QgaXNWYWwgPSBSLmN1cnJ5KCh2LCBzKSA9PiBzLnZhbCgpID09PSB2KTtcblxuLy8gU3ludGF4IC0+IEJvb2xlYW5cbmNvbnN0IGlzRG90ID0gUi5hbGxQYXNzKFtpc1B1bmN0dWF0b3IsIGlzVmFsKCcuJyldKTtcbmNvbnN0IGlzQ29sb24gPSBSLmFsbFBhc3MoW2lzUHVuY3R1YXRvciwgaXNWYWwoJzonKV0pO1xuY29uc3QgaXNGdW5jdGlvbktleXdvcmQgPSBSLmFsbFBhc3MoW2lzS2V5d29yZCwgaXNWYWwoJ2Z1bmN0aW9uJyldKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSBzID0+IChzLm1hdGNoKCdwdW5jdHVhdG9yJykgfHwgcy5tYXRjaCgna2V5d29yZCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBSLmFueShSLmVxdWFscyhzLnZhbCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduT3BzLmNvbmNhdChiaW5hcnlPcHMpLmNvbmNhdCh1bmFyeU9wcykpO1xuY29uc3QgaXNOb25MaXRlcmFsS2V5d29yZCA9IFIuYWxsUGFzcyhbaXNLZXl3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9PiBSLm5vbmUoUi5lcXVhbHMocy52YWwoKSksIGxpdGVyYWxLZXl3b3JkcyldKTtcbmNvbnN0IGlzS2V5d29yZEV4cHJQcmVmaXggPSBSLmFsbFBhc3MoW2lzS2V5d29yZCxcbiAgcyA9PiBSLmFueShSLmVxdWFscyhzLnZhbCgpKSwgWydpbnN0YW5jZW9mJywgJ3R5cGVvZicsICdkZWxldGUnLCAndm9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3lpZWxkJywgJ3Rocm93JywgJ25ldycsICdjYXNlJ10pXSk7XG4vLyBMaXN0IGEgLT4gYT9cbmxldCBsYXN0ID0gcCA9PiBwLmxhc3QoKTtcbi8vIExpc3QgYSAtPiBNYXliZSBhXG5sZXQgc2FmZUxhc3QgPSBSLnBpcGUoUi5jb25kKFtcbiAgW2lzRW1wdHksIFIuYWx3YXlzKE5vdGhpbmcoKSldLFxuICBbUi5ULCBSLmNvbXBvc2UoTWF5YmUub2YsIGxhc3QpXVxuXSkpO1xuXG4vLyBUT0RPOiBiZXR0ZXIgbmFtZSAoYXJlVHJ1ZSAmIGFyZUZhbHNlKT9cbi8vIExpc3QgLT4gQm9vbGVhbiAtPiBNYXliZSBMaXN0XG5sZXQgc3R1ZmZUcnVlID0gUi5jdXJyeSgocCwgYikgPT4gYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xubGV0IHN0dWZmRmFsc2UgPSBSLmN1cnJ5KChwLCBiKSA9PiAhYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xuXG4vLyBMaXN0IGEgLT4gQm9vbGVhblxubGV0IGlzVG9wQ29sb24gPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc0NvbG9uKSxcbiAgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpXG4pO1xuLy8gTGlzdCBhIC0+IEJvb2xlYW5cbmxldCBpc1RvcFB1bmN0dWF0b3IgPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc1B1bmN0dWF0b3IpLFxuICBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSlcbik7XG5cbi8vIE51bWJlciAtPiBMaXN0IC0+IEJvb2xlYW5cbmxldCBpc0V4cHJSZXR1cm4gPSBSLmN1cnJ5KChsLCBwKSA9PiB7XG4gIGxldCByZXRLd2QgPSBzYWZlTGFzdChwKTtcbiAgbGV0IG1heWJlRG90ID0gcG9wKHApLmNoYWluKHNhZmVMYXN0KTtcblxuICBpZiAobWF5YmVEb3QubWFwKGlzRG90KS5nZXRPckVsc2UoZmFsc2UpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldEt3ZC5tYXAocyA9PiB7XG4gICAgcmV0dXJuIHMubWF0Y2goJ2tleXdvcmQnKSAmJiBzLnZhbCgpID09PSAncmV0dXJuJyAmJiBzLmxpbmVOdW1iZXIoKSA9PT0gbDtcbiAgfSkuZ2V0T3JFbHNlKGZhbHNlKTtcbn0pO1xuXG5jb25zdCBpc1RvcE9wZXJhdG9yID0gUi5waXBlKFxuICBzYWZlTGFzdCxcbiAgUi5tYXAoaXNPcGVyYXRvciksXG4gIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KVxuKTtcblxuY29uc3QgaXNUb3BLZXl3b3JkRXhwclByZWZpeCA9IFIucGlwZShcbiAgc2FmZUxhc3QsXG4gIFIubWFwKGlzS2V5d29yZEV4cHJQcmVmaXgpLFxuICBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSlcbik7XG5cbi8vIE51bWJlciAtPiBCb29sZWFuIC0+IExpc3QgLT4gQm9vbGVhblxuZXhwb3J0IGxldCBpc0V4cHJQcmVmaXggPSBSLmN1cnJ5KChsLCBiKSA9PiBSLmNvbmQoW1xuICAvLyAuLi4gKHt4OiA0Mn0gL3IvaSlcbiAgW2lzRW1wdHksIFIuYWx3YXlzKGIpXSxcbiAgLy8gLi4uICh7eDoge3g6IDQyfSAvci9pIH0pXG4gIFtpc1RvcENvbG9uLCBSLmFsd2F5cyhiKV0sXG4gIC8vIC4uLiB0aHJvdyB7eDogNDJ9IC9yL2lcbiAgW2lzVG9wS2V5d29yZEV4cHJQcmVmaXgsIFIuVF0sXG4gIC8vIC4uLiA0MiArIHt4OiA0Mn0gL3IvaVxuICBbaXNUb3BPcGVyYXRvciwgUi5UXSxcbiAgLy8gLi4uIGZvciAoIDsge3g6IDQyfS9yL2kpXG4gIFtpc1RvcFB1bmN0dWF0b3IsIFIuYWx3YXlzKGIpXSxcbiAgLy8gLi4uIHJldHVybiB7eDogNDJ9IC9yIC9pXG4gIC8vIC4uLiByZXR1cm5cXG57eDogNDJ9IC9yIC9pXG4gIFtpc0V4cHJSZXR1cm4obCksIFIuVF0sXG4gIFtSLlQsIFIuRl0sXG5dKSk7XG5cbi8vIExpc3QgYSAtPiBNYXliZSBMaXN0IGFcbmxldCBjdXJseSA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzQnJhY2VzKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IHBhcmVuID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNQYXJlbnMpLmNoYWluKHN0dWZmVHJ1ZShwKSk7XG5sZXQgZnVuYyA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzRnVuY3Rpb25LZXl3b3JkKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IGlkZW50ID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNJZGVudGlmaWVyKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IG5vbkxpdGVyYWxLZXl3b3JkID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNOb25MaXRlcmFsS2V5d29yZCkuY2hhaW4oc3R1ZmZUcnVlKHApKTtcblxubGV0IG9wdCA9IFIuY3VycnkoKGEsIGIsIHApID0+IHtcbiAgbGV0IHJlc3VsdCA9IFIucGlwZUsoYSwgYikoTWF5YmUub2YocCkpO1xuICByZXR1cm4gTWF5YmUuaXNKdXN0KHJlc3VsdCkgPyByZXN1bHQgOiBNYXliZS5vZihwKTtcbn0pO1xuXG5sZXQgbm90RG90ID0gUi5pZkVsc2UoXG4gIFIud2hlcmVFcSh7c2l6ZTogMH0pLFxuICBKdXN0LFxuICBwID0+IHNhZmVMYXN0KHApLm1hcChzID0+ICEocy5tYXRjaCgncHVuY3R1YXRvcicpICYmIHMudmFsKCkgPT09ICcuJykpLmNoYWluKHN0dWZmVHJ1ZShwKSlcbik7XG5cbi8vIExpc3QgYSAtPiBNYXliZSBMaXN0IGFcbmxldCBwb3AgPSBSLmNvbXBvc2UoSnVzdCwgcCA9PiBwLnBvcCgpKTtcblxuLy8gTWF5YmUgTGlzdCBhIC0+IE1heWJlIExpc3QgYVxuY29uc3QgZnVuY3Rpb25QcmVmaXggPSBSLnBpcGVLKFxuICAgIGN1cmx5LFxuICAgIHBvcCxcbiAgICBwYXJlbixcbiAgICBwb3AsXG4gICAgb3B0KGlkZW50LCBwb3ApLFxuICAgIGZ1bmMpO1xuXG4vLyBCb29sZWFuIC0+IExpc3QgYSAtPiBCb29sZWFuXG5leHBvcnQgY29uc3QgaXNSZWdleFByZWZpeCA9IChleHByQWxsb3dlZDogYm9vbGVhbikgPT4gUi5hbnlQYXNzKFtcbiAgLy8gzrVcbiAgaXNFbXB0eSxcbiAgLy8gUCAuIHQgICB3aGVyZSB0IOKIiCBQdW5jdHVhdG9yXG4gIGlzVG9wUHVuY3R1YXRvcixcbiAgLy8gUCAuIHQgLiB0JyAgd2hlcmUgdCBcXG5vdCA9IFwiLlwiIGFuZCB0JyDiiIggKEtleXdvcmQgXFxzZXRtaW51cyAgTGl0ZXJhbEtleXdvcmQpXG4gIFIucGlwZShcbiAgICBNYXliZS5vZixcbiAgICBSLnBpcGVLKFxuICAgICAgbm9uTGl0ZXJhbEtleXdvcmQsXG4gICAgICBwb3AsXG4gICAgICBub3REb3RcbiAgICApLFxuICAgIE1heWJlLmlzSnVzdFxuICApLFxuICAvLyBQIC4gdCAuIHQnIC4gKFQpICB3aGVyZSB0IFxcbm90ID0gXCIuXCIgYW5kIHQnIOKIiCAoS2V5d29yZCBcXHNldG1pbnVzIExpdGVyYWxLZXl3b3JkKVxuICBSLnBpcGUoXG4gICAgTWF5YmUub2YsXG4gICAgUi5waXBlSyhcbiAgICAgIHBhcmVuLFxuICAgICAgcG9wLFxuICAgICAgbm9uTGl0ZXJhbEtleXdvcmQsXG4gICAgICBwb3AsXG4gICAgICBub3REb3RcbiAgICApLFxuICAgIE1heWJlLmlzSnVzdFxuICApLFxuICAvLyBQIC4gZnVuY3Rpb25ebCAuIHg/IC4gKCkgLiB7fSAgICAgd2hlcmUgaXNFeHByUHJlZml4KFAsIGIsIGwpID0gZmFsc2VcbiAgUi5waXBlKFxuICAgIE1heWJlLm9mLFxuICAgIGZ1bmN0aW9uUHJlZml4LFxuICAgIFIuY2hhaW4ocCA9PiB7XG4gICAgICAgIHJldHVybiBzYWZlTGFzdChwKVxuICAgICAgICAgIC5tYXAocyA9PiBzLmxpbmVOdW1iZXIoKSlcbiAgICAgICAgICAuY2hhaW4oZm5MaW5lID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwb3AocCkubWFwKGlzRXhwclByZWZpeChmbkxpbmUsIGV4cHJBbGxvd2VkKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2hhaW4oc3R1ZmZGYWxzZShwKSk7XG4gICAgICB9XG4gICAgKSxcbiAgICBNYXliZS5pc0p1c3RcbiAgKSxcbiAgLy8gUCAuIHtUfV5sICB3aGVyZSBpc0V4cHJQcmVmaXgoUCwgYiwgbCkgPSBmYWxzZVxuICBwID0+IHtcbiAgICBsZXQgYWxyZWFkeUNoZWNrZWRGdW5jdGlvbiA9IFIucGlwZShcbiAgICAgIE1heWJlLm9mLFxuICAgICAgZnVuY3Rpb25QcmVmaXgsXG4gICAgICBNYXliZS5pc0p1c3RcbiAgICApKHApO1xuICAgIGlmIChhbHJlYWR5Q2hlY2tlZEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBSLnBpcGUoXG4gICAgICBNYXliZS5vZixcbiAgICAgIFIuY2hhaW4oY3VybHkpLFxuICAgICAgUi5jaGFpbihwID0+IHtcbiAgICAgICAgcmV0dXJuIHNhZmVMYXN0KHApXG4gICAgICAgIC5tYXAocyA9PiBzLmxpbmVOdW1iZXIoKSlcbiAgICAgICAgLmNoYWluKGN1cmx5TGluZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBvcChwKS5tYXAoaXNFeHByUHJlZml4KGN1cmx5TGluZSwgZXhwckFsbG93ZWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNoYWluKHN0dWZmRmFsc2UocCkpO1xuICAgICAgfSksXG4gICAgICBNYXliZS5pc0p1c3RcbiAgICApKHApO1xuICB9XG5cblxuXSk7XG4iXX0=

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/


	(function () {
	    'use strict';

	    exports.ast = __webpack_require__(15);
	    exports.code = __webpack_require__(16);
	    exports.keyword = __webpack_require__(17);
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 15 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }

	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }

	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }

	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }

	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;

	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }

	    function isProblematicIfStatement(node) {
	        var current;

	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);

	        return false;
	    }

	    module.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,

	        trailingStatement: trailingStatement
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 16 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

	    // See `tools/generate-identifier-regex.js`.
	    ES5Regex = {
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	    };

	    ES6Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };

	    function isDecimalDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39;  // 0..9
	    }

	    function isHexDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
	            0x61 <= ch && ch <= 0x66 ||     // a..f
	            0x41 <= ch && ch <= 0x46;       // A..F
	    }

	    function isOctalDigit(ch) {
	        return ch >= 0x30 && ch <= 0x37;  // 0..7
	    }

	    // 7.2 White Space

	    NON_ASCII_WHITESPACES = [
	        0x1680, 0x180E,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];

	    function isWhiteSpace(ch) {
	        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
	            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	    }

	    // 7.6 Identifier Names and Identifiers

	    function fromCodePoint(cp) {
	        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
	        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
	        return cu1 + cu2;
	    }

	    IDENTIFIER_START = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_START[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    IDENTIFIER_PART = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_PART[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch >= 0x30 && ch <= 0x39 ||  // 0..9
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }

	    function isIdentifierStartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    function isIdentifierStartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }

	    function isIdentifierPartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }

	    module.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStartES5: isIdentifierStartES5,
	        isIdentifierPartES5: isIdentifierPartES5,
	        isIdentifierStartES6: isIdentifierStartES6,
	        isIdentifierPartES6: isIdentifierPartES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function () {
	    'use strict';

	    var code = __webpack_require__(16);

	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isKeywordES5(id, strict) {
	        // yield should not be treated as keyword under non-strict mode.
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }

	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }

	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    function isIdentifierNameES5(id) {
	        var i, iz, ch;

	        if (id.length === 0) { return false; }

	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStartES5(ch)) {
	            return false;
	        }

	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPartES5(ch)) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function decodeUtf16(lead, trail) {
	        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	    }

	    function isIdentifierNameES6(id) {
	        var i, iz, ch, lowCh, check;

	        if (id.length === 0) { return false; }

	        check = code.isIdentifierStartES6;
	        for (i = 0, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (0xD800 <= ch && ch <= 0xDBFF) {
	                ++i;
	                if (i >= iz) { return false; }
	                lowCh = id.charCodeAt(i);
	                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
	                    return false;
	                }
	                ch = decodeUtf16(ch, lowCh);
	            }
	            if (!check(ch)) {
	                return false;
	            }
	            check = code.isIdentifierPartES6;
	        }
	        return true;
	    }

	    function isIdentifierES5(id, strict) {
	        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	    }

	    function isIdentifierES6(id, strict) {
	        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	    }

	    module.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierNameES5: isIdentifierNameES5,
	        isIdentifierNameES6: isIdentifierNameES6,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	//  Ramda v0.22.1
	//  https://github.com/ramda/ramda
	//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
	//  Ramda may be freely distributed under the MIT license.

	;(function() {

	  'use strict';

	  /**
	     * A special placeholder value used to specify "gaps" within curried functions,
	     * allowing partial application of any combination of arguments, regardless of
	     * their positions.
	     *
	     * If `g` is a curried ternary function and `_` is `R.__`, the following are
	     * equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2, _)(1, 3)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @constant
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @example
	     *
	     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	     *      greet('Alice'); //=> 'Hello, Alice!'
	     */
	    var __ = { '@@functional/placeholder': true };

	    /* eslint-disable no-unused-vars */
	    var _arity = function _arity(n, fn) {
	        /* eslint-disable no-unused-vars */
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.apply(this, arguments);
	            };
	        case 1:
	            return function (a0) {
	                return fn.apply(this, arguments);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.apply(this, arguments);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.apply(this, arguments);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.apply(this, arguments);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.apply(this, arguments);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.apply(this, arguments);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.apply(this, arguments);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.apply(this, arguments);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.apply(this, arguments);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.apply(this, arguments);
	            };
	        default:
	            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	        }
	    };

	    var _arrayFromIterator = function _arrayFromIterator(iter) {
	        var list = [];
	        var next;
	        while (!(next = iter.next()).done) {
	            list.push(next.value);
	        }
	        return list;
	    };

	    var _arrayOf = function _arrayOf() {
	        return Array.prototype.slice.call(arguments);
	    };

	    var _cloneRegExp = function _cloneRegExp(pattern) {
	        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	    };

	    var _complement = function _complement(f) {
	        return function () {
	            return !f.apply(this, arguments);
	        };
	    };

	    /**
	     * Private `concat` function to merge two array-like objects.
	     *
	     * @private
	     * @param {Array|Arguments} [set1=[]] An array-like object.
	     * @param {Array|Arguments} [set2=[]] An array-like object.
	     * @return {Array} A new, merged array.
	     * @example
	     *
	     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     */
	    var _concat = function _concat(set1, set2) {
	        set1 = set1 || [];
	        set2 = set2 || [];
	        var idx;
	        var len1 = set1.length;
	        var len2 = set2.length;
	        var result = [];
	        idx = 0;
	        while (idx < len1) {
	            result[result.length] = set1[idx];
	            idx += 1;
	        }
	        idx = 0;
	        while (idx < len2) {
	            result[result.length] = set2[idx];
	            idx += 1;
	        }
	        return result;
	    };

	    var _containsWith = function _containsWith(pred, x, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (pred(x, list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    };

	    var _filter = function _filter(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        while (idx < len) {
	            if (fn(list[idx])) {
	                result[result.length] = list[idx];
	            }
	            idx += 1;
	        }
	        return result;
	    };

	    var _forceReduced = function _forceReduced(x) {
	        return {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    // String(x => x) evaluates to "x => x", so the pattern may not match.
	    var _functionName = function _functionName(f) {
	        // String(x => x) evaluates to "x => x", so the pattern may not match.
	        var match = String(f).match(/^function (\w*)/);
	        return match == null ? '' : match[1];
	    };

	    var _has = function _has(prop, obj) {
	        return Object.prototype.hasOwnProperty.call(obj, prop);
	    };

	    var _identity = function _identity(x) {
	        return x;
	    };

	    var _isArguments = function () {
	        var toString = Object.prototype.toString;
	        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
	            return toString.call(x) === '[object Arguments]';
	        } : function _isArguments(x) {
	            return _has('callee', x);
	        };
	    }();

	    /**
	     * Tests whether or not an object is an array.
	     *
	     * @private
	     * @param {*} val The object to test.
	     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	     * @example
	     *
	     *      _isArray([]); //=> true
	     *      _isArray(null); //=> false
	     *      _isArray({}); //=> false
	     */
	    var _isArray = Array.isArray || function _isArray(val) {
	        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	    };

	    var _isFunction = function _isFunction(x) {
	        return Object.prototype.toString.call(x) === '[object Function]';
	    };

	    /**
	     * Determine if the passed argument is an integer.
	     *
	     * @private
	     * @param {*} n
	     * @category Type
	     * @return {Boolean}
	     */
	    var _isInteger = Number.isInteger || function _isInteger(n) {
	        return n << 0 === n;
	    };

	    var _isNumber = function _isNumber(x) {
	        return Object.prototype.toString.call(x) === '[object Number]';
	    };

	    var _isObject = function _isObject(x) {
	        return Object.prototype.toString.call(x) === '[object Object]';
	    };

	    var _isPlaceholder = function _isPlaceholder(a) {
	        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	    };

	    var _isRegExp = function _isRegExp(x) {
	        return Object.prototype.toString.call(x) === '[object RegExp]';
	    };

	    var _isString = function _isString(x) {
	        return Object.prototype.toString.call(x) === '[object String]';
	    };

	    var _isTransformer = function _isTransformer(obj) {
	        return typeof obj['@@transducer/step'] === 'function';
	    };

	    var _map = function _map(fn, functor) {
	        var idx = 0;
	        var len = functor.length;
	        var result = Array(len);
	        while (idx < len) {
	            result[idx] = fn(functor[idx]);
	            idx += 1;
	        }
	        return result;
	    };

	    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	    var _objectAssign = function _objectAssign(target) {
	        if (target == null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }
	        var output = Object(target);
	        var idx = 1;
	        var length = arguments.length;
	        while (idx < length) {
	            var source = arguments[idx];
	            if (source != null) {
	                for (var nextKey in source) {
	                    if (_has(nextKey, source)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	            idx += 1;
	        }
	        return output;
	    };

	    var _of = function _of(x) {
	        return [x];
	    };

	    var _pipe = function _pipe(f, g) {
	        return function () {
	            return g.call(this, f.apply(this, arguments));
	        };
	    };

	    var _pipeP = function _pipeP(f, g) {
	        return function () {
	            var ctx = this;
	            return f.apply(ctx, arguments).then(function (x) {
	                return g.call(ctx, x);
	            });
	        };
	    };

	    // \b matches word boundary; [\b] matches backspace
	    var _quote = function _quote(s) {
	        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
	    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
	        return '"' + escaped.replace(/"/g, '\\"') + '"';
	    };

	    var _reduced = function _reduced(x) {
	        return x && x['@@transducer/reduced'] ? x : {
	            '@@transducer/value': x,
	            '@@transducer/reduced': true
	        };
	    };

	    /**
	     * An optimized, private array `slice` implementation.
	     *
	     * @private
	     * @param {Arguments|Array} args The array or arguments object to consider.
	     * @param {Number} [from=0] The array index to slice from, inclusive.
	     * @param {Number} [to=args.length] The array index to slice to, exclusive.
	     * @return {Array} A new, sliced array.
	     * @example
	     *
	     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
	     *
	     *      var firstThreeArgs = function(a, b, c, d) {
	     *        return _slice(arguments, 0, 3);
	     *      };
	     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
	     */
	    var _slice = function _slice(args, from, to) {
	        switch (arguments.length) {
	        case 1:
	            return _slice(args, 0, args.length);
	        case 2:
	            return _slice(args, from, args.length);
	        default:
	            var list = [];
	            var idx = 0;
	            var len = Math.max(0, Math.min(args.length, to) - from);
	            while (idx < len) {
	                list[idx] = args[from + idx];
	                idx += 1;
	            }
	            return list;
	        }
	    };

	    /**
	     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	     */
	    var _toISOString = function () {
	        var pad = function pad(n) {
	            return (n < 10 ? '0' : '') + n;
	        };
	        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	            return d.toISOString();
	        } : function _toISOString(d) {
	            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	        };
	    }();

	    var _xfBase = {
	        init: function () {
	            return this.xf['@@transducer/init']();
	        },
	        result: function (result) {
	            return this.xf['@@transducer/result'](result);
	        }
	    };

	    var _xwrap = function () {
	        function XWrap(fn) {
	            this.f = fn;
	        }
	        XWrap.prototype['@@transducer/init'] = function () {
	            throw new Error('init not implemented on XWrap');
	        };
	        XWrap.prototype['@@transducer/result'] = function (acc) {
	            return acc;
	        };
	        XWrap.prototype['@@transducer/step'] = function (acc, x) {
	            return this.f(acc, x);
	        };
	        return function _xwrap(fn) {
	            return new XWrap(fn);
	        };
	    }();

	    var _aperture = function _aperture(n, list) {
	        var idx = 0;
	        var limit = list.length - (n - 1);
	        var acc = new Array(limit >= 0 ? limit : 0);
	        while (idx < limit) {
	            acc[idx] = _slice(list, idx, idx + n);
	            idx += 1;
	        }
	        return acc;
	    };

	    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

	    /**
	     * Similar to hasMethod, this checks whether a function has a [methodname]
	     * function. If it isn't an array it will execute that function otherwise it
	     * will default to the ramda implementation.
	     *
	     * @private
	     * @param {Function} fn ramda implemtation
	     * @param {String} methodname property to check for a custom implementation
	     * @return {Object} Whatever the return value of the method is.
	     */
	    var _checkForMethod = function _checkForMethod(methodname, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
	        };
	    };

	    /**
	     * Optimized internal one-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry1 = function _curry1(fn) {
	        return function f1(a) {
	            if (arguments.length === 0 || _isPlaceholder(a)) {
	                return f1;
	            } else {
	                return fn.apply(this, arguments);
	            }
	        };
	    };

	    /**
	     * Optimized internal two-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry2 = function _curry2(fn) {
	        return function f2(a, b) {
	            switch (arguments.length) {
	            case 0:
	                return f2;
	            case 1:
	                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	                    return fn(a, _b);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b);
	                }) : fn(a, b);
	            }
	        };
	    };

	    /**
	     * Optimized internal three-arity curry function.
	     *
	     * @private
	     * @category Function
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curry3 = function _curry3(fn) {
	        return function f3(a, b, c) {
	            switch (arguments.length) {
	            case 0:
	                return f3;
	            case 1:
	                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                });
	            case 2:
	                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _curry1(function (_c) {
	                    return fn(a, b, _c);
	                });
	            default:
	                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	                    return fn(_a, _b, c);
	                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	                    return fn(_a, b, _c);
	                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	                    return fn(a, _b, _c);
	                }) : _isPlaceholder(a) ? _curry1(function (_a) {
	                    return fn(_a, b, c);
	                }) : _isPlaceholder(b) ? _curry1(function (_b) {
	                    return fn(a, _b, c);
	                }) : _isPlaceholder(c) ? _curry1(function (_c) {
	                    return fn(a, b, _c);
	                }) : fn(a, b, c);
	            }
	        };
	    };

	    /**
	     * Internal curryN function.
	     *
	     * @private
	     * @category Function
	     * @param {Number} length The arity of the curried function.
	     * @param {Array} received An array of arguments received thus far.
	     * @param {Function} fn The function to curry.
	     * @return {Function} The curried function.
	     */
	    var _curryN = function _curryN(length, received, fn) {
	        return function () {
	            var combined = [];
	            var argsIdx = 0;
	            var left = length;
	            var combinedIdx = 0;
	            while (combinedIdx < received.length || argsIdx < arguments.length) {
	                var result;
	                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	                    result = received[combinedIdx];
	                } else {
	                    result = arguments[argsIdx];
	                    argsIdx += 1;
	                }
	                combined[combinedIdx] = result;
	                if (!_isPlaceholder(result)) {
	                    left -= 1;
	                }
	                combinedIdx += 1;
	            }
	            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	        };
	    };

	    /**
	     * Returns a function that dispatches with different strategies based on the
	     * object in list position (last argument). If it is an array, executes [fn].
	     * Otherwise, if it has a function with [methodname], it will execute that
	     * function (functor case). Otherwise, if it is a transformer, uses transducer
	     * [xf] to return a new transformer (transducer case). Otherwise, it will
	     * default to executing [fn].
	     *
	     * @private
	     * @param {String} methodname property to check for a custom implementation
	     * @param {Function} xf transducer to initialize if object is transformer
	     * @param {Function} fn default ramda implementation
	     * @return {Function} A function that dispatches on object in list position
	     */
	    var _dispatchable = function _dispatchable(methodname, xf, fn) {
	        return function () {
	            var length = arguments.length;
	            if (length === 0) {
	                return fn();
	            }
	            var obj = arguments[length - 1];
	            if (!_isArray(obj)) {
	                var args = _slice(arguments, 0, length - 1);
	                if (typeof obj[methodname] === 'function') {
	                    return obj[methodname].apply(obj, args);
	                }
	                if (_isTransformer(obj)) {
	                    var transducer = xf.apply(null, args);
	                    return transducer(obj);
	                }
	            }
	            return fn.apply(this, arguments);
	        };
	    };

	    var _dropLastWhile = function dropLastWhile(pred, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && pred(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, 0, idx + 1);
	    };

	    var _xall = function () {
	        function XAll(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.all = true;
	        }
	        XAll.prototype['@@transducer/init'] = _xfBase.init;
	        XAll.prototype['@@transducer/result'] = function (result) {
	            if (this.all) {
	                result = this.xf['@@transducer/step'](result, true);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAll.prototype['@@transducer/step'] = function (result, input) {
	            if (!this.f(input)) {
	                this.all = false;
	                result = _reduced(this.xf['@@transducer/step'](result, false));
	            }
	            return result;
	        };
	        return _curry2(function _xall(f, xf) {
	            return new XAll(f, xf);
	        });
	    }();

	    var _xany = function () {
	        function XAny(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.any = false;
	        }
	        XAny.prototype['@@transducer/init'] = _xfBase.init;
	        XAny.prototype['@@transducer/result'] = function (result) {
	            if (!this.any) {
	                result = this.xf['@@transducer/step'](result, false);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XAny.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.any = true;
	                result = _reduced(this.xf['@@transducer/step'](result, true));
	            }
	            return result;
	        };
	        return _curry2(function _xany(f, xf) {
	            return new XAny(f, xf);
	        });
	    }();

	    var _xaperture = function () {
	        function XAperture(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XAperture.prototype['@@transducer/init'] = _xfBase.init;
	        XAperture.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XAperture.prototype['@@transducer/step'] = function (result, input) {
	            this.store(input);
	            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
	        };
	        XAperture.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        XAperture.prototype.getCopy = function () {
	            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
	        };
	        return _curry2(function _xaperture(n, xf) {
	            return new XAperture(n, xf);
	        });
	    }();

	    var _xdrop = function () {
	        function XDrop(n, xf) {
	            this.xf = xf;
	            this.n = n;
	        }
	        XDrop.prototype['@@transducer/init'] = _xfBase.init;
	        XDrop.prototype['@@transducer/result'] = _xfBase.result;
	        XDrop.prototype['@@transducer/step'] = function (result, input) {
	            if (this.n > 0) {
	                this.n -= 1;
	                return result;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdrop(n, xf) {
	            return new XDrop(n, xf);
	        });
	    }();

	    var _xdropLast = function () {
	        function XDropLast(n, xf) {
	            this.xf = xf;
	            this.pos = 0;
	            this.full = false;
	            this.acc = new Array(n);
	        }
	        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLast.prototype['@@transducer/result'] = function (result) {
	            this.acc = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.full) {
	                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
	            }
	            this.store(input);
	            return result;
	        };
	        XDropLast.prototype.store = function (input) {
	            this.acc[this.pos] = input;
	            this.pos += 1;
	            if (this.pos === this.acc.length) {
	                this.pos = 0;
	                this.full = true;
	            }
	        };
	        return _curry2(function _xdropLast(n, xf) {
	            return new XDropLast(n, xf);
	        });
	    }();

	    var _xdropRepeatsWith = function () {
	        function XDropRepeatsWith(pred, xf) {
	            this.xf = xf;
	            this.pred = pred;
	            this.lastValue = undefined;
	            this.seenFirstValue = false;
	        }
	        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
	            return this.xf['@@transducer/init']();
	        };
	        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	            var sameAsLast = false;
	            if (!this.seenFirstValue) {
	                this.seenFirstValue = true;
	            } else if (this.pred(this.lastValue, input)) {
	                sameAsLast = true;
	            }
	            this.lastValue = input;
	            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropRepeatsWith(pred, xf) {
	            return new XDropRepeatsWith(pred, xf);
	        });
	    }();

	    var _xdropWhile = function () {
	        function XDropWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f) {
	                if (this.f(input)) {
	                    return result;
	                }
	                this.f = null;
	            }
	            return this.xf['@@transducer/step'](result, input);
	        };
	        return _curry2(function _xdropWhile(f, xf) {
	            return new XDropWhile(f, xf);
	        });
	    }();

	    var _xfilter = function () {
	        function XFilter(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFilter.prototype['@@transducer/init'] = _xfBase.init;
	        XFilter.prototype['@@transducer/result'] = _xfBase.result;
	        XFilter.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	        };
	        return _curry2(function _xfilter(f, xf) {
	            return new XFilter(f, xf);
	        });
	    }();

	    var _xfind = function () {
	        function XFind(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.found = false;
	        }
	        XFind.prototype['@@transducer/init'] = _xfBase.init;
	        XFind.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, void 0);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFind.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, input));
	            }
	            return result;
	        };
	        return _curry2(function _xfind(f, xf) {
	            return new XFind(f, xf);
	        });
	    }();

	    var _xfindIndex = function () {
	        function XFindIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.found = false;
	        }
	        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindIndex.prototype['@@transducer/result'] = function (result) {
	            if (!this.found) {
	                result = this.xf['@@transducer/step'](result, -1);
	            }
	            return this.xf['@@transducer/result'](result);
	        };
	        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.found = true;
	                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	            }
	            return result;
	        };
	        return _curry2(function _xfindIndex(f, xf) {
	            return new XFindIndex(f, xf);
	        });
	    }();

	    var _xfindLast = function () {
	        function XFindLast(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLast.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	        };
	        XFindLast.prototype['@@transducer/step'] = function (result, input) {
	            if (this.f(input)) {
	                this.last = input;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLast(f, xf) {
	            return new XFindLast(f, xf);
	        });
	    }();

	    var _xfindLastIndex = function () {
	        function XFindLastIndex(f, xf) {
	            this.xf = xf;
	            this.f = f;
	            this.idx = -1;
	            this.lastIdx = -1;
	        }
	        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	        };
	        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	            this.idx += 1;
	            if (this.f(input)) {
	                this.lastIdx = this.idx;
	            }
	            return result;
	        };
	        return _curry2(function _xfindLastIndex(f, xf) {
	            return new XFindLastIndex(f, xf);
	        });
	    }();

	    var _xmap = function () {
	        function XMap(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XMap.prototype['@@transducer/init'] = _xfBase.init;
	        XMap.prototype['@@transducer/result'] = _xfBase.result;
	        XMap.prototype['@@transducer/step'] = function (result, input) {
	            return this.xf['@@transducer/step'](result, this.f(input));
	        };
	        return _curry2(function _xmap(f, xf) {
	            return new XMap(f, xf);
	        });
	    }();

	    var _xreduceBy = function () {
	        function XReduceBy(valueFn, valueAcc, keyFn, xf) {
	            this.valueFn = valueFn;
	            this.valueAcc = valueAcc;
	            this.keyFn = keyFn;
	            this.xf = xf;
	            this.inputs = {};
	        }
	        XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
	        XReduceBy.prototype['@@transducer/result'] = function (result) {
	            var key;
	            for (key in this.inputs) {
	                if (_has(key, this.inputs)) {
	                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
	                    if (result['@@transducer/reduced']) {
	                        result = result['@@transducer/value'];
	                        break;
	                    }
	                }
	            }
	            this.inputs = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XReduceBy.prototype['@@transducer/step'] = function (result, input) {
	            var key = this.keyFn(input);
	            this.inputs[key] = this.inputs[key] || [
	                key,
	                this.valueAcc
	            ];
	            this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
	            return result;
	        };
	        return _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
	            return new XReduceBy(valueFn, valueAcc, keyFn, xf);
	        });
	    }();

	    var _xtake = function () {
	        function XTake(n, xf) {
	            this.xf = xf;
	            this.n = n;
	            this.i = 0;
	        }
	        XTake.prototype['@@transducer/init'] = _xfBase.init;
	        XTake.prototype['@@transducer/result'] = _xfBase.result;
	        XTake.prototype['@@transducer/step'] = function (result, input) {
	            this.i += 1;
	            var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
	            return this.i >= this.n ? _reduced(ret) : ret;
	        };
	        return _curry2(function _xtake(n, xf) {
	            return new XTake(n, xf);
	        });
	    }();

	    var _xtakeWhile = function () {
	        function XTakeWhile(f, xf) {
	            this.xf = xf;
	            this.f = f;
	        }
	        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	        };
	        return _curry2(function _xtakeWhile(f, xf) {
	            return new XTakeWhile(f, xf);
	        });
	    }();

	    /**
	     * Adds two values.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Number}
	     * @see R.subtract
	     * @example
	     *
	     *      R.add(2, 3);       //=>  5
	     *      R.add(7)(10);      //=> 17
	     */
	    var add = _curry2(function add(a, b) {
	        return Number(a) + Number(b);
	    });

	    /**
	     * Applies a function to the value at the given index of an array, returning a
	     * new copy of the array with the element at the given index replaced with the
	     * result of the function application.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a -> a) -> Number -> [a] -> [a]
	     * @param {Function} fn The function to apply.
	     * @param {Number} idx The index.
	     * @param {Array|Arguments} list An array-like object whose value
	     *        at the supplied index will be replaced.
	     * @return {Array} A copy of the supplied array-like object with
	     *         the element at index `idx` replaced with the value
	     *         returned by applying `fn` to the existing element.
	     * @see R.update
	     * @example
	     *
	     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var adjust = _curry3(function adjust(fn, idx, list) {
	        if (idx >= list.length || idx < -list.length) {
	            return list;
	        }
	        var start = idx < 0 ? list.length : 0;
	        var _idx = start + idx;
	        var _list = _concat(list);
	        _list[_idx] = fn(list[_idx]);
	        return _list;
	    });

	    /**
	     * Returns `true` if all elements of the list match the predicate, `false` if
	     * there are any that don't.
	     *
	     * Dispatches to the `all` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	     *         otherwise.
	     * @see R.any, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      var lessThan3 = R.flip(R.lt)(3);
	     *      R.all(lessThan2)([1, 2]); //=> false
	     *      R.all(lessThan3)([1, 2]); //=> true
	     */
	    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (!fn(list[idx])) {
	                return false;
	            }
	            idx += 1;
	        }
	        return true;
	    }));

	    /**
	     * Returns a function that always returns the given value. Note that for
	     * non-primitives the value returned is a reference to the original value.
	     *
	     * This function is known as `const`, `constant`, or `K` (for K combinator) in
	     * other languages and libraries.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> (* -> a)
	     * @param {*} val The value to wrap in a function
	     * @return {Function} A Function :: * -> val.
	     * @example
	     *
	     *      var t = R.always('Tee');
	     *      t(); //=> 'Tee'
	     */
	    var always = _curry1(function always(val) {
	        return function () {
	            return val;
	        };
	    });

	    /**
	     * Returns `true` if both arguments are `true`; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
	     * @see R.both
	     * @example
	     *
	     *      R.and(true, true); //=> true
	     *      R.and(true, false); //=> false
	     *      R.and(false, true); //=> false
	     *      R.and(false, false); //=> false
	     */
	    var and = _curry2(function and(a, b) {
	        return a && b;
	    });

	    /**
	     * Returns `true` if at least one of elements of the list match the predicate,
	     * `false` otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	     *         otherwise.
	     * @see R.all, R.none, R.transduce
	     * @example
	     *
	     *      var lessThan0 = R.flip(R.lt)(0);
	     *      var lessThan2 = R.flip(R.lt)(2);
	     *      R.any(lessThan0)([1, 2]); //=> false
	     *      R.any(lessThan2)([1, 2]); //=> true
	     */
	    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
	        var idx = 0;
	        while (idx < list.length) {
	            if (fn(list[idx])) {
	                return true;
	            }
	            idx += 1;
	        }
	        return false;
	    }));

	    /**
	     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
	     * greater than the length of the list, an empty list is returned.
	     *
	     * Dispatches to the `aperture` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @param {Number} n The size of the tuples to create
	     * @param {Array} list The list to split into `n`-tuples
	     * @return {Array} The new list.
	     * @see R.transduce
	     * @example
	     *
	     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	     */
	    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

	    /**
	     * Returns a new list containing the contents of the given list, followed by
	     * the given element.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The element to add to the end of the new list.
	     * @param {Array} list The list whose contents will be added to the beginning of the output
	     *        list.
	     * @return {Array} A new list containing the contents of the old list followed by `el`.
	     * @see R.prepend
	     * @example
	     *
	     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	     *      R.append('tests', []); //=> ['tests']
	     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	     */
	    var append = _curry2(function append(el, list) {
	        return _concat(list, [el]);
	    });

	    /**
	     * Applies function `fn` to the argument list `args`. This is useful for
	     * creating a fixed-arity function from a variadic function. `fn` should be a
	     * bound function if context is significant.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> a) -> [*] -> a
	     * @param {Function} fn
	     * @param {Array} args
	     * @return {*}
	     * @see R.call, R.unapply
	     * @example
	     *
	     *      var nums = [1, 2, 3, -99, 42, 6, 7];
	     *      R.apply(Math.max, nums); //=> 42
	     */
	    var apply = _curry2(function apply(fn, args) {
	        return fn.apply(this, args);
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the specified
	     * property with the given value. Note that this copies and flattens prototype
	     * properties onto the new object as well. All non-primitive properties are
	     * copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig String -> a -> {k: v} -> {k: v}
	     * @param {String} prop the property name to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except for the specified property.
	     * @see R.dissoc
	     * @example
	     *
	     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	     */
	    var assoc = _curry3(function assoc(prop, val, obj) {
	        var result = {};
	        for (var p in obj) {
	            result[p] = obj[p];
	        }
	        result[prop] = val;
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, setting or overriding the nodes required
	     * to create the given path, and placing the specific value at the tail end of
	     * that path. Note that this copies and flattens prototype properties onto the
	     * new object as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig [String] -> a -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {*} val the new value
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original except along the specified path.
	     * @see R.dissocPath
	     * @example
	     *
	     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	     */
	    var assocPath = _curry3(function assocPath(path, val, obj) {
	        switch (path.length) {
	        case 0:
	            return val;
	        case 1:
	            return assoc(path[0], val, obj);
	        default:
	            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
	        }
	    });

	    /**
	     * Creates a function that is bound to a context.
	     * Note: `R.bind` does not provide the additional argument-binding capabilities of
	     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Function
	     * @category Object
	     * @sig (* -> *) -> {*} -> (* -> *)
	     * @param {Function} fn The function to bind to context
	     * @param {Object} thisObj The context to bind `fn` to
	     * @return {Function} A function that will execute in the context of `thisObj`.
	     * @see R.partial
	     * @example
	     *
	     *      var log = R.bind(console.log, console);
	     *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
	     *      // logs {a: 2}
	     */
	    var bind = _curry2(function bind(fn, thisObj) {
	        return _arity(fn.length, function () {
	            return fn.apply(thisObj, arguments);
	        });
	    });

	    /**
	     * Restricts a number to be within a range.
	     *
	     * Also works for other ordered types such as Strings and Dates.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.20.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a -> a
	     * @param {Number} minimum number
	     * @param {Number} maximum number
	     * @param {Number} value to be clamped
	     * @return {Number} Returns the clamped value
	     * @example
	     *
	     *      R.clamp(1, 10, -1) // => 1
	     *      R.clamp(1, 10, 11) // => 10
	     *      R.clamp(1, 10, 4)  // => 4
	     */
	    var clamp = _curry3(function clamp(min, max, value) {
	        if (min > max) {
	            throw new Error('min must not be greater than max in clamp(min, max, value)');
	        }
	        return value < min ? min : value > max ? max : value;
	    });

	    /**
	     * Makes a comparator function out of a function that reports whether the first
	     * element is less than the second.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a, b -> Boolean) -> (a, b -> Number)
	     * @param {Function} pred A predicate function of arity two.
	     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
	     * @example
	     *
	     *      var cmp = R.comparator((a, b) => a.age < b.age);
	     *      var people = [
	     *        // ...
	     *      ];
	     *      R.sort(cmp, people);
	     */
	    var comparator = _curry1(function comparator(pred) {
	        return function (a, b) {
	            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	        };
	    });

	    /**
	     * Returns a curried equivalent of the provided function, with the specified
	     * arity. The curried function has two unusual capabilities. First, its
	     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curry
	     * @example
	     *
	     *      var sumArgs = (...args) => R.sum(args);
	     *
	     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curryN = _curry2(function curryN(length, fn) {
	        if (length === 1) {
	            return _curry1(fn);
	        }
	        return _arity(length, _curryN(length, [], fn));
	    });

	    /**
	     * Decrements its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.inc
	     * @example
	     *
	     *      R.dec(42); //=> 41
	     */
	    var dec = add(-1);

	    /**
	     * Returns the second argument if it is not `null`, `undefined` or `NaN`
	     * otherwise the first argument is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Logic
	     * @sig a -> b -> a | b
	     * @param {a} val The default value.
	     * @param {b} val The value to return if it is not null or undefined
	     * @return {*} The the second value or the default value
	     * @example
	     *
	     *      var defaultTo42 = R.defaultTo(42);
	     *
	     *      defaultTo42(null);  //=> 42
	     *      defaultTo42(undefined);  //=> 42
	     *      defaultTo42('Ramda');  //=> 'Ramda'
	     *      defaultTo42(parseInt('string')); //=> 42
	     */
	    var defaultTo = _curry2(function defaultTo(d, v) {
	        return v == null || v !== v ? d : v;
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
	     * @example
	     *
	     *      var cmp = (x, y) => x.a === y.a;
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	     *      var l2 = [{a: 3}, {a: 4}];
	     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	     */
	    var differenceWith = _curry3(function differenceWith(pred, first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
	                out.push(first[idx]);
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object that does not contain a `prop` property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Object
	     * @sig String -> {k: v} -> {k: v}
	     * @param {String} prop the name of the property to dissociate
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object similar to the original but without the specified property
	     * @see R.assoc
	     * @example
	     *
	     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	     */
	    var dissoc = _curry2(function dissoc(prop, obj) {
	        var result = {};
	        for (var p in obj) {
	            if (p !== prop) {
	                result[p] = obj[p];
	            }
	        }
	        return result;
	    });

	    /**
	     * Makes a shallow clone of an object, omitting the property at the given path.
	     * Note that this copies and flattens prototype properties onto the new object
	     * as well. All non-primitive properties are copied by reference.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.11.0
	     * @category Object
	     * @sig [String] -> {k: v} -> {k: v}
	     * @param {Array} path the path to set
	     * @param {Object} obj the object to clone
	     * @return {Object} a new object without the property at path
	     * @see R.assocPath
	     * @example
	     *
	     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	     */
	    var dissocPath = _curry2(function dissocPath(path, obj) {
	        switch (path.length) {
	        case 0:
	            return obj;
	        case 1:
	            return dissoc(path[0], obj);
	        default:
	            var head = path[0];
	            var tail = _slice(path, 1);
	            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
	        }
	    });

	    /**
	     * Divides two numbers. Equivalent to `a / b`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a / b`.
	     * @see R.multiply
	     * @example
	     *
	     *      R.divide(71, 100); //=> 0.71
	     *
	     *      var half = R.divide(R.__, 2);
	     *      half(42); //=> 21
	     *
	     *      var reciprocal = R.divide(1);
	     *      reciprocal(4);   //=> 0.25
	     */
	    var divide = _curry2(function divide(a, b) {
	        return a / b;
	    });

	    /**
	     * Returns a new list excluding the leading elements of a given list which
	     * satisfy the supplied predicate function. It passes each value to the supplied
	     * predicate function, skipping elements while the predicate function returns
	     * `true`. The predicate function is applied to one argument: *(value)*.
	     *
	     * Dispatches to the `dropWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var lteTwo = x => x <= 2;
	     *
	     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	     */
	    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && pred(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, idx);
	    }));

	    /**
	     * Returns the empty value of its argument's type. Ramda defines the empty
	     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
	     * types are supported if they define `<Type>.empty` and/or
	     * `<Type>.prototype.empty`.
	     *
	     * Dispatches to the `empty` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x
	     * @return {*}
	     * @example
	     *
	     *      R.empty(Just(42));      //=> Nothing()
	     *      R.empty([1, 2, 3]);     //=> []
	     *      R.empty('unicorns');    //=> ''
	     *      R.empty({x: 1, y: 2});  //=> {}
	     */
	    // else
	    var empty = _curry1(function empty(x) {
	        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
	            return arguments;
	        }() : // else
	        void 0;
	    });

	    /**
	     * Creates a new object by recursively evolving a shallow copy of `object`,
	     * according to the `transformation` functions. All non-primitive properties
	     * are copied by reference.
	     *
	     * A `transformation` function will not be invoked if its corresponding key
	     * does not exist in the evolved object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	     * @param {Object} transformations The object specifying transformation functions to apply
	     *        to the object.
	     * @param {Object} object The object to be transformed.
	     * @return {Object} The transformed object.
	     * @example
	     *
	     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	     *      var transformations = {
	     *        firstName: R.trim,
	     *        lastName: R.trim, // Will not get invoked.
	     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	     *      };
	     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	     */
	    var evolve = _curry2(function evolve(transformations, object) {
	        var result = {};
	        var transformation, key, type;
	        for (key in object) {
	            transformation = transformations[key];
	            type = typeof transformation;
	            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
	        }
	        return result;
	    });

	    /**
	     * Returns the first element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `find` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     *        desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	     *      R.find(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx += 1;
	        }
	    }));

	    /**
	     * Returns the index of the first element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    }));

	    /**
	     * Returns the last element of the list which matches the predicate, or
	     * `undefined` if no element matches.
	     *
	     * Dispatches to the `findLast` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> a | undefined
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Object} The element found, or `undefined`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	     */
	    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return list[idx];
	            }
	            idx -= 1;
	        }
	    }));

	    /**
	     * Returns the index of the last element of the list which matches the
	     * predicate, or `-1` if no element matches.
	     *
	     * Dispatches to the `findLastIndex` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Number
	     * @param {Function} fn The predicate function used to determine if the element is the
	     * desired one.
	     * @param {Array} list The array to consider.
	     * @return {Number} The index of the element found, or `-1`.
	     * @see R.transduce
	     * @example
	     *
	     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	     */
	    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            if (fn(list[idx])) {
	                return idx;
	            }
	            idx -= 1;
	        }
	        return -1;
	    }));

	    /**
	     * Iterate over an input `list`, calling a provided function `fn` for each
	     * element in the list.
	     *
	     * `fn` receives one argument: *(value)*.
	     *
	     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.forEach` method. For more
	     * details on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	     *
	     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	     * the original array. In some libraries this function is named `each`.
	     *
	     * Dispatches to the `forEach` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig (a -> *) -> [a] -> [a]
	     * @param {Function} fn The function to invoke. Receives one argument, `value`.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} The original list.
	     * @see R.addIndex
	     * @example
	     *
	     *      var printXPlusFive = x => console.log(x + 5);
	     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	     *      // logs 6
	     *      // logs 7
	     *      // logs 8
	     */
	    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
	        var len = list.length;
	        var idx = 0;
	        while (idx < len) {
	            fn(list[idx]);
	            idx += 1;
	        }
	        return list;
	    }));

	    /**
	     * Creates a new object from a list key-value pairs. If a key appears in
	     * multiple pairs, the rightmost pair is included in the object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [[k,v]] -> {k: v}
	     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	     * @return {Object} The object made by pairing up `keys` and `values`.
	     * @see R.toPairs, R.pair
	     * @example
	     *
	     *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	     */
	    var fromPairs = _curry1(function fromPairs(pairs) {
	        var result = {};
	        var idx = 0;
	        while (idx < pairs.length) {
	            result[pairs[idx][0]] = pairs[idx][1];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Takes a list and returns a list of lists where each sublist's elements are
	     * all "equal" according to the provided equality function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.21.0
	     * @category List
	     * @sig ((a, a)  Boolean)  [a]  [[a]]
	     * @param {Function} fn Function for determining whether two given (adjacent)
	     *        elements should be in the same group
	     * @param {Array} list The array to group. Also accepts a string, which will be
	     *        treated as a list of characters.
	     * @return {List} A list that contains sublists of equal elements,
	     *         whose concatenations are equal to the original list.
	     * @example
	     *
	     * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	     * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
	     *
	     * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	     * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
	     *
	     * R.groupWith(R.eqBy(isVowel), 'aestiou')
	     * //=> ['ae', 'st', 'iou']
	     */
	    var groupWith = _curry2(function (fn, list) {
	        var res = [];
	        var idx = 0;
	        var len = list.length;
	        while (idx < len) {
	            var nextidx = idx + 1;
	            while (nextidx < len && fn(list[idx], list[nextidx])) {
	                nextidx += 1;
	            }
	            res.push(list.slice(idx, nextidx));
	            idx = nextidx;
	        }
	        return res;
	    });

	    /**
	     * Returns `true` if the first argument is greater than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.lt
	     * @example
	     *
	     *      R.gt(2, 1); //=> true
	     *      R.gt(2, 2); //=> false
	     *      R.gt(2, 3); //=> false
	     *      R.gt('a', 'z'); //=> false
	     *      R.gt('z', 'a'); //=> true
	     */
	    var gt = _curry2(function gt(a, b) {
	        return a > b;
	    });

	    /**
	     * Returns `true` if the first argument is greater than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.lte
	     * @example
	     *
	     *      R.gte(2, 1); //=> true
	     *      R.gte(2, 2); //=> true
	     *      R.gte(2, 3); //=> false
	     *      R.gte('a', 'z'); //=> false
	     *      R.gte('z', 'a'); //=> true
	     */
	    var gte = _curry2(function gte(a, b) {
	        return a >= b;
	    });

	    /**
	     * Returns whether or not an object has an own property with the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      var hasName = R.has('name');
	     *      hasName({name: 'alice'});   //=> true
	     *      hasName({name: 'bob'});     //=> true
	     *      hasName({});                //=> false
	     *
	     *      var point = {x: 0, y: 0};
	     *      var pointHas = R.has(R.__, point);
	     *      pointHas('x');  //=> true
	     *      pointHas('y');  //=> true
	     *      pointHas('z');  //=> false
	     */
	    var has = _curry2(_has);

	    /**
	     * Returns whether or not an object or its prototype chain has a property with
	     * the specified name
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Object
	     * @sig s -> {s: x} -> Boolean
	     * @param {String} prop The name of the property to check for.
	     * @param {Object} obj The object to query.
	     * @return {Boolean} Whether the property exists.
	     * @example
	     *
	     *      function Rectangle(width, height) {
	     *        this.width = width;
	     *        this.height = height;
	     *      }
	     *      Rectangle.prototype.area = function() {
	     *        return this.width * this.height;
	     *      };
	     *
	     *      var square = new Rectangle(2, 2);
	     *      R.hasIn('width', square);  //=> true
	     *      R.hasIn('area', square);  //=> true
	     */
	    var hasIn = _curry2(function hasIn(prop, obj) {
	        return prop in obj;
	    });

	    /**
	     * Returns true if its arguments are identical, false otherwise. Values are
	     * identical if they reference the same memory. `NaN` is identical to `NaN`;
	     * `0` and `-0` are not identical.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      var o = {};
	     *      R.identical(o, o); //=> true
	     *      R.identical(1, 1); //=> true
	     *      R.identical(1, '1'); //=> false
	     *      R.identical([], []); //=> false
	     *      R.identical(0, -0); //=> false
	     *      R.identical(NaN, NaN); //=> true
	     */
	    // SameValue algorithm
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Step 6.a: NaN == NaN
	    var identical = _curry2(function identical(a, b) {
	        // SameValue algorithm
	        if (a === b) {
	            // Steps 1-5, 7-10
	            // Steps 6.b-6.e: +0 != -0
	            return a !== 0 || 1 / a === 1 / b;
	        } else {
	            // Step 6.a: NaN == NaN
	            return a !== a && b !== b;
	        }
	    });

	    /**
	     * A function that does nothing but return the parameter supplied to it. Good
	     * as a default or placeholder function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig a -> a
	     * @param {*} x The value to return.
	     * @return {*} The input value, `x`.
	     * @example
	     *
	     *      R.identity(1); //=> 1
	     *
	     *      var obj = {};
	     *      R.identity(obj) === obj; //=> true
	     */
	    var identity = _curry1(_identity);

	    /**
	     * Creates a function that will process either the `onTrue` or the `onFalse`
	     * function depending upon the result of the `condition` predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	     * @param {Function} condition A predicate function
	     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	     *                    function depending upon the result of the `condition` predicate.
	     * @see R.unless, R.when
	     * @example
	     *
	     *      var incCount = R.ifElse(
	     *        R.has('count'),
	     *        R.over(R.lensProp('count'), R.inc),
	     *        R.assoc('count', 1)
	     *      );
	     *      incCount({});           //=> { count: 1 }
	     *      incCount({ count: 1 }); //=> { count: 2 }
	     */
	    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
	        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	        });
	    });

	    /**
	     * Increments its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @see R.dec
	     * @example
	     *
	     *      R.inc(42); //=> 43
	     */
	    var inc = add(1);

	    /**
	     * Inserts the supplied element into the list, at index `index`. _Note that
	     * this is not destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} index The position to insert the element
	     * @param {*} elt The element to insert into the Array
	     * @param {Array} list The list to insert into
	     * @return {Array} A new Array with `elt` inserted at `index`.
	     * @example
	     *
	     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	     */
	    var insert = _curry3(function insert(idx, elt, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        var result = _slice(list);
	        result.splice(idx, 0, elt);
	        return result;
	    });

	    /**
	     * Inserts the sub-list into the list, at index `index`. _Note that this is not
	     * destructive_: it returns a copy of the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig Number -> [a] -> [a] -> [a]
	     * @param {Number} index The position to insert the sub-list
	     * @param {Array} elts The sub-list to insert into the Array
	     * @param {Array} list The list to insert the sub-list into
	     * @return {Array} A new Array with `elts` inserted starting at `index`.
	     * @example
	     *
	     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	     */
	    var insertAll = _curry3(function insertAll(idx, elts, list) {
	        idx = idx < list.length && idx >= 0 ? idx : list.length;
	        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
	    });

	    /**
	     * Creates a new list with the separator interposed between elements.
	     *
	     * Dispatches to the `intersperse` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} separator The element to add to the list.
	     * @param {Array} list The list to be interposed.
	     * @return {Array} The new list.
	     * @example
	     *
	     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	     */
	    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
	        var out = [];
	        var idx = 0;
	        var length = list.length;
	        while (idx < length) {
	            if (idx === length - 1) {
	                out.push(list[idx]);
	            } else {
	                out.push(list[idx], separator);
	            }
	            idx += 1;
	        }
	        return out;
	    }));

	    /**
	     * See if an object (`val`) is an instance of the supplied constructor. This
	     * function will check up the inheritance chain, if any.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Type
	     * @sig (* -> {*}) -> a -> Boolean
	     * @param {Object} ctor A constructor
	     * @param {*} val The value to test
	     * @return {Boolean}
	     * @example
	     *
	     *      R.is(Object, {}); //=> true
	     *      R.is(Number, 1); //=> true
	     *      R.is(Object, 1); //=> false
	     *      R.is(String, 's'); //=> true
	     *      R.is(String, new String('')); //=> true
	     *      R.is(Object, new String('')); //=> true
	     *      R.is(Object, 's'); //=> false
	     *      R.is(Number, {}); //=> false
	     */
	    var is = _curry2(function is(Ctor, val) {
	        return val != null && val.constructor === Ctor || val instanceof Ctor;
	    });

	    /**
	     * Tests whether or not an object is similar to an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.5.0
	     * @category Type
	     * @category List
	     * @sig * -> Boolean
	     * @param {*} x The object to test.
	     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	     * @example
	     *
	     *      R.isArrayLike([]); //=> true
	     *      R.isArrayLike(true); //=> false
	     *      R.isArrayLike({}); //=> false
	     *      R.isArrayLike({length: 10}); //=> false
	     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	     */
	    var isArrayLike = _curry1(function isArrayLike(x) {
	        if (_isArray(x)) {
	            return true;
	        }
	        if (!x) {
	            return false;
	        }
	        if (typeof x !== 'object') {
	            return false;
	        }
	        if (_isString(x)) {
	            return false;
	        }
	        if (x.nodeType === 1) {
	            return !!x.length;
	        }
	        if (x.length === 0) {
	            return true;
	        }
	        if (x.length > 0) {
	            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	        }
	        return false;
	    });

	    /**
	     * Checks if the input value is `null` or `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Type
	     * @sig * -> Boolean
	     * @param {*} x The value to test.
	     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	     * @example
	     *
	     *      R.isNil(null); //=> true
	     *      R.isNil(undefined); //=> true
	     *      R.isNil(0); //=> false
	     *      R.isNil([]); //=> false
	     */
	    var isNil = _curry1(function isNil(x) {
	        return x == null;
	    });

	    /**
	     * Returns a list containing the names of all the enumerable own properties of
	     * the supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own properties.
	     * @example
	     *
	     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	     */
	    // cover IE < 9 keys issues
	    // Safari bug
	    var keys = function () {
	        // cover IE < 9 keys issues
	        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	        var nonEnumerableProps = [
	            'constructor',
	            'valueOf',
	            'isPrototypeOf',
	            'toString',
	            'propertyIsEnumerable',
	            'hasOwnProperty',
	            'toLocaleString'
	        ];
	        // Safari bug
	        var hasArgsEnumBug = function () {
	            'use strict';
	            return arguments.propertyIsEnumerable('length');
	        }();
	        var contains = function contains(list, item) {
	            var idx = 0;
	            while (idx < list.length) {
	                if (list[idx] === item) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        };
	        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
	            return Object(obj) !== obj ? [] : Object.keys(obj);
	        }) : _curry1(function keys(obj) {
	            if (Object(obj) !== obj) {
	                return [];
	            }
	            var prop, nIdx;
	            var ks = [];
	            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
	            for (prop in obj) {
	                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
	                    ks[ks.length] = prop;
	                }
	            }
	            if (hasEnumBug) {
	                nIdx = nonEnumerableProps.length - 1;
	                while (nIdx >= 0) {
	                    prop = nonEnumerableProps[nIdx];
	                    if (_has(prop, obj) && !contains(ks, prop)) {
	                        ks[ks.length] = prop;
	                    }
	                    nIdx -= 1;
	                }
	            }
	            return ks;
	        });
	    }();

	    /**
	     * Returns a list containing the names of all the properties of the supplied
	     * object, including prototype properties.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [k]
	     * @param {Object} obj The object to extract properties from
	     * @return {Array} An array of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.keysIn(f); //=> ['x', 'y']
	     */
	    var keysIn = _curry1(function keysIn(obj) {
	        var prop;
	        var ks = [];
	        for (prop in obj) {
	            ks[ks.length] = prop;
	        }
	        return ks;
	    });

	    /**
	     * Returns the number of elements in the array by returning `list.length`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [a] -> Number
	     * @param {Array} list The array to inspect.
	     * @return {Number} The length of the array.
	     * @example
	     *
	     *      R.length([]); //=> 0
	     *      R.length([1, 2, 3]); //=> 3
	     */
	    var length = _curry1(function length(list) {
	        return list != null && _isNumber(list.length) ? list.length : NaN;
	    });

	    /**
	     * Returns `true` if the first argument is less than the second; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @see R.gt
	     * @example
	     *
	     *      R.lt(2, 1); //=> false
	     *      R.lt(2, 2); //=> false
	     *      R.lt(2, 3); //=> true
	     *      R.lt('a', 'z'); //=> true
	     *      R.lt('z', 'a'); //=> false
	     */
	    var lt = _curry2(function lt(a, b) {
	        return a < b;
	    });

	    /**
	     * Returns `true` if the first argument is less than or equal to the second;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> Boolean
	     * @param {Number} a
	     * @param {Number} b
	     * @return {Boolean}
	     * @see R.gte
	     * @example
	     *
	     *      R.lte(2, 1); //=> false
	     *      R.lte(2, 2); //=> true
	     *      R.lte(2, 3); //=> true
	     *      R.lte('a', 'z'); //=> true
	     *      R.lte('z', 'a'); //=> false
	     */
	    var lte = _curry2(function lte(a, b) {
	        return a <= b;
	    });

	    /**
	     * The mapAccum function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from left to right, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var appender = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	     */
	    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var tuple = [acc];
	        while (idx < len) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx += 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * The mapAccumRight function behaves like a combination of map and reduce; it
	     * applies a function to each element of a list, passing an accumulating
	     * parameter from right to left, and returning a final value of this
	     * accumulator together with the new list.
	     *
	     * Similar to `mapAccum`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two arguments, *acc* and *value*, and should
	     * return a tuple *[acc, value]*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var digits = ['1', '2', '3', '4'];
	     *      var append = (a, b) => [a + b, a + b];
	     *
	     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
	     */
	    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
	        var idx = list.length - 1;
	        var result = [];
	        var tuple = [acc];
	        while (idx >= 0) {
	            tuple = fn(tuple[0], list[idx]);
	            result[idx] = tuple[1];
	            idx -= 1;
	        }
	        return [
	            tuple[0],
	            result
	        ];
	    });

	    /**
	     * Tests a regular expression against a String. Note that this function will
	     * return an empty array when there are no matches. This differs from
	     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	     * which returns `null` when there are no matches.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig RegExp -> String -> [String | Undefined]
	     * @param {RegExp} rx A regular expression.
	     * @param {String} str The string to match against
	     * @return {Array} The list of matches or empty array.
	     * @see R.test
	     * @example
	     *
	     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	     *      R.match(/a/, 'b'); //=> []
	     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	     */
	    var match = _curry2(function match(rx, str) {
	        return str.match(rx) || [];
	    });

	    /**
	     * mathMod behaves like the modulo operator should mathematically, unlike the
	     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
	     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
	     * when the modulus is zero or negative.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} m The dividend.
	     * @param {Number} p the modulus.
	     * @return {Number} The result of `b mod a`.
	     * @example
	     *
	     *      R.mathMod(-17, 5);  //=> 3
	     *      R.mathMod(17, 5);   //=> 2
	     *      R.mathMod(17, -5);  //=> NaN
	     *      R.mathMod(17, 0);   //=> NaN
	     *      R.mathMod(17.2, 5); //=> NaN
	     *      R.mathMod(17, 5.3); //=> NaN
	     *
	     *      var clock = R.mathMod(R.__, 12);
	     *      clock(15); //=> 3
	     *      clock(24); //=> 0
	     *
	     *      var seventeenMod = R.mathMod(17);
	     *      seventeenMod(3);  //=> 2
	     *      seventeenMod(4);  //=> 1
	     *      seventeenMod(10); //=> 7
	     */
	    var mathMod = _curry2(function mathMod(m, p) {
	        if (!_isInteger(m)) {
	            return NaN;
	        }
	        if (!_isInteger(p) || p < 1) {
	            return NaN;
	        }
	        return (m % p + p) % p;
	    });

	    /**
	     * Returns the larger of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.maxBy, R.min
	     * @example
	     *
	     *      R.max(789, 123); //=> 789
	     *      R.max('a', 'b'); //=> 'b'
	     */
	    var max = _curry2(function max(a, b) {
	        return b > a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * larger result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.max, R.minBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.maxBy(square, -3, 2); //=> -3
	     *
	     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
	     *      R.reduce(R.maxBy(square), 0, []); //=> 0
	     */
	    var maxBy = _curry3(function maxBy(f, a, b) {
	        return f(b) > f(a) ? b : a;
	    });

	    /**
	     * Create a new object with the own properties of the first object merged with
	     * the own properties of the second object. If a key exists in both objects,
	     * the value from the second object will be used.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> {k: v} -> {k: v}
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.mergeWith, R.mergeWithKey
	     * @example
	     *
	     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	     *      //=> { 'name': 'fred', 'age': 40 }
	     *
	     *      var resetToDefault = R.merge(R.__, {x: 0});
	     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	     */
	    var merge = _curry2(function merge(l, r) {
	        return _assign({}, l, r);
	    });

	    /**
	     * Merges a list of objects together into one object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig [{k: v}] -> {k: v}
	     * @param {Array} list An array of objects
	     * @return {Object} A merged object.
	     * @see R.reduce
	     * @example
	     *
	     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	     */
	    var mergeAll = _curry1(function mergeAll(list) {
	        return _assign.apply(null, [{}].concat(list));
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the key
	     * and the values associated with the key in each object, with the result being
	     * used as the value associated with the key in the returned object. The key
	     * will be excluded from the returned object if the resulting value is
	     * `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Object
	     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWith
	     * @example
	     *
	     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	     *      R.mergeWithKey(concatValues,
	     *                     { a: true, thing: 'foo', values: [10, 20] },
	     *                     { b: true, thing: 'bar', values: [15, 35] });
	     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
	     */
	    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
	        var result = {};
	        var k;
	        for (k in l) {
	            if (_has(k, l)) {
	                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
	            }
	        }
	        for (k in r) {
	            if (_has(k, r) && !_has(k, result)) {
	                result[k] = r[k];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the smaller of its two arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord a => a -> a -> a
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.minBy, R.max
	     * @example
	     *
	     *      R.min(789, 123); //=> 123
	     *      R.min('a', 'b'); //=> 'a'
	     */
	    var min = _curry2(function min(a, b) {
	        return b < a ? b : a;
	    });

	    /**
	     * Takes a function and two values, and returns whichever value produces the
	     * smaller result when passed to the provided function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> a -> a -> a
	     * @param {Function} f
	     * @param {*} a
	     * @param {*} b
	     * @return {*}
	     * @see R.min, R.maxBy
	     * @example
	     *
	     *      //  square :: Number -> Number
	     *      var square = n => n * n;
	     *
	     *      R.minBy(square, -3, 2); //=> 2
	     *
	     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
	     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
	     */
	    var minBy = _curry3(function minBy(f, a, b) {
	        return f(b) < f(a) ? b : a;
	    });

	    /**
	     * Divides the first parameter by the second and returns the remainder. Note
	     * that this function preserves the JavaScript-style behavior for modulo. For
	     * mathematical modulo see `mathMod`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The value to the divide.
	     * @param {Number} b The pseudo-modulus
	     * @return {Number} The result of `b % a`.
	     * @see R.mathMod
	     * @example
	     *
	     *      R.modulo(17, 3); //=> 2
	     *      // JS behavior:
	     *      R.modulo(-17, 3); //=> -2
	     *      R.modulo(17, -3); //=> 2
	     *
	     *      var isOdd = R.modulo(R.__, 2);
	     *      isOdd(42); //=> 0
	     *      isOdd(21); //=> 1
	     */
	    var modulo = _curry2(function modulo(a, b) {
	        return a % b;
	    });

	    /**
	     * Multiplies two numbers. Equivalent to `a * b` but curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a * b`.
	     * @see R.divide
	     * @example
	     *
	     *      var double = R.multiply(2);
	     *      var triple = R.multiply(3);
	     *      double(3);       //=>  6
	     *      triple(4);       //=> 12
	     *      R.multiply(2, 5);  //=> 10
	     */
	    var multiply = _curry2(function multiply(a, b) {
	        return a * b;
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly `n` parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> (* -> a) -> (* -> a)
	     * @param {Number} n The desired arity of the new function.
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity `n`.
	     * @example
	     *
	     *      var takesTwoArgs = (a, b) => [a, b];
	     *
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.nAry(1, takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only `n` arguments are passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var nAry = _curry2(function nAry(n, fn) {
	        switch (n) {
	        case 0:
	            return function () {
	                return fn.call(this);
	            };
	        case 1:
	            return function (a0) {
	                return fn.call(this, a0);
	            };
	        case 2:
	            return function (a0, a1) {
	                return fn.call(this, a0, a1);
	            };
	        case 3:
	            return function (a0, a1, a2) {
	                return fn.call(this, a0, a1, a2);
	            };
	        case 4:
	            return function (a0, a1, a2, a3) {
	                return fn.call(this, a0, a1, a2, a3);
	            };
	        case 5:
	            return function (a0, a1, a2, a3, a4) {
	                return fn.call(this, a0, a1, a2, a3, a4);
	            };
	        case 6:
	            return function (a0, a1, a2, a3, a4, a5) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5);
	            };
	        case 7:
	            return function (a0, a1, a2, a3, a4, a5, a6) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	            };
	        case 8:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	            };
	        case 9:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	            };
	        case 10:
	            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	            };
	        default:
	            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	        }
	    });

	    /**
	     * Negates its argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Math
	     * @sig Number -> Number
	     * @param {Number} n
	     * @return {Number}
	     * @example
	     *
	     *      R.negate(42); //=> -42
	     */
	    var negate = _curry1(function negate(n) {
	        return -n;
	    });

	    /**
	     * Returns `true` if no elements of the list match the predicate, `false`
	     * otherwise.
	     *
	     * Dispatches to the `any` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> Boolean
	     * @param {Function} fn The predicate function.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	     * @see R.all, R.any
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
	     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
	     */
	    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

	    /**
	     * A function that returns the `!` of its argument. It will return `true` when
	     * passed false-y value, and `false` when passed a truth-y one.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> Boolean
	     * @param {*} a any value
	     * @return {Boolean} the logical inverse of passed argument.
	     * @see R.complement
	     * @example
	     *
	     *      R.not(true); //=> false
	     *      R.not(false); //=> true
	     *      R.not(0); //=> true
	     *      R.not(1); //=> false
	     */
	    var not = _curry1(function not(a) {
	        return !a;
	    });

	    /**
	     * Returns the nth element of the given list or string. If n is negative the
	     * element at index length + n is returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> a | Undefined
	     * @sig Number -> String -> String
	     * @param {Number} offset
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      var list = ['foo', 'bar', 'baz', 'quux'];
	     *      R.nth(1, list); //=> 'bar'
	     *      R.nth(-1, list); //=> 'quux'
	     *      R.nth(-99, list); //=> undefined
	     *
	     *      R.nth(2, 'abc'); //=> 'c'
	     *      R.nth(3, 'abc'); //=> ''
	     */
	    var nth = _curry2(function nth(offset, list) {
	        var idx = offset < 0 ? list.length + offset : offset;
	        return _isString(list) ? list.charAt(idx) : list[idx];
	    });

	    /**
	     * Returns a function which returns its nth argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig Number -> *... -> *
	     * @param {Number} n
	     * @return {Function}
	     * @example
	     *
	     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	     */
	    var nthArg = _curry1(function nthArg(n) {
	        var arity = n < 0 ? 1 : n + 1;
	        return curryN(arity, function () {
	            return nth(n, arguments);
	        });
	    });

	    /**
	     * Creates an object containing a single key:value pair.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig String -> a -> {String:a}
	     * @param {String} key
	     * @param {*} val
	     * @return {Object}
	     * @see R.pair
	     * @example
	     *
	     *      var matchPhrases = R.compose(
	     *        R.objOf('must'),
	     *        R.map(R.objOf('match_phrase'))
	     *      );
	     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	     */
	    var objOf = _curry2(function objOf(key, val) {
	        var obj = {};
	        obj[key] = val;
	        return obj;
	    });

	    /**
	     * Returns a singleton array containing the value provided.
	     *
	     * Note this `of` is different from the ES6 `of`; See
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig a -> [a]
	     * @param {*} x any value
	     * @return {Array} An array wrapping `x`.
	     * @example
	     *
	     *      R.of(null); //=> [null]
	     *      R.of([42]); //=> [[42]]
	     */
	    var of = _curry1(_of);

	    /**
	     * Accepts a function `fn` and returns a function that guards invocation of
	     * `fn` such that `fn` can only ever be called once, no matter how many times
	     * the returned function is invoked. The first value calculated is returned in
	     * subsequent invocations.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> (a... -> b)
	     * @param {Function} fn The function to wrap in a call-only-once wrapper.
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      var addOneOnce = R.once(x => x + 1);
	     *      addOneOnce(10); //=> 11
	     *      addOneOnce(addOneOnce(50)); //=> 11
	     */
	    var once = _curry1(function once(fn) {
	        var called = false;
	        var result;
	        return _arity(fn.length, function () {
	            if (called) {
	                return result;
	            }
	            called = true;
	            result = fn.apply(this, arguments);
	            return result;
	        });
	    });

	    /**
	     * Returns `true` if one or both of its arguments are `true`. Returns `false`
	     * if both arguments are `false`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig * -> * -> *
	     * @param {Boolean} a A boolean value
	     * @param {Boolean} b A boolean value
	     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
	     * @see R.either
	     * @example
	     *
	     *      R.or(true, true); //=> true
	     *      R.or(true, false); //=> true
	     *      R.or(false, true); //=> true
	     *      R.or(false, false); //=> false
	     */
	    var or = _curry2(function or(a, b) {
	        return a || b;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the result of applying the given function to
	     * the focused value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> (a -> a) -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	     */
	    // `Identity` is a functor that holds a single value, where `map` simply
	    // transforms the held value with the provided function.
	    // The value returned by the getter function is first transformed with `f`,
	    // then set as the value of an `Identity`. This is then mapped over with the
	    // setter function of the lens.
	    var over = function () {
	        // `Identity` is a functor that holds a single value, where `map` simply
	        // transforms the held value with the provided function.
	        var Identity = function (x) {
	            return {
	                value: x,
	                map: function (f) {
	                    return Identity(f(x));
	                }
	            };
	        };
	        return _curry3(function over(lens, f, x) {
	            // The value returned by the getter function is first transformed with `f`,
	            // then set as the value of an `Identity`. This is then mapped over with the
	            // setter function of the lens.
	            return lens(function (y) {
	                return Identity(f(y));
	            })(x).value;
	        });
	    }();

	    /**
	     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category List
	     * @sig a -> b -> (a,b)
	     * @param {*} fst
	     * @param {*} snd
	     * @return {Array}
	     * @see R.objOf, R.of
	     * @example
	     *
	     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
	     */
	    var pair = _curry2(function pair(fst, snd) {
	        return [
	            fst,
	            snd
	        ];
	    });

	    /**
	     * Retrieve the value at a given path.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig [String] -> {k: v} -> v | Undefined
	     * @param {Array} path The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path`.
	     * @see R.prop
	     * @example
	     *
	     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	     */
	    var path = _curry2(function path(paths, obj) {
	        var val = obj;
	        var idx = 0;
	        while (idx < paths.length) {
	            if (val == null) {
	                return;
	            }
	            val = val[paths[idx]];
	            idx += 1;
	        }
	        return val;
	    });

	    /**
	     * If the given, non-null object has a value at the given path, returns the
	     * value at that path. Otherwise returns the provided default value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Object
	     * @sig a -> [String] -> Object -> a
	     * @param {*} d The default value.
	     * @param {Array} p The path to use.
	     * @param {Object} obj The object to retrieve the nested property from.
	     * @return {*} The data at `path` of the supplied object or the default value.
	     * @example
	     *
	     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
	     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
	     */
	    var pathOr = _curry3(function pathOr(d, p, obj) {
	        return defaultTo(d, path(p, obj));
	    });

	    /**
	     * Returns `true` if the specified object property at given path satisfies the
	     * given predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Logic
	     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
	     * @param {Function} pred
	     * @param {Array} propPath
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propSatisfies, R.path
	     * @example
	     *
	     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
	     */
	    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
	        return propPath.length > 0 && pred(path(propPath, obj));
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys specified. If
	     * the key does not exist, the property is ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.omit, R.props
	     * @example
	     *
	     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	     */
	    var pick = _curry2(function pick(names, obj) {
	        var result = {};
	        var idx = 0;
	        while (idx < names.length) {
	            if (names[idx] in obj) {
	                result[names[idx]] = obj[names[idx]];
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Similar to `pick` except that this one includes a `key: undefined` pair for
	     * properties that don't exist.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> {k: v}
	     * @param {Array} names an array of String property names to copy onto a new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties from `names` on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	     */
	    var pickAll = _curry2(function pickAll(names, obj) {
	        var result = {};
	        var idx = 0;
	        var len = names.length;
	        while (idx < len) {
	            var name = names[idx];
	            result[name] = obj[name];
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a partial copy of an object containing only the keys that satisfy
	     * the supplied predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
	     * @param {Function} pred A predicate to determine whether or not a key
	     *        should be included on the output object.
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with only properties that satisfy `pred`
	     *         on it.
	     * @see R.pick, R.filter
	     * @example
	     *
	     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	     */
	    var pickBy = _curry2(function pickBy(test, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (test(obj[prop], prop, obj)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns a new list with the given element at the front, followed by the
	     * contents of the list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> [a]
	     * @param {*} el The item to add to the head of the output list.
	     * @param {Array} list The array to add to the tail of the output list.
	     * @return {Array} A new array.
	     * @see R.append
	     * @example
	     *
	     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	     */
	    var prepend = _curry2(function prepend(el, list) {
	        return _concat([el], list);
	    });

	    /**
	     * Returns a function that when supplied an object returns the indicated
	     * property of that object, if it exists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig s -> {s: a} -> a | Undefined
	     * @param {String} p The property name
	     * @param {Object} obj The object to query
	     * @return {*} The value at `obj.p`.
	     * @see R.path
	     * @example
	     *
	     *      R.prop('x', {x: 100}); //=> 100
	     *      R.prop('x', {}); //=> undefined
	     */
	    var prop = _curry2(function prop(p, obj) {
	        return obj[p];
	    });

	    /**
	     * Returns `true` if the specified object property is of the given type;
	     * `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Type
	     * @sig Type -> String -> Object -> Boolean
	     * @param {Function} type
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.is, R.propSatisfies
	     * @example
	     *
	     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	     *      R.propIs(Number, 'x', {});            //=> false
	     */
	    var propIs = _curry3(function propIs(type, name, obj) {
	        return is(type, obj[name]);
	    });

	    /**
	     * If the given, non-null object has an own property with the specified name,
	     * returns the value of that property. Otherwise returns the provided default
	     * value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Object
	     * @sig a -> String -> Object -> a
	     * @param {*} val The default value.
	     * @param {String} p The name of the property to return.
	     * @param {Object} obj The object to query.
	     * @return {*} The value of given property of the supplied object or the default value.
	     * @example
	     *
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var favorite = R.prop('favoriteLibrary');
	     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	     *
	     *      favorite(alice);  //=> undefined
	     *      favoriteWithDefault(alice);  //=> 'Ramda'
	     */
	    var propOr = _curry3(function propOr(val, p, obj) {
	        return obj != null && _has(p, obj) ? obj[p] : val;
	    });

	    /**
	     * Returns `true` if the specified object property satisfies the given
	     * predicate; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Logic
	     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	     * @param {Function} pred
	     * @param {String} name
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.propEq, R.propIs
	     * @example
	     *
	     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	     */
	    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
	        return pred(obj[name]);
	    });

	    /**
	     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [k] -> {k: v} -> [v]
	     * @param {Array} ps The property names to fetch
	     * @param {Object} obj The object to query
	     * @return {Array} The corresponding values or partially applied function.
	     * @example
	     *
	     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	     *
	     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	     */
	    var props = _curry2(function props(ps, obj) {
	        var len = ps.length;
	        var out = [];
	        var idx = 0;
	        while (idx < len) {
	            out[idx] = obj[ps[idx]];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> Number -> [Number]
	     * @param {Number} from The first number in the list.
	     * @param {Number} to One more than the last number in the list.
	     * @return {Array} The list of numbers in tthe set `[a, b)`.
	     * @example
	     *
	     *      R.range(1, 5);    //=> [1, 2, 3, 4]
	     *      R.range(50, 53);  //=> [50, 51, 52]
	     */
	    var range = _curry2(function range(from, to) {
	        if (!(_isNumber(from) && _isNumber(to))) {
	            throw new TypeError('Both arguments to range must be numbers');
	        }
	        var result = [];
	        var n = from;
	        while (n < to) {
	            result.push(n);
	            n += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * Similar to `reduce`, except moves through the input list from the right to
	     * the left.
	     *
	     * The iterator function receives two values: *(acc, value)*
	     *
	     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.addIndex
	     * @example
	     *
	     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
	     *      var flattenPairs = (acc, pair) => acc.concat(pair);
	     *
	     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
	     */
	    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
	        var idx = list.length - 1;
	        while (idx >= 0) {
	            acc = fn(acc, list[idx]);
	            idx -= 1;
	        }
	        return acc;
	    });

	    /**
	     * Returns a value wrapped to indicate that it is the final value of the reduce
	     * and transduce functions. The returned value should be considered a black
	     * box: the internal structure is not guaranteed to be stable.
	     *
	     * Note: this optimization is unavailable to functions not explicitly listed
	     * above. For instance, it is not currently supported by reduceRight.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category List
	     * @sig a -> *
	     * @param {*} x The final value of the reduce.
	     * @return {*} The wrapped value.
	     * @see R.reduce, R.transduce
	     * @example
	     *
	     *      R.reduce(
	     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
	     *        0,
	     *        [1, 2, 3, 4, 5]) // 10
	     */
	    var reduced = _curry1(_reduced);

	    /**
	     * Removes the sub-list of `list` starting at index `start` and containing
	     * `count` elements. _Note that this is not destructive_: it returns a copy of
	     * the list with the changes.
	     * <small>No lists have been harmed in the application of this function.</small>
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.2
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @param {Number} start The position to start removing elements
	     * @param {Number} count The number of elements to remove
	     * @param {Array} list The list to remove from
	     * @return {Array} A new Array with `count` elements from `start` removed.
	     * @example
	     *
	     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	     */
	    var remove = _curry3(function remove(start, count, list) {
	        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
	    });

	    /**
	     * Replace a substring or regex match in a string with a replacement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category String
	     * @sig RegExp|String -> String -> String -> String
	     * @param {RegExp|String} pattern A regular expression or a substring to match.
	     * @param {String} replacement The string to replace the matches with.
	     * @param {String} str The String to do the search and replacement in.
	     * @return {String} The result.
	     * @example
	     *
	     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	     *
	     *      // Use the "g" (global) flag to replace all occurrences:
	     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	     */
	    var replace = _curry3(function replace(regex, replacement, str) {
	        return str.replace(regex, replacement);
	    });

	    /**
	     * Returns a new list or string with the elements or characters in reverse
	     * order.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {Array|String}
	     * @example
	     *
	     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	     *      R.reverse([1, 2]);     //=> [2, 1]
	     *      R.reverse([1]);        //=> [1]
	     *      R.reverse([]);         //=> []
	     *
	     *      R.reverse('abc');      //=> 'cba'
	     *      R.reverse('ab');       //=> 'ba'
	     *      R.reverse('a');        //=> 'a'
	     *      R.reverse('');         //=> ''
	     */
	    var reverse = _curry1(function reverse(list) {
	        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
	    });

	    /**
	     * Scan is similar to reduce, but returns a list of successively reduced values
	     * from the left
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a,b -> a) -> a -> [b] -> [a]
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {Array} A list of all intermediately reduced values.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	     */
	    var scan = _curry3(function scan(fn, acc, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [acc];
	        while (idx < len) {
	            acc = fn(acc, list[idx]);
	            result[idx + 1] = acc;
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns the result of "setting" the portion of the given data structure
	     * focused by the given lens to the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> a -> s -> s
	     * @param {Lens} lens
	     * @param {*} v
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	     */
	    var set = _curry3(function set(lens, v, x) {
	        return over(lens, always(v), x);
	    });

	    /**
	     * Returns the elements of the given list or string (or object with a `slice`
	     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	     *
	     * Dispatches to the `slice` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Number -> Number -> [a] -> [a]
	     * @sig Number -> Number -> String -> String
	     * @param {Number} fromIndex The start index (inclusive).
	     * @param {Number} toIndex The end index (exclusive).
	     * @param {*} list
	     * @return {*}
	     * @example
	     *
	     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	     */
	    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	        return Array.prototype.slice.call(list, fromIndex, toIndex);
	    }));

	    /**
	     * Returns a copy of the list, sorted according to the comparator function,
	     * which should accept two values at a time and return a negative number if the
	     * first value is smaller, a positive number if it's larger, and zero if they
	     * are equal. Please note that this is a **copy** of the list. It does not
	     * modify the original.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,a -> Number) -> [a] -> [a]
	     * @param {Function} comparator A sorting function :: a -> b -> Int
	     * @param {Array} list The list to sort
	     * @return {Array} a new array with its elements sorted by the comparator function.
	     * @example
	     *
	     *      var diff = function(a, b) { return a - b; };
	     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	     */
	    var sort = _curry2(function sort(comparator, list) {
	        return _slice(list).sort(comparator);
	    });

	    /**
	     * Sorts the list according to the supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig Ord b => (a -> b) -> [a] -> [a]
	     * @param {Function} fn
	     * @param {Array} list The list to sort.
	     * @return {Array} A new list sorted by the keys generated by `fn`.
	     * @example
	     *
	     *      var sortByFirstItem = R.sortBy(R.prop(0));
	     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	     *      var alice = {
	     *        name: 'ALICE',
	     *        age: 101
	     *      };
	     *      var bob = {
	     *        name: 'Bob',
	     *        age: -10
	     *      };
	     *      var clara = {
	     *        name: 'clara',
	     *        age: 314.159
	     *      };
	     *      var people = [clara, bob, alice];
	     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	     */
	    var sortBy = _curry2(function sortBy(fn, list) {
	        return _slice(list).sort(function (a, b) {
	            var aa = fn(a);
	            var bb = fn(b);
	            return aa < bb ? -1 : aa > bb ? 1 : 0;
	        });
	    });

	    /**
	     * Splits a given list or string at a given index.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig Number -> [a] -> [[a], [a]]
	     * @sig Number -> String -> [String, String]
	     * @param {Number} index The index where the array/string is split.
	     * @param {Array|String} array The array/string to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
	     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
	     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
	     */
	    var splitAt = _curry2(function splitAt(index, array) {
	        return [
	            slice(0, index, array),
	            slice(index, length(array), array)
	        ];
	    });

	    /**
	     * Splits a collection into slices of the specified length.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [[a]]
	     * @sig Number -> String -> [String]
	     * @param {Number} n
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	     */
	    var splitEvery = _curry2(function splitEvery(n, list) {
	        if (n <= 0) {
	            throw new Error('First argument to splitEvery must be a positive integer');
	        }
	        var result = [];
	        var idx = 0;
	        while (idx < list.length) {
	            result.push(slice(idx, idx += n, list));
	        }
	        return result;
	    });

	    /**
	     * Takes a list and a predicate and returns a pair of lists with the following properties:
	     *
	     *  - the result of concatenating the two output lists is equivalent to the input list;
	     *  - none of the elements of the first output list satisfies the predicate; and
	     *  - if the second output list is non-empty, its first element satisfies the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
	     * @param {Function} pred The predicate that determines where the array is split.
	     * @param {Array} list The array to be split.
	     * @return {Array}
	     * @example
	     *
	     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
	     */
	    var splitWhen = _curry2(function splitWhen(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var prefix = [];
	        while (idx < len && !pred(list[idx])) {
	            prefix.push(list[idx]);
	            idx += 1;
	        }
	        return [
	            prefix,
	            _slice(list, idx)
	        ];
	    });

	    /**
	     * Subtracts its second argument from its first argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig Number -> Number -> Number
	     * @param {Number} a The first value.
	     * @param {Number} b The second value.
	     * @return {Number} The result of `a - b`.
	     * @see R.add
	     * @example
	     *
	     *      R.subtract(10, 8); //=> 2
	     *
	     *      var minus5 = R.subtract(R.__, 5);
	     *      minus5(17); //=> 12
	     *
	     *      var complementaryAngle = R.subtract(90);
	     *      complementaryAngle(30); //=> 60
	     *      complementaryAngle(72); //=> 18
	     */
	    var subtract = _curry2(function subtract(a, b) {
	        return Number(a) - Number(b);
	    });

	    /**
	     * Returns all but the first element of the given list or string (or object
	     * with a `tail` method).
	     *
	     * Dispatches to the `slice` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.head, R.init, R.last
	     * @example
	     *
	     *      R.tail([1, 2, 3]);  //=> [2, 3]
	     *      R.tail([1, 2]);     //=> [2]
	     *      R.tail([1]);        //=> []
	     *      R.tail([]);         //=> []
	     *
	     *      R.tail('abc');  //=> 'bc'
	     *      R.tail('ab');   //=> 'b'
	     *      R.tail('a');    //=> ''
	     *      R.tail('');     //=> ''
	     */
	    var tail = _checkForMethod('tail', slice(1, Infinity));

	    /**
	     * Returns the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `take` method).
	     *
	     * Dispatches to the `take` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.drop
	     * @example
	     *
	     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.take(3, 'ramda');               //=> 'ram'
	     *
	     *      var personnel = [
	     *        'Dave Brubeck',
	     *        'Paul Desmond',
	     *        'Eugene Wright',
	     *        'Joe Morello',
	     *        'Gerry Mulligan',
	     *        'Bob Bates',
	     *        'Joe Dodge',
	     *        'Ron Crotty'
	     *      ];
	     *
	     *      var takeFive = R.take(5);
	     *      takeFive(personnel);
	     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	     */
	    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
	        return slice(0, n < 0 ? Infinity : n, xs);
	    }));

	    /**
	     * Returns a new list containing the last `n` elements of a given list, passing
	     * each value to the supplied predicate function, and terminating when the
	     * predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropLastWhile, R.addIndex
	     * @example
	     *
	     *      var isNotOne = x => x !== 1;
	     *
	     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	     */
	    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
	        var idx = list.length - 1;
	        while (idx >= 0 && fn(list[idx])) {
	            idx -= 1;
	        }
	        return _slice(list, idx + 1, Infinity);
	    });

	    /**
	     * Returns a new list containing the first `n` elements of a given list,
	     * passing each value to the supplied predicate function, and terminating when
	     * the predicate function returns `false`. Excludes the element that caused the
	     * predicate function to fail. The predicate function is passed one argument:
	     * *(value)*.
	     *
	     * Dispatches to the `takeWhile` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.dropWhile, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isNotFour = x => x !== 4;
	     *
	     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
	     */
	    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
	        var idx = 0;
	        var len = list.length;
	        while (idx < len && fn(list[idx])) {
	            idx += 1;
	        }
	        return _slice(list, 0, idx);
	    }));

	    /**
	     * Runs the given function with the supplied object, then returns the object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> *) -> a -> a
	     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	     * @param {*} x
	     * @return {*} `x`.
	     * @example
	     *
	     *      var sayX = x => console.log('x is ' + x);
	     *      R.tap(sayX, 100); //=> 100
	     *      // logs 'x is 100'
	     */
	    var tap = _curry2(function tap(fn, x) {
	        fn(x);
	        return x;
	    });

	    /**
	     * Calls an input function `n` times, returning an array containing the results
	     * of those function calls.
	     *
	     * `fn` is passed one argument: The current value of `n`, which begins at `0`
	     * and is gradually incremented to `n - 1`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.3
	     * @category List
	     * @sig (Number -> a) -> Number -> [a]
	     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	     * @return {Array} An array containing the return values of all calls to `fn`.
	     * @example
	     *
	     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	     */
	    var times = _curry2(function times(fn, n) {
	        var len = Number(n);
	        var idx = 0;
	        var list;
	        if (len < 0 || isNaN(len)) {
	            throw new RangeError('n must be a non-negative number');
	        }
	        list = new Array(len);
	        while (idx < len) {
	            list[idx] = fn(idx);
	            idx += 1;
	        }
	        return list;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. Only the object's
	     * own properties are used.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own properties.
	     * @see R.fromPairs
	     * @example
	     *
	     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	     */
	    var toPairs = _curry1(function toPairs(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            if (_has(prop, obj)) {
	                pairs[pairs.length] = [
	                    prop,
	                    obj[prop]
	                ];
	            }
	        }
	        return pairs;
	    });

	    /**
	     * Converts an object into an array of key, value arrays. The object's own
	     * properties and prototype properties are used. Note that the order of the
	     * output array is not guaranteed to be consistent across different JS
	     * platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Object
	     * @sig {String: *} -> [[String,*]]
	     * @param {Object} obj The object to extract from
	     * @return {Array} An array of key, value arrays from the object's own
	     *         and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	     */
	    var toPairsIn = _curry1(function toPairsIn(obj) {
	        var pairs = [];
	        for (var prop in obj) {
	            pairs[pairs.length] = [
	                prop,
	                obj[prop]
	            ];
	        }
	        return pairs;
	    });

	    /**
	     * Transposes the rows and columns of a 2D list.
	     * When passed a list of `n` lists of length `x`,
	     * returns a list of `x` lists of length `n`.
	     *
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig [[a]] -> [[a]]
	     * @param {Array} list A 2D list
	     * @return {Array} A 2D list
	     * @example
	     *
	     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
	     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     *
	     * If some of the rows are shorter than the following rows, their elements are skipped:
	     *
	     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
	     */
	    var transpose = _curry1(function transpose(outerlist) {
	        var i = 0;
	        var result = [];
	        while (i < outerlist.length) {
	            var innerlist = outerlist[i];
	            var j = 0;
	            while (j < innerlist.length) {
	                if (typeof result[j] === 'undefined') {
	                    result[j] = [];
	                }
	                result[j].push(innerlist[j]);
	                j += 1;
	            }
	            i += 1;
	        }
	        return result;
	    });

	    /**
	     * Removes (strips) whitespace from both ends of the string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to trim.
	     * @return {String} Trimmed version of `str`.
	     * @example
	     *
	     *      R.trim('   xyz  '); //=> 'xyz'
	     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	     */
	    var trim = function () {
	        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	        var zeroWidth = '\u200B';
	        var hasProtoTrim = typeof String.prototype.trim === 'function';
	        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
	            return _curry1(function trim(str) {
	                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	                return str.replace(beginRx, '').replace(endRx, '');
	            });
	        } else {
	            return _curry1(function trim(str) {
	                return str.trim();
	            });
	        }
	    }();

	    /**
	     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
	     * function evaluates the `tryer`; if it does not throw, it simply returns the
	     * result. If the `tryer` *does* throw, the returned function evaluates the
	     * `catcher` function and returns its result. Note that for effective
	     * composition with this function, both the `tryer` and `catcher` functions
	     * must return the same type of results.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.20.0
	     * @category Function
	     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
	     * @param {Function} tryer The function that may throw.
	     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
	     * @return {Function} A new function that will catch exceptions and send then to the catcher.
	     * @example
	     *
	     *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
	     *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
	     */
	    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
	        return _arity(tryer.length, function () {
	            try {
	                return tryer.apply(this, arguments);
	            } catch (e) {
	                return catcher.apply(this, _concat([e], arguments));
	            }
	        });
	    });

	    /**
	     * Gives a single-word string description of the (native) type of a value,
	     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	     * attempt to distinguish user Object types any further, reporting them all as
	     * 'Object'.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Type
	     * @sig (* -> {*}) -> String
	     * @param {*} val The value to test
	     * @return {String}
	     * @example
	     *
	     *      R.type({}); //=> "Object"
	     *      R.type(1); //=> "Number"
	     *      R.type(false); //=> "Boolean"
	     *      R.type('s'); //=> "String"
	     *      R.type(null); //=> "Null"
	     *      R.type([]); //=> "Array"
	     *      R.type(/[A-z]/); //=> "RegExp"
	     */
	    var type = _curry1(function type(val) {
	        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	    });

	    /**
	     * Takes a function `fn`, which takes a single array argument, and returns a
	     * function which:
	     *
	     *   - takes any number of positional arguments;
	     *   - passes these arguments to `fn` as an array; and
	     *   - returns the result.
	     *
	     * In other words, R.unapply derives a variadic function from a function which
	     * takes an array. R.unapply is the inverse of R.apply.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Function
	     * @sig ([*...] -> a) -> (*... -> a)
	     * @param {Function} fn
	     * @return {Function}
	     * @see R.apply
	     * @example
	     *
	     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	     */
	    var unapply = _curry1(function unapply(fn) {
	        return function () {
	            return fn(_slice(arguments));
	        };
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 1 parameter. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> b) -> (a -> b)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 1.
	     * @example
	     *
	     *      var takesTwoArgs = function(a, b) {
	     *        return [a, b];
	     *      };
	     *      takesTwoArgs.length; //=> 2
	     *      takesTwoArgs(1, 2); //=> [1, 2]
	     *
	     *      var takesOneArg = R.unary(takesTwoArgs);
	     *      takesOneArg.length; //=> 1
	     *      // Only 1 argument is passed to the wrapped function
	     *      takesOneArg(1, 2); //=> [1, undefined]
	     */
	    var unary = _curry1(function unary(fn) {
	        return nAry(1, fn);
	    });

	    /**
	     * Returns a function of arity `n` from a (manually) curried function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Function
	     * @sig Number -> (a -> b) -> (a -> c)
	     * @param {Number} length The arity for the returned function.
	     * @param {Function} fn The function to uncurry.
	     * @return {Function} A new function.
	     * @see R.curry
	     * @example
	     *
	     *      var addFour = a => b => c => d => a + b + c + d;
	     *
	     *      var uncurriedAddFour = R.uncurryN(4, addFour);
	     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
	     */
	    var uncurryN = _curry2(function uncurryN(depth, fn) {
	        return curryN(depth, function () {
	            var currentDepth = 1;
	            var value = fn;
	            var idx = 0;
	            var endIdx;
	            while (currentDepth <= depth && typeof value === 'function') {
	                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	                value = value.apply(this, _slice(arguments, idx, endIdx));
	                currentDepth += 1;
	                idx = endIdx;
	            }
	            return value;
	        });
	    });

	    /**
	     * Builds a list from a seed value. Accepts an iterator function, which returns
	     * either false to stop iteration or an array of length 2 containing the value
	     * to add to the resulting list and the seed to be used in the next call to the
	     * iterator function.
	     *
	     * The iterator function receives one argument: *(seed)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category List
	     * @sig (a -> [b]) -> * -> [b]
	     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	     *        either false to quit iteration or an array of length two to proceed. The element
	     *        at index 0 of this array will be added to the resulting array, and the element
	     *        at index 1 will be passed to the next call to `fn`.
	     * @param {*} seed The seed value.
	     * @return {Array} The final list.
	     * @example
	     *
	     *      var f = n => n > 50 ? false : [-n, n + 10];
	     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	     */
	    var unfold = _curry2(function unfold(fn, seed) {
	        var pair = fn(seed);
	        var result = [];
	        while (pair && pair.length) {
	            result[result.length] = pair[0];
	            pair = fn(pair[1]);
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied predicate to
	     * two list elements. Prefers the first item if two items compare equal based
	     * on the predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      var strEq = R.eqBy(String);
	     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	     */
	    var uniqWith = _curry2(function uniqWith(pred, list) {
	        var idx = 0;
	        var len = list.length;
	        var result = [];
	        var item;
	        while (idx < len) {
	            item = list[idx];
	            if (!_containsWith(pred, item, result)) {
	                result[result.length] = item;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is not satisfied, the function will return the result of
	     * calling the `whenFalseFn` function with the same argument. If the predicate
	     * is satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred        A predicate function
	     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
	     *                               to a falsy value.
	     * @param {*}        x           An object to test with the `pred` function and
	     *                               pass to `whenFalseFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
	     * @see R.ifElse, R.when
	     * @example
	     *
	     *      // coerceArray :: (a|[a]) -> [a]
	     *      var coerceArray = R.unless(R.isArrayLike, R.of);
	     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
	     *      coerceArray(1);         //=> [1]
	     */
	    var unless = _curry3(function unless(pred, whenFalseFn, x) {
	        return pred(x) ? x : whenFalseFn(x);
	    });

	    /**
	     * Takes a predicate, a transformation function, and an initial value,
	     * and returns a value of the same type as the initial value.
	     * It does so by applying the transformation until the predicate is satisfied,
	     * at which point it returns the satisfactory value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.20.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred A predicate function
	     * @param {Function} fn The iterator function
	     * @param {*} init Initial value
	     * @return {*} Final value that satisfies predicate
	     * @example
	     *
	     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
	     */
	    var until = _curry3(function until(pred, fn, init) {
	        var val = init;
	        while (!pred(val)) {
	            val = fn(val);
	        }
	        return val;
	    });

	    /**
	     * Returns a new copy of the array with the element at the provided index
	     * replaced with the given value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig Number -> a -> [a] -> [a]
	     * @param {Number} idx The index to update.
	     * @param {*} x The value to exist at the given index of the returned array.
	     * @param {Array|Arguments} list The source array-like object to be updated.
	     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	     * @see R.adjust
	     * @example
	     *
	     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	     */
	    var update = _curry3(function update(idx, x, list) {
	        return adjust(always(x), idx, list);
	    });

	    /**
	     * Accepts a function `fn` and a list of transformer functions and returns a
	     * new curried function. When the new function is invoked, it calls the
	     * function `fn` with parameters consisting of the result of calling each
	     * supplied handler on successive arguments to the new function.
	     *
	     * If more arguments are passed to the returned function than transformer
	     * functions, those arguments are passed directly to `fn` as additional
	     * parameters. If you expect additional arguments that don't need to be
	     * transformed, although you can ignore them, it's best to pass an identity
	     * function so that the new function reports the correct arity.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} fn The function to wrap.
	     * @param {Array} transformers A list of transformer functions
	     * @return {Function} The wrapped function.
	     * @example
	     *
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
	     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
	     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
	     */
	    var useWith = _curry2(function useWith(fn, transformers) {
	        return curryN(transformers.length, function () {
	            var args = [];
	            var idx = 0;
	            while (idx < transformers.length) {
	                args.push(transformers[idx].call(this, arguments[idx]));
	                idx += 1;
	            }
	            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
	        });
	    });

	    /**
	     * Returns a list of all the enumerable own properties of the supplied object.
	     * Note that the order of the output array is not guaranteed across different
	     * JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own properties.
	     * @example
	     *
	     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	     */
	    var values = _curry1(function values(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var vals = [];
	        var idx = 0;
	        while (idx < len) {
	            vals[idx] = obj[props[idx]];
	            idx += 1;
	        }
	        return vals;
	    });

	    /**
	     * Returns a list of all the properties, including prototype properties, of the
	     * supplied object.
	     * Note that the order of the output array is not guaranteed to be consistent
	     * across different JS platforms.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Object
	     * @sig {k: v} -> [v]
	     * @param {Object} obj The object to extract values from
	     * @return {Array} An array of the values of the object's own and prototype properties.
	     * @example
	     *
	     *      var F = function() { this.x = 'X'; };
	     *      F.prototype.y = 'Y';
	     *      var f = new F();
	     *      R.valuesIn(f); //=> ['X', 'Y']
	     */
	    var valuesIn = _curry1(function valuesIn(obj) {
	        var prop;
	        var vs = [];
	        for (prop in obj) {
	            vs[vs.length] = obj[prop];
	        }
	        return vs;
	    });

	    /**
	     * Returns a "view" of the given data structure, determined by the given lens.
	     * The lens's focus determines which portion of the data structure is visible.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Lens s a -> s -> a
	     * @param {Lens} lens
	     * @param {*} x
	     * @return {*}
	     * @see R.prop, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});  //=> 1
	     *      R.view(xLens, {x: 4, y: 2});  //=> 4
	     */
	    // `Const` is a functor that effectively ignores the function given to `map`.
	    // Using `Const` effectively ignores the setter function of the `lens`,
	    // leaving the value returned by the getter function unmodified.
	    var view = function () {
	        // `Const` is a functor that effectively ignores the function given to `map`.
	        var Const = function (x) {
	            return {
	                value: x,
	                map: function () {
	                    return this;
	                }
	            };
	        };
	        return _curry2(function view(lens, x) {
	            // Using `Const` effectively ignores the setter function of the `lens`,
	            // leaving the value returned by the getter function unmodified.
	            return lens(Const)(x).value;
	        });
	    }();

	    /**
	     * Tests the final argument by passing it to the given predicate function. If
	     * the predicate is satisfied, the function will return the result of calling
	     * the `whenTrueFn` function with the same argument. If the predicate is not
	     * satisfied, the argument is returned as is.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Logic
	     * @sig (a -> Boolean) -> (a -> a) -> a -> a
	     * @param {Function} pred       A predicate function
	     * @param {Function} whenTrueFn A function to invoke when the `condition`
	     *                              evaluates to a truthy value.
	     * @param {*}        x          An object to test with the `pred` function and
	     *                              pass to `whenTrueFn` if necessary.
	     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
	     * @see R.ifElse, R.unless
	     * @example
	     *
	     *      // truncate :: String -> String
	     *      var truncate = R.when(
	     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
	     *        R.pipe(R.take(10), R.append(''), R.join(''))
	     *      );
	     *      truncate('12345');         //=> '12345'
	     *      truncate('0123456789ABC'); //=> '0123456789'
	     */
	    var when = _curry3(function when(pred, whenTrueFn, x) {
	        return pred(x) ? whenTrueFn(x) : x;
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec. Each of the spec's own properties must be a predicate function.
	     * Each predicate is applied to the value of the corresponding property of the
	     * test object. `where` returns true if all the predicates return true, false
	     * otherwise.
	     *
	     * `where` is well suited to declaratively expressing constraints for other
	     * functions such as `filter` and `find`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category Object
	     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = where({
	     *        a: equals('foo'),
	     *        b: complement(equals('bar')),
	     *        x: gt(__, 10),
	     *        y: lt(__, 20)
	     *      });
	     *
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	     */
	    var where = _curry2(function where(spec, testObj) {
	        for (var prop in spec) {
	            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	                return false;
	            }
	        }
	        return true;
	    });

	    /**
	     * Wrap a function inside another to allow you to make adjustments to the
	     * parameters, or do other processing either before the internal function is
	     * called or with its results.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
	     * @param {Function} fn The function to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @return {Function} The wrapped function.
	     * @deprecated since v0.22.0
	     * @example
	     *
	     *      var greet = name => 'Hello ' + name;
	     *
	     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
	     *
	     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
	     *
	     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
	     *        return gr(name.substring(0, 3));
	     *      });
	     *      shortenedGreet("Robert"); //=> "Hello Rob"
	     */
	    var wrap = _curry2(function wrap(fn, wrapper) {
	        return curryN(fn.length, function () {
	            return wrapper.apply(this, _concat([fn], arguments));
	        });
	    });

	    /**
	     * Creates a new list out of the two supplied by creating each possible pair
	     * from the lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The list made by combining each possible pair from
	     *         `as` and `bs` into pairs (`[a, b]`).
	     * @example
	     *
	     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	     */
	    // = xprodWith(prepend); (takes about 3 times as long...)
	    var xprod = _curry2(function xprod(a, b) {
	        // = xprodWith(prepend); (takes about 3 times as long...)
	        var idx = 0;
	        var ilen = a.length;
	        var j;
	        var jlen = b.length;
	        var result = [];
	        while (idx < ilen) {
	            j = 0;
	            while (j < jlen) {
	                result[result.length] = [
	                    a[idx],
	                    b[j]
	                ];
	                j += 1;
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Creates a new list out of the two supplied by pairing up equally-positioned
	     * items from both lists. The returned list is truncated to the length of the
	     * shorter of the two input lists.
	     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b] -> [[a,b]]
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	     * @example
	     *
	     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	     */
	    var zip = _curry2(function zip(a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = [
	                a[idx],
	                b[idx]
	            ];
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * Creates a new object out of a list of keys and a list of values.
	     * Key/value pairing is truncated to the length of the shorter of the two lists.
	     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig [String] -> [*] -> {String: *}
	     * @param {Array} keys The array that will be properties on the output object.
	     * @param {Array} values The list of values on the output object.
	     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	     * @example
	     *
	     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	     */
	    var zipObj = _curry2(function zipObj(keys, values) {
	        var idx = 0;
	        var len = Math.min(keys.length, values.length);
	        var out = {};
	        while (idx < len) {
	            out[keys[idx]] = values[idx];
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Creates a new list out of the two supplied by applying the function to each
	     * equally-positioned pair in the lists. The returned list is truncated to the
	     * length of the shorter of the two input lists.
	     *
	     * @function
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a,b -> c) -> [a] -> [b] -> [c]
	     * @param {Function} fn The function used to combine the two elements into one value.
	     * @param {Array} list1 The first array to consider.
	     * @param {Array} list2 The second array to consider.
	     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	     *         using `fn`.
	     * @example
	     *
	     *      var f = (x, y) => {
	     *        // ...
	     *      };
	     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	     */
	    var zipWith = _curry3(function zipWith(fn, a, b) {
	        var rv = [];
	        var idx = 0;
	        var len = Math.min(a.length, b.length);
	        while (idx < len) {
	            rv[idx] = fn(a[idx], b[idx]);
	            idx += 1;
	        }
	        return rv;
	    });

	    /**
	     * A function that always returns `false`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.T
	     * @example
	     *
	     *      R.F(); //=> false
	     */
	    var F = always(false);

	    /**
	     * A function that always returns `true`. Any passed in parameters are ignored.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig * -> Boolean
	     * @param {*}
	     * @return {Boolean}
	     * @see R.always, R.F
	     * @example
	     *
	     *      R.T(); //=> true
	     */
	    var T = always(true);

	    /**
	     * Copies an object.
	     *
	     * @private
	     * @param {*} value The value to be copied
	     * @param {Array} refFrom Array containing the source references
	     * @param {Array} refTo Array containing the copied source references
	     * @param {Boolean} deep Whether or not to perform deep cloning.
	     * @return {*} The copied value.
	     */
	    var _clone = function _clone(value, refFrom, refTo, deep) {
	        var copy = function copy(copiedValue) {
	            var len = refFrom.length;
	            var idx = 0;
	            while (idx < len) {
	                if (value === refFrom[idx]) {
	                    return refTo[idx];
	                }
	                idx += 1;
	            }
	            refFrom[idx + 1] = value;
	            refTo[idx + 1] = copiedValue;
	            for (var key in value) {
	                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
	            }
	            return copiedValue;
	        };
	        switch (type(value)) {
	        case 'Object':
	            return copy({});
	        case 'Array':
	            return copy([]);
	        case 'Date':
	            return new Date(value.valueOf());
	        case 'RegExp':
	            return _cloneRegExp(value);
	        default:
	            return value;
	        }
	    };

	    var _createPartialApplicator = function _createPartialApplicator(concat) {
	        return _curry2(function (fn, args) {
	            return _arity(Math.max(0, fn.length - args.length), function () {
	                return fn.apply(this, concat(args, arguments));
	            });
	        });
	    };

	    var _dropLast = function dropLast(n, xs) {
	        return take(n < xs.length ? xs.length - n : 0, xs);
	    };

	    // Values of other types are only equal if identical.
	    var _equals = function _equals(a, b, stackA, stackB) {
	        if (identical(a, b)) {
	            return true;
	        }
	        if (type(a) !== type(b)) {
	            return false;
	        }
	        if (a == null || b == null) {
	            return false;
	        }
	        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	        }
	        switch (type(a)) {
	        case 'Arguments':
	        case 'Array':
	        case 'Object':
	            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
	                return a === b;
	            }
	            break;
	        case 'Boolean':
	        case 'Number':
	        case 'String':
	            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	                return false;
	            }
	            break;
	        case 'Date':
	            if (!identical(a.valueOf(), b.valueOf())) {
	                return false;
	            }
	            break;
	        case 'Error':
	            return a.name === b.name && a.message === b.message;
	        case 'RegExp':
	            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	                return false;
	            }
	            break;
	        case 'Map':
	        case 'Set':
	            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
	                return false;
	            }
	            break;
	        case 'Int8Array':
	        case 'Uint8Array':
	        case 'Uint8ClampedArray':
	        case 'Int16Array':
	        case 'Uint16Array':
	        case 'Int32Array':
	        case 'Uint32Array':
	        case 'Float32Array':
	        case 'Float64Array':
	            break;
	        case 'ArrayBuffer':
	            break;
	        default:
	            // Values of other types are only equal if identical.
	            return false;
	        }
	        var keysA = keys(a);
	        if (keysA.length !== keys(b).length) {
	            return false;
	        }
	        var idx = stackA.length - 1;
	        while (idx >= 0) {
	            if (stackA[idx] === a) {
	                return stackB[idx] === b;
	            }
	            idx -= 1;
	        }
	        stackA.push(a);
	        stackB.push(b);
	        idx = keysA.length - 1;
	        while (idx >= 0) {
	            var key = keysA[idx];
	            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
	                return false;
	            }
	            idx -= 1;
	        }
	        stackA.pop();
	        stackB.pop();
	        return true;
	    };

	    /**
	     * `_makeFlat` is a helper function that returns a one-level or fully recursive
	     * function based on the flag passed in.
	     *
	     * @private
	     */
	    var _makeFlat = function _makeFlat(recursive) {
	        return function flatt(list) {
	            var value, jlen, j;
	            var result = [];
	            var idx = 0;
	            var ilen = list.length;
	            while (idx < ilen) {
	                if (isArrayLike(list[idx])) {
	                    value = recursive ? flatt(list[idx]) : list[idx];
	                    j = 0;
	                    jlen = value.length;
	                    while (j < jlen) {
	                        result[result.length] = value[j];
	                        j += 1;
	                    }
	                } else {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	            return result;
	        };
	    };

	    var _reduce = function () {
	        function _arrayReduce(xf, acc, list) {
	            var idx = 0;
	            var len = list.length;
	            while (idx < len) {
	                acc = xf['@@transducer/step'](acc, list[idx]);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                idx += 1;
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _iterableReduce(xf, acc, iter) {
	            var step = iter.next();
	            while (!step.done) {
	                acc = xf['@@transducer/step'](acc, step.value);
	                if (acc && acc['@@transducer/reduced']) {
	                    acc = acc['@@transducer/value'];
	                    break;
	                }
	                step = iter.next();
	            }
	            return xf['@@transducer/result'](acc);
	        }
	        function _methodReduce(xf, acc, obj) {
	            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
	        }
	        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	        return function _reduce(fn, acc, list) {
	            if (typeof fn === 'function') {
	                fn = _xwrap(fn);
	            }
	            if (isArrayLike(list)) {
	                return _arrayReduce(fn, acc, list);
	            }
	            if (typeof list.reduce === 'function') {
	                return _methodReduce(fn, acc, list);
	            }
	            if (list[symIterator] != null) {
	                return _iterableReduce(fn, acc, list[symIterator]());
	            }
	            if (typeof list.next === 'function') {
	                return _iterableReduce(fn, acc, list);
	            }
	            throw new TypeError('reduce: list must be array or iterable');
	        };
	    }();

	    var _stepCat = function () {
	        var _stepCatArray = {
	            '@@transducer/init': Array,
	            '@@transducer/step': function (xs, x) {
	                xs.push(x);
	                return xs;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatString = {
	            '@@transducer/init': String,
	            '@@transducer/step': function (a, b) {
	                return a + b;
	            },
	            '@@transducer/result': _identity
	        };
	        var _stepCatObject = {
	            '@@transducer/init': Object,
	            '@@transducer/step': function (result, input) {
	                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
	            },
	            '@@transducer/result': _identity
	        };
	        return function _stepCat(obj) {
	            if (_isTransformer(obj)) {
	                return obj;
	            }
	            if (isArrayLike(obj)) {
	                return _stepCatArray;
	            }
	            if (typeof obj === 'string') {
	                return _stepCatString;
	            }
	            if (typeof obj === 'object') {
	                return _stepCatObject;
	            }
	            throw new Error('Cannot create transformer for ' + obj);
	        };
	    }();

	    var _xdropLastWhile = function () {
	        function XDropLastWhile(fn, xf) {
	            this.f = fn;
	            this.retained = [];
	            this.xf = xf;
	        }
	        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
	        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
	            this.retained = null;
	            return this.xf['@@transducer/result'](result);
	        };
	        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
	            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
	        };
	        XDropLastWhile.prototype.flush = function (result, input) {
	            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
	            this.retained = [];
	            return this.xf['@@transducer/step'](result, input);
	        };
	        XDropLastWhile.prototype.retain = function (result, input) {
	            this.retained.push(input);
	            return result;
	        };
	        return _curry2(function _xdropLastWhile(fn, xf) {
	            return new XDropLastWhile(fn, xf);
	        });
	    }();

	    /**
	     * Creates a new list iteration function from an existing one by adding two new
	     * parameters to its callback function: the current index, and the entire list.
	     *
	     * This would turn, for instance, Ramda's simple `map` function into one that
	     * more closely resembles `Array.prototype.map`. Note that this will only work
	     * for functions in which the iteration callback function is the first
	     * parameter, and where the list is the last parameter. (This latter might be
	     * unimportant if the list parameter is not used.)
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Function
	     * @category List
	     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	     * @param {Function} fn A list iteration function that does not pass index or list to its callback
	     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	     * @example
	     *
	     *      var mapIndexed = R.addIndex(R.map);
	     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	     */
	    var addIndex = _curry1(function addIndex(fn) {
	        return curryN(fn.length, function () {
	            var idx = 0;
	            var origFn = arguments[0];
	            var list = arguments[arguments.length - 1];
	            var args = _slice(arguments);
	            args[0] = function () {
	                var result = origFn.apply(this, _concat(arguments, [
	                    idx,
	                    list
	                ]));
	                idx += 1;
	                return result;
	            };
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Wraps a function of any arity (including nullary) in a function that accepts
	     * exactly 2 parameters. Any extraneous parameters will not be passed to the
	     * supplied function.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.2.0
	     * @category Function
	     * @sig (* -> c) -> (a, b -> c)
	     * @param {Function} fn The function to wrap.
	     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	     *         arity 2.
	     * @example
	     *
	     *      var takesThreeArgs = function(a, b, c) {
	     *        return [a, b, c];
	     *      };
	     *      takesThreeArgs.length; //=> 3
	     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      var takesTwoArgs = R.binary(takesThreeArgs);
	     *      takesTwoArgs.length; //=> 2
	     *      // Only 2 arguments are passed to the wrapped function
	     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	     */
	    var binary = _curry1(function binary(fn) {
	        return nAry(2, fn);
	    });

	    /**
	     * Creates a deep copy of the value which may contain (nested) `Array`s and
	     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
	     * copied, but assigned by their reference.
	     *
	     * Dispatches to a `clone` method if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig {*} -> {*}
	     * @param {*} value The object or array to clone
	     * @return {*} A new object or array.
	     * @example
	     *
	     *      var objects = [{}, {}, {}];
	     *      var objectsClone = R.clone(objects);
	     *      objects[0] === objectsClone[0]; //=> false
	     */
	    var clone = _curry1(function clone(value) {
	        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
	    });

	    /**
	     * Returns a curried equivalent of the provided function. The curried function
	     * has two unusual capabilities. First, its arguments needn't be provided one
	     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	     * following are equivalent:
	     *
	     *   - `g(1)(2)(3)`
	     *   - `g(1)(2, 3)`
	     *   - `g(1, 2)(3)`
	     *   - `g(1, 2, 3)`
	     *
	     * Secondly, the special placeholder value `R.__` may be used to specify
	     * "gaps", allowing partial application of any combination of arguments,
	     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
	     * following are equivalent:
	     *
	     *   - `g(1, 2, 3)`
	     *   - `g(_, 2, 3)(1)`
	     *   - `g(_, _, 3)(1)(2)`
	     *   - `g(_, _, 3)(1, 2)`
	     *   - `g(_, 2)(1)(3)`
	     *   - `g(_, 2)(1, 3)`
	     *   - `g(_, 2)(_, 3)(1)`
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> a) -> (* -> a)
	     * @param {Function} fn The function to curry.
	     * @return {Function} A new, curried function.
	     * @see R.curryN
	     * @example
	     *
	     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	     *
	     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	     *      var f = curriedAddFourNumbers(1, 2);
	     *      var g = f(3);
	     *      g(4); //=> 10
	     */
	    var curry = _curry1(function curry(fn) {
	        return curryN(fn.length, fn);
	    });

	    /**
	     * Returns all but the first `n` elements of the given list, string, or
	     * transducer/transformer (or object with a `drop` method).
	     *
	     * Dispatches to the `drop` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n
	     * @param {*} list
	     * @return {*}
	     * @see R.take, R.transduce
	     * @example
	     *
	     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.drop(3, 'ramda');               //=> 'da'
	     */
	    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
	        return slice(Math.max(0, n), Infinity, xs);
	    }));

	    /**
	     * Returns a list containing all but the last `n` elements of the given `list`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements of `xs` to skip.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.takeLast
	     * @example
	     *
	     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	     *      R.dropLast(3, 'ramda');               //=> 'ra'
	     */
	    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

	    /**
	     * Returns a new list excluding all the tailing elements of a given list which
	     * satisfy the supplied predicate function. It passes each value from the right
	     * to the supplied predicate function, skipping elements while the predicate
	     * function returns `true`. The predicate function is applied to one argument:
	     * *(value)*.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> Boolean) -> [a] -> [a]
	     * @param {Function} fn The function called per iteration.
	     * @param {Array} list The collection to iterate over.
	     * @return {Array} A new array.
	     * @see R.takeLastWhile, R.addIndex
	     * @example
	     *
	     *      var lteThree = x => x <= 3;
	     *
	     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
	     */
	    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

	    /**
	     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	     * cyclical data structures.
	     *
	     * Dispatches symmetrically to the `equals` methods of both arguments, if
	     * present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.15.0
	     * @category Relation
	     * @sig a -> b -> Boolean
	     * @param {*} a
	     * @param {*} b
	     * @return {Boolean}
	     * @example
	     *
	     *      R.equals(1, 1); //=> true
	     *      R.equals(1, '1'); //=> false
	     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	     *
	     *      var a = {}; a.v = a;
	     *      var b = {}; b.v = b;
	     *      R.equals(a, b); //=> true
	     */
	    var equals = _curry2(function equals(a, b) {
	        return _equals(a, b, [], []);
	    });

	    /**
	     * Takes a predicate and a "filterable", and returns a new filterable of the
	     * same type containing the members of the given filterable which satisfy the
	     * given predicate.
	     *
	     * Dispatches to the `filter` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.reject, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *
	     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    // else
	    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
	        return _isObject(filterable) ? _reduce(function (acc, key) {
	            if (pred(filterable[key])) {
	                acc[key] = filterable[key];
	            }
	            return acc;
	        }, {}, keys(filterable)) : // else
	        _filter(pred, filterable);
	    }));

	    /**
	     * Returns a new list by pulling every item out of it (and all its sub-arrays)
	     * and putting them in a new array, depth-first.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [b]
	     * @param {Array} list The array to consider.
	     * @return {Array} The flattened list.
	     * @see R.unnest
	     * @example
	     *
	     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	     */
	    var flatten = _curry1(_makeFlat(true));

	    /**
	     * Returns a new function much like the supplied one, except that the first two
	     * arguments' order is reversed.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
	     * @param {Function} fn The function to invoke with its first two parameters reversed.
	     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	     * @example
	     *
	     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
	     *
	     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	     *
	     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	     */
	    var flip = _curry1(function flip(fn) {
	        return curry(function (a, b) {
	            var args = _slice(arguments);
	            args[0] = b;
	            args[1] = a;
	            return fn.apply(this, args);
	        });
	    });

	    /**
	     * Returns the first element of the given list or string. In some libraries
	     * this function is named `first`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {Array|String} list
	     * @return {*}
	     * @see R.tail, R.init, R.last
	     * @example
	     *
	     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	     *      R.head([]); //=> undefined
	     *
	     *      R.head('abc'); //=> 'a'
	     *      R.head(''); //=> ''
	     */
	    var head = nth(0);

	    /**
	     * Returns all but the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category List
	     * @sig [a] -> [a]
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.last, R.head, R.tail
	     * @example
	     *
	     *      R.init([1, 2, 3]);  //=> [1, 2]
	     *      R.init([1, 2]);     //=> [1]
	     *      R.init([1]);        //=> []
	     *      R.init([]);         //=> []
	     *
	     *      R.init('abc');  //=> 'ab'
	     *      R.init('ab');   //=> 'a'
	     *      R.init('a');    //=> ''
	     *      R.init('');     //=> ''
	     */
	    var init = slice(0, -1);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists. Duplication is determined according to the
	     * value returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate function that determines whether
	     *        the two supplied elements are equal.
	     * @param {Array} list1 One list of items to compare
	     * @param {Array} list2 A second list of items to compare
	     * @return {Array} A new list containing those elements common to both lists.
	     * @see R.intersection
	     * @example
	     *
	     *      var buffaloSpringfield = [
	     *        {id: 824, name: 'Richie Furay'},
	     *        {id: 956, name: 'Dewey Martin'},
	     *        {id: 313, name: 'Bruce Palmer'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *      var csny = [
	     *        {id: 204, name: 'David Crosby'},
	     *        {id: 456, name: 'Stephen Stills'},
	     *        {id: 539, name: 'Graham Nash'},
	     *        {id: 177, name: 'Neil Young'}
	     *      ];
	     *
	     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
	     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	     */
	    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
	        var lookupList, filteredList;
	        if (list1.length > list2.length) {
	            lookupList = list1;
	            filteredList = list2;
	        } else {
	            lookupList = list2;
	            filteredList = list1;
	        }
	        var results = [];
	        var idx = 0;
	        while (idx < filteredList.length) {
	            if (_containsWith(pred, filteredList[idx], lookupList)) {
	                results[results.length] = filteredList[idx];
	            }
	            idx += 1;
	        }
	        return uniqWith(pred, results);
	    });

	    /**
	     * Transforms the items of the list with the transducer and appends the
	     * transformed items to the accumulator using an appropriate iterator function
	     * based on the accumulator type.
	     *
	     * The accumulator can be an array, string, object or a transformer. Iterated
	     * items will be appended to arrays and concatenated to strings. Objects will
	     * be merged directly or 2-item arrays will be merged as key, value pairs.
	     *
	     * The accumulator can also be a transformer object that provides a 2-arity
	     * reducing iterator function, step, 0-arity initial value function, init, and
	     * 1-arity result extraction function result. The step function is used as the
	     * iterator function in reduce. The result function is used to convert the
	     * final accumulator into the return type and in most cases is R.identity. The
	     * init function is used to provide the initial accumulator.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig a -> (b -> b) -> [c] -> a
	     * @param {*} acc The initial accumulator value.
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.into([], transducer, numbers); //=> [2, 3]
	     *
	     *      var intoArray = R.into([]);
	     *      intoArray(transducer, numbers); //=> [2, 3]
	     */
	    var into = _curry3(function into(acc, xf, list) {
	        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
	    });

	    /**
	     * Same as R.invertObj, however this accounts for objects with duplicate values
	     * by putting the values into an array.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: [ s, ... ]}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object with keys
	     * in an array.
	     * @example
	     *
	     *      var raceResultsByFirstName = {
	     *        first: 'alice',
	     *        second: 'jake',
	     *        third: 'alice',
	     *      };
	     *      R.invert(raceResultsByFirstName);
	     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	     */
	    var invert = _curry1(function invert(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            var val = obj[key];
	            var list = _has(val, out) ? out[val] : out[val] = [];
	            list[list.length] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new object with the keys of the given object as values, and the
	     * values of the given object, which are coerced to strings, as keys. Note
	     * that the last key found is preferred when handling the same value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig {s: x} -> {x: s}
	     * @param {Object} obj The object or array to invert
	     * @return {Object} out A new object
	     * @example
	     *
	     *      var raceResults = {
	     *        first: 'alice',
	     *        second: 'jake'
	     *      };
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': 'first', 'jake':'second' }
	     *
	     *      // Alternatively:
	     *      var raceResults = ['alice', 'jake'];
	     *      R.invertObj(raceResults);
	     *      //=> { 'alice': '0', 'jake':'1' }
	     */
	    var invertObj = _curry1(function invertObj(obj) {
	        var props = keys(obj);
	        var len = props.length;
	        var idx = 0;
	        var out = {};
	        while (idx < len) {
	            var key = props[idx];
	            out[obj[key]] = key;
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns `true` if the given value is its type's empty value; `false`
	     * otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Logic
	     * @sig a -> Boolean
	     * @param {*} x
	     * @return {Boolean}
	     * @see R.empty
	     * @example
	     *
	     *      R.isEmpty([1, 2, 3]);   //=> false
	     *      R.isEmpty([]);          //=> true
	     *      R.isEmpty('');          //=> true
	     *      R.isEmpty(null);        //=> false
	     *      R.isEmpty({});          //=> true
	     *      R.isEmpty({length: 0}); //=> false
	     */
	    var isEmpty = _curry1(function isEmpty(x) {
	        return x != null && equals(x, empty(x));
	    });

	    /**
	     * Returns the last element of the given list or string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig [a] -> a | Undefined
	     * @sig String -> String
	     * @param {*} list
	     * @return {*}
	     * @see R.init, R.head, R.tail
	     * @example
	     *
	     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	     *      R.last([]); //=> undefined
	     *
	     *      R.last('abc'); //=> 'c'
	     *      R.last(''); //=> ''
	     */
	    var last = nth(-1);

	    /**
	     * Returns the position of the last occurrence of an item in an array, or -1 if
	     * the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.indexOf
	     * @example
	     *
	     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	     */
	    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
	        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
	            return xs.lastIndexOf(target);
	        } else {
	            var idx = xs.length - 1;
	            while (idx >= 0) {
	                if (equals(xs[idx], target)) {
	                    return idx;
	                }
	                idx -= 1;
	            }
	            return -1;
	        }
	    });

	    /**
	     * Takes a function and
	     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
	     * applies the function to each of the functor's values, and returns
	     * a functor of the same shape.
	     *
	     * Ramda provides suitable `map` implementations for `Array` and `Object`,
	     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
	     *
	     * Dispatches to the `map` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * Also treats functions as functors and will compose them together.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Functor f => (a -> b) -> f a -> f b
	     * @param {Function} fn The function to be called on every element of the input `list`.
	     * @param {Array} list The list to be iterated over.
	     * @return {Array} The new list.
	     * @see R.transduce, R.addIndex
	     * @example
	     *
	     *      var double = x => x * 2;
	     *
	     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	     *
	     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	     */
	    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
	        switch (Object.prototype.toString.call(functor)) {
	        case '[object Function]':
	            return curryN(functor.length, function () {
	                return fn.call(this, functor.apply(this, arguments));
	            });
	        case '[object Object]':
	            return _reduce(function (acc, key) {
	                acc[key] = fn(functor[key]);
	                return acc;
	            }, {}, keys(functor));
	        default:
	            return _map(fn, functor);
	        }
	    }));

	    /**
	     * An Object-specific version of `map`. The function is applied to three
	     * arguments: *(value, key, obj)*. If only the value is significant, use
	     * `map` instead.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Object
	     * @sig ((*, String, Object) -> *) -> Object -> Object
	     * @param {Function} fn
	     * @param {Object} obj
	     * @return {Object}
	     * @see R.map
	     * @example
	     *
	     *      var values = { x: 1, y: 2, z: 3 };
	     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	     *
	     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	     */
	    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
	        return _reduce(function (acc, key) {
	            acc[key] = fn(obj[key], key, obj);
	            return acc;
	        }, {}, keys(obj));
	    });

	    /**
	     * Creates a new object with the own properties of the two provided objects. If
	     * a key exists in both objects, the provided function is applied to the values
	     * associated with the key in each object, with the result being used as the
	     * value associated with the key in the returned object. The key will be
	     * excluded from the returned object if the resulting value is `undefined`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Object
	     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
	     * @param {Function} fn
	     * @param {Object} l
	     * @param {Object} r
	     * @return {Object}
	     * @see R.merge, R.mergeWithKey
	     * @example
	     *
	     *      R.mergeWith(R.concat,
	     *                  { a: true, values: [10, 20] },
	     *                  { b: true, values: [15, 35] });
	     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
	     */
	    var mergeWith = _curry3(function mergeWith(fn, l, r) {
	        return mergeWithKey(function (_, _l, _r) {
	            return fn(_l, _r);
	        }, l, r);
	    });

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided initially followed by the arguments provided to `g`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partialRight
	     * @example
	     *
	     *      var multiply = (a, b) => a * b;
	     *      var double = R.partial(multiply, [2]);
	     *      double(2); //=> 4
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var sayHello = R.partial(greet, ['Hello']);
	     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
	     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partial = _createPartialApplicator(_concat);

	    /**
	     * Takes a function `f` and a list of arguments, and returns a function `g`.
	     * When applied, `g` returns the result of applying `f` to the arguments
	     * provided to `g` followed by the arguments provided initially.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
	     * @param {Function} f
	     * @param {Array} args
	     * @return {Function}
	     * @see R.partial
	     * @example
	     *
	     *      var greet = (salutation, title, firstName, lastName) =>
	     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	     *
	     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
	     *
	     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	     */
	    var partialRight = _createPartialApplicator(flip(_concat));

	    /**
	     * Determines whether a nested path on an object has a specific value, in
	     * `R.equals` terms. Most likely used to filter a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Relation
	     * @sig [String] -> * -> {String: *} -> Boolean
	     * @param {Array} path The path of the nested property to use
	     * @param {*} val The value to compare the nested property with
	     * @param {Object} obj The object to check the nested property in
	     * @return {Boolean} `true` if the value equals the nested object property,
	     *         `false` otherwise.
	     * @example
	     *
	     *      var user1 = { address: { zipCode: 90210 } };
	     *      var user2 = { address: { zipCode: 55555 } };
	     *      var user3 = { name: 'Bob' };
	     *      var users = [ user1, user2, user3 ];
	     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	     *      R.filter(isFamous, users); //=> [ user1 ]
	     */
	    var pathEq = _curry3(function pathEq(_path, val, obj) {
	        return equals(path(_path, obj), val);
	    });

	    /**
	     * Returns a new list by plucking the same named property off all objects in
	     * the list supplied.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig k -> [{k: v}] -> [v]
	     * @param {Number|String} key The key name to pluck off of each object.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of values for the given key.
	     * @see R.props
	     * @example
	     *
	     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	     */
	    var pluck = _curry2(function pluck(p, list) {
	        return map(prop(p), list);
	    });

	    /**
	     * Reasonable analog to SQL `select` statement.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @category Relation
	     * @sig [k] -> [{k: v}] -> [{k: v}]
	     * @param {Array} props The property names to project
	     * @param {Array} objs The objects to query
	     * @return {Array} An array of objects with just the `props` properties.
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	     *      var kids = [abby, fred];
	     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	     */
	    // passing `identity` gives correct arity
	    var project = useWith(_map, [
	        pickAll,
	        identity
	    ]);

	    /**
	     * Returns `true` if the specified object property is equal, in `R.equals`
	     * terms, to the given value; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig String -> a -> Object -> Boolean
	     * @param {String} name
	     * @param {*} val
	     * @param {*} obj
	     * @return {Boolean}
	     * @see R.equals, R.propSatisfies
	     * @example
	     *
	     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	     *      var kids = [abby, fred, rusty, alois];
	     *      var hasBrownHair = R.propEq('hair', 'brown');
	     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	     */
	    var propEq = _curry3(function propEq(name, val, obj) {
	        return equals(val, obj[name]);
	    });

	    /**
	     * Returns a single item by iterating through the list, successively calling
	     * the iterator function and passing it an accumulator value and the current
	     * value from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It may use
	     * `R.reduced` to shortcut the iteration.
	     *
	     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	     * arrays), unlike the native `Array.prototype.reduce` method. For more details
	     * on this behavior, see:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	     *
	     * Dispatches to the `reduce` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array.
	     * @param {*} acc The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduced, R.addIndex
	     * @example
	     *
	     *      var numbers = [1, 2, 3];
	     *      var plus = (a, b) => a + b;
	     *
	     *      R.reduce(plus, 10, numbers); //=> 16
	     */
	    var reduce = _curry3(_reduce);

	    /**
	     * Groups the elements of the list according to the result of calling
	     * the String-returning function `keyFn` on each element and reduces the elements
	     * of each group to a single value via the reducer function `valueFn`.
	     *
	     * This function is basically a more general `groupBy` function.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.20.0
	     * @category List
	     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
	     * @param {Function} valueFn The function that reduces the elements of each group to a single
	     *        value. Receives two values, accumulator for a particular group and the current element.
	     * @param {*} acc The (initial) accumulator value for each group.
	     * @param {Function} keyFn The function that maps the list's element into a key.
	     * @param {Array} list The array to group.
	     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
	     *         `valueFn` for elements which produced that key when passed to `keyFn`.
	     * @see R.groupBy, R.reduce
	     * @example
	     *
	     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
	     *      var namesByGrade = reduceToNamesBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Lucy', score: 92},
	     *                      {name: 'Drew', score: 85},
	     *                      // ...
	     *                      {name: 'Bart', score: 62}];
	     *      namesByGrade(students);
	     *      // {
	     *      //   'A': ['Lucy'],
	     *      //   'B': ['Drew']
	     *      //   // ...,
	     *      //   'F': ['Bart']
	     *      // }
	     */
	    var reduceBy = _curryN(4, [], _dispatchable('reduceBy', _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
	        return _reduce(function (acc, elt) {
	            var key = keyFn(elt);
	            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
	            return acc;
	        }, {}, list);
	    }));

	    /**
	     * Like `reduce`, `reduceWhile` returns a single item by iterating through
	     * the list, successively calling the iterator function. `reduceWhile` also
	     * takes a predicate that is evaluated before each step. If the predicate returns
	     * `false`, it "short-circuits" the iteration and returns the current value
	     * of the accumulator.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.22.0
	     * @category List
	     * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
	     * @param {Function} pred The predicate. It is passed the accumulator and the
	     *        current element.
	     * @param {Function} fn The iterator function. Receives two values, the
	     *        accumulator and the current element.
	     * @param {*} a The accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduce, R.reduced
	     * @example
	     *
	     *      var isOdd = (acc, x) => x % 2 === 1;
	     *      var xs = [1, 3, 5, 60, 777, 800];
	     *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
	     *
	     *      var ys = [2, 4, 6]
	     *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
	     */
	    var reduceWhile = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
	        return _reduce(function (acc, x) {
	            return pred(acc, x) ? fn(acc, x) : _reduced(acc);
	        }, a, list);
	    });

	    /**
	     * The complement of `filter`.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> f a
	     * @param {Function} pred
	     * @param {Array} filterable
	     * @return {Array}
	     * @see R.filter, R.transduce, R.addIndex
	     * @example
	     *
	     *      var isOdd = (n) => n % 2 === 1;
	     *
	     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	     *
	     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	     */
	    var reject = _curry2(function reject(pred, filterable) {
	        return filter(_complement(pred), filterable);
	    });

	    /**
	     * Returns a fixed list of size `n` containing a specified identical value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.1
	     * @category List
	     * @sig a -> n -> [a]
	     * @param {*} value The value to repeat.
	     * @param {Number} n The desired size of the output list.
	     * @return {Array} A new array containing `n` `value`s.
	     * @example
	     *
	     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	     *
	     *      var obj = {};
	     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	     */
	    var repeat = _curry2(function repeat(value, n) {
	        return times(always(value), n);
	    });

	    /**
	     * Adds together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The sum of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.sum([2,4,6,8,100,1]); //=> 121
	     */
	    var sum = reduce(add, 0);

	    /**
	     * Returns a new list containing the last `n` elements of the given list.
	     * If `n > list.length`, returns a list of `list.length` elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig Number -> [a] -> [a]
	     * @sig Number -> String -> String
	     * @param {Number} n The number of elements to return.
	     * @param {Array} xs The collection to consider.
	     * @return {Array}
	     * @see R.dropLast
	     * @example
	     *
	     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	     *      R.takeLast(3, 'ramda');               //=> 'mda'
	     */
	    var takeLast = _curry2(function takeLast(n, xs) {
	        return drop(n >= 0 ? xs.length - n : 0, xs);
	    });

	    /**
	     * Initializes a transducer using supplied iterator function. Returns a single
	     * item by iterating through the list, successively calling the transformed
	     * iterator function and passing it an accumulator value and the current value
	     * from the array, and then passing the result to the next call.
	     *
	     * The iterator function receives two values: *(acc, value)*. It will be
	     * wrapped as a transformer to initialize the transducer. A transformer can be
	     * passed directly in place of an iterator function. In both cases, iteration
	     * may be stopped early with the `R.reduced` function.
	     *
	     * A transducer is a function that accepts a transformer and returns a
	     * transformer and can be composed directly.
	     *
	     * A transformer is an an object that provides a 2-arity reducing iterator
	     * function, step, 0-arity initial value function, init, and 1-arity result
	     * extraction function, result. The step function is used as the iterator
	     * function in reduce. The result function is used to convert the final
	     * accumulator into the return type and in most cases is R.identity. The init
	     * function can be used to provide an initial accumulator, but is ignored by
	     * transduce.
	     *
	     * The iteration is performed with R.reduce after initializing the transducer.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category List
	     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
	     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	     *        current element from the array. Wrapped as transformer, if necessary, and used to
	     *        initialize the transducer
	     * @param {*} acc The initial accumulator value.
	     * @param {Array} list The list to iterate over.
	     * @return {*} The final, accumulated value.
	     * @see R.reduce, R.reduced, R.into
	     * @example
	     *
	     *      var numbers = [1, 2, 3, 4];
	     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	     *
	     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	     */
	    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
	        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list. Duplication is determined according to the value returned by
	     * applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @see R.union
	     * @example
	     *
	     *      var l1 = [{a: 1}, {a: 2}];
	     *      var l2 = [{a: 1}, {a: 4}];
	     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	     */
	    var unionWith = _curry3(function unionWith(pred, list1, list2) {
	        return uniqWith(pred, _concat(list1, list2));
	    });

	    /**
	     * Takes a spec object and a test object; returns true if the test satisfies
	     * the spec, false otherwise. An object satisfies the spec if, for each of the
	     * spec's own properties, accessing that property of the object gives the same
	     * value (in `R.equals` terms) as accessing that property of the spec.
	     *
	     * `whereEq` is a specialization of [`where`](#where).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @sig {String: *} -> {String: *} -> Boolean
	     * @param {Object} spec
	     * @param {Object} testObj
	     * @return {Boolean}
	     * @see R.where
	     * @example
	     *
	     *      // pred :: Object -> Boolean
	     *      var pred = R.whereEq({a: 1, b: 2});
	     *
	     *      pred({a: 1});              //=> false
	     *      pred({a: 1, b: 2});        //=> true
	     *      pred({a: 1, b: 2, c: 3});  //=> true
	     *      pred({a: 1, b: 1});        //=> false
	     */
	    var whereEq = _curry2(function whereEq(spec, testObj) {
	        return where(map(equals, spec), testObj);
	    });

	    var _flatCat = function () {
	        var preservingReduced = function (xf) {
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return xf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    var ret = xf['@@transducer/step'](result, input);
	                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	                }
	            };
	        };
	        return function _xcat(xf) {
	            var rxf = preservingReduced(xf);
	            return {
	                '@@transducer/init': _xfBase.init,
	                '@@transducer/result': function (result) {
	                    return rxf['@@transducer/result'](result);
	                },
	                '@@transducer/step': function (result, input) {
	                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	                }
	            };
	        };
	    }();

	    // Array.prototype.indexOf doesn't exist below IE9
	    // manually crawl the list to distinguish between +0 and -0
	    // NaN
	    // non-zero numbers can utilise Set
	    // all these types can utilise Set
	    // null can utilise Set
	    // anything else not covered above, defer to R.equals
	    var _indexOf = function _indexOf(list, a, idx) {
	        var inf, item;
	        // Array.prototype.indexOf doesn't exist below IE9
	        if (typeof list.indexOf === 'function') {
	            switch (typeof a) {
	            case 'number':
	                if (a === 0) {
	                    // manually crawl the list to distinguish between +0 and -0
	                    inf = 1 / a;
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (item === 0 && 1 / item === inf) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                } else if (a !== a) {
	                    // NaN
	                    while (idx < list.length) {
	                        item = list[idx];
	                        if (typeof item === 'number' && item !== item) {
	                            return idx;
	                        }
	                        idx += 1;
	                    }
	                    return -1;
	                }
	                // non-zero numbers can utilise Set
	                return list.indexOf(a, idx);
	            // all these types can utilise Set
	            case 'string':
	            case 'boolean':
	            case 'function':
	            case 'undefined':
	                return list.indexOf(a, idx);
	            case 'object':
	                if (a === null) {
	                    // null can utilise Set
	                    return list.indexOf(a, idx);
	                }
	            }
	        }
	        // anything else not covered above, defer to R.equals
	        while (idx < list.length) {
	            if (equals(list[idx], a)) {
	                return idx;
	            }
	            idx += 1;
	        }
	        return -1;
	    };

	    var _xchain = _curry2(function _xchain(f, xf) {
	        return map(f, _flatCat(xf));
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if every one of the provided predicates is satisfied
	     * by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.anyPass
	     * @example
	     *
	     *      var isQueen = R.propEq('rank', 'Q');
	     *      var isSpade = R.propEq('suit', '');
	     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
	     *
	     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
	     *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
	     */
	    var allPass = _curry1(function allPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (!preds[idx].apply(this, arguments)) {
	                    return false;
	                }
	                idx += 1;
	            }
	            return true;
	        });
	    });

	    /**
	     * Takes a list of predicates and returns a predicate that returns true for a
	     * given list of arguments if at least one of the provided predicates is
	     * satisfied by those arguments.
	     *
	     * The function returned is a curried function whose arity matches that of the
	     * highest-arity predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Logic
	     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	     * @param {Array} preds
	     * @return {Function}
	     * @see R.allPass
	     * @example
	     *
	     *      var gte = R.anyPass([R.gt, R.equals]);
	     *
	     *      gte(3, 2); //=> true
	     *      gte(2, 2); //=> true
	     *      gte(2, 3); //=> false
	     */
	    var anyPass = _curry1(function anyPass(preds) {
	        return curryN(reduce(max, 0, pluck('length', preds)), function () {
	            var idx = 0;
	            var len = preds.length;
	            while (idx < len) {
	                if (preds[idx].apply(this, arguments)) {
	                    return true;
	                }
	                idx += 1;
	            }
	            return false;
	        });
	    });

	    /**
	     * ap applies a list of functions to a list of values.
	     *
	     * Dispatches to the `ap` method of the second argument, if present. Also
	     * treats curried functions as applicatives.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category Function
	     * @sig [a -> b] -> [a] -> [b]
	     * @sig Apply f => f (a -> b) -> f a -> f b
	     * @param {Array} fns An array of functions
	     * @param {Array} vs An array of values
	     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
	     * @example
	     *
	     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	     */
	    // else
	    var ap = _curry2(function ap(applicative, fn) {
	        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? function (x) {
	            return applicative(x)(fn(x));
	        } : // else
	        _reduce(function (acc, f) {
	            return _concat(acc, map(f, fn));
	        }, [], applicative);
	    });

	    /**
	     * Given a spec object recursively mapping properties to functions, creates a
	     * function producing an object of the same structure, by mapping each property
	     * to the result of calling its associated function with the supplied arguments.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.20.0
	     * @category Function
	     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
	     * @param {Object} spec an object recursively mapping properties to functions for
	     *        producing the values for these properties.
	     * @return {Function} A function that returns an object of the same structure
	     * as `spec', with each property set to the value returned by calling its
	     * associated function with the supplied arguments.
	     * @see R.converge, R.juxt
	     * @example
	     *
	     *      var getMetrics = R.applySpec({
	     *                                      sum: R.add,
	     *                                      nested: { mul: R.multiply }
	     *                                   });
	     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
	     */
	    var applySpec = _curry1(function applySpec(spec) {
	        spec = map(function (v) {
	            return typeof v == 'function' ? v : applySpec(v);
	        }, spec);
	        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
	            var args = arguments;
	            return map(function (f) {
	                return apply(f, args);
	            }, spec);
	        });
	    });

	    /**
	     * Returns the result of calling its first argument with the remaining
	     * arguments. This is occasionally useful as a converging function for
	     * `R.converge`: the left branch can produce a function while the right branch
	     * produces a value to be passed to that function as an argument.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category Function
	     * @sig (*... -> a),*... -> a
	     * @param {Function} fn The function to apply to the remaining arguments.
	     * @param {...*} args Any number of positional arguments.
	     * @return {*}
	     * @see R.apply
	     * @example
	     *
	     *      var indentN = R.pipe(R.times(R.always(' ')),
	     *                           R.join(''),
	     *                           R.replace(/^(?!$)/gm));
	     *
	     *      var format = R.converge(R.call, [
	     *                                  R.pipe(R.prop('indent'), indentN),
	     *                                  R.prop('value')
	     *                              ]);
	     *
	     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	     */
	    var call = curry(function call(fn) {
	        return fn.apply(this, _slice(arguments, 1));
	    });

	    /**
	     * `chain` maps a function over a list and concatenates the results. `chain`
	     * is also known as `flatMap` in some libraries
	     *
	     * Dispatches to the `chain` method of the second argument, if present,
	     * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig Chain m => (a -> m b) -> m a -> m b
	     * @param {Function} fn
	     * @param {Array} list
	     * @return {Array}
	     * @example
	     *
	     *      var duplicate = n => [n, n];
	     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	     */
	    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
	        if (typeof monad === 'function') {
	            return function () {
	                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
	            };
	        }
	        return _makeFlat(false)(map(fn, monad));
	    }));

	    /**
	     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
	     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
	     * to `fn` are applied to each of the predicates in turn until one returns a
	     * "truthy" value, at which point `fn` returns the result of applying its
	     * arguments to the corresponding transformer. If none of the predicates
	     * matches, `fn` returns undefined.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.6.0
	     * @category Logic
	     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	     * @param {Array} pairs
	     * @return {Function}
	     * @example
	     *
	     *      var fn = R.cond([
	     *        [R.equals(0),   R.always('water freezes at 0C')],
	     *        [R.equals(100), R.always('water boils at 100C')],
	     *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
	     *      ]);
	     *      fn(0); //=> 'water freezes at 0C'
	     *      fn(50); //=> 'nothing special happens at 50C'
	     *      fn(100); //=> 'water boils at 100C'
	     */
	    var cond = _curry1(function cond(pairs) {
	        var arity = reduce(max, 0, map(function (pair) {
	            return pair[0].length;
	        }, pairs));
	        return _arity(arity, function () {
	            var idx = 0;
	            while (idx < pairs.length) {
	                if (pairs[idx][0].apply(this, arguments)) {
	                    return pairs[idx][1].apply(this, arguments);
	                }
	                idx += 1;
	            }
	        });
	    });

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type. The arity of the function
	     * returned is specified to allow using variadic constructor functions.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.0
	     * @category Function
	     * @sig Number -> (* -> {*}) -> (* -> {*})
	     * @param {Number} n The arity of the constructor function.
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Variadic constructor function
	     *      var Widget = () => {
	     *        this.children = Array.prototype.slice.call(arguments);
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
	     */
	    var constructN = _curry2(function constructN(n, Fn) {
	        if (n > 10) {
	            throw new Error('Constructor with greater than ten arguments');
	        }
	        if (n === 0) {
	            return function () {
	                return new Fn();
	            };
	        }
	        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	            switch (arguments.length) {
	            case 1:
	                return new Fn($0);
	            case 2:
	                return new Fn($0, $1);
	            case 3:
	                return new Fn($0, $1, $2);
	            case 4:
	                return new Fn($0, $1, $2, $3);
	            case 5:
	                return new Fn($0, $1, $2, $3, $4);
	            case 6:
	                return new Fn($0, $1, $2, $3, $4, $5);
	            case 7:
	                return new Fn($0, $1, $2, $3, $4, $5, $6);
	            case 8:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	            case 9:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	            case 10:
	                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	            }
	        }));
	    });

	    /**
	     * Accepts a converging function and a list of branching functions and returns
	     * a new function. When invoked, this new function is applied to some
	     * arguments, each branching function is applied to those same arguments. The
	     * results of each branching function are passed as arguments to the converging
	     * function to produce the return value.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.4.2
	     * @category Function
	     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
	     * @param {Function} after A function. `after` will be invoked with the return values of
	     *        `fn1` and `fn2` as its arguments.
	     * @param {Array} functions A list of functions.
	     * @return {Function} A new function.
	     * @example
	     *
	     *      var add = (a, b) => a + b;
	     *      var multiply = (a, b) => a * b;
	     *      var subtract = (a, b) => a - b;
	     *
	     *      // multiply( add(1, 2), subtract(1, 2) );
	     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
	     *
	     *      var add3 = (a, b, c) => a + b + c;
	     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
	     */
	    var converge = _curry2(function converge(after, fns) {
	        return curryN(reduce(max, 0, pluck('length', fns)), function () {
	            var args = arguments;
	            var context = this;
	            return after.apply(context, _map(function (fn) {
	                return fn.apply(context, args);
	            }, fns));
	        });
	    });

	    /**
	     * Counts the elements of a list according to how many match each value of a
	     * key generated by the supplied function. Returns an object mapping the keys
	     * produced by `fn` to the number of occurrences in the list. Note that all
	     * keys are coerced to strings because of how JavaScript objects work.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig (a -> String) -> [a] -> {*}
	     * @param {Function} fn The function used to map values to keys.
	     * @param {Array} list The list to count elements from.
	     * @return {Object} An object mapping keys to number of occurrences in the list.
	     * @example
	     *
	     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	     *      var letters = R.split('', 'abcABCaaaBBc');
	     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
	     */
	    var countBy = reduceBy(function (acc, elem) {
	        return acc + 1;
	    }, 0);

	    /**
	     * Returns a new list without any consecutively repeating elements. Equality is
	     * determined by applying the supplied predicate two consecutive elements. The
	     * first element in a series of equal element is the one being preserved.
	     *
	     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig (a, a -> Boolean) -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
	     */
	    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	        var result = [];
	        var idx = 1;
	        var len = list.length;
	        if (len !== 0) {
	            result[0] = list[0];
	            while (idx < len) {
	                if (!pred(last(result), list[idx])) {
	                    result[result.length] = list[idx];
	                }
	                idx += 1;
	            }
	        }
	        return result;
	    }));

	    /**
	     * Takes a function and two values in its domain and returns `true` if the
	     * values map to the same value in the codomain; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.18.0
	     * @category Relation
	     * @sig (a -> b) -> a -> a -> Boolean
	     * @param {Function} f
	     * @param {*} x
	     * @param {*} y
	     * @return {Boolean}
	     * @example
	     *
	     *      R.eqBy(Math.abs, 5, -5); //=> true
	     */
	    var eqBy = _curry3(function eqBy(f, x, y) {
	        return equals(f(x), f(y));
	    });

	    /**
	     * Reports whether two objects have the same value, in `R.equals` terms, for
	     * the specified property. Useful as a curried predicate.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig k -> {k: v} -> {k: v} -> Boolean
	     * @param {String} prop The name of the property to compare
	     * @param {Object} obj1
	     * @param {Object} obj2
	     * @return {Boolean}
	     *
	     * @example
	     *
	     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	     *      R.eqProps('a', o1, o2); //=> false
	     *      R.eqProps('c', o1, o2); //=> true
	     */
	    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
	        return equals(obj1[prop], obj2[prop]);
	    });

	    /**
	     * Splits a list into sub-lists stored in an object, based on the result of
	     * calling a String-returning function on each element, and grouping the
	     * results according to values returned.
	     *
	     * Dispatches to the `groupBy` method of the second argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig (a -> String) -> [a] -> {String: [a]}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} list The array to group
	     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	     *         that produced that key when passed to `fn`.
	     * @see R.transduce
	     * @example
	     *
	     *      var byGrade = R.groupBy(function(student) {
	     *        var score = student.score;
	     *        return score < 65 ? 'F' :
	     *               score < 70 ? 'D' :
	     *               score < 80 ? 'C' :
	     *               score < 90 ? 'B' : 'A';
	     *      });
	     *      var students = [{name: 'Abby', score: 84},
	     *                      {name: 'Eddy', score: 58},
	     *                      // ...
	     *                      {name: 'Jack', score: 69}];
	     *      byGrade(students);
	     *      // {
	     *      //   'A': [{name: 'Dianne', score: 99}],
	     *      //   'B': [{name: 'Abby', score: 84}]
	     *      //   // ...,
	     *      //   'F': [{name: 'Eddy', score: 58}]
	     *      // }
	     */
	    var groupBy = _curry2(_checkForMethod('groupBy', reduceBy(function (acc, item) {
	        if (acc == null) {
	            acc = [];
	        }
	        acc.push(item);
	        return acc;
	    }, null)));

	    /**
	     * Given a function that generates a key, turns a list of objects into an
	     * object indexing the objects by the given key. Note that if multiple
	     * objects generate the same value for the indexing key only the last value
	     * will be included in the generated object.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
	     * @param {Function} fn Function :: a -> String
	     * @param {Array} array The array of objects to index
	     * @return {Object} An object indexing each array element by the given property.
	     * @example
	     *
	     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
	     *      R.indexBy(R.prop('id'), list);
	     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
	     */
	    var indexBy = reduceBy(function (acc, elem) {
	        return elem;
	    }, null);

	    /**
	     * Returns the position of the first occurrence of an item in an array, or -1
	     * if the item is not included in the array. `R.equals` is used to determine
	     * equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Number
	     * @param {*} target The item to find.
	     * @param {Array} xs The array to search in.
	     * @return {Number} the index of the target, or -1 if the target is not found.
	     * @see R.lastIndexOf
	     * @example
	     *
	     *      R.indexOf(3, [1,2,3,4]); //=> 2
	     *      R.indexOf(10, [1,2,3,4]); //=> -1
	     */
	    var indexOf = _curry2(function indexOf(target, xs) {
	        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	    });

	    /**
	     * juxt applies a list of functions to a list of values.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Function
	     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
	     * @param {Array} fns An array of functions
	     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
	     * @see R.applySpec
	     * @example
	     *
	     *      var getRange = R.juxt([Math.min, Math.max]);
	     *      getRange(3, 4, 9, -3); //=> [-3, 9]
	     */
	    var juxt = _curry1(function juxt(fns) {
	        return converge(_arrayOf, fns);
	    });

	    /**
	     * Returns a lens for the given getter and setter functions. The getter "gets"
	     * the value of the focus; the setter "sets" the value of the focus. The setter
	     * should not mutate the data structure.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.8.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	     * @param {Function} getter
	     * @param {Function} setter
	     * @return {Lens}
	     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	     * @example
	     *
	     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lens = _curry2(function lens(getter, setter) {
	        return function (toFunctorFn) {
	            return function (target) {
	                return map(function (focus) {
	                    return setter(focus, target);
	                }, toFunctorFn(getter(target)));
	            };
	        };
	    });

	    /**
	     * Returns a lens whose focus is the specified index.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig Number -> Lens s a
	     * @param {Number} n
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var headLens = R.lensIndex(0);
	     *
	     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	     */
	    var lensIndex = _curry1(function lensIndex(n) {
	        return lens(nth(n), update(n));
	    });

	    /**
	     * Returns a lens whose focus is the specified path.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig [String] -> Lens s a
	     * @param {Array} path The path to use.
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xyLens = R.lensPath(['x', 'y']);
	     *
	     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
	     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
	     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
	     */
	    var lensPath = _curry1(function lensPath(p) {
	        return lens(path(p), assocPath(p));
	    });

	    /**
	     * Returns a lens whose focus is the specified property.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Object
	     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	     * @sig String -> Lens s a
	     * @param {String} k
	     * @return {Lens}
	     * @see R.view, R.set, R.over
	     * @example
	     *
	     *      var xLens = R.lensProp('x');
	     *
	     *      R.view(xLens, {x: 1, y: 2});            //=> 1
	     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	     */
	    var lensProp = _curry1(function lensProp(k) {
	        return lens(prop(k), assoc(k));
	    });

	    /**
	     * "lifts" a function to be the specified arity, so that it may "map over" that
	     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig Number -> (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.lift, R.ap
	     * @example
	     *
	     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     */
	    var liftN = _curry2(function liftN(arity, fn) {
	        var lifted = curryN(arity, fn);
	        return curryN(arity, function () {
	            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
	        });
	    });

	    /**
	     * Returns the mean of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.mean([2, 7, 9]); //=> 6
	     *      R.mean([]); //=> NaN
	     */
	    var mean = _curry1(function mean(list) {
	        return sum(list) / list.length;
	    });

	    /**
	     * Returns the median of the given list of numbers.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list
	     * @return {Number}
	     * @example
	     *
	     *      R.median([2, 9, 7]); //=> 7
	     *      R.median([7, 2, 10, 9]); //=> 8
	     *      R.median([]); //=> NaN
	     */
	    var median = _curry1(function median(list) {
	        var len = list.length;
	        if (len === 0) {
	            return NaN;
	        }
	        var width = 2 - len % 2;
	        var idx = (len - width) / 2;
	        return mean(_slice(list).sort(function (a, b) {
	            return a < b ? -1 : a > b ? 1 : 0;
	        }).slice(idx, idx + width));
	    });

	    /**
	     * Takes a predicate and a list or other "filterable" object and returns the
	     * pair of filterable objects of the same type of elements which do and do not
	     * satisfy, the predicate, respectively.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.4
	     * @category List
	     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
	     * @param {Function} pred A predicate to determine which side the element belongs to.
	     * @param {Array} filterable the list (or other filterable) to partition.
	     * @return {Array} An array, containing first the subset of elements that satisfy the
	     *         predicate, and second the subset of elements that do not satisfy.
	     * @see R.filter, R.reject
	     * @example
	     *
	     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	     *
	     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
	     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
	     */
	    var partition = juxt([
	        filter,
	        reject
	    ]);

	    /**
	     * Performs left-to-right function composition. The leftmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * In some libraries this function is named `sequence`.
	     *
	     * **Note:** The result of pipe is not automatically curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.compose
	     * @example
	     *
	     *      var f = R.pipe(Math.pow, R.negate, R.inc);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var pipe = function pipe() {
	        if (arguments.length === 0) {
	            throw new Error('pipe requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	    };

	    /**
	     * Performs left-to-right composition of one or more Promise-returning
	     * functions. The leftmost function may have any arity; the remaining functions
	     * must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.composeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	     */
	    var pipeP = function pipeP() {
	        if (arguments.length === 0) {
	            throw new Error('pipeP requires at least one argument');
	        }
	        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	    };

	    /**
	     * Multiplies together all the elements of a list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Math
	     * @sig [Number] -> Number
	     * @param {Array} list An array of numbers
	     * @return {Number} The product of all the numbers in the list.
	     * @see R.reduce
	     * @example
	     *
	     *      R.product([2,4,6,8,100,1]); //=> 38400
	     */
	    var product = reduce(multiply, 1);

	    /**
	     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
	     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
	     * Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the second argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
	     * @param {Function} of
	     * @param {*} traversable
	     * @return {*}
	     * @see R.traverse
	     * @example
	     *
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	     *
	     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
	     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
	     */
	    var sequence = _curry2(function sequence(of, traversable) {
	        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
	            return ap(map(prepend, x), acc);
	        }, of([]), traversable);
	    });

	    /**
	     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
	     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
	     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
	     * into an Applicative of Traversable.
	     *
	     * Dispatches to the `sequence` method of the third argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
	     * @param {Function} of
	     * @param {Function} f
	     * @param {*} traversable
	     * @return {*}
	     * @see R.sequence
	     * @example
	     *
	     *      // Returns `Nothing` if the given divisor is `0`
	     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
	     *
	     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
	     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
	     */
	    var traverse = _curry3(function traverse(of, f, traversable) {
	        return sequence(of, map(f, traversable));
	    });

	    /**
	     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
	     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.3.0
	     * @category List
	     * @sig Chain c => c (c a) -> c a
	     * @param {*} list
	     * @return {*}
	     * @see R.flatten, R.chain
	     * @example
	     *
	     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	     */
	    var unnest = chain(_identity);

	    var _contains = function _contains(a, list) {
	        return _indexOf(list, a, 0) >= 0;
	    };

	    //  mapPairs :: (Object, [String]) -> [String]
	    var _toString = function _toString(x, seen) {
	        var recur = function recur(y) {
	            var xs = seen.concat([x]);
	            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	        };
	        //  mapPairs :: (Object, [String]) -> [String]
	        var mapPairs = function (obj, keys) {
	            return _map(function (k) {
	                return _quote(k) + ': ' + recur(obj[k]);
	            }, keys.slice().sort());
	        };
	        switch (Object.prototype.toString.call(x)) {
	        case '[object Arguments]':
	            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	        case '[object Array]':
	            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
	                return /^\d+$/.test(k);
	            }, keys(x)))).join(', ') + ']';
	        case '[object Boolean]':
	            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	        case '[object Date]':
	            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
	        case '[object Null]':
	            return 'null';
	        case '[object Number]':
	            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	        case '[object String]':
	            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	        case '[object Undefined]':
	            return 'undefined';
	        default:
	            if (typeof x.toString === 'function') {
	                var repr = x.toString();
	                if (repr !== '[object Object]') {
	                    return repr;
	                }
	            }
	            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
	        }
	    };

	    /**
	     * Performs right-to-left function composition. The rightmost function may have
	     * any arity; the remaining functions must be unary.
	     *
	     * **Note:** The result of compose is not automatically curried.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipe
	     * @example
	     *
	     *      var f = R.compose(R.inc, R.negate, Math.pow);
	     *
	     *      f(3, 4); // -(3^4) + 1
	     */
	    var compose = function compose() {
	        if (arguments.length === 0) {
	            throw new Error('compose requires at least one argument');
	        }
	        return pipe.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the right-to-left Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.pipeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.composeK(
	     *        R.compose(Maybe.of, R.toUpper),
	     *        get('state'),
	     *        get('address'),
	     *        get('user'),
	     *        parseJson
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var composeK = function composeK() {
	        return compose.apply(this, prepend(identity, map(chain, arguments)));
	    };

	    /**
	     * Performs right-to-left composition of one or more Promise-returning
	     * functions. The rightmost function may have any arity; the remaining
	     * functions must be unary.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.10.0
	     * @category Function
	     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	     * @param {...Function} functions
	     * @return {Function}
	     * @see R.pipeP
	     * @example
	     *
	     *      //  followersForUser :: String -> Promise [User]
	     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
	     */
	    var composeP = function composeP() {
	        if (arguments.length === 0) {
	            throw new Error('composeP requires at least one argument');
	        }
	        return pipeP.apply(this, reverse(arguments));
	    };

	    /**
	     * Wraps a constructor function inside a curried function that can be called
	     * with the same arguments and returns the same type.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (* -> {*}) -> (* -> {*})
	     * @param {Function} Fn The constructor function to wrap.
	     * @return {Function} A wrapped, curried constructor function.
	     * @example
	     *
	     *      // Constructor function
	     *      var Widget = config => {
	     *        // ...
	     *      };
	     *      Widget.prototype = {
	     *        // ...
	     *      };
	     *      var allConfigs = [
	     *        // ...
	     *      ];
	     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
	     */
	    var construct = _curry1(function construct(Fn) {
	        return constructN(Fn.length, Fn);
	    });

	    /**
	     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
	     * least one element of the given list; `false` otherwise.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig a -> [a] -> Boolean
	     * @param {Object} a The item to compare against.
	     * @param {Array} list The array to consider.
	     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
	     * @see R.any
	     * @example
	     *
	     *      R.contains(3, [1, 2, 3]); //=> true
	     *      R.contains(4, [1, 2, 3]); //=> false
	     *      R.contains([42], [[42]]); //=> true
	     */
	    var contains = _curry2(_contains);

	    /**
	     * Finds the set (i.e. no duplicates) of all elements in the first list not
	     * contained in the second list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` that are not in `list2`.
	     * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith
	     * @example
	     *
	     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	     */
	    var difference = _curry2(function difference(first, second) {
	        var out = [];
	        var idx = 0;
	        var firstLen = first.length;
	        while (idx < firstLen) {
	            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	                out[out.length] = first[idx];
	            }
	            idx += 1;
	        }
	        return out;
	    });

	    /**
	     * Returns a new list without any consecutively repeating elements. `R.equals`
	     * is used to determine equality.
	     *
	     * Dispatches to the `dropRepeats` method of the first argument, if present.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} `list` without repeating elements.
	     * @see R.transduce
	     * @example
	     *
	     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	     */
	    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

	    /**
	     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
	     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	     *
	     * @func
	     * @memberOf R
	     * @since v0.7.0
	     * @category Function
	     * @sig (*... -> *) -> ([*]... -> [*])
	     * @param {Function} fn The function to lift into higher context
	     * @return {Function} The lifted function.
	     * @see R.liftN
	     * @example
	     *
	     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
	     *
	     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	     *
	     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
	     *
	     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	     */
	    var lift = _curry1(function lift(fn) {
	        return liftN(fn.length, fn);
	    });

	    /**
	     * Returns a partial copy of an object omitting the keys specified.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Object
	     * @sig [String] -> {String: *} -> {String: *}
	     * @param {Array} names an array of String property names to omit from the new object
	     * @param {Object} obj The object to copy from
	     * @return {Object} A new object with properties from `names` not on it.
	     * @see R.pick
	     * @example
	     *
	     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	     */
	    var omit = _curry2(function omit(names, obj) {
	        var result = {};
	        for (var prop in obj) {
	            if (!_contains(prop, names)) {
	                result[prop] = obj[prop];
	            }
	        }
	        return result;
	    });

	    /**
	     * Returns the left-to-right Kleisli composition of the provided functions,
	     * each of which must return a value of a type supported by [`chain`](#chain).
	     *
	     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category Function
	     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
	     * @param {...Function}
	     * @return {Function}
	     * @see R.composeK
	     * @example
	     *
	     *      //  parseJson :: String -> Maybe *
	     *      //  get :: String -> Object -> Maybe *
	     *
	     *      //  getStateCode :: Maybe String -> Maybe String
	     *      var getStateCode = R.pipeK(
	     *        parseJson,
	     *        get('user'),
	     *        get('address'),
	     *        get('state'),
	     *        R.compose(Maybe.of, R.toUpper)
	     *      );
	     *
	     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
	     *      //=> Just('NY')
	     *      getStateCode(Maybe.of('[Invalid JSON]'));
	     *      //=> Nothing()
	     */
	    var pipeK = function pipeK() {
	        return composeK.apply(this, reverse(arguments));
	    };

	    /**
	     * Returns the string representation of the given value. `eval`'ing the output
	     * should result in a value equivalent to the input value. Many of the built-in
	     * `toString` methods do not satisfy this requirement.
	     *
	     * If the given value is an `[object Object]` with a `toString` method other
	     * than `Object.prototype.toString`, this method is invoked with no arguments
	     * to produce the return value. This means user-defined constructor functions
	     * can provide a suitable `toString` method. For example:
	     *
	     *     function Point(x, y) {
	     *       this.x = x;
	     *       this.y = y;
	     *     }
	     *
	     *     Point.prototype.toString = function() {
	     *       return 'new Point(' + this.x + ', ' + this.y + ')';
	     *     };
	     *
	     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	     *
	     * @func
	     * @memberOf R
	     * @since v0.14.0
	     * @category String
	     * @sig * -> String
	     * @param {*} val
	     * @return {String}
	     * @example
	     *
	     *      R.toString(42); //=> '42'
	     *      R.toString('abc'); //=> '"abc"'
	     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	     */
	    var toString = _curry1(function toString(val) {
	        return _toString(val, []);
	    });

	    /**
	     * Returns a new list without values in the first argument.
	     * `R.equals` is used to determine equality.
	     *
	     * Acts as a transducer if a transformer is given in list position.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @param {Array} list1 The values to be removed from `list2`.
	     * @param {Array} list2 The array to remove values from.
	     * @return {Array} The new array without values in `list1`.
	     * @see R.transduce
	     * @example
	     *
	     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
	     */
	    var without = _curry2(function (xs, list) {
	        return reject(flip(_contains)(xs), list);
	    });

	    // A simple Set type that honours R.equals semantics
	    /* globals Set */
	    // until we figure out why jsdoc chokes on this
	    // @param item The item to add to the Set
	    // @returns {boolean} true if the item did not exist prior, otherwise false
	    //
	    //
	    // @param item The item to check for existence in the Set
	    // @returns {boolean} true if the item exists in the Set, otherwise false
	    //
	    //
	    // Combines the logic for checking whether an item is a member of the set and
	    // for adding a new item to the set.
	    //
	    // @param item       The item to check or add to the Set instance.
	    // @param shouldAdd  If true, the item will be added to the set if it doesn't
	    //                   already exist.
	    // @param set        The set instance to check or add to.
	    // @return {boolean} true if the item already existed, otherwise false.
	    //
	    // distinguish between +0 and -0
	    // these types can all utilise the native Set
	    // set._items['boolean'] holds a two element array
	    // representing [ falseExists, trueExists ]
	    // compare functions for reference equality
	    /* falls through */
	    // reduce the search size of heterogeneous sets by creating buckets
	    // for each type.
	    // scan through all previously applied items
	    var _Set = function () {
	        function _Set() {
	            /* globals Set */
	            this._nativeSet = typeof Set === 'function' ? new Set() : null;
	            this._items = {};
	        }
	        // until we figure out why jsdoc chokes on this
	        // @param item The item to add to the Set
	        // @returns {boolean} true if the item did not exist prior, otherwise false
	        //
	        _Set.prototype.add = function (item) {
	            return !hasOrAdd(item, true, this);
	        };
	        //
	        // @param item The item to check for existence in the Set
	        // @returns {boolean} true if the item exists in the Set, otherwise false
	        //
	        _Set.prototype.has = function (item) {
	            return hasOrAdd(item, false, this);
	        };
	        //
	        // Combines the logic for checking whether an item is a member of the set and
	        // for adding a new item to the set.
	        //
	        // @param item       The item to check or add to the Set instance.
	        // @param shouldAdd  If true, the item will be added to the set if it doesn't
	        //                   already exist.
	        // @param set        The set instance to check or add to.
	        // @return {boolean} true if the item already existed, otherwise false.
	        //
	        function hasOrAdd(item, shouldAdd, set) {
	            var type = typeof item;
	            var prevSize, newSize;
	            switch (type) {
	            case 'string':
	            case 'number':
	                // distinguish between +0 and -0
	                if (item === 0 && 1 / item === -Infinity) {
	                    if (set._items['-0']) {
	                        return true;
	                    } else {
	                        if (shouldAdd) {
	                            set._items['-0'] = true;
	                        }
	                        return false;
	                    }
	                }
	                // these types can all utilise the native Set
	                if (set._nativeSet !== null) {
	                    if (shouldAdd) {
	                        prevSize = set._nativeSet.size;
	                        set._nativeSet.add(item);
	                        newSize = set._nativeSet.size;
	                        return newSize === prevSize;
	                    } else {
	                        return set._nativeSet.has(item);
	                    }
	                } else {
	                    if (!(type in set._items)) {
	                        if (shouldAdd) {
	                            set._items[type] = {};
	                            set._items[type][item] = true;
	                        }
	                        return false;
	                    } else if (item in set._items[type]) {
	                        return true;
	                    } else {
	                        if (shouldAdd) {
	                            set._items[type][item] = true;
	                        }
	                        return false;
	                    }
	                }
	            case 'boolean':
	                // set._items['boolean'] holds a two element array
	                // representing [ falseExists, trueExists ]
	                if (type in set._items) {
	                    var bIdx = item ? 1 : 0;
	                    if (set._items[type][bIdx]) {
	                        return true;
	                    } else {
	                        if (shouldAdd) {
	                            set._items[type][bIdx] = true;
	                        }
	                        return false;
	                    }
	                } else {
	                    if (shouldAdd) {
	                        set._items[type] = item ? [
	                            false,
	                            true
	                        ] : [
	                            true,
	                            false
	                        ];
	                    }
	                    return false;
	                }
	            case 'function':
	                // compare functions for reference equality
	                if (set._nativeSet !== null) {
	                    if (shouldAdd) {
	                        prevSize = set._nativeSet.size;
	                        set._nativeSet.add(item);
	                        newSize = set._nativeSet.size;
	                        return newSize > prevSize;
	                    } else {
	                        return set._nativeSet.has(item);
	                    }
	                } else {
	                    if (!(type in set._items)) {
	                        if (shouldAdd) {
	                            set._items[type] = [item];
	                        }
	                        return false;
	                    }
	                    if (!_contains(item, set._items[type])) {
	                        if (shouldAdd) {
	                            set._items[type].push(item);
	                        }
	                        return false;
	                    }
	                    return true;
	                }
	            case 'undefined':
	                if (set._items[type]) {
	                    return true;
	                } else {
	                    if (shouldAdd) {
	                        set._items[type] = true;
	                    }
	                    return false;
	                }
	            case 'object':
	                if (item === null) {
	                    if (!set._items['null']) {
	                        if (shouldAdd) {
	                            set._items['null'] = true;
	                        }
	                        return false;
	                    }
	                    return true;
	                }
	            /* falls through */
	            default:
	                // reduce the search size of heterogeneous sets by creating buckets
	                // for each type.
	                type = Object.prototype.toString.call(item);
	                if (!(type in set._items)) {
	                    if (shouldAdd) {
	                        set._items[type] = [item];
	                    }
	                    return false;
	                }
	                // scan through all previously applied items
	                if (!_contains(item, set._items[type])) {
	                    if (shouldAdd) {
	                        set._items[type].push(item);
	                    }
	                    return false;
	                }
	                return true;
	            }
	        }
	        return _Set;
	    }();

	    /**
	     * A function wrapping calls to the two functions in an `&&` operation,
	     * returning the result of the first function if it is false-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * false-y value.
	     *
	     * In addition to functions, `R.both` also accepts any fantasy-land compatible
	     * applicative functor.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	     * @see R.and
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.both(gt10, even);
	     *      f(100); //=> true
	     *      f(101); //=> false
	     */
	    var both = _curry2(function both(f, g) {
	        return _isFunction(f) ? function _both() {
	            return f.apply(this, arguments) && g.apply(this, arguments);
	        } : lift(and)(f, g);
	    });

	    /**
	     * Takes a function `f` and returns a function `g` such that:
	     *
	     *   - applying `g` to zero or more arguments will give __true__ if applying
	     *     the same arguments to `f` gives a logical __false__ value; and
	     *
	     *   - applying `g` to zero or more arguments will give __false__ if applying
	     *     the same arguments to `f` gives a logical __true__ value.
	     *
	     * `R.complement` will work on all other functors as well.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> *) -> (*... -> Boolean)
	     * @param {Function} f
	     * @return {Function}
	     * @see R.not
	     * @example
	     *
	     *      var isEven = n => n % 2 === 0;
	     *      var isOdd = R.complement(isEven);
	     *      isOdd(21); //=> true
	     *      isOdd(42); //=> false
	     */
	    var complement = lift(not);

	    /**
	     * Returns the result of concatenating the given lists or strings.
	     *
	     * Note: `R.concat` expects both arguments to be of the same type,
	     * unlike the native `Array.prototype.concat` method. It will throw
	     * an error if you `concat` an Array with a non-Array value.
	     *
	     * Dispatches to the `concat` method of the first argument, if present.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a] -> [a]
	     * @sig String -> String -> String
	     * @param {Array|String} a
	     * @param {Array|String} b
	     * @return {Array|String}
	     *
	     * @example
	     *
	     *      R.concat([], []); //=> []
	     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	     */
	    var concat = _curry2(function concat(a, b) {
	        if (a == null || !_isFunction(a.concat)) {
	            throw new TypeError(toString(a) + ' does not have a method named "concat"');
	        }
	        if (_isArray(a) && !_isArray(b)) {
	            throw new TypeError(toString(b) + ' is not an array');
	        }
	        return a.concat(b);
	    });

	    /**
	     * A function wrapping calls to the two functions in an `||` operation,
	     * returning the result of the first function if it is truth-y and the result
	     * of the second function otherwise. Note that this is short-circuited,
	     * meaning that the second function will not be invoked if the first returns a
	     * truth-y value.
	     *
	     * In addition to functions, `R.either` also accepts any fantasy-land compatible
	     * applicative functor.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category Logic
	     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	     * @param {Function} f a predicate
	     * @param {Function} g another predicate
	     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	     * @see R.or
	     * @example
	     *
	     *      var gt10 = x => x > 10;
	     *      var even = x => x % 2 === 0;
	     *      var f = R.either(gt10, even);
	     *      f(101); //=> true
	     *      f(8); //=> true
	     */
	    var either = _curry2(function either(f, g) {
	        return _isFunction(f) ? function _either() {
	            return f.apply(this, arguments) || g.apply(this, arguments);
	        } : lift(or)(f, g);
	    });

	    /**
	     * Turns a named method with a specified arity into a function that can be
	     * called directly supplied with arguments and a target object.
	     *
	     * The returned function is curried and accepts `arity + 1` parameters where
	     * the final parameter is the target object.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	     * @param {Number} arity Number of arguments the returned function should take
	     *        before the target object.
	     * @param {String} method Name of the method to call.
	     * @return {Function} A new curried function.
	     * @example
	     *
	     *      var sliceFrom = R.invoker(1, 'slice');
	     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	     */
	    var invoker = _curry2(function invoker(arity, method) {
	        return curryN(arity + 1, function () {
	            var target = arguments[arity];
	            if (target != null && _isFunction(target[method])) {
	                return target[method].apply(target, _slice(arguments, 0, arity));
	            }
	            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	        });
	    });

	    /**
	     * Returns a string made by inserting the `separator` between each element and
	     * concatenating all the elements into a single string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig String -> [a] -> String
	     * @param {Number|String} separator The string used to separate the elements.
	     * @param {Array} xs The elements to join into a string.
	     * @return {String} str The string made by concatenating `xs` with `separator`.
	     * @see R.split
	     * @example
	     *
	     *      var spacer = R.join(' ');
	     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	     */
	    var join = invoker(1, 'join');

	    /**
	     * Creates a new function that, when invoked, caches the result of calling `fn`
	     * for a given argument set and returns the result. Subsequent calls to the
	     * memoized `fn` with the same argument set will not result in an additional
	     * call to `fn`; instead, the cached result for that set of arguments will be
	     * returned.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Function
	     * @sig (*... -> a) -> (*... -> a)
	     * @param {Function} fn The function to memoize.
	     * @return {Function} Memoized version of `fn`.
	     * @example
	     *
	     *      var count = 0;
	     *      var factorial = R.memoize(n => {
	     *        count += 1;
	     *        return R.product(R.range(1, n + 1));
	     *      });
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      factorial(5); //=> 120
	     *      count; //=> 1
	     */
	    var memoize = _curry1(function memoize(fn) {
	        var cache = {};
	        return _arity(fn.length, function () {
	            var key = toString(arguments);
	            if (!_has(key, cache)) {
	                cache[key] = fn.apply(this, arguments);
	            }
	            return cache[key];
	        });
	    });

	    /**
	     * Splits a string into an array of strings based on the given
	     * separator.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category String
	     * @sig (String | RegExp) -> String -> [String]
	     * @param {String|RegExp} sep The pattern.
	     * @param {String} str The string to separate into an array.
	     * @return {Array} The array of strings from `str` separated by `str`.
	     * @see R.join
	     * @example
	     *
	     *      var pathComponents = R.split('/');
	     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	     *
	     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	     */
	    var split = invoker(1, 'split');

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
	     * @example
	     *
	     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
	     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
	     */
	    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
	        return concat(difference(list1, list2), difference(list2, list1));
	    });

	    /**
	     * Finds the set (i.e. no duplicates) of all elements contained in the first or
	     * second list, but not both. Duplication is determined according to the value
	     * returned by applying the supplied predicate to two list elements.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.19.0
	     * @category Relation
	     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
	     * @param {Function} pred A predicate used to test whether two items are equal.
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The elements in `list1` or `list2`, but not both.
	     * @see R.symmetricDifference, R.difference, R.differenceWith
	     * @example
	     *
	     *      var eqA = R.eqBy(R.prop('a'));
	     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
	     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
	     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
	     */
	    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
	        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
	    });

	    /**
	     * Determines whether a given string matches a given regular expression.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.12.0
	     * @category String
	     * @sig RegExp -> String -> Boolean
	     * @param {RegExp} pattern
	     * @param {String} str
	     * @return {Boolean}
	     * @see R.match
	     * @example
	     *
	     *      R.test(/^x/, 'xyz'); //=> true
	     *      R.test(/^y/, 'xyz'); //=> false
	     */
	    var test = _curry2(function test(pattern, str) {
	        if (!_isRegExp(pattern)) {
	            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
	        }
	        return _cloneRegExp(pattern).test(str);
	    });

	    /**
	     * The lower case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to lower case.
	     * @return {String} The lower case version of `str`.
	     * @see R.toUpper
	     * @example
	     *
	     *      R.toLower('XYZ'); //=> 'xyz'
	     */
	    var toLower = invoker(0, 'toLowerCase');

	    /**
	     * The upper case version of a string.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.9.0
	     * @category String
	     * @sig String -> String
	     * @param {String} str The string to upper case.
	     * @return {String} The upper case version of `str`.
	     * @see R.toLower
	     * @example
	     *
	     *      R.toUpper('abc'); //=> 'ABC'
	     */
	    var toUpper = invoker(0, 'toUpperCase');

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list, based upon the value returned by applying the supplied function to
	     * each list element. Prefers the first item if the supplied function produces
	     * the same value on two items. `R.equals` is used for comparison.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.16.0
	     * @category List
	     * @sig (a -> b) -> [a] -> [a]
	     * @param {Function} fn A function used to produce a value to use during comparisons.
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	     */
	    var uniqBy = _curry2(function uniqBy(fn, list) {
	        var set = new _Set();
	        var result = [];
	        var idx = 0;
	        var appliedItem, item;
	        while (idx < list.length) {
	            item = list[idx];
	            appliedItem = fn(item);
	            if (set.add(appliedItem)) {
	                result.push(item);
	            }
	            idx += 1;
	        }
	        return result;
	    });

	    /**
	     * Returns a new list containing only one copy of each element in the original
	     * list. `R.equals` is used to determine equality.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category List
	     * @sig [a] -> [a]
	     * @param {Array} list The array to consider.
	     * @return {Array} The list of unique items.
	     * @example
	     *
	     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	     *      R.uniq([1, '1']);     //=> [1, '1']
	     *      R.uniq([[42], [42]]); //=> [[42]]
	     */
	    var uniq = uniqBy(identity);

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of those
	     * elements common to both lists.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} list1 The first list.
	     * @param {Array} list2 The second list.
	     * @return {Array} The list of elements found in both `list1` and `list2`.
	     * @see R.intersectionWith
	     * @example
	     *
	     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	     */
	    var intersection = _curry2(function intersection(list1, list2) {
	        var lookupList, filteredList;
	        if (list1.length > list2.length) {
	            lookupList = list1;
	            filteredList = list2;
	        } else {
	            lookupList = list2;
	            filteredList = list1;
	        }
	        return uniq(_filter(flip(_contains)(lookupList), filteredList));
	    });

	    /**
	     * Combines two lists into a set (i.e. no duplicates) composed of the elements
	     * of each list.
	     *
	     * @func
	     * @memberOf R
	     * @since v0.1.0
	     * @category Relation
	     * @sig [*] -> [*] -> [*]
	     * @param {Array} as The first list.
	     * @param {Array} bs The second list.
	     * @return {Array} The first and second lists concatenated, with
	     *         duplicates removed.
	     * @example
	     *
	     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	     */
	    var union = _curry2(compose(uniq, _concat));

	    var R = {
	        F: F,
	        T: T,
	        __: __,
	        add: add,
	        addIndex: addIndex,
	        adjust: adjust,
	        all: all,
	        allPass: allPass,
	        always: always,
	        and: and,
	        any: any,
	        anyPass: anyPass,
	        ap: ap,
	        aperture: aperture,
	        append: append,
	        apply: apply,
	        applySpec: applySpec,
	        assoc: assoc,
	        assocPath: assocPath,
	        binary: binary,
	        bind: bind,
	        both: both,
	        call: call,
	        chain: chain,
	        clamp: clamp,
	        clone: clone,
	        comparator: comparator,
	        complement: complement,
	        compose: compose,
	        composeK: composeK,
	        composeP: composeP,
	        concat: concat,
	        cond: cond,
	        construct: construct,
	        constructN: constructN,
	        contains: contains,
	        converge: converge,
	        countBy: countBy,
	        curry: curry,
	        curryN: curryN,
	        dec: dec,
	        defaultTo: defaultTo,
	        difference: difference,
	        differenceWith: differenceWith,
	        dissoc: dissoc,
	        dissocPath: dissocPath,
	        divide: divide,
	        drop: drop,
	        dropLast: dropLast,
	        dropLastWhile: dropLastWhile,
	        dropRepeats: dropRepeats,
	        dropRepeatsWith: dropRepeatsWith,
	        dropWhile: dropWhile,
	        either: either,
	        empty: empty,
	        eqBy: eqBy,
	        eqProps: eqProps,
	        equals: equals,
	        evolve: evolve,
	        filter: filter,
	        find: find,
	        findIndex: findIndex,
	        findLast: findLast,
	        findLastIndex: findLastIndex,
	        flatten: flatten,
	        flip: flip,
	        forEach: forEach,
	        fromPairs: fromPairs,
	        groupBy: groupBy,
	        groupWith: groupWith,
	        gt: gt,
	        gte: gte,
	        has: has,
	        hasIn: hasIn,
	        head: head,
	        identical: identical,
	        identity: identity,
	        ifElse: ifElse,
	        inc: inc,
	        indexBy: indexBy,
	        indexOf: indexOf,
	        init: init,
	        insert: insert,
	        insertAll: insertAll,
	        intersection: intersection,
	        intersectionWith: intersectionWith,
	        intersperse: intersperse,
	        into: into,
	        invert: invert,
	        invertObj: invertObj,
	        invoker: invoker,
	        is: is,
	        isArrayLike: isArrayLike,
	        isEmpty: isEmpty,
	        isNil: isNil,
	        join: join,
	        juxt: juxt,
	        keys: keys,
	        keysIn: keysIn,
	        last: last,
	        lastIndexOf: lastIndexOf,
	        length: length,
	        lens: lens,
	        lensIndex: lensIndex,
	        lensPath: lensPath,
	        lensProp: lensProp,
	        lift: lift,
	        liftN: liftN,
	        lt: lt,
	        lte: lte,
	        map: map,
	        mapAccum: mapAccum,
	        mapAccumRight: mapAccumRight,
	        mapObjIndexed: mapObjIndexed,
	        match: match,
	        mathMod: mathMod,
	        max: max,
	        maxBy: maxBy,
	        mean: mean,
	        median: median,
	        memoize: memoize,
	        merge: merge,
	        mergeAll: mergeAll,
	        mergeWith: mergeWith,
	        mergeWithKey: mergeWithKey,
	        min: min,
	        minBy: minBy,
	        modulo: modulo,
	        multiply: multiply,
	        nAry: nAry,
	        negate: negate,
	        none: none,
	        not: not,
	        nth: nth,
	        nthArg: nthArg,
	        objOf: objOf,
	        of: of,
	        omit: omit,
	        once: once,
	        or: or,
	        over: over,
	        pair: pair,
	        partial: partial,
	        partialRight: partialRight,
	        partition: partition,
	        path: path,
	        pathEq: pathEq,
	        pathOr: pathOr,
	        pathSatisfies: pathSatisfies,
	        pick: pick,
	        pickAll: pickAll,
	        pickBy: pickBy,
	        pipe: pipe,
	        pipeK: pipeK,
	        pipeP: pipeP,
	        pluck: pluck,
	        prepend: prepend,
	        product: product,
	        project: project,
	        prop: prop,
	        propEq: propEq,
	        propIs: propIs,
	        propOr: propOr,
	        propSatisfies: propSatisfies,
	        props: props,
	        range: range,
	        reduce: reduce,
	        reduceBy: reduceBy,
	        reduceRight: reduceRight,
	        reduceWhile: reduceWhile,
	        reduced: reduced,
	        reject: reject,
	        remove: remove,
	        repeat: repeat,
	        replace: replace,
	        reverse: reverse,
	        scan: scan,
	        sequence: sequence,
	        set: set,
	        slice: slice,
	        sort: sort,
	        sortBy: sortBy,
	        split: split,
	        splitAt: splitAt,
	        splitEvery: splitEvery,
	        splitWhen: splitWhen,
	        subtract: subtract,
	        sum: sum,
	        symmetricDifference: symmetricDifference,
	        symmetricDifferenceWith: symmetricDifferenceWith,
	        tail: tail,
	        take: take,
	        takeLast: takeLast,
	        takeLastWhile: takeLastWhile,
	        takeWhile: takeWhile,
	        tap: tap,
	        test: test,
	        times: times,
	        toLower: toLower,
	        toPairs: toPairs,
	        toPairsIn: toPairsIn,
	        toString: toString,
	        toUpper: toUpper,
	        transduce: transduce,
	        transpose: transpose,
	        traverse: traverse,
	        trim: trim,
	        tryCatch: tryCatch,
	        type: type,
	        unapply: unapply,
	        unary: unary,
	        uncurryN: uncurryN,
	        unfold: unfold,
	        union: union,
	        unionWith: unionWith,
	        uniq: uniq,
	        uniqBy: uniqBy,
	        uniqWith: uniqWith,
	        unless: unless,
	        unnest: unnest,
	        until: until,
	        update: update,
	        useWith: useWith,
	        values: values,
	        valuesIn: valuesIn,
	        view: view,
	        when: when,
	        where: where,
	        whereEq: whereEq,
	        without: without,
	        wrap: wrap,
	        xprod: xprod,
	        zip: zip,
	        zipObj: zipObj,
	        zipWith: zipWith
	    };
	  /* eslint-env amd */

	  /* TEST_ENTRY_POINT */

	  if (true) {
	    module.exports = R;
	  } else if (typeof define === 'function' && define.amd) {
	    define(function() { return R; });
	  } else {
	    this.R = R;
	  }

	}.call(this));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    Either: __webpack_require__(20),
	    Future: __webpack_require__(22),
	    Identity: __webpack_require__(23),
	    IO: __webpack_require__(24),
	    lift2: __webpack_require__(25),
	    lift3: __webpack_require__(26),
	    Maybe: __webpack_require__(27),
	    Tuple: __webpack_require__(28),
	    Reader: __webpack_require__(29)
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	var util = __webpack_require__(21);


	function Either(left, right) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Either');
	    case 1:
	      return function(right) {
	        return right == null ? Either.Left(left) : Either.Right(right);
	      };
	    default:
	      return right == null ? Either.Left(left) : Either.Right(right);
	  }
	}

	Either.prototype['@@type'] = 'ramda-fantasy/Either';

	Either.prototype.map = util.returnThis;

	Either.of = Either.prototype.of = function(value) {
	  return Either.Right(value);
	};

	Either.prototype.chain = util.returnThis; // throw?


	Either.equals = Either.prototype.equals = util.getEquals(Either);

	Either.either = R.curry(function either(leftFn, rightFn, e) {
	  if (e instanceof _Left) {
	    return leftFn(e.value);
	  } else if (e instanceof _Right) {
	    return rightFn(e.value);
	  } else {
	    throw new TypeError('invalid type given to Either.either');
	  }
	});

	Either.isLeft = function(x) {
	  return x.isLeft;
	};

	Either.isRight = function(x) {
	  return x.isRight;
	};


	// Right
	function _Right(x) {
	  this.value = x;
	}
	util.extend(_Right, Either);

	_Right.prototype.isRight = true;
	_Right.prototype.isLeft = false;

	_Right.prototype.map = function(fn) {
	  return new _Right(fn(this.value));
	};

	_Right.prototype.ap = function(that) {
	  return that.map(this.value);
	};

	_Right.prototype.chain = function(f) {
	  return f(this.value);
	};

	_Right.prototype.bimap = function(_, f) {
	  return new _Right(f(this.value));
	};

	_Right.prototype.extend = function(f) {
	  return new _Right(f(this));
	};

	_Right.prototype.toString = function() {
	  return 'Either.Right(' + R.toString(this.value) + ')';
	};

	Either.Right = function(value) {
	  return new _Right(value);
	};


	// Left
	function _Left(x) {
	  this.value = x;
	}
	util.extend(_Left, Either);

	_Left.prototype.isLeft = true;
	_Left.prototype.isRight = false;

	_Left.prototype.ap = util.returnThis;

	_Left.prototype.bimap = function(f) {
	  return new _Left(f(this.value));
	};

	_Left.prototype.extend = util.returnThis;

	_Left.prototype.toString = function() {
	  return 'Either.Left(' + R.toString(this.value) + ')';
	};

	Either.Left = function(value) {
	  return new _Left(value);
	};


	module.exports = Either;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var _equals = __webpack_require__(18).equals;


	module.exports = {

	  baseMap: function(f) {
	    return f(this.value);
	  },

	  getEquals: function(constructor) {
	    return function equals(that) {
	      return that instanceof constructor && _equals(this.value, that.value);
	    };
	  },

	  extend: function(Child, Parent) {
	    function Ctor() {
	      this.constructor = Child;
	    }
	    Ctor.prototype = Parent.prototype;
	    Child.prototype = new Ctor();
	    Child.super_ = Parent.prototype;
	  },

	  identity: function(x) { return x; },

	  notImplemented: function(str) {
	    return function() {
	      throw new Error(str + ' is not implemented');
	    };
	  },

	  notCallable: function(fn) {
	    return function() {
	      throw new Error(fn + ' cannot be called directly');
	    };
	  },

	  returnThis: function() { return this; }

	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	function jail(handler, f){
	  return function(a){
	    try{
	      return f(a);
	    } catch(err) {
	      handler(err);
	    }
	  };
	}

	// `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)
	function Future(f) {
	  if (!(this instanceof Future)) {
	    return new Future(f);
	  }
	  this._fork = f;
	}

	Future.prototype['@@type'] = 'ramda-fantasy/Future';

	Future.prototype.fork = function(reject, resolve) {
	  this._fork(reject, jail(reject, resolve));
	};

	// functor
	Future.prototype.map = function(f) {
	  return this.chain(function(a) { return Future.of(f(a)); });
	};

	// apply
	Future.prototype.ap = function(m) {
	  var self = this;

	  return new Future(function(rej, res) {
	    var applyFn, val;
	    var doReject = R.once(rej);

	    var resolveIfDone = jail(doReject, function() {
	      if (applyFn != null && val != null) {
	        return res(applyFn(val));
	      }
	    });

	    self._fork(doReject, function(fn) {
	      applyFn = fn;
	      resolveIfDone();
	    });

	    m._fork(doReject, function(v) {
	      val = v;
	      resolveIfDone();
	    });

	  });

	};

	// applicative
	Future.of = function(x) {
	  // should include a default rejection?
	  return new Future(function(_, resolve) { return resolve(x); });
	};

	Future.prototype.of = Future.of;

	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	//:: Future a, b => (b -> Future c) -> Future c
	Future.prototype.chain = function(f) {  // Sorella's:
	  return new Future(function(reject, resolve) {
	    return this._fork(
	      function(a) { return reject(a); },
	      jail(reject, function(b) { return f(b)._fork(reject, resolve); })
	    );
	  }.bind(this));
	};

	// chainReject
	// Like chain but operates on the reject instead of the resolve case.
	//:: Future a, b => (a -> Future c) -> Future c
	Future.prototype.chainReject = function(f) {
	  return new Future(function(reject, resolve) {
	    return this._fork(
	      jail(reject, function(a) { return f(a)._fork(reject, resolve); }),
	      function(b) { return resolve(b); }
	    );
	  }.bind(this));
	};

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	Future.prototype.bimap = function(errFn, successFn) {
	  var self = this;
	  return new Future(function(reject, resolve) {
	    self._fork(
	      jail(reject, function(err) { reject(errFn(err)); }),
	      jail(reject, function(val) { resolve(successFn(val)); })
	    );
	  });
	};

	Future.reject = function(val) {
	  return new Future(function(reject) {
	    reject(val);
	  });
	};

	Future.prototype.toString = function() {
	  return 'Future(' + R.toString(this._fork) + ')';
	};

	Future.cache = function(f) {
	  var status = 'IDLE';
	  var listeners = [];
	  var cachedValue;

	  var handleCompletion = R.curry(function(newStatus, cb, val) {
	    status = newStatus;
	    cachedValue = val;
	    cb(val);
	    R.forEach(function(listener) {
	      listener[status](cachedValue);
	    }, listeners);
	  });

	  function addListeners(reject, resolve) {
	    listeners.push({ REJECTED: reject, RESOLVED: resolve } );
	  }

	  function doResolve(reject, resolve) {
	    status = 'PENDING';
	    return f._fork(
	      handleCompletion('REJECTED', reject),
	      handleCompletion('RESOLVED', resolve)
	    );
	  }

	  return new Future(function(reject, resolve) {

	    switch(status) {
	      case 'IDLE': doResolve(reject, resolve); break;
	      case 'PENDING': addListeners(reject, resolve); break;
	      case 'REJECTED': reject(cachedValue); break;
	      case 'RESOLVED': resolve(cachedValue); break;
	    }

	  });
	};

	module.exports = Future;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	var util = __webpack_require__(21);


	/**
	 * A data type that holds a value and exposes a monadic api.
	 */

	/**
	 * Constructs a new `Identity[a]` data type that holds a single
	 * value `a`.
	 * @param {*} a Value of any type
	 * @sig a -> Identity[a]
	 */
	function Identity(x) {
	  if (!(this instanceof Identity)) {
	    return new Identity(x);
	  }
	  this.value = x;
	}

	Identity.prototype['@@type'] = 'ramda-fantasy/Identity';

	/**
	 * Applicative specification. Creates a new `Identity[a]` holding the value `a`.
	 * @param {*} a Value of any type
	 * @returns Identity[a]
	 * @sig a -> Identity[a]
	 */
	Identity.of = function(x) {
	  return new Identity(x);
	};
	Identity.prototype.of = Identity.of;

	/**
	 * Functor specification. Creates a new `Identity[a]` mapping function `f` onto
	 * `a` returning any value b.
	 * @param {Function} f Maps `a` to any value `b`
	 * @returns Identity[b]
	 * @sig @Identity[a] => (a -> b) -> Identity[b]
	 */
	Identity.prototype.map = function(f) {
	  return new Identity(f(this.value));
	};

	/**
	 * Apply specification. Applies the function inside the `Identity[a]`
	 * type to another applicative type.
	 * @param {Applicative[a]} app Applicative that will apply its function
	 * @returns Applicative[b]
	 * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]
	 */
	Identity.prototype.ap = function(app) {
	  return app.map(this.value);
	};

	/**
	 * Chain specification. Transforms the value of the `Identity[a]`
	 * type using an unary function to monads. The `Identity[a]` type
	 * should contain a function, otherwise an error is thrown.
	 *
	 * @param {Function} fn Transforms `a` into a `Monad[b]`
	 * @returns Monad[b]
	 * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]
	 */
	Identity.prototype.chain = function(fn) {
	  return fn(this.value);
	};

	/**
	 * Returns the value of `Identity[a]`
	 *
	 * @returns a
	 * @sig (Identity[a]) => a
	 */
	Identity.prototype.get = function() {
	  return this.value;
	};

	// equality method to enable testing
	Identity.prototype.equals = util.getEquals(Identity);

	Identity.prototype.toString = function() {
	  return 'Identity(' + R.toString(this.value) + ')';
	};

	module.exports = Identity;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	module.exports = IO;

	var compose = R.compose;

	function IO(fn) {
	  if (!(this instanceof IO)) {
	    return new IO(fn);
	  }
	  this.fn = fn;
	}

	IO.prototype['@@type'] = 'ramda-fantasy/IO';

	// `f` must return an IO
	IO.prototype.chain = function(f) {
	  var io = this;
	  return new IO(function() {
	    var next = f(io.fn.apply(io, arguments));
	    return next.fn.apply(next, arguments);
	  });
	};

	IO.prototype.map = function(f) {
	  var io = this;
	  return new IO(compose(f, io.fn));
	};

	// `this` IO must wrap a function `f` that takes an IO (`thatIo`) as input
	// `f` must return an IO
	IO.prototype.ap = function(thatIo) {
	  return this.chain(function(f) {
	    return thatIo.map(f);
	  });
	};

	IO.runIO = function(io) {
	  return io.runIO.apply(io, [].slice.call(arguments, 1));
	};

	IO.prototype.runIO = function() {
	  return this.fn.apply(this, arguments);
	};

	IO.prototype.of = function(x) {
	  return new IO(function() { return x; });
	};

	IO.of = IO.prototype.of;

	IO.prototype.toString = function() {
	  return 'IO(' + R.toString(this.fn) + ')';
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	module.exports = R.curryN(3, function lift2(f, a1, a2) {
	  return a1.map(f).ap(a2);
	});


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	module.exports = R.curryN(4, function lift3(f, a1, a2, a3) {
	  return a1.map(f).ap(a2).ap(a3);
	});


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);

	var util = __webpack_require__(21);

	function Maybe(x) {
	  return x == null ? _nothing : Maybe.Just(x);
	}

	Maybe.prototype['@@type'] = 'ramda-fantasy/Maybe';

	function Just(x) {
	  this.value = x;
	}
	util.extend(Just, Maybe);

	Just.prototype.isJust = true;
	Just.prototype.isNothing = false;

	function Nothing() {}
	util.extend(Nothing, Maybe);

	Nothing.prototype.isNothing = true;
	Nothing.prototype.isJust = false;

	var _nothing = new Nothing();

	Maybe.Nothing = function() {
	  return _nothing;
	};

	Maybe.Just = function(x) {
	  return new Just(x);
	};

	Maybe.of = Maybe.Just;

	Maybe.prototype.of = Maybe.Just;

	Maybe.isJust = function(x) {
	  return x.isJust;
	};

	Maybe.isNothing = function(x) {
	  return x.isNothing;
	};

	Maybe.maybe = R.curry(function(nothingVal, justFn, m) {
	  return m.reduce(function(_, x) {
	    return justFn(x);
	  }, nothingVal);
	});

	// functor
	Just.prototype.map = function(f) {
	  return this.of(f(this.value));
	};

	Nothing.prototype.map = util.returnThis;

	// apply
	// takes a Maybe that wraps a function (`app`) and applies its `map`
	// method to this Maybe's value, which must be a function.
	Just.prototype.ap = function(m) {
	  return m.map(this.value);
	};

	Nothing.prototype.ap = util.returnThis;

	// applicative
	// `of` inherited from `Maybe`


	// chain
	//  f must be a function which returns a value
	//  f must return a value of the same Chain
	//  chain must return a value of the same Chain
	Just.prototype.chain = util.baseMap;

	Nothing.prototype.chain = util.returnThis;


	//
	Just.prototype.datatype = Just;

	Nothing.prototype.datatype = Nothing;

	// monad
	// A value that implements the Monad specification must also implement the Applicative and Chain specifications.
	// see above.

	// equality method to enable testing
	Just.prototype.equals = util.getEquals(Just);

	Nothing.prototype.equals = function(that) {
	  return that === _nothing;
	};

	Maybe.prototype.isNothing = function() {
	  return this === _nothing;
	};

	Maybe.prototype.isJust = function() {
	  return this instanceof Just;
	};

	Just.prototype.getOrElse = function() {
	  return this.value;
	};

	Nothing.prototype.getOrElse = function(a) {
	  return a;
	};

	Just.prototype.reduce = function(f, x) {
	  return f(x, this.value);
	};

	Nothing.prototype.reduce = function(f, x) {
	  return x;
	};

	Just.prototype.toString = function() {
	  return 'Maybe.Just(' + R.toString(this.value) + ')';
	};

	Nothing.prototype.toString = function() {
	  return 'Maybe.Nothing()';
	};

	module.exports = Maybe;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);


	function Tuple(x, y) {
	  switch (arguments.length) {
	    case 0:
	      throw new TypeError('no arguments to Tuple');
	    case 1:
	      return function(y) {
	        return new _Tuple(x, y);
	      };
	    default:
	      return new _Tuple(x, y);
	  }
	}

	function _Tuple(x, y) {
	  this[0] = x;
	  this[1] = y;
	  this.length = 2;
	}

	function ensureConcat(xs) {
	  xs.forEach(function(x) {
	    if (typeof x.concat != 'function') {
	      throw new TypeError(R.toString(x) + ' must be a semigroup to perform this operation');
	    }
	  });
	}

	Tuple.fst = function(x) {
	  return x[0];
	};

	Tuple.snd = function(x) {
	  return x[1];
	};

	_Tuple.prototype['@@type'] = 'ramda-fantasy/Tuple';

	// semigroup
	_Tuple.prototype.concat = function(x) {
	  ensureConcat([this[0], this[1]]);
	  return Tuple(this[0].concat(x[0]), this[1].concat(x[1]));
	};

	// functor
	_Tuple.prototype.map = function(f) {
	  return Tuple(this[0], f(this[1]));
	};

	// apply
	_Tuple.prototype.ap = function(m) {
	  ensureConcat([this[0]]);
	  return Tuple(this[0].concat(m[0]), this[1](m[1]));
	};

	// setoid
	_Tuple.prototype.equals = function(that) {
	  return that instanceof _Tuple && R.equals(this[0], that[0]) && R.equals(this[1], that[1]);
	};

	_Tuple.prototype.toString = function() {
	  return 'Tuple(' + R.toString(this[0]) + ', ' + R.toString(this[1]) + ')';
	};

	module.exports = Tuple;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var R = __webpack_require__(18);


	function Reader(run) {
	  if (!(this instanceof Reader)) {
	    return new Reader(run);
	  }
	  this.run = run;
	}

	Reader.run = function(reader) {
	  return reader.run.apply(reader, [].slice.call(arguments, 1));
	};

	Reader.prototype['@@type'] = 'ramda-fantasy/Reader';

	Reader.prototype.chain = function(f) {
	  var reader = this;
	  return new Reader(function(r) {
	    return f(reader.run(r)).run(r);
	  });
	};

	Reader.prototype.ap = function(a) {
	  return this.chain(function(f) {
	    return a.map(f);
	  });
	};

	Reader.prototype.map = function(f) {
	  return this.chain(function(a) {
	    return Reader.of(f(a));
	  });
	};

	Reader.prototype.of = function(a) {
	  return new Reader(function() {
	    return a;
	  });
	};
	Reader.of = Reader.prototype.of;

	Reader.ask = Reader(R.identity);

	Reader.prototype.toString = function() {
	  return 'Reader(' + R.toString(this.run) + ')';
	};

	Reader.T = function(M) {
	  var ReaderT = function ReaderT(run) {
	    if (!(this instanceof ReaderT)) {
	      return new ReaderT(run);
	    }
	    this.run = run;
	  };

	  ReaderT.lift = R.compose(ReaderT, R.always);

	  ReaderT.ask = ReaderT(M.of);

	  ReaderT.prototype.of = ReaderT.of = function(a) {
	    return ReaderT(function() {
	      return M.of(a);
	    });
	  };

	  ReaderT.prototype.chain = function(f) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      var m = readerT.run(e);
	      return m.chain(function(a) {
	        return f(a).run(e);
	      });
	    });
	  };

	  ReaderT.prototype.map = function(f) {
	    return this.chain(function(a) {
	      return ReaderT.of(f(a));
	    });
	  };

	  ReaderT.prototype.ap = function(a) {
	    var readerT = this;
	    return ReaderT(function(e) {
	      return readerT.run(e).ap(a.run(e));
	    });
	  };

	  ReaderT.prototype.equals = function(that) {
	    return this === that ||
	      this.run === that.run ||
	      R.equals(this.run().get(), that.run().get());
	  };

	  ReaderT.prototype.toString = function() {
	    return 'ReaderT[' + M.name + '](' + R.toString(this.run) + ')';
	  };

	  return ReaderT;
	};

	module.exports = Reader;


/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	const TokenClass = exports.TokenClass = {
	  Eof: { name: '<End>' },
	  Ident: { name: 'Identifier', isIdentifierName: true },
	  Keyword: { name: 'Keyword', isIdentifierName: true },
	  NumericLiteral: { name: 'Numeric' },
	  TemplateElement: { name: 'Template' },
	  Punctuator: { name: 'Punctuator' },
	  StringLiteral: { name: 'String' },
	  RegularExpression: { name: 'RegularExpression' },
	  Illegal: { name: 'Illegal' }
	};

	const TC = TokenClass;

	const TokenType = exports.TokenType = {
	  EOS: { klass: TC.Eof, name: 'EOS' },
	  LPAREN: { klass: TC.Punctuator, name: '(' },
	  RPAREN: { klass: TC.Punctuator, name: ')' },
	  LBRACK: { klass: TC.Punctuator, name: '[' },
	  RBRACK: { klass: TC.Punctuator, name: ']' },
	  LBRACE: { klass: TC.Punctuator, name: '{' },
	  RBRACE: { klass: TC.Punctuator, name: '}' },
	  COLON: { klass: TC.Punctuator, name: ':' },
	  SEMICOLON: { klass: TC.Punctuator, name: ';' },
	  PERIOD: { klass: TC.Punctuator, name: '.' },
	  ELLIPSIS: { klass: TC.Punctuator, name: '...' },
	  ARROW: { klass: TC.Punctuator, name: '=>' },
	  CONDITIONAL: { klass: TC.Punctuator, name: '?' },
	  INC: { klass: TC.Punctuator, name: '++' },
	  DEC: { klass: TC.Punctuator, name: '--' },
	  ASSIGN: { klass: TC.Punctuator, name: '=' },
	  ASSIGN_BIT_OR: { klass: TC.Punctuator, name: '|=' },
	  ASSIGN_BIT_XOR: { klass: TC.Punctuator, name: '^=' },
	  ASSIGN_BIT_AND: { klass: TC.Punctuator, name: '&=' },
	  ASSIGN_SHL: { klass: TC.Punctuator, name: '<<=' },
	  ASSIGN_SHR: { klass: TC.Punctuator, name: '>>=' },
	  ASSIGN_SHR_UNSIGNED: { klass: TC.Punctuator, name: '>>>=' },
	  ASSIGN_ADD: { klass: TC.Punctuator, name: '+=' },
	  ASSIGN_SUB: { klass: TC.Punctuator, name: '-=' },
	  ASSIGN_MUL: { klass: TC.Punctuator, name: '*=' },
	  ASSIGN_DIV: { klass: TC.Punctuator, name: '/=' },
	  ASSIGN_MOD: { klass: TC.Punctuator, name: '%=' },
	  ASSIGN_EXP: { klass: TC.Punctuator, name: '**=' },
	  COMMA: { klass: TC.Punctuator, name: ',' },
	  OR: { klass: TC.Punctuator, name: '||' },
	  AND: { klass: TC.Punctuator, name: '&&' },
	  BIT_OR: { klass: TC.Punctuator, name: '|' },
	  BIT_XOR: { klass: TC.Punctuator, name: '^' },
	  BIT_AND: { klass: TC.Punctuator, name: '&' },
	  SHL: { klass: TC.Punctuator, name: '<<' },
	  SHR: { klass: TC.Punctuator, name: '>>' },
	  SHR_UNSIGNED: { klass: TC.Punctuator, name: '>>>' },
	  ADD: { klass: TC.Punctuator, name: '+' },
	  SUB: { klass: TC.Punctuator, name: '-' },
	  MUL: { klass: TC.Punctuator, name: '*' },
	  DIV: { klass: TC.Punctuator, name: '/' },
	  MOD: { klass: TC.Punctuator, name: '%' },
	  EXP: { klass: TC.Punctuator, name: '**' },
	  EQ: { klass: TC.Punctuator, name: '==' },
	  NE: { klass: TC.Punctuator, name: '!=' },
	  EQ_STRICT: { klass: TC.Punctuator, name: '===' },
	  NE_STRICT: { klass: TC.Punctuator, name: '!==' },
	  LT: { klass: TC.Punctuator, name: '<' },
	  GT: { klass: TC.Punctuator, name: '>' },
	  LTE: { klass: TC.Punctuator, name: '<=' },
	  GTE: { klass: TC.Punctuator, name: '>=' },
	  INSTANCEOF: { klass: TC.Keyword, name: 'instanceof' },
	  IN: { klass: TC.Keyword, name: 'in' },
	  NOT: { klass: TC.Punctuator, name: '!' },
	  BIT_NOT: { klass: TC.Punctuator, name: '~' },
	  AWAIT: { klass: TC.Keyword, name: 'await' },
	  DELETE: { klass: TC.Keyword, name: 'delete' },
	  TYPEOF: { klass: TC.Keyword, name: 'typeof' },
	  VOID: { klass: TC.Keyword, name: 'void' },
	  BREAK: { klass: TC.Keyword, name: 'break' },
	  CASE: { klass: TC.Keyword, name: 'case' },
	  CATCH: { klass: TC.Keyword, name: 'catch' },
	  CLASS: { klass: TC.Keyword, name: 'class' },
	  CONTINUE: { klass: TC.Keyword, name: 'continue' },
	  DEBUGGER: { klass: TC.Keyword, name: 'debugger' },
	  DEFAULT: { klass: TC.Keyword, name: 'default' },
	  DO: { klass: TC.Keyword, name: 'do' },
	  ELSE: { klass: TC.Keyword, name: 'else' },
	  EXPORT: { klass: TC.Keyword, name: 'export' },
	  EXTENDS: { klass: TC.Keyword, name: 'extends' },
	  FINALLY: { klass: TC.Keyword, name: 'finally' },
	  FOR: { klass: TC.Keyword, name: 'for' },
	  FUNCTION: { klass: TC.Keyword, name: 'function' },
	  IF: { klass: TC.Keyword, name: 'if' },
	  IMPORT: { klass: TC.Keyword, name: 'import' },
	  LET: { klass: TC.Keyword, name: 'let' },
	  NEW: { klass: TC.Keyword, name: 'new' },
	  RETURN: { klass: TC.Keyword, name: 'return' },
	  SUPER: { klass: TC.Keyword, name: 'super' },
	  SWITCH: { klass: TC.Keyword, name: 'switch' },
	  THIS: { klass: TC.Keyword, name: 'this' },
	  THROW: { klass: TC.Keyword, name: 'throw' },
	  TRY: { klass: TC.Keyword, name: 'try' },
	  VAR: { klass: TC.Keyword, name: 'var' },
	  WHILE: { klass: TC.Keyword, name: 'while' },
	  WITH: { klass: TC.Keyword, name: 'with' },
	  NULL: { klass: TC.Keyword, name: 'null' },
	  TRUE: { klass: TC.Keyword, name: 'true' },
	  FALSE: { klass: TC.Keyword, name: 'false' },
	  YIELD: { klass: TC.Keyword, name: 'yield' },
	  NUMBER: { klass: TC.NumericLiteral, name: '' },
	  STRING: { klass: TC.StringLiteral, name: '' },
	  REGEXP: { klass: TC.RegularExpression, name: '' },
	  IDENTIFIER: { klass: TC.Ident, name: '' },
	  CONST: { klass: TC.Keyword, name: 'const' },
	  TEMPLATE: { klass: TC.TemplateElement, name: '' },
	  ILLEGAL: { klass: TC.Illegal, name: '' }
	};

	const TT = TokenType;

	const punctuatorTable = exports.punctuatorTable = {
	  '(': TT.LPAREN, ')': TT.RPAREN,
	  '[': TT.LBRACK, ']': TT.RBRACK,
	  '{': TT.LBRACE, '}': TT.RBRACE,
	  ':': TT.COLON, ';': TT.SEMICOLON,
	  '.': TT.PERIOD, '...': TT.ELLIPSIS,
	  '=>': TT.ARROW, '?': TT.CONDITIONAL,
	  '++': TT.INC, '--': TT.DEC,
	  '=': TT.ASSIGN, '|=': TT.ASSIGN_BIT_OR, '^=': TT.ASSIGN_BIT_XOR, '&=': TT.ASSIGN_BIT_AND,
	  '<<=': TT.ASSIGN_SHL, '>>=': TT.ASSIGN_SHR, '>>>=': TT.ASSIGN_SHR_UNSIGNED,
	  '+=': TT.ASSIGN_ADD, '-=': TT.ASSIGN_SUB, '*=': TT.ASSIGN_MUL,
	  '/=': TT.ASSIGN_DIV, '%=': TT.ASSIGN_MOD, '**=': TT.ASSIGN_EXP,
	  ',': TT.COMMA,
	  '||': TT.OR, '&&': TT.AND,
	  '|': TT.BIT_OR, '&': TT.BIT_AND, '^': TT.BIT_XOR,
	  '<<': TT.SHL, '>>': TT.SHR, '>>>': TT.SHR_UNSIGNED,
	  '+': TT.ADD, '-': TT.SUB, '*': TT.MUL, '/': TT.DIV,
	  '%': TT.MOD, '**': TT.EXP,
	  '==': TT.EQ, '!=': TT.NE, '===': TT.EQ_STRICT, '!==': TT.NE_STRICT,
	  '<': TT.LT, '>': TT.GT, '<=': TT.LTE, '>=': TT.GTE,
	  '!': TT.NOT, '~': TT.BIT_NOT
	};

	const keywordTable = exports.keywordTable = {
	  // 'await': TT.AWAIT, TODO: uncomment when new version of shift is used
	  // TODO: add 'async'
	  'break': TT.BREAK,
	  'case': TT.CASE, 'catch': TT.CATCH, 'class': TT.CLASS, 'const': TT.CONST, 'continue': TT.CONTINUE,
	  'delete': TT.DELETE, 'debugger': TT.DEBUGGER, 'default': TT.DEFAULT, 'do': TT.DO,
	  'else': TT.ELSE, 'export': TT.EXPORT, 'extends': TT.EXTENDS,
	  'false': TT.FALSE, 'finally': TT.FINALLY, 'for': TT.FOR, 'function': TT.FUNCTION,
	  'if': TT.IF, 'import': TT.IMPORT, 'in': TT.IN, 'instanceof': TT.INSTANCEOF,
	  'let': TT.LET,
	  'new': TT.NEW, 'null': TT.NULL,
	  'return': TT.RETURN,
	  'super': TT.SUPER, 'switch': TT.SWITCH,
	  'this': TT.THIS, 'throw': TT.THROW, 'true': TT.TRUE, 'try': TT.TRY, 'typeof': TT.TYPEOF,
	  'var': TT.VAR, 'void': TT.VOID,
	  'while': TT.WHILE, 'with': TT.WITH,
	  'yield': TT.YIELD
	};

	const EmptyToken = exports.EmptyToken = {};

	class BaseToken {

	  constructor({ type, value, slice }) {
	    this.type = type;
	    this.value = value;
	    this.slice = slice;
	  }
	}

	class StringToken {
	  constructor({ str, octal, slice }) {
	    this.type = TT.STRING;
	    this.str = str;
	    this.octal = octal;
	    this.slice = slice;
	  }
	}

	exports.StringToken = StringToken;
	class IdentifierToken extends BaseToken {
	  constructor({ value, slice }) {
	    super({ type: TT.IDENTIFIER, value, slice });
	  }
	}

	exports.IdentifierToken = IdentifierToken;
	class KeywordToken extends BaseToken {
	  constructor({ value, slice }) {
	    super({ type: keywordTable[value], value, slice });
	  }
	}

	exports.KeywordToken = KeywordToken;
	class PunctuatorToken extends BaseToken {
	  constructor({ value, slice }) {
	    super({ type: punctuatorTable[value], value, slice });
	  }
	}

	exports.PunctuatorToken = PunctuatorToken;
	class NumericToken extends BaseToken {

	  constructor({ value, octal = false, noctal = false, slice }) {
	    super({ type: TT.NUMBER, value, slice });
	    this.octal = octal;
	    this.noctal = noctal;
	  }
	}

	exports.NumericToken = NumericToken;
	class TemplateElementToken extends BaseToken {

	  constructor({ value, tail, interp, slice }) {
	    super({ type: TT.TEMPLATE, value, slice });
	    this.tail = tail;
	    this.interp = interp;
	  }
	}

	exports.TemplateElementToken = TemplateElementToken;
	class TemplateToken extends BaseToken {

	  constructor({ items, slice }) {
	    super({ type: TT.TEMPLATE, slice });
	    this.items = items;
	  }
	}

	exports.TemplateToken = TemplateToken;
	class RegExpToken extends BaseToken {
	  constructor({ value, slice }) {
	    super({ type: TT.REGEXP, value, slice });
	  }
	}

	exports.RegExpToken = RegExpToken;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90b2tlbnMuanMiXSwibmFtZXMiOlsiVG9rZW5DbGFzcyIsIkVvZiIsIm5hbWUiLCJJZGVudCIsImlzSWRlbnRpZmllck5hbWUiLCJLZXl3b3JkIiwiTnVtZXJpY0xpdGVyYWwiLCJUZW1wbGF0ZUVsZW1lbnQiLCJQdW5jdHVhdG9yIiwiU3RyaW5nTGl0ZXJhbCIsIlJlZ3VsYXJFeHByZXNzaW9uIiwiSWxsZWdhbCIsIlRDIiwiVG9rZW5UeXBlIiwiRU9TIiwia2xhc3MiLCJMUEFSRU4iLCJSUEFSRU4iLCJMQlJBQ0siLCJSQlJBQ0siLCJMQlJBQ0UiLCJSQlJBQ0UiLCJDT0xPTiIsIlNFTUlDT0xPTiIsIlBFUklPRCIsIkVMTElQU0lTIiwiQVJST1ciLCJDT05ESVRJT05BTCIsIklOQyIsIkRFQyIsIkFTU0lHTiIsIkFTU0lHTl9CSVRfT1IiLCJBU1NJR05fQklUX1hPUiIsIkFTU0lHTl9CSVRfQU5EIiwiQVNTSUdOX1NITCIsIkFTU0lHTl9TSFIiLCJBU1NJR05fU0hSX1VOU0lHTkVEIiwiQVNTSUdOX0FERCIsIkFTU0lHTl9TVUIiLCJBU1NJR05fTVVMIiwiQVNTSUdOX0RJViIsIkFTU0lHTl9NT0QiLCJBU1NJR05fRVhQIiwiQ09NTUEiLCJPUiIsIkFORCIsIkJJVF9PUiIsIkJJVF9YT1IiLCJCSVRfQU5EIiwiU0hMIiwiU0hSIiwiU0hSX1VOU0lHTkVEIiwiQUREIiwiU1VCIiwiTVVMIiwiRElWIiwiTU9EIiwiRVhQIiwiRVEiLCJORSIsIkVRX1NUUklDVCIsIk5FX1NUUklDVCIsIkxUIiwiR1QiLCJMVEUiLCJHVEUiLCJJTlNUQU5DRU9GIiwiSU4iLCJOT1QiLCJCSVRfTk9UIiwiQVdBSVQiLCJERUxFVEUiLCJUWVBFT0YiLCJWT0lEIiwiQlJFQUsiLCJDQVNFIiwiQ0FUQ0giLCJDTEFTUyIsIkNPTlRJTlVFIiwiREVCVUdHRVIiLCJERUZBVUxUIiwiRE8iLCJFTFNFIiwiRVhQT1JUIiwiRVhURU5EUyIsIkZJTkFMTFkiLCJGT1IiLCJGVU5DVElPTiIsIklGIiwiSU1QT1JUIiwiTEVUIiwiTkVXIiwiUkVUVVJOIiwiU1VQRVIiLCJTV0lUQ0giLCJUSElTIiwiVEhST1ciLCJUUlkiLCJWQVIiLCJXSElMRSIsIldJVEgiLCJOVUxMIiwiVFJVRSIsIkZBTFNFIiwiWUlFTEQiLCJOVU1CRVIiLCJTVFJJTkciLCJSRUdFWFAiLCJJREVOVElGSUVSIiwiQ09OU1QiLCJURU1QTEFURSIsIklMTEVHQUwiLCJUVCIsInB1bmN0dWF0b3JUYWJsZSIsImtleXdvcmRUYWJsZSIsIkVtcHR5VG9rZW4iLCJCYXNlVG9rZW4iLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ2YWx1ZSIsInNsaWNlIiwiU3RyaW5nVG9rZW4iLCJzdHIiLCJvY3RhbCIsIklkZW50aWZpZXJUb2tlbiIsIktleXdvcmRUb2tlbiIsIlB1bmN0dWF0b3JUb2tlbiIsIk51bWVyaWNUb2tlbiIsIm5vY3RhbCIsIlRlbXBsYXRlRWxlbWVudFRva2VuIiwidGFpbCIsImludGVycCIsIlRlbXBsYXRlVG9rZW4iLCJpdGVtcyIsIlJlZ0V4cFRva2VuIl0sIm1hcHBpbmdzIjoiOzs7OztBQU1PLE1BQU1BLGtDQUFhO0FBQ3hCQyxPQUFLLEVBQUNDLE1BQU0sT0FBUCxFQURtQjtBQUV4QkMsU0FBTyxFQUFDRCxNQUFNLFlBQVAsRUFBcUJFLGtCQUFrQixJQUF2QyxFQUZpQjtBQUd4QkMsV0FBUyxFQUFDSCxNQUFNLFNBQVAsRUFBa0JFLGtCQUFrQixJQUFwQyxFQUhlO0FBSXhCRSxrQkFBZ0IsRUFBQ0osTUFBTSxTQUFQLEVBSlE7QUFLeEJLLG1CQUFpQixFQUFDTCxNQUFNLFVBQVAsRUFMTztBQU14Qk0sY0FBWSxFQUFDTixNQUFNLFlBQVAsRUFOWTtBQU94Qk8saUJBQWUsRUFBQ1AsTUFBTSxRQUFQLEVBUFM7QUFReEJRLHFCQUFtQixFQUFDUixNQUFNLG1CQUFQLEVBUks7QUFTeEJTLFdBQVMsRUFBQ1QsTUFBTSxTQUFQO0FBVGUsQ0FBbkI7O0FBWVAsTUFBTVUsS0FBS1osVUFBWDs7QUFF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QVksRUFBRWdCLEtBQUYsRUFBU2IsS0FBVCxFQUFaLEVBQXFFO0FBQ25FLFVBQU0sRUFBRUYsTUFBTU4sR0FBR0YsUUFBWCxFQUFxQlUsS0FBckIsRUFBTjtBQUNBLFNBQUthLEtBQUwsR0FBYUEsS0FBYjtBQUNEO0FBTjBDOztRQUFoQ0QsYSxHQUFBQSxhO0FBU04sTUFBTUUsV0FBTixTQUEwQmxCLFNBQTFCLENBQW9DO0FBQ3pDQyxjQUFZLEVBQUVFLEtBQUYsRUFBU0MsS0FBVCxFQUFaLEVBQWdFO0FBQzlELFVBQU0sRUFBRUYsTUFBTU4sR0FBR0wsTUFBWCxFQUFtQlksS0FBbkIsRUFBMEJDLEtBQTFCLEVBQU47QUFDRDtBQUh3Qzs7UUFBOUJjLFcsR0FBQUEsVyIsImZpbGUiOiJ0b2tlbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuXG5leHBvcnQgdHlwZSBMb2NhdGlvbkluZm8gPSB7IGZpbGVuYW1lOiBzdHJpbmcsIHBvc2l0aW9uOiBudW1iZXIsIGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIgfTtcblxuZXhwb3J0IGNvbnN0IFRva2VuQ2xhc3MgPSB7XG4gIEVvZjoge25hbWU6ICc8RW5kPid9LFxuICBJZGVudDoge25hbWU6ICdJZGVudGlmaWVyJywgaXNJZGVudGlmaWVyTmFtZTogdHJ1ZX0sXG4gIEtleXdvcmQ6IHtuYW1lOiAnS2V5d29yZCcsIGlzSWRlbnRpZmllck5hbWU6IHRydWV9LFxuICBOdW1lcmljTGl0ZXJhbDoge25hbWU6ICdOdW1lcmljJ30sXG4gIFRlbXBsYXRlRWxlbWVudDoge25hbWU6ICdUZW1wbGF0ZSd9LFxuICBQdW5jdHVhdG9yOiB7bmFtZTogJ1B1bmN0dWF0b3InfSxcbiAgU3RyaW5nTGl0ZXJhbDoge25hbWU6ICdTdHJpbmcnfSxcbiAgUmVndWxhckV4cHJlc3Npb246IHtuYW1lOiAnUmVndWxhckV4cHJlc3Npb24nfSxcbiAgSWxsZWdhbDoge25hbWU6ICdJbGxlZ2FsJ31cbn07XG5cbmNvbnN0IFRDID0gVG9rZW5DbGFzcztcblxuZXhwb3J0IGNvbnN0IFRva2VuVHlwZSA9IHtcbiAgRU9TOiB7a2xhc3M6IFRDLkVvZiwgbmFtZTogJ0VPUyd9LFxuICBMUEFSRU46IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJygnfSxcbiAgUlBBUkVOOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcpJ30sXG4gIExCUkFDSzoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnWyd9LFxuICBSQlJBQ0s6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJ10nfSxcbiAgTEJSQUNFOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICd7J30sXG4gIFJCUkFDRToge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnfSd9LFxuICBDT0xPTjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnOid9LFxuICBTRU1JQ09MT046IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJzsnfSxcbiAgUEVSSU9EOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcuJ30sXG4gIEVMTElQU0lTOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcuLi4nfSxcbiAgQVJST1c6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJz0+J30sXG4gIENPTkRJVElPTkFMOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc/J30sXG4gIElOQzoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnKysnfSxcbiAgREVDOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICctLSd9LFxuICBBU1NJR046IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJz0nfSxcbiAgQVNTSUdOX0JJVF9PUjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnfD0nfSxcbiAgQVNTSUdOX0JJVF9YT1I6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJ149J30sXG4gIEFTU0lHTl9CSVRfQU5EOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcmPSd9LFxuICBBU1NJR05fU0hMOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc8PD0nfSxcbiAgQVNTSUdOX1NIUjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnPj49J30sXG4gIEFTU0lHTl9TSFJfVU5TSUdORUQ6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJz4+Pj0nfSxcbiAgQVNTSUdOX0FERDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnKz0nfSxcbiAgQVNTSUdOX1NVQjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnLT0nfSxcbiAgQVNTSUdOX01VTDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnKj0nfSxcbiAgQVNTSUdOX0RJVjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnLz0nfSxcbiAgQVNTSUdOX01PRDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnJT0nfSxcbiAgQVNTSUdOX0VYUDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnKio9J30sXG4gIENPTU1BOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcsJ30sXG4gIE9SOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICd8fCd9LFxuICBBTkQ6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJyYmJ30sXG4gIEJJVF9PUjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnfCd9LFxuICBCSVRfWE9SOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICdeJ30sXG4gIEJJVF9BTkQ6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJyYnfSxcbiAgU0hMOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc8PCd9LFxuICBTSFI6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJz4+J30sXG4gIFNIUl9VTlNJR05FRDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnPj4+J30sXG4gIEFERDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnKyd9LFxuICBTVUI6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJy0nfSxcbiAgTVVMOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcqJ30sXG4gIERJVjoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnLyd9LFxuICBNT0Q6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJyUnfSxcbiAgRVhQOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICcqKid9LFxuICBFUToge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnPT0nfSxcbiAgTkU6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJyE9J30sXG4gIEVRX1NUUklDVDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnPT09J30sXG4gIE5FX1NUUklDVDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnIT09J30sXG4gIExUOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc8J30sXG4gIEdUOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc+J30sXG4gIExURToge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnPD0nfSxcbiAgR1RFOiB7a2xhc3M6IFRDLlB1bmN0dWF0b3IsIG5hbWU6ICc+PSd9LFxuICBJTlNUQU5DRU9GOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdpbnN0YW5jZW9mJ30sXG4gIElOOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdpbid9LFxuICBOT1Q6IHtrbGFzczogVEMuUHVuY3R1YXRvciwgbmFtZTogJyEnfSxcbiAgQklUX05PVDoge2tsYXNzOiBUQy5QdW5jdHVhdG9yLCBuYW1lOiAnfid9LFxuICBBV0FJVDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnYXdhaXQnfSxcbiAgREVMRVRFOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdkZWxldGUnfSxcbiAgVFlQRU9GOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICd0eXBlb2YnfSxcbiAgVk9JRDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAndm9pZCd9LFxuICBCUkVBSzoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnYnJlYWsnfSxcbiAgQ0FTRToge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnY2FzZSd9LFxuICBDQVRDSDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnY2F0Y2gnfSxcbiAgQ0xBU1M6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2NsYXNzJ30sXG4gIENPTlRJTlVFOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdjb250aW51ZSd9LFxuICBERUJVR0dFUjoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnZGVidWdnZXInfSxcbiAgREVGQVVMVDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnZGVmYXVsdCd9LFxuICBETzoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnZG8nfSxcbiAgRUxTRToge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnZWxzZSd9LFxuICBFWFBPUlQ6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2V4cG9ydCd9LFxuICBFWFRFTkRTOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdleHRlbmRzJ30sXG4gIEZJTkFMTFk6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2ZpbmFsbHknfSxcbiAgRk9SOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdmb3InfSxcbiAgRlVOQ1RJT046IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2Z1bmN0aW9uJ30sXG4gIElGOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdpZid9LFxuICBJTVBPUlQ6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2ltcG9ydCd9LFxuICBMRVQ6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ2xldCd9LFxuICBORVc6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ25ldyd9LFxuICBSRVRVUk46IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ3JldHVybid9LFxuICBTVVBFUjoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnc3VwZXInfSxcbiAgU1dJVENIOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdzd2l0Y2gnfSxcbiAgVEhJUzoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAndGhpcyd9LFxuICBUSFJPVzoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAndGhyb3cnfSxcbiAgVFJZOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICd0cnknfSxcbiAgVkFSOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICd2YXInfSxcbiAgV0hJTEU6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ3doaWxlJ30sXG4gIFdJVEg6IHtrbGFzczogVEMuS2V5d29yZCwgbmFtZTogJ3dpdGgnfSxcbiAgTlVMTDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAnbnVsbCd9LFxuICBUUlVFOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICd0cnVlJ30sXG4gIEZBTFNFOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdmYWxzZSd9LFxuICBZSUVMRDoge2tsYXNzOiBUQy5LZXl3b3JkLCBuYW1lOiAneWllbGQnfSxcbiAgTlVNQkVSOiB7a2xhc3M6IFRDLk51bWVyaWNMaXRlcmFsLCBuYW1lOiAnJ30sXG4gIFNUUklORzoge2tsYXNzOiBUQy5TdHJpbmdMaXRlcmFsLCBuYW1lOiAnJ30sXG4gIFJFR0VYUDoge2tsYXNzOiBUQy5SZWd1bGFyRXhwcmVzc2lvbiwgbmFtZTogJyd9LFxuICBJREVOVElGSUVSOiB7a2xhc3M6IFRDLklkZW50LCBuYW1lOiAnJ30sXG4gIENPTlNUOiB7a2xhc3M6IFRDLktleXdvcmQsIG5hbWU6ICdjb25zdCd9LFxuICBURU1QTEFURToge2tsYXNzOiBUQy5UZW1wbGF0ZUVsZW1lbnQsIG5hbWU6ICcnfSxcbiAgSUxMRUdBTDoge2tsYXNzOiBUQy5JbGxlZ2FsLCBuYW1lOiAnJ31cbn07XG5cbmNvbnN0IFRUID0gVG9rZW5UeXBlO1xuXG5leHBvcnQgY29uc3QgcHVuY3R1YXRvclRhYmxlID0ge1xuICAnKCc6IFRULkxQQVJFTiwgJyknOiBUVC5SUEFSRU4sXG4gICdbJzogVFQuTEJSQUNLLCAnXSc6IFRULlJCUkFDSyxcbiAgJ3snOiBUVC5MQlJBQ0UsICd9JzogVFQuUkJSQUNFLFxuICAnOic6IFRULkNPTE9OLCAnOyc6IFRULlNFTUlDT0xPTixcbiAgJy4nOiBUVC5QRVJJT0QsICcuLi4nOiBUVC5FTExJUFNJUyxcbiAgJz0+JzogVFQuQVJST1csICc/JzogVFQuQ09ORElUSU9OQUwsXG4gICcrKyc6IFRULklOQywgJy0tJzogVFQuREVDLFxuICAnPSc6IFRULkFTU0lHTiwgJ3w9JzogVFQuQVNTSUdOX0JJVF9PUiwgJ149JzogVFQuQVNTSUdOX0JJVF9YT1IsICcmPSc6IFRULkFTU0lHTl9CSVRfQU5ELFxuICAnPDw9JzogVFQuQVNTSUdOX1NITCwgJz4+PSc6IFRULkFTU0lHTl9TSFIsICc+Pj49JzogVFQuQVNTSUdOX1NIUl9VTlNJR05FRCxcbiAgJys9JzogVFQuQVNTSUdOX0FERCwgJy09JzogVFQuQVNTSUdOX1NVQiwgJyo9JzogVFQuQVNTSUdOX01VTCxcbiAgJy89JzogVFQuQVNTSUdOX0RJViwgJyU9JzogVFQuQVNTSUdOX01PRCwgJyoqPSc6IFRULkFTU0lHTl9FWFAsXG4gICcsJzogVFQuQ09NTUEsXG4gICd8fCc6IFRULk9SLCAnJiYnOiBUVC5BTkQsXG4gICd8JzogVFQuQklUX09SLCAnJic6IFRULkJJVF9BTkQsICdeJzogVFQuQklUX1hPUixcbiAgJzw8JzogVFQuU0hMLCAnPj4nOiBUVC5TSFIsICc+Pj4nOiBUVC5TSFJfVU5TSUdORUQsXG4gICcrJzogVFQuQURELCAnLSc6IFRULlNVQiwgJyonOiBUVC5NVUwsICcvJzogVFQuRElWLFxuICAnJSc6IFRULk1PRCwgJyoqJzogVFQuRVhQLFxuICAnPT0nOiBUVC5FUSwgJyE9JzogVFQuTkUsICc9PT0nOiBUVC5FUV9TVFJJQ1QsICchPT0nOiBUVC5ORV9TVFJJQ1QsXG4gICc8JzogVFQuTFQsICc+JzogVFQuR1QsICc8PSc6IFRULkxURSwgJz49JzogVFQuR1RFLFxuICAnISc6IFRULk5PVCwgJ34nOiBUVC5CSVRfTk9UXG59O1xuXG5leHBvcnQgY29uc3Qga2V5d29yZFRhYmxlID0ge1xuICAvLyAnYXdhaXQnOiBUVC5BV0FJVCwgVE9ETzogdW5jb21tZW50IHdoZW4gbmV3IHZlcnNpb24gb2Ygc2hpZnQgaXMgdXNlZFxuICAvLyBUT0RPOiBhZGQgJ2FzeW5jJ1xuICAnYnJlYWsnOiBUVC5CUkVBSyxcbiAgJ2Nhc2UnOiBUVC5DQVNFLCAnY2F0Y2gnOiBUVC5DQVRDSCwgJ2NsYXNzJzogVFQuQ0xBU1MsICdjb25zdCc6IFRULkNPTlNULCAnY29udGludWUnOiBUVC5DT05USU5VRSxcbiAgJ2RlbGV0ZSc6IFRULkRFTEVURSwgJ2RlYnVnZ2VyJzogVFQuREVCVUdHRVIsICdkZWZhdWx0JzogVFQuREVGQVVMVCwgJ2RvJzogVFQuRE8sXG4gICdlbHNlJzogVFQuRUxTRSwgJ2V4cG9ydCc6IFRULkVYUE9SVCwgJ2V4dGVuZHMnOiBUVC5FWFRFTkRTLFxuICAnZmFsc2UnOiBUVC5GQUxTRSwgJ2ZpbmFsbHknOiBUVC5GSU5BTExZLCAnZm9yJzogVFQuRk9SLCAnZnVuY3Rpb24nOiBUVC5GVU5DVElPTixcbiAgJ2lmJzogVFQuSUYsICdpbXBvcnQnOiBUVC5JTVBPUlQsICdpbic6IFRULklOLCAnaW5zdGFuY2VvZic6IFRULklOU1RBTkNFT0YsXG4gICdsZXQnOiBUVC5MRVQsXG4gICduZXcnOiBUVC5ORVcsICdudWxsJzogVFQuTlVMTCxcbiAgJ3JldHVybic6IFRULlJFVFVSTixcbiAgJ3N1cGVyJzogVFQuU1VQRVIsICdzd2l0Y2gnOiBUVC5TV0lUQ0gsXG4gICd0aGlzJzogVFQuVEhJUywgJ3Rocm93JzogVFQuVEhST1csICd0cnVlJzogVFQuVFJVRSwgJ3RyeSc6IFRULlRSWSwgJ3R5cGVvZic6IFRULlRZUEVPRixcbiAgJ3Zhcic6IFRULlZBUiwgJ3ZvaWQnOiBUVC5WT0lELFxuICAnd2hpbGUnOiBUVC5XSElMRSwgJ3dpdGgnOiBUVC5XSVRILFxuICAneWllbGQnOiBUVC5ZSUVMRFxufTtcblxuZXhwb3J0IGNvbnN0IEVtcHR5VG9rZW4gPSB7fTtcblxuZXhwb3J0IHR5cGUgU3RhcnRMb2NhdGlvbiA9IHtcbiAgbGluZTogbnVtYmVyLFxuICBjb2x1bW46IG51bWJlcixcbiAgZmlsZW5hbWU6IHN0cmluZyxcbiAgcG9zaXRpb246IG51bWJlclxufTtcblxuZXhwb3J0IHR5cGUgU2xpY2UgPSB7XG4gIHRleHQ6IHN0cmluZyxcbiAgc3RhcnQ6IG51bWJlcixcbiAgc3RhcnRMb2NhdGlvbjogU3RhcnRMb2NhdGlvbixcbiAgZW5kOiBudW1iZXJcbn07XG5cbnR5cGUgVG9rZW5UeXBlVHlwZSA9IHsga2xhc3M6IHsgbmFtZTogc3RyaW5nLCBpc0lkZW50aWZpZXJOYW1lPzogYm9vbGVhbn0sIG5hbWU6IHN0cmluZyB9O1xuXG5jbGFzcyBCYXNlVG9rZW4ge1xuICB0eXBlOiBUb2tlblR5cGVUeXBlO1xuICB2YWx1ZTogP3N0cmluZyB8ID9udW1iZXI7XG4gIHNsaWNlOiA/U2xpY2U7XG5cbiAgY29uc3RydWN0b3IoeyB0eXBlLCB2YWx1ZSwgc2xpY2UgfTogeyB0eXBlOiBUb2tlblR5cGVUeXBlLCB2YWx1ZT86IHN0cmluZyB8IG51bWJlciwgc2xpY2U/OiBTbGljZX0pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0cmluZ1Rva2VuIHtcbiAgdHlwZTogVG9rZW5UeXBlVHlwZTtcbiAgc3RyOiBzdHJpbmc7XG4gIG9jdGFsOiA/c3RyaW5nO1xuICBzbGljZTogP1NsaWNlO1xuICBjb25zdHJ1Y3Rvcih7IHN0ciwgb2N0YWwsIHNsaWNlIH06IHsgc3RyOiBzdHJpbmcsIG9jdGFsOiA/c3RyaW5nLCBzbGljZT86IFNsaWNlIH0pIHtcbiAgICB0aGlzLnR5cGUgPSBUVC5TVFJJTkc7XG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgdGhpcy5vY3RhbCA9IG9jdGFsO1xuICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSWRlbnRpZmllclRva2VuIGV4dGVuZHMgQmFzZVRva2VuIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgc2xpY2UgfTogeyB2YWx1ZTogc3RyaW5nLCBzbGljZT86IFNsaWNlIH0pIHtcbiAgICBzdXBlcih7IHR5cGU6IFRULklERU5USUZJRVIsIHZhbHVlLCBzbGljZSB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgS2V5d29yZFRva2VuIGV4dGVuZHMgQmFzZVRva2VuIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgc2xpY2UgfTogeyB2YWx1ZTogc3RyaW5nLCBzbGljZT86IFNsaWNlIH0pIHtcbiAgICBzdXBlcih7IHR5cGU6IGtleXdvcmRUYWJsZVt2YWx1ZV0sIHZhbHVlLCBzbGljZSB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVuY3R1YXRvclRva2VuIGV4dGVuZHMgQmFzZVRva2VuIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgc2xpY2UgfTogeyB2YWx1ZTogc3RyaW5nLCBzbGljZT86IFNsaWNlIH0pIHtcbiAgICBzdXBlcih7IHR5cGU6IHB1bmN0dWF0b3JUYWJsZVt2YWx1ZV0sIHZhbHVlLCBzbGljZSB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTnVtZXJpY1Rva2VuIGV4dGVuZHMgQmFzZVRva2VuIHtcbiAgb2N0YWw6IGJvb2xlYW47XG4gIG5vY3RhbDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBvY3RhbD1mYWxzZSwgbm9jdGFsPWZhbHNlLCBzbGljZSB9OiB7IHZhbHVlOiBudW1iZXIsIG9jdGFsPzogYm9vbGVhbiwgbm9jdGFsPzogYm9vbGVhbiwgc2xpY2U/OiBTbGljZSB9KSB7XG4gICAgc3VwZXIoe3R5cGU6IFRULk5VTUJFUiwgdmFsdWUsIHNsaWNlIH0pO1xuICAgIHRoaXMub2N0YWwgPSBvY3RhbDtcbiAgICB0aGlzLm5vY3RhbCA9IG5vY3RhbDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVFbGVtZW50VG9rZW4gZXh0ZW5kcyBCYXNlVG9rZW4ge1xuICB0YWlsOiBib29sZWFuO1xuICBpbnRlcnA6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgdGFpbCwgaW50ZXJwLCBzbGljZSB9OiB7IHZhbHVlOiBzdHJpbmcsIHRhaWw6IGJvb2xlYW4sIGludGVycDogYm9vbGVhbiwgc2xpY2U/OiBTbGljZSB9KSB7XG4gICAgc3VwZXIoeyB0eXBlOiBUVC5URU1QTEFURSwgdmFsdWUsIHNsaWNlIH0pO1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgdGhpcy5pbnRlcnAgPSBpbnRlcnA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlVG9rZW4gZXh0ZW5kcyBCYXNlVG9rZW4ge1xuICBpdGVtczogTGlzdDxUb2tlbj47XG5cbiAgY29uc3RydWN0b3IoeyBpdGVtcywgc2xpY2UgfTogeyBpdGVtczogTGlzdDxUb2tlbj4sIHNsaWNlPzogU2xpY2UgfSkge1xuICAgIHN1cGVyKHsgdHlwZTogVFQuVEVNUExBVEUsIHNsaWNlIH0pO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVnRXhwVG9rZW4gZXh0ZW5kcyBCYXNlVG9rZW4ge1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBzbGljZSB9OiB7IHZhbHVlOiBzdHJpbmcsIHNsaWNlPzogU2xpY2UgfSkge1xuICAgIHN1cGVyKHsgdHlwZTogVFQuUkVHRVhQLCB2YWx1ZSwgc2xpY2UgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVG9rZW4gPSBTdHJpbmdUb2tlbiB8IElkZW50aWZpZXJUb2tlbiB8IEtleXdvcmRUb2tlbiB8IFB1bmN0dWF0b3JUb2tlbiB8IE51bWVyaWNUb2tlbiB8IFRlbXBsYXRlRWxlbWVudFRva2VuIHwgVGVtcGxhdGVUb2tlbiB8IFJlZ0V4cFRva2VuO1xuIl19

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readNumericLiteral;

	var _charStream = __webpack_require__(8);

	var _esutils = __webpack_require__(14);

	var _utils = __webpack_require__(13);

	var _tokens = __webpack_require__(30);

	const { isIdentifierPartES6: isIdentifierPart,
	  isIdentifierStartES6: isIdentifierStart
	} = _esutils.code;

	function readNumericLiteral(stream) {
	  let idx = 0,
	      char = stream.peek();

	  if (char === '0') {
	    char = stream.peek(++idx);
	    if (!(0, _charStream.isEOS)(char)) {
	      char = char.toLowerCase();
	      switch (char) {
	        case 'x':
	          return readHexLiteral.call(this, stream);
	        case 'b':
	          return readBinaryLiteral.call(this, stream);
	        case 'o':
	          return readOctalLiteral.call(this, stream);
	        default:
	          if (isDecimalChar(char)) {
	            return readLegacyOctalLiteral.call(this, stream); // reads legacy octal and decimal
	          }
	      }
	    } else {
	      return new _tokens.NumericToken({
	        value: +stream.readString()
	      });
	    }
	  } else if (char !== '.') {
	    while (isDecimalChar(char)) {
	      char = stream.peek(++idx);
	    }
	    if ((0, _charStream.isEOS)(char)) {
	      return new _tokens.NumericToken({
	        value: +stream.readString(idx)
	      });
	    }
	  }

	  idx = addDecimalLiteralSuffixLength.call(this, stream, idx);

	  char = stream.peek(idx);
	  if (!(0, _charStream.isEOS)(char) && isIdentifierStart(char)) {
	    throw this.createILLEGAL(char);
	  }

	  return new _tokens.NumericToken({
	    value: +stream.readString(idx)
	  });
	}

	function addDecimalLiteralSuffixLength(stream, idx) {
	  let char = stream.peek(idx);
	  if (char === '.') {
	    char = stream.peek(++idx);
	    if ((0, _charStream.isEOS)(char)) return idx;

	    while (isDecimalChar(char)) {
	      char = stream.peek(++idx);
	      if ((0, _charStream.isEOS)(char)) return idx;
	    }
	  }

	  if (char.toLowerCase() === 'e') {
	    char = stream.peek(++idx);
	    if ((0, _charStream.isEOS)(char)) throw this.createILLEGAL(char);

	    if (char === '+' || char === '-') {
	      char = stream.peek(++idx);
	      if ((0, _charStream.isEOS)(char)) throw this.createILLEGAL(char);
	    }

	    while (isDecimalChar(char)) {
	      char = stream.peek(++idx);
	      if ((0, _charStream.isEOS)(char)) break;
	    }
	  }
	  return idx;
	}

	function readLegacyOctalLiteral(stream) {
	  let idx = 0,
	      isOctal = true,
	      char = stream.peek();

	  while (!(0, _charStream.isEOS)(char)) {
	    if ('0' <= char && char <= '7') {
	      idx++;
	    } else if (char === '8' || char === '9') {
	      isOctal = false;
	      idx++;
	    } else if (isIdentifierPart(char.charCodeAt(0))) {
	      throw this.createILLEGAL(char);
	    } else {
	      break;
	    }

	    char = stream.peek(idx);
	  }

	  if (!isOctal) return new _tokens.NumericToken({
	    value: parseNumeric(stream, idx, 10),
	    octal: true,
	    noctal: !isOctal
	  });

	  return new _tokens.NumericToken({
	    value: parseNumeric(stream, idx, 8),
	    octal: true,
	    noctal: !isOctal
	  });
	}

	function readOctalLiteral(stream) {
	  let start,
	      idx = start = 2,
	      char = stream.peek(idx);
	  while (!(0, _charStream.isEOS)(char)) {
	    if ('0' <= char && char <= '7') {
	      char = stream.peek(++idx);
	    } else if (isIdentifierPart(char.charCodeAt(0))) {
	      throw this.createILLEGAL(char);
	    } else {
	      break;
	    }
	  }

	  if (idx === start) {
	    throw this.createILLEGAL(char);
	  }

	  return new _tokens.NumericToken({
	    value: parseNumeric(stream, idx, 8, start)
	  });
	}

	function readBinaryLiteral(stream) {
	  let start,
	      idx = start = 2;
	  let char = stream.peek(idx);

	  while (!(0, _charStream.isEOS)(char)) {
	    if (char !== '0' && char !== '1') {
	      break;
	    }
	    char = stream.peek(idx);
	    idx++;
	  }

	  if (idx === start) {
	    throw this.createILLEGAL(char);
	  }

	  if (!(0, _charStream.isEOS)(char) && (isIdentifierStart(char) || isDecimalChar(char))) {
	    throw this.createILLEGAL(char);
	  }

	  return new _tokens.NumericToken({
	    value: parseNumeric(stream, idx, 2, start)
	  });
	}

	function readHexLiteral(stream) {
	  let start,
	      idx = start = 2,
	      char = stream.peek(idx);
	  while (true) {
	    let hex = (0, _utils.getHexValue)(char);
	    if (hex === -1) {
	      break;
	    }
	    char = stream.peek(++idx);
	  }

	  if (idx === start) {
	    throw this.createILLEGAL(char);
	  }

	  if (!(0, _charStream.isEOS)(char) && isIdentifierStart(char)) {
	    throw this.createILLEGAL(char);
	  }

	  return new _tokens.NumericToken({
	    value: parseNumeric(stream, idx, 16, start)
	  });
	}

	function parseNumeric(stream, len, radix, start = 0) {
	  stream.readString(start);
	  return parseInt(stream.readString(len - start), radix);
	}

	function isDecimalChar(char) {
	  return '0' <= char && char <= '9';
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1udW1lcmljLmpzIl0sIm5hbWVzIjpbInJlYWROdW1lcmljTGl0ZXJhbCIsImlzSWRlbnRpZmllclBhcnRFUzYiLCJpc0lkZW50aWZpZXJQYXJ0IiwiaXNJZGVudGlmaWVyU3RhcnRFUzYiLCJpc0lkZW50aWZpZXJTdGFydCIsInN0cmVhbSIsImlkeCIsImNoYXIiLCJwZWVrIiwidG9Mb3dlckNhc2UiLCJyZWFkSGV4TGl0ZXJhbCIsImNhbGwiLCJyZWFkQmluYXJ5TGl0ZXJhbCIsInJlYWRPY3RhbExpdGVyYWwiLCJpc0RlY2ltYWxDaGFyIiwicmVhZExlZ2FjeU9jdGFsTGl0ZXJhbCIsInZhbHVlIiwicmVhZFN0cmluZyIsImFkZERlY2ltYWxMaXRlcmFsU3VmZml4TGVuZ3RoIiwiY3JlYXRlSUxMRUdBTCIsImlzT2N0YWwiLCJjaGFyQ29kZUF0IiwicGFyc2VOdW1lcmljIiwib2N0YWwiLCJub2N0YWwiLCJzdGFydCIsImhleCIsImxlbiIsInJhZGl4IiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQWF3QkEsa0I7O0FBWHhCOztBQUNBOztBQUNBOztBQUNBOztBQUlBLE1BQU0sRUFBRUMscUJBQXFCQyxnQkFBdkI7QUFDRUMsd0JBQXNCQztBQUR4QixpQkFBTjs7QUFJZSxTQUFTSixrQkFBVCxDQUE0QkssTUFBNUIsRUFBZ0Q7QUFDN0QsTUFBSUMsTUFBTSxDQUFWO0FBQUEsTUFBYUMsT0FBT0YsT0FBT0csSUFBUCxFQUFwQjs7QUFFQSxNQUFJRCxTQUFTLEdBQWIsRUFBa0I7QUFDaEJBLFdBQU9GLE9BQU9HLElBQVAsQ0FBWSxFQUFFRixHQUFkLENBQVA7QUFDQSxRQUFJLENBQUMsdUJBQU1DLElBQU4sQ0FBTCxFQUFrQjtBQUNoQkEsYUFBT0EsS0FBS0UsV0FBTCxFQUFQO0FBQ0EsY0FBUUYsSUFBUjtBQUNFLGFBQUssR0FBTDtBQUFVLGlCQUFPRyxlQUFlQyxJQUFmLENBQW9CLElBQXBCLEVB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Ly8gQGZsb3dcblxuaW1wb3J0IHsgaXNFT1MgfSBmcm9tICcuL2NoYXItc3RyZWFtJztcbmltcG9ydCB7IGNvZGUgfSBmcm9tICdlc3V0aWxzJztcbmltcG9ydCB7IGdldEhleFZhbHVlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBOdW1lcmljVG9rZW4gfSBmcm9tICcuLi90b2tlbnMnO1xuXG5pbXBvcnQgdHlwZSBDaGFyU3RyZWFtIGZyb20gJy4vY2hhci1zdHJlYW0nO1xuXG5jb25zdCB7IGlzSWRlbnRpZmllclBhcnRFUzY6IGlzSWRlbnRpZmllclBhcnQsXG4gICAgICAgIGlzSWRlbnRpZmllclN0YXJ0RVM2OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICAgICAgfSA9IGNvZGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWROdW1lcmljTGl0ZXJhbChzdHJlYW06IENoYXJTdHJlYW0pIHtcbiAgbGV0IGlkeCA9IDAsIGNoYXIgPSBzdHJlYW0ucGVlaygpO1xuXG4gIGlmIChjaGFyID09PSAnMCcpIHtcbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgIGlmICghaXNFT1MoY2hhcikpIHtcbiAgICAgIGNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAneCc6IHJldHVybiByZWFkSGV4TGl0ZXJhbC5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgIGNhc2UgJ2InOiByZXR1cm4gcmVhZEJpbmFyeUxpdGVyYWwuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgICAgICBjYXNlICdvJzogcmV0dXJuIHJlYWRPY3RhbExpdGVyYWwuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgICAgICBkZWZhdWx0OiBpZiAoaXNEZWNpbWFsQ2hhcihjaGFyKSkge1xuICAgICAgICAgIHJldHVybiByZWFkTGVnYWN5T2N0YWxMaXRlcmFsLmNhbGwodGhpcywgc3RyZWFtKTsgLy8gcmVhZHMgbGVnYWN5IG9jdGFsIGFuZCBkZWNpbWFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVG9rZW4oe1xuICAgICAgICB2YWx1ZTogK3N0cmVhbS5yZWFkU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGFyICE9PSAnLicpIHtcbiAgICB3aGlsZSAoaXNEZWNpbWFsQ2hhcihjaGFyKSkge1xuICAgICAgY2hhciA9IHN0cmVhbS5wZWVrKCsraWR4KTtcbiAgICB9XG4gICAgaWYgKGlzRU9TKGNoYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWVyaWNUb2tlbih7XG4gICAgICAgIHZhbHVlOiArc3RyZWFtLnJlYWRTdHJpbmcoaWR4KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWR4ID0gYWRkRGVjaW1hbExpdGVyYWxTdWZmaXhMZW5ndGguY2FsbCh0aGlzLCBzdHJlYW0sIGlkeCk7XG5cbiAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIGlmICghaXNFT1MoY2hhcikgJiYgaXNJZGVudGlmaWVyU3RhcnQoY2hhcikpIHtcbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gIH1cblxuICByZXR1cm4gbmV3IE51bWVyaWNUb2tlbih7XG4gICAgdmFsdWU6ICtzdHJlYW0ucmVhZFN0cmluZyhpZHgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREZWNpbWFsTGl0ZXJhbFN1ZmZpeExlbmd0aChzdHJlYW0sIGlkeCkge1xuICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIGlmIChjaGFyID09PSAnLicpIHtcbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgIGlmIChpc0VPUyhjaGFyKSkgcmV0dXJuIGlkeDtcblxuICAgIHdoaWxlIChpc0RlY2ltYWxDaGFyKGNoYXIpKSB7XG4gICAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgICAgaWYgKGlzRU9TKGNoYXIpKSByZXR1cm4gaWR4O1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGFyLnRvTG93ZXJDYXNlKCkgPT09ICdlJykge1xuICAgIGNoYXIgPSBzdHJlYW0ucGVlaygrK2lkeCk7XG4gICAgaWYgKGlzRU9TKGNoYXIpKSB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG5cbiAgICBpZiAoY2hhciA9PT0gJysnIHx8IGNoYXIgPT09ICctJykge1xuICAgICAgY2hhciA9IHN0cmVhbS5wZWVrKCsraWR4KTtcbiAgICAgIGlmIChpc0VPUyhjaGFyKSkgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICAgIH1cblxuICAgIHdoaWxlIChpc0RlY2ltYWxDaGFyKGNoYXIpKSB7XG4gICAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgICAgaWYgKGlzRU9TKGNoYXIpKSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gcmVhZExlZ2FjeU9jdGFsTGl0ZXJhbChzdHJlYW0pIHtcbiAgbGV0IGlkeCA9IDAsIGlzT2N0YWwgPSB0cnVlLCBjaGFyID0gc3RyZWFtLnBlZWsoKTtcblxuXG4gIHdoaWxlICghaXNFT1MoY2hhcikpIHtcbiAgICBpZiAoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnNycpIHtcbiAgICAgIGlkeCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJzgnIHx8IGNoYXIgPT09ICc5Jykge1xuICAgICAgaXNPY3RhbCA9IGZhbHNlO1xuICAgICAgaWR4Kys7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoYXIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIH1cblxuICBpZiAoIWlzT2N0YWwpIHJldHVybiBuZXcgTnVtZXJpY1Rva2VuKHtcbiAgICB2YWx1ZTogcGFyc2VOdW1lcmljKHN0cmVhbSwgaWR4LCAxMCksXG4gICAgb2N0YWw6IHRydWUsXG4gICAgbm9jdGFsOiAhaXNPY3RhbFxuICB9KTtcblxuICByZXR1cm4gbmV3IE51bWVyaWNUb2tlbih7XG4gICAgdmFsdWU6IHBhcnNlTnVtZXJpYyhzdHJlYW0sIGlkeCwgOCksXG4gICAgb2N0YWw6IHRydWUsXG4gICAgbm9jdGFsOiAhaXNPY3RhbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZE9jdGFsTGl0ZXJhbChzdHJlYW0pIHtcbiAgbGV0IHN0YXJ0LCBpZHggPSBzdGFydCA9IDIsIGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgaWYgKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzcnKSB7XG4gICAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyUGFydChjaGFyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpZHggPT09IHN0YXJ0KSB7XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBOdW1lcmljVG9rZW4oe1xuICAgIHZhbHVlOiBwYXJzZU51bWVyaWMoc3RyZWFtLCBpZHgsIDgsIHN0YXJ0KVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEJpbmFyeUxpdGVyYWwoc3RyZWFtKSB7XG4gIGxldCBzdGFydCwgaWR4ID0gc3RhcnQgPSAyO1xuICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG5cbiAgd2hpbGUoIWlzRU9TKGNoYXIpKSB7XG4gICAgaWYgKGNoYXIgIT09ICcwJyAmJiBjaGFyICE9PSAnMScpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgICBpZHgrKztcbiAgfVxuXG4gIGlmIChpZHggPT09IHN0YXJ0KSB7XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICB9XG5cbiAgaWYgKCFpc0VPUyhjaGFyKSAmJiAoaXNJZGVudGlmaWVyU3RhcnQoY2hhcikgfHwgaXNEZWNpbWFsQ2hhcihjaGFyKSkpIHtcbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gIH1cblxuICByZXR1cm4gbmV3IE51bWVyaWNUb2tlbih7XG4gICAgdmFsdWU6IHBhcnNlTnVtZXJpYyhzdHJlYW0sIGlkeCwgMiwgc3RhcnQpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkSGV4TGl0ZXJhbChzdHJlYW0pIHtcbiAgbGV0IHN0YXJ0LCBpZHggPSBzdGFydCA9IDIsIGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICB3aGlsZSh0cnVlKSB7XG4gICAgbGV0IGhleCA9IGdldEhleFZhbHVlKGNoYXIpO1xuICAgIGlmIChoZXggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2hhciA9IHN0cmVhbS5wZWVrKCsraWR4KTtcbiAgfVxuXG4gIGlmIChpZHggPT09IHN0YXJ0KSB7XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICB9XG5cbiAgaWYgKCFpc0VPUyhjaGFyKSAmJiBpc0lkZW50aWZpZXJTdGFydChjaGFyKSkge1xuICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTnVtZXJpY1Rva2VuKHtcbiAgICB2YWx1ZTogcGFyc2VOdW1lcmljKHN0cmVhbSwgaWR4LCAxNiwgc3RhcnQpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZU51bWVyaWMoc3RyZWFtLCBsZW4sIHJhZGl4LCBzdGFydD0wKSB7XG4gIHN0cmVhbS5yZWFkU3RyaW5nKHN0YXJ0KTtcbiAgcmV0dXJuIHBhcnNlSW50KHN0cmVhbS5yZWFkU3RyaW5nKGxlbiAtIHN0YXJ0KSwgcmFkaXgpO1xufVxuXG5mdW5jdGlvbiBpc0RlY2ltYWxDaGFyKGNoYXIpIHtcbiAgcmV0dXJuICcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknO1xufVxuIl19

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readStringLiteral;

	var _utils = __webpack_require__(13);

	var _charStream = __webpack_require__(8);

	var _tokens = __webpack_require__(30);

	function readStringLiteral(stream) {
	  let str = '',
	      octal = null,
	      idx = 0,
	      quote = stream.readString(),
	      char = stream.peek(),
	      lineStart;

	  while (!(0, _charStream.isEOS)(char)) {
	    if (char === quote) {
	      stream.readString(++idx);
	      if (lineStart != null) this.locationInfo.column += idx - lineStart;
	      return new _tokens.StringToken({ str, octal });
	    } else if (char === '\\') {
	      [str, idx, octal, lineStart] = _utils.readStringEscape.call(this, str, stream, idx, octal);
	    } else if ((0, _utils.isLineTerminator)(char.charCodeAt(0))) {
	      throw this.createILLEGAL(char);
	    } else {
	      ++idx;
	      str += char;
	    }
	    char = stream.peek(idx);
	  }
	  throw this.createILLEGAL(char);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1zdHJpbmcuanMiXSwibmFtZXMiOlsicmVhZFN0cmluZ0xpdGVyYWwiLCJzdHJlYW0iLCJzdHIiLCJvY3RhbCIsImlkeCIsInF1b3RlIiwicmVhZFN0cmluZyIsImNoYXIiLCJwZWVrIiwibGluZVN0YXJ0IiwibG9jYXRpb25JbmZvIiwiY29sdW1uIiwiY2FsbCIsImNoYXJDb2RlQXQiLCJjcmVhdGVJTExFR0FMIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFPd0JBLGlCOztBQUp4Qjs7QUFDQTs7QUFDQTs7QUFFZSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBNEQ7QUFDekUsTUFBSUMsTUFBTSxFQUFWO0FBQUEsTUFBY0MsUUFBUSxJQUF0QjtBQUFBLE1BQTRCQyxNQUFjLENBQTFDO0FBQUEsTUFDSUMsUUFBUUosT0FBT0ssVUFBUCxFQURaO0FBQUEsTUFFSUMsT0FBT04sT0FBT08sSUFBUCxFQUZYO0FBQUEsTUFHSUMsU0FISjs7QUFLQSxTQUFPLENBQUMsdUJBQU1GLElBQU4sQ0FBUixFQUFxQjtBQUNuQixRQUFJQSxTQUFTRixLQUFiLEVBQW9CO0FBQ2xCSixhQUFPSyxVQUFQLENBQWtCLEVBQUVGLEdBQXBCO0FBQ0EsVUFBSUssYUFBYSxJQUFqQixFQUF1QixLQUFLQyxZQUFMLENBQWtCQyxNQUFsQixJQUE0QlAsTUFBTUssU0FBbEM7QUFDdkIsYUFBTyx3QkFBZ0IsRUFBRVAsR0FBRixFQUFPQyxLQUFQLEVBQWhCLENBQVA7QUFDRCxLQUpELE1BSU8sSUFBSUksU0FBUyxJQUFiLEVBQW1CO0FBQ3hCLE9BQUNMLEdBQUQsRUFBTUUsR0FBTixFQUFXRCxLQUFYLEVBQWtCTSxTQUFsQixJQUErQix3QkFBaUJHLElBQWpCLENBQXNCLElBQXRCLEVBQTRCVixHQUE1QixFQUFpQ0QsTUFBakMsRUFBeUNHLEdBQXpDLEVBQThDRCxLQUE5QyxDQUEvQjtBQUNELEtBRk0sTUFFQSxJQUFJLDZCQUFpQkksS0FBS00sVUFBTCxDQUFnQixDQUFoQixDQUFqQixDQUFKLEVBQTBDO0FBQy9DLFlBQU0sS0FBS0MsYUFBTCxDQUFtQlAsSUFBbkIsQ0FBTjtBQUNELEtBRk0sTUFFQTtBQUNMLFFBQUVILEdBQUY7QUFDQUYsYUFBT0ssSUFBUDtBQUNEO0FBQ0RBLFdBQU9OLE9BQU9PLElBQVAsQ0FBWUosR0FBWixDQUFQO0FBQ0Q7QUFDRCxRQUFNLEtBQUtVLGFBQUwsQ0FBbUJQLElBQW5CLENBQU47QUFDRCIsImZpbGUiOiJyZWFkLXN0cmluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgdHlwZSBDaGFyU3RyZWFtIGZyb20gJy4vY2hhci1zdHJlYW0nO1xuXG5pbXBvcnQgeyByZWFkU3RyaW5nRXNjYXBlLCBpc0xpbmVUZXJtaW5hdG9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBpc0VPUyB9IGZyb20gJy4vY2hhci1zdHJlYW0nO1xuaW1wb3J0IHsgU3RyaW5nVG9rZW4gfSBmcm9tICcuLi90b2tlbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkU3RyaW5nTGl0ZXJhbChzdHJlYW06IENoYXJTdHJlYW0pOiBTdHJpbmdUb2tlbiB7XG4gIGxldCBzdHIgPSAnJywgb2N0YWwgPSBudWxsLCBpZHg6IG51bWJlciA9IDAsXG4gICAgICBxdW90ZSA9IHN0cmVhbS5yZWFkU3RyaW5nKCksXG4gICAgICBjaGFyID0gc3RyZWFtLnBlZWsoKSxcbiAgICAgIGxpbmVTdGFydDtcblxuICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgaWYgKGNoYXIgPT09IHF1b3RlKSB7XG4gICAgICBzdHJlYW0ucmVhZFN0cmluZygrK2lkeCk7XG4gICAgICBpZiAobGluZVN0YXJ0ICE9IG51bGwpIHRoaXMubG9jYXRpb25JbmZvLmNvbHVtbiArPSBpZHggLSBsaW5lU3RhcnQ7XG4gICAgICByZXR1cm4gbmV3IFN0cmluZ1Rva2VuKHsgc3RyLCBvY3RhbCB9KTtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgW3N0ciwgaWR4LCBvY3RhbCwgbGluZVN0YXJ0XSA9IHJlYWRTdHJpbmdFc2NhcGUuY2FsbCh0aGlzLCBzdHIsIHN0cmVhbSwgaWR4LCBvY3RhbCk7XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoYXIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKytpZHg7XG4gICAgICBzdHIgKz0gY2hhcjtcbiAgICB9XG4gICAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG4gIH1cbiAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xufVxuIl19

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readTemplateLiteral;

	var _immutable = __webpack_require__(10);

	var _charStream = __webpack_require__(8);

	var _utils = __webpack_require__(13);

	var _tokenReader = __webpack_require__(6);

	var _tokens = __webpack_require__(30);

	function readTemplateLiteral(stream, prefix) {
	  let element,
	      items = [];
	  stream.readString();

	  do {
	    element = readTemplateElement.call(this, stream);
	    items.push(element);
	    if (element.interp) {
	      element = this.readToken(stream, (0, _immutable.List)(), false);
	      items.push(element);
	    }
	  } while (!element.tail);

	  return new _tokens.TemplateToken({
	    items: (0, _immutable.List)(items)
	  });
	}


	function readTemplateElement(stream) {
	  let char = stream.peek(),
	      idx = 0,
	      value = '',
	      octal = null;
	  const startLocation = Object.assign({}, this.locationInfo, stream.sourceInfo);
	  while (!(0, _charStream.isEOS)(char)) {
	    switch (char) {
	      case '`':
	        {
	          stream.readString(idx);
	          const slice = (0, _tokenReader.getSlice)(stream, startLocation);
	          stream.readString();
	          return new _tokens.TemplateElementToken({
	            tail: true,
	            interp: false,
	            value,
	            slice
	          });
	        }
	      case '$':
	        {
	          if (stream.peek(idx + 1) === '{') {
	            stream.readString(idx);
	            const slice = (0, _tokenReader.getSlice)(stream, startLocation);
	            stream.readString();

	            return new _tokens.TemplateElementToken({
	              tail: false,
	              interp: true,
	              value,
	              slice
	            });
	          }
	          break;
	        }
	      case '\\':
	        {
	          let newVal;
	          [newVal, idx, octal] = _utils.readStringEscape.call(this, '', stream, idx, octal);
	          if (octal != null) throw this.createILLEGAL(octal);
	          value += newVal;
	          --idx;
	          break;
	        }
	      default:
	        {
	          value += char;
	        }
	    }
	    char = stream.peek(++idx);
	  }
	  throw this.createILLEGAL(char);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC10ZW1wbGF0ZS5qcyJdLCJuYW1lcyI6WyJyZWFkVGVtcGxhdGVMaXRlcmFsIiwic3RyZWFtIiwicHJlZml4IiwiZWxlbWVudCIsIml0ZW1zIiwicmVhZFN0cmluZyIsInJlYWRUZW1wbGF0ZUVsZW1lbnQiLCJjYWxsIiwicHVzaCIsImludGVycCIsInJlYWRUb2tlbiIsInRhaWwiLCJjaGFyIiwicGVlayIsImlkeCIsInZhbHVlIiwib2N0YWwiLCJzdGFydExvY2F0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwibG9jYXRpb25JbmZvIiwic291cmNlSW5mbyIsInNsaWNlIiwibmV3VmFsIiwiY3JlYXRlSUxMRUdBTCJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBV3dCQSxtQjs7QUFWeEI7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRWUsU0FBU0EsbUJBQVQsQ0FBNkJDLE1BQTdCLEVBQWlEQyxNQUFqRCxFQUFzRjtBQUNuRyxNQUFJQyxPQUFKO0FBQUEsTUFBYUMsUUFBUSxFQUFyQjtBQUNBSCxTQUFPSSxVQUFQOztBQUVBLEtBQUc7QUFDREYsY0FBVUcsb0JBQW9CQyxJQUFwQixDQUF5QixJQUF6QixFQUErQk4sTUFBL0IsQ0FBVjtBQUNBRyxVQUFNSSxJQUFOLENBQVdMLE9BQVg7QUFDQSxRQUFJQSxRQUFRTSxNQUFaLEVBQW9CO0FBQ2xCTixnQkFBVSxLQUFLTyxTQUFMLENBQWVULE1BQWYsRUFBdUIsc0JBQXZCLEVBQStCLEtBQS9CLENBQVY7QUFDQUcsWUFBTUksSUFBTixDQUFXTCxPQUFYO0FBQ0Q7QUFDRixHQVBELFFBT1EsQ0FBQ0EsUUFBUVEsSUFQakI7O0FBU0EsU0FBTywwQkFBa0I7QUFDdkJQLFdBQU8scUJBQUtBLEtBQUw7QUFEZ0IsR0FBbEIsQ0FBUDtBQUdEOzs7QUFFRCxTQUFTRSxtQkFBVCxDQUE2QkwsTUFBN0IsRUFBdUU7QUFDckUsTUFBSVcsT0FBT1gsT0FBT1ksSUFBUCxFQUFYO0FBQUEsTUFBMEJDLE1BQU0sQ0FBaEM7QUFBQSxNQUFtQ0MsUUFBUSxFQUEzQztBQUFBLE1BQStDQyxRQUFRLElBQXZEO0FBQ0EsUUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLQyxZQUF2QixFQUFxQ25CLE9BQU9vQixVQUE1QyxDQUF0QjtBQUNBLFNBQU8sQ0FBQyx1QkFBTVQsSUFBTixDQUFSLEVBQXFCO0FBQ25CLFlBQVFBLElBQVI7QUFDRSxXQUFLLEdBQUw7QUFBVTtBQUNSWCxpQkFBT0ksVUFBUCxDQUFrQlMsR0FBbEI7QUFDQSxnQkFBTVEsUUFBUSwyQkFBU3JCLE1BQVQsRUFBaUJnQixhQUFqQixDQUFkO0FBQ0FoQixpQkFBT0ksVUFBUDtBQUNBLGlCQUFPLGlDQUF5QjtBQUM5Qk0sa0JBQU0sSUFEd0I7QUFFOUJGLG9CQUFRLEtBRnNCO0FBRzlCTSxpQkFIOEI7QUFJOUJPO0FBSjhCLFdBQXpCLENBQVA7QUFNRDtBQUNELFdBQUssR0FBTDtBQUFVO0FBQ1IsY0FBSXJCLE9BQU9ZLElBQVAsQ0FBWUMsTUFBSSxDQUFoQixNQUF1QixHQUEzQixFQUFnQztBQUM5QmIsbUJBQU9JLFVBQVAsQ0FBa0JTLEdBQWxCO0FBQ0Esa0JBQU1RLFFBQVEsMkJBQVNyQixNQUFULEVBQWlCZ0IsYUFBakIsQ0FBZDtBQUNBaEIsbUJBQU9JLFVBQVA7O0FBRUEsbUJBQU8saUNBQXlCO0FBQzlCTSxvQkFBTSxLQUR3QjtBQUU5QkYsc0JBQVEsSUFGc0I7QUFHOUJNLG1CQUg4QjtBQUk5Qk87QUFKOEIsYUFBekIsQ0FBUDtBQU1EO0FBQ0Q7QUFDRDtBQUNELFdBQUssSUFBTDtBQUFXO0FBQ1QsY0FBSUMsTUFBSjtBQUNBLFdBQUNBLE1BQUQsRUFBU1QsR0FBVCxFQUFjRSxLQUFkLElBQXVCLHdCQUFpQlQsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIsRUFBNUIsRUFBZ0NOLE1BQWhDLEVBQXdDYSxHQUF4QyxFQUE2Q0UsS0FBN0MsQ0FBdkI7QUFDQSxjQUFJQSxTQUFTLElBQWIsRUFBbUIsTUFBTSxLQUFLUSxhQUFMLENBQW1CUixLQUFuQixDQUFOO0FBQ25CRCxtQkFBU1EsTUFBVDtBQUNBLFlBQUVULEdBQUY7QUFDQTtBQUNEO0FBQ0Q7QUFBUztBQUNQQyxtQkFBU0gsSUFBVDtBQUNEO0FBckNIO0FBdUNBQSxXQUFPWCxPQUFPWSxJQUFQLENBQVksRUFBRUMsR0FBZCxDQUFQO0FBQ0Q7QUFDRCxRQUFNLEtBQUtVLGFBQUwsQ0FBbUJaLElBQW5CLENBQU47QUFDRCIsImZpbGUiOiJyZWFkLXRlbXBsYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuXG5pbXBvcnQgdHlwZSBDaGFyU3RyZWFtIGZyb20gJy4vY2hhci1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgU3ludGF4IGZyb20gJy4uL3N5bnRheCc7XG5cbmltcG9ydCB7IGlzRU9TIH0gZnJvbSAnLi9jaGFyLXN0cmVhbSc7XG5pbXBvcnQgeyByZWFkU3RyaW5nRXNjYXBlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZXRTbGljZSB9IGZyb20gJy4vdG9rZW4tcmVhZGVyJztcbmltcG9ydCB7IFRlbXBsYXRlVG9rZW4sIFRlbXBsYXRlRWxlbWVudFRva2VuIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZFRlbXBsYXRlTGl0ZXJhbChzdHJlYW06IENoYXJTdHJlYW0sIHByZWZpeDogTGlzdDxTeW50YXg+KTogVGVtcGxhdGVUb2tlbiB7XG4gIGxldCBlbGVtZW50LCBpdGVtcyA9IFtdO1xuICBzdHJlYW0ucmVhZFN0cmluZygpO1xuXG4gIGRvIHtcbiAgICBlbGVtZW50ID0gcmVhZFRlbXBsYXRlRWxlbWVudC5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgaXRlbXMucHVzaChlbGVtZW50KTtcbiAgICBpZiAoZWxlbWVudC5pbnRlcnApIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLnJlYWRUb2tlbihzdHJlYW0sIExpc3QoKSwgZmFsc2UpO1xuICAgICAgaXRlbXMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0gd2hpbGUoIWVsZW1lbnQudGFpbCk7XG5cbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZVRva2VuKHtcbiAgICBpdGVtczogTGlzdChpdGVtcylcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUZW1wbGF0ZUVsZW1lbnQoc3RyZWFtOiBDaGFyU3RyZWFtKTogVGVtcGxhdGVFbGVtZW50VG9rZW4ge1xuICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKCksIGlkeCA9IDAsIHZhbHVlID0gJycsIG9jdGFsID0gbnVsbDtcbiAgY29uc3Qgc3RhcnRMb2NhdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9jYXRpb25JbmZvLCBzdHJlYW0uc291cmNlSW5mbyk7XG4gIHdoaWxlICghaXNFT1MoY2hhcikpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgIHN0cmVhbS5yZWFkU3RyaW5nKGlkeCk7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gZ2V0U2xpY2Uoc3RyZWFtLCBzdGFydExvY2F0aW9uKTtcbiAgICAgICAgc3RyZWFtLnJlYWRTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUVsZW1lbnRUb2tlbih7XG4gICAgICAgICAgdGFpbDogdHJ1ZSxcbiAgICAgICAgICBpbnRlcnA6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHNsaWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSAnJCc6IHtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKGlkeCsxKSA9PT0gJ3snKSB7XG4gICAgICAgICAgc3RyZWFtLnJlYWRTdHJpbmcoaWR4KTtcbiAgICAgICAgICBjb25zdCBzbGljZSA9IGdldFNsaWNlKHN0cmVhbSwgc3RhcnRMb2NhdGlvbik7XG4gICAgICAgICAgc3RyZWFtLnJlYWRTdHJpbmcoKTtcblxuICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVFbGVtZW50VG9rZW4oe1xuICAgICAgICAgICAgdGFpbDogZmFsc2UsXG4gICAgICAgICAgICBpbnRlcnA6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHNsaWNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdcXFxcJzoge1xuICAgICAgICBsZXQgbmV3VmFsO1xuICAgICAgICBbbmV3VmFsLCBpZHgsIG9jdGFsXSA9IHJlYWRTdHJpbmdFc2NhcGUuY2FsbCh0aGlzLCAnJywgc3RyZWFtLCBpZHgsIG9jdGFsKTtcbiAgICAgICAgaWYgKG9jdGFsICE9IG51bGwpIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChvY3RhbCk7XG4gICAgICAgIHZhbHVlICs9IG5ld1ZhbDtcbiAgICAgICAgLS1pZHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoKytpZHgpO1xuICB9XG4gIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbn1cbiJdfQ==

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readDelimiter;

	var _immutable = __webpack_require__(10);

	var _tokens = __webpack_require__(30);

	function readDelimiter(delimiter, stream, prefix, exprAllowed) {
	  let results = (0, _immutable.List)();
	  let result;
	  while (stream.peek() !== delimiter) {
	    result = this.readToken(stream, results, exprAllowed);

	    if (result !== _tokens.EmptyToken) {
	      results = results.push(result);
	    }
	  }
	  return results;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1kZWxpbWl0ZXIuanMiXSwibmFtZXMiOlsicmVhZERlbGltaXRlciIsImRlbGltaXRlciIsInN0cmVhbSIsInByZWZpeCIsImV4cHJBbGxvd2VkIiwicmVzdWx0cyIsInJlc3VsdCIsInBlZWsiLCJyZWFkVG9rZW4iLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFRd0JBLGE7O0FBTnhCOztBQUNBOztBQUtlLFNBQVNBLGFBQVQsQ0FBdUJDLFNBQXZCLEVBQTBDQyxNQUExQyxFQUE4REMsTUFBOUQsRUFBb0ZDLFdBQXBGLEVBQTBHO0FBQ3ZILE1BQUlDLFVBQVUsc0JBQWQ7QUFDQSxNQUFJQyxNQUFKO0FBQ0EsU0FBT0osT0FBT0ssSUFBUCxPQUFrQk4sU0FBekIsRUFBb0M7QUFDbENLLGFBQVMsS0FBS0UsU0FBTCxDQUFlTixNQUFmLEVBQXVCRyxPQUF2QixFQUFnQ0QsV0FBaEMsQ0FBVDs7QUFFQSxRQUFJRSw2QkFBSixFQUEyQjtBQUN6QkQsZ0JBQVVBLFFBQVFJLElBQVIsQ0FBYUgsTUFBYixDQUFWO0FBQ0Q7QUFDRjtBQUNELFNBQU9ELE9BQVA7QUFDRCIsImZpbGUiOiJyZWFkLWRlbGltaXRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgRW1wdHlUb2tlbiB9IGZyb20gJy4uL3Rva2Vucyc7XG5cbmltcG9ydCB0eXBlIENoYXJTdHJlYW0gZnJvbSAnLi9jaGFyLXN0cmVhbSc7XG5pbXBvcnQgdHlwZSBTeW50YXggZnJvbSAnLi4vc3ludGF4JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZERlbGltaXRlcihkZWxpbWl0ZXI6IHN0cmluZywgc3RyZWFtOiBDaGFyU3RyZWFtLCBwcmVmaXg6IExpc3Q8U3ludGF4PiwgZXhwckFsbG93ZWQ6IGJvb2xlYW4pIHtcbiAgbGV0IHJlc3VsdHMgPSBMaXN0KCk7XG4gIGxldCByZXN1bHQ7XG4gIHdoaWxlIChzdHJlYW0ucGVlaygpICE9PSBkZWxpbWl0ZXIpIHtcbiAgICByZXN1bHQgPSB0aGlzLnJlYWRUb2tlbihzdHJlYW0sIHJlc3VsdHMsIGV4cHJBbGxvd2VkKTtcblxuICAgIGlmIChyZXN1bHQgIT09IEVtcHR5VG9rZW4pIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iXX0=

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readRegExp;

	var _charStream = __webpack_require__(8);

	var _tokens = __webpack_require__(30);

	var _utils = __webpack_require__(13);

	function readRegExp(stream) {
	  let value = stream.readString(),
	      char = stream.peek(),
	      idx = 0,
	      classMarker = false,
	      terminated = false;

	  const UNTERMINATED_REGEXP_MSG = 'Invalid regular expression: missing /';

	  while (!(0, _charStream.isEOS)(char)) {
	    if (char === '\\') {
	      value += char;
	      ++idx;
	      char = stream.peek(idx);

	      if ((0, _utils.isLineTerminator)(char.charCodeAt(0))) {
	        throw this.createError(UNTERMINATED_REGEXP_MSG);
	      }
	      value += char;
	      ++idx;
	    } else if ((0, _utils.isLineTerminator)(char.charCodeAt(0))) {
	      throw this.createError(UNTERMINATED_REGEXP_MSG);
	    } else {
	      if (classMarker) {
	        if (char === ']') {
	          classMarker = false;
	        }
	      } else {
	        if (char === '/') {
	          terminated = true;
	          value += char;
	          ++idx;
	          char = stream.peek(idx);
	          break;
	        } else if (char === '[') {
	          classMarker = true;
	        }
	      }
	      value += char;
	      ++idx;
	    }
	    char = stream.peek(idx);
	  }

	  if (!terminated) {
	    throw this.createError(UNTERMINATED_REGEXP_MSG);
	  }

	  while (!(0, _charStream.isEOS)(char)) {
	    if (char === '\\') {
	      throw this.createError('Invalid regular expression flags');
	    }
	    if (!(0, _utils.isIdentifierPart)(char.charCodeAt(0))) {
	      break;
	    }
	    value += char;
	    ++idx;
	    char = stream.peek(idx);
	  }

	  stream.readString(idx);

	  return new _tokens.RegExpToken({
	    value
	  });
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1yZWdleHAuanMiXSwibmFtZXMiOlsicmVhZFJlZ0V4cCIsInN0cmVhbSIsInZhbHVlIiwicmVhZFN0cmluZyIsImNoYXIiLCJwZWVrIiwiaWR4IiwiY2xhc3NNYXJrZXIiLCJ0ZXJtaW5hdGVkIiwiVU5URVJNSU5BVEVEX1JFR0VYUF9NU0ciLCJjaGFyQ29kZUF0IiwiY3JlYXRlRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQU93QkEsVTs7QUFKeEI7O0FBQ0E7O0FBQ0E7O0FBRWUsU0FBU0EsVUFBVCxDQUFvQkMsTUFBcEIsRUFBd0M7QUFDckQsTUFBSUMsUUFBUUQsT0FBT0UsVUFBUCxFQUFaO0FBQUEsTUFBaUNDLE9BQU9ILE9BQU9JLElBQVAsRUFBeEM7QUFBQSxNQUF1REMsTUFBTSxDQUE3RDtBQUFBLE1BQWdFQyxjQUFjLEtBQTlFO0FBQUEsTUFBcUZDLGFBQWEsS0FBbEc7O0FBRUEsUUFBTUMsMEJBQTBCLHVDQUFoQzs7QUFFQSxTQUFPLENBQUMsdUJBQU1MLElBQU4sQ0FBUixFQUFxQjtBQUNuQixRQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakJGLGVBQVNFLElBQVQ7QUFDQSxRQUFFRSxHQUFGO0FBQ0FGLGFBQU9ILE9BQU9JLElBQVAsQ0FBWUMsR0FBWixDQUFQOztBQUVBLFVBQUksNkJBQWlCRixLQUFLTSxVQUFMLENBQWdCLENBQWhCLENBQWpCLENBQUosRUFBMEM7QUFDeEMsY0FBTSxLQUFLQyxXQUFMLENBQWlCRix1QkFBakIsQ0FBTjtBQUNEO0FBQ0RQLGVBQVNFLElBQVQ7QUFDQSxRQUFFRSxHQUFGO0FBQ0QsS0FWRCxNQVVPLElBQUksNkJBQWlCRixLQUFLTSxVQUFMLENBQWdCLENBQWhCLENBQWpCLENBQUosRUFBMEM7QUFDL0MsWUFBTSxLQUFLQyxXQUFMLENBQWlCRix1QkFBakIsQ0FBTjtBQUNELEtBRk0sTUFFQTtBQUNMLFVBQUlGLFdBQUosRUFBaUI7QUFDZixZQUFJSCxTQUFTLEdBQWIsRUFBa0I7QUFDaEJHLHdCQUFjLEtBQWQ7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLFlBQUlILFNBQVMsR0FBYixFQUFrQjtBQUNoQkksdUJBQWEsSUFBYjtBQUNBTixtQkFBU0UsSUFBVDtBQUNBLFlBQUVFLEdBQUY7QUFDQUYsaUJBQU9ILE9BQU9JLElBQVAsQ0FBWUMsR0FBWixDQUFQO0FBQ0E7QUFDRCxTQU5ELE1BTU8sSUFBSUYsU0FBUyxHQUFiLEVBQWtCO0FBQ3ZCRyx3QkFBYyxJQUFkO0FBQ0Q7QUFDRjtBQUNETCxlQUFTRSxJQUFUO0FBQ0EsUUFBRUUsR0FBRjtBQUNEO0FBQ0RGLFdBQU9ILE9BQU9JLElBQVAsQ0FBWUMsR0FBWixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDRSxVQUFMLEVBQWlCO0FBQ2YsVUFBTSxLQUFLRyxXQUFMLENBQWlCRix1QkFBakIsQ0FBTjtBQUNEOztBQUVELFNBQU8sQ0FBQyx1QkFBTUwsSUFBTixDQUFSLEVBQXFCO0FBQ25CLFFBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNqQixZQUFNLEtBQUtPLFdBQUwsQ0FBaUIsa0NBQWpCLENBQU47QUFDRDtBQUNELFFBQUksQ0FBQyw2QkFBaUJQLEtBQUtNLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBakIsQ0FBTCxFQUEyQztBQUN6QztBQUNEO0FBQ0RSLGFBQVNFLElBQVQ7QUFDQSxNQUFFRSxHQUFGO0FBQ0FGLFdBQU9ILE9BQU9JLElBQVAsQ0FBWUMsR0FBWixDQUFQO0FBQ0Q7O0FBRURMLFNBQU9FLFVBQVAsQ0FBa0JHLEdBQWxCOztBQUVBLFNBQU8sd0JBQWdCO0FBQ3JCSjtBQURxQixHQUFoQixDQUFQO0FBR0QiLCJmaWxlIjoicmVhZC1yZWdleHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgQ2hhclN0cmVhbSBmcm9tICcuL2NoYXItc3RyZWFtJztcblxuaW1wb3J0IHsgaXNFT1MgfSBmcm9tICcuL2NoYXItc3RyZWFtJztcbmltcG9ydCB7IFJlZ0V4cFRva2VuIH0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IGlzTGluZVRlcm1pbmF0b3IsIGlzSWRlbnRpZmllclBhcnQgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZFJlZ0V4cChzdHJlYW06IENoYXJTdHJlYW0pIHtcbiAgbGV0IHZhbHVlID0gc3RyZWFtLnJlYWRTdHJpbmcoKSwgY2hhciA9IHN0cmVhbS5wZWVrKCksIGlkeCA9IDAsIGNsYXNzTWFya2VyID0gZmFsc2UsIHRlcm1pbmF0ZWQgPSBmYWxzZTtcblxuICBjb25zdCBVTlRFUk1JTkFURURfUkVHRVhQX01TRyA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJztcblxuICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICsraWR4O1xuICAgICAgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG5cbiAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoYXIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihVTlRFUk1JTkFURURfUkVHRVhQX01TRyk7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgKytpZHg7XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoYXIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoVU5URVJNSU5BVEVEX1JFR0VYUF9NU0cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICddJykge1xuICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaGFyID09PSAnLycpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICsraWR4O1xuICAgICAgICAgIGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICsraWR4O1xuICAgIH1cbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgfVxuXG4gIGlmICghdGVybWluYXRlZCkge1xuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoVU5URVJNSU5BVEVEX1JFR0VYUF9NU0cpO1xuICB9XG5cbiAgd2hpbGUgKCFpc0VPUyhjaGFyKSkge1xuICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzJyk7XG4gICAgfVxuICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaGFyLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFsdWUgKz0gY2hhcjtcbiAgICArK2lkeDtcbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgfVxuXG4gIHN0cmVhbS5yZWFkU3RyaW5nKGlkeCk7XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHBUb2tlbih7XG4gICAgdmFsdWVcbiAgfSk7XG59XG4iXX0=

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readComment;

	var _charStream = __webpack_require__(8);

	var _utils = __webpack_require__(13);

	var _tokens = __webpack_require__(30);

	function readComment(stream) {
	  let char = stream.peek();

	  while (!(0, _charStream.isEOS)(char)) {
	    let chCode = char.charCodeAt(0);
	    if (chCode === 47 /* "/" */) {
	        const nxt = stream.peek(1);
	        if ((0, _charStream.isEOS)(nxt)) {
	          break;
	        }
	        chCode = nxt.charCodeAt(0);
	        if (chCode === 47 /* "/" */) {
	            _utils.skipSingleLineComment.call(this, stream);
	          } else if (chCode === 42 /* "*" */) {
	            skipMultiLineComment.call(this, stream);
	          } else {
	          break;
	        }
	      } else {
	      break;
	    }
	    char = stream.peek();
	  }

	  return _tokens.EmptyToken;
	}

	function skipMultiLineComment(stream) {
	  let idx = 2;
	  let char = stream.peek(idx);
	  const { position: startPosition } = stream.sourceInfo;
	  let lineStart;
	  while (!(0, _charStream.isEOS)(char)) {
	    let chCode = char.charCodeAt(0);
	    if (chCode < 0x80) {
	      switch (chCode) {
	        case 42:
	          // "*"
	          // Block comment ends with "*/".
	          if (stream.peek(idx + 1).charAt(0) === '/') {
	            stream.readString(idx + 2);
	            if (lineStart) this.locationInfo.column = stream.sourceInfo.position - lineStart;
	            return;
	          }
	          ++idx;
	          break;
	        case 10:
	          // "\n"
	          this.incrementLine();
	          lineStart = startPosition + idx;
	          ++idx;
	          break;
	        case 13:
	          // "\r":
	          {
	            let startIdx = idx;
	            if (stream.peek(idx + 1).charAt(0) === '\n') {
	              ++idx;
	            }
	            ++idx;
	            this.incrementLine();
	            lineStart = startPosition + startIdx;
	            break;
	          }
	        default:
	          ++idx;
	      }
	    } else if (chCode === 0x2028 || chCode === 0x2029) {
	      this.incrementLine();
	      lineStart = startPosition + idx;
	      ++idx;
	    } else {
	      ++idx;
	    }
	    char = stream.peek(idx);
	  }
	  throw this.createILLEGAL(char);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1jb21tZW50LmpzIl0sIm5hbWVzIjpbInJlYWRDb21tZW50Iiwic3RyZWFtIiwiY2hhciIsInBlZWsiLCJjaENvZGUiLCJjaGFyQ29kZUF0Iiwibnh0IiwiY2FsbCIsInNraXBNdWx0aUxpbmVDb21tZW50IiwiaWR4IiwicG9zaXRpb24iLCJzdGFydFBvc2l0aW9uIiwic291cmNlSW5mbyIsImxpbmVTdGFydCIsImNoYXJBdCIsInJlYWRTdHJpbmciLCJsb2NhdGlvbkluZm8iLCJjb2x1bW4iLCJpbmNyZW1lbnRMaW5lIiwic3RhcnRJZHgiLCJjcmVhdGVJTExFR0FMIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFPd0JBLFc7O0FBSnhCOztBQUNBOztBQUNBOztBQUVlLFNBQVNBLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTREO0FBQ3pFLE1BQUlDLE9BQU9ELE9BQU9FLElBQVAsRUFBWDs7QUFFQSxTQUFPLENBQUMsdUJBQU1ELElBQU4sQ0FBUixFQUFxQjtBQUNuQixRQUFJRSxTQUFTRixLQUFLRyxVQUFMLENBQWdCLENBQWhCLENBQWI7QUFDQSxRQUFJRCxXQUFXLEVBQWYsQ0FBa0IsU0FBbEIsRUFBNkI7QUFDM0IsY0FBTUUsTUFBTUwsT0FBT0UsSUFBUCxDQUFZLENBQVosQ0FBWjtBQUNBLFlBQUksdUJBQU1HLEdBQU4sQ0FBSixFQUFnQjtBQUNkO0FBQ0Q7QUFDREYsaUJBQVNFLElBQUlELFVBQUosQ0FBZSxDQUFmLENBQVQ7QUFDQSxZQUFJRCxXQUFXLEVBQWYsQ0FBa0IsU0FBbEIsRUFBNkI7QUFDM0IseUNBQXNCRyxJQUF0QixDQUEyQixJQUEzQixFQUFpQ04sTUFBakM7QUFDRCxXQUZELE1BRU8sSUFBSUcsV0FBVyxFQUFmLENBQWtCLFNBQWxCLEVBQTZCO0FBQ2xDSSxpQ0FBcUJELElBQXJCLENBQTBCLElBQTFCLEVBQWdDTixNQUFoQztBQUNELFdBRk0sTUFFQTtBQUNMO0FBQ0Q7QUFDRixPQWJELE1BYU87QUFDTDtBQUNEO0FBQ0RDLFdBQU9ELE9BQU9FLElBQVAsRUFBUDtBQUNEOztBQUVEO0FBQ0Q7O0FBRUQsU0FBU0ssb0JBQVQsQ0FBOEJQLE1BQTlCLEVBQXdEO0FBQ3RELE1BQUlRLE1BQU0sQ0FBVjtBQUNBLE1BQUlQLE9BQU9ELE9BQU9FLElBQVAsQ0FBWU0sR0FBWixDQUFYO0FBQ0EsUUFBTSxFQUFFQyxVQUFVQyxhQUFaLEtBQThCVixPQUFPVyxVQUEzQztBQUNBLE1BQUlDLFNBQUo7QUFDQSxTQUFPLENBQUMsdUJBQU1YLElBQU4sQ0FBUixFQUFxQjtBQUNuQixRQUFJRSxTQUFTRixLQUFLRyxVQUFMLENBQWdCLENBQWhCLENBQWI7QUFDQSxRQUFJRCxTQUFTLElBQWIsRUFBbUI7QUFDakIsY0FBUUEsTUFBUjtBQUNBLGFBQUssRUFBTDtBQUFVO0FBQ1I7QUFDQSxjQUFJSCxPQUFPRSxJQUFQLENBQVlNLE1BQU0sQ0FBbEIsRUFBcUJLLE1BQXJCLENBQTRCLENBQTVCLE1BQW1DLEdBQXZDLEVBQTRDO0FBQzFDYixtQkFBT2MsVUFBUCxDQUFrQk4sTUFBTSxDQUF4QjtBQUNBLGdCQUFJSSxTQUFKLEVBQWUsS0FBS0csWUFBTCxDQUFrQkMsTUFBbEIsR0FBMkJoQixPQUFPVyxVQUFQLENBQWtCRixRQUFsQixHQUE2QkcsU0FBeEQ7QUFDZjtBQUNEO0FBQ0QsWUFBRUosR0FBRjtBQUNBO0FBQ0YsYUFBSyxFQUFMO0FBQVU7QUFDUixlQUFLUyxhQUFMO0FBQ0FMLHNCQUFZRixnQkFBZ0JGLEdBQTVCO0FBQ0EsWUFBRUEsR0FBRjtBQUNBO0FBQ0YsYUFBSyxFQUFMO0FBQVM7QUFDVDtBQUNFLGdCQUFJVSxXQUFXVixHQUFmO0FBQ0EsZ0JBQUlSLE9BQU9FLElBQVAsQ0FBWU0sTUFBTSxDQUFsQixFQUFxQkssTUFBckIsQ0FBNEIsQ0FBNUIsTUFBbUMsSUFBdkMsRUFBNkM7QUFDM0MsZ0JBQUVMLEdBQUY7QUFDRDtBQUNELGNBQUVBLEdBQUY7QUFDQSxpQkFBS1MsYUFBTDtBQUNBTCx3QkFBWUYsZ0JBQWdCUSxRQUE1QjtBQUNBO0FBQ0Q7QUFDRDtBQUNFLFlBQUVWLEdBQUY7QUEzQkY7QUE2QkQsS0E5QkQsTUE4Qk8sSUFBSUwsV0FBVyxNQUFYLElBQXFCQSxXQUFXLE1BQXBDLEVBQTRDO0FBQ2pELFdBQUtjLGFBQUw7QUFDQUwsa0JBQVlGLGdCQUFnQkYsR0FBNUI7QUFDQSxRQUFFQSxHQUFGO0FBQ0QsS0FKTSxNQUlBO0FBQ0wsUUFBRUEsR0FBRjtBQUNEO0FBQ0RQLFdBQU9ELE9BQU9FLElBQVAsQ0FBWU0sR0FBWixDQUFQO0FBQ0Q7QUFDRCxRQUFNLEtBQUtXLGFBQUwsQ0FBbUJsQixJQUFuQixDQUFOO0FBQ0QiLCJmaWxlIjoicmVhZC1jb21tZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIENoYXJTdHJlYW0gZnJvbSAnLi9jaGFyLXN0cmVhbSc7XG5cbmltcG9ydCB7IGlzRU9TIH0gZnJvbSAnLi9jaGFyLXN0cmVhbSc7XG5pbXBvcnQgeyBza2lwU2luZ2xlTGluZUNvbW1lbnQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IEVtcHR5VG9rZW4gfSBmcm9tICcuLi90b2tlbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkQ29tbWVudChzdHJlYW06IENoYXJTdHJlYW0pOiB0eXBlb2YgRW1wdHlUb2tlbiB7XG4gIGxldCBjaGFyID0gc3RyZWFtLnBlZWsoKTtcblxuICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgbGV0IGNoQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoY2hDb2RlID09PSA0NyAvKiBcIi9cIiAqLykge1xuICAgICAgY29uc3Qgbnh0ID0gc3RyZWFtLnBlZWsoMSk7XG4gICAgICBpZiAoaXNFT1Mobnh0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNoQ29kZSA9IG54dC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNoQ29kZSA9PT0gNDcgLyogXCIvXCIgKi8pIHtcbiAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50LmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hDb2RlID09PSA0MiAvKiBcIipcIiAqLykge1xuICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudC5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNoYXIgPSBzdHJlYW0ucGVlaygpO1xuICB9XG5cbiAgcmV0dXJuIEVtcHR5VG9rZW47XG59XG5cbmZ1bmN0aW9uIHNraXBNdWx0aUxpbmVDb21tZW50KHN0cmVhbTogQ2hhclN0cmVhbSk6IHZvaWQge1xuICBsZXQgaWR4ID0gMjtcbiAgbGV0IGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICBjb25zdCB7IHBvc2l0aW9uOiBzdGFydFBvc2l0aW9uIH0gPSBzdHJlYW0uc291cmNlSW5mbztcbiAgbGV0IGxpbmVTdGFydDtcbiAgd2hpbGUgKCFpc0VPUyhjaGFyKSkge1xuICAgIGxldCBjaENvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGNoQ29kZSA8IDB4ODApIHtcbiAgICAgIHN3aXRjaCAoY2hDb2RlKSB7XG4gICAgICBjYXNlIDQyOiAgLy8gXCIqXCJcbiAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggXCIqL1wiLlxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoaWR4ICsgMSkuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICBzdHJlYW0ucmVhZFN0cmluZyhpZHggKyAyKTtcbiAgICAgICAgICBpZiAobGluZVN0YXJ0KSB0aGlzLmxvY2F0aW9uSW5mby5jb2x1bW4gPSBzdHJlYW0uc291cmNlSW5mby5wb3NpdGlvbiAtIGxpbmVTdGFydDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKytpZHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDogIC8vIFwiXFxuXCJcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRMaW5lKCk7XG4gICAgICAgIGxpbmVTdGFydCA9IHN0YXJ0UG9zaXRpb24gKyBpZHg7XG4gICAgICAgICsraWR4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTM6IC8vIFwiXFxyXCI6XG4gICAgICB7XG4gICAgICAgIGxldCBzdGFydElkeCA9IGlkeDtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKGlkeCArIDEpLmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICArK2lkeDtcbiAgICAgICAgfVxuICAgICAgICArK2lkeDtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRMaW5lKCk7XG4gICAgICAgIGxpbmVTdGFydCA9IHN0YXJ0UG9zaXRpb24gKyBzdGFydElkeDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICArK2lkeDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoQ29kZSA9PT0gMHgyMDI4IHx8IGNoQ29kZSA9PT0gMHgyMDI5KSB7XG4gICAgICB0aGlzLmluY3JlbWVudExpbmUoKTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0UG9zaXRpb24gKyBpZHg7XG4gICAgICArK2lkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgKytpZHg7XG4gICAgfVxuICAgIGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICB9XG4gIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbn1cbiJdfQ==

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = readDispatch;

	var _readtable = __webpack_require__(11);

	var _readDelimiter = __webpack_require__(34);

	var _readDelimiter2 = _interopRequireDefault(_readDelimiter);

	var _utils = __webpack_require__(13);

	var _immutable = __webpack_require__(10);

	var _tokenReader = __webpack_require__(6);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _tokens = __webpack_require__(30);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	const dispatchReadtable = _readtable.EmptyReadtable.extendReadtable({
	  key: '`',
	  action: function readSyntaxTemplate(stream, prefix, exprAllowed, dispatchKey) {
	    // return read('syntaxTemplate').first().token;
	    // TODO: Can we simply tack 'syntaxTemplate' on the front and process it as a
	    //       syntax macro?
	    let startLocation = Object.assign({}, this.locationInfo, stream.sourceInfo);
	    const opening = new _syntax2.default({
	      type: _utils.LSYNTAX,
	      value: `${ dispatchKey }${ stream.readString() }`,
	      slice: (0, _tokenReader.getSlice)(stream, startLocation)
	    }, this.context);
	    const result = _readDelimiter2.default.call(this, '`', stream, (0, _immutable.List)(), true);

	    startLocation = Object.assign({}, this.locationInfo, stream.sourceInfo);
	    const closing = new _syntax2.default({
	      type: _utils.RSYNTAX,
	      value: stream.readString(),
	      slice: (0, _tokenReader.getSlice)(stream, startLocation)
	    }, this.context);
	    return result.unshift(opening).push(closing);
	  }
	}, {
	  action: function readDefault(stream, prefix, exprAllowed, dispatchKey) {
	    // treating them as single line comments
	    _utils.skipSingleLineComment.call(this, stream);
	    return _tokens.EmptyToken;
	  }
	});

	function readDispatch(stream, prefix, exprAllowed) {
	  const dispatchKey = stream.readString();
	  const dispatchEntry = dispatchReadtable.getEntry(stream.peek());
	  const result = dispatchEntry.action.call(this, stream, prefix, exprAllowed, dispatchKey);
	  return result;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1kaXNwYXRjaC5qcyJdLCJuYW1lcyI6WyJyZWFkRGlzcGF0Y2giLCJkaXNwYXRjaFJlYWR0YWJsZSIsImV4dGVuZFJlYWR0YWJsZSIsImtleSIsImFjdGlvbiIsInJlYWRTeW50YXhUZW1wbGF0ZSIsInN0cmVhbSIsInByZWZpeCIsImV4cHJBbGxvd2VkIiwiZGlzcGF0Y2hLZXkiLCJzdGFydExvY2F0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwibG9jYXRpb25JbmZvIiwic291cmNlSW5mbyIsIm9wZW5pbmciLCJ0eXBlIiwidmFsdWUiLCJyZWFkU3RyaW5nIiwic2xpY2UiLCJjb250ZXh0IiwicmVzdWx0IiwiY2FsbCIsImNsb3NpbmciLCJ1bnNoaWZ0IiwicHVzaCIsInJlYWREZWZhdWx0IiwiZGlzcGF0Y2hFbnRyeSIsImdldEVudHJ5IiwicGVlayJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBMkN3QkEsWTs7QUF6Q3hCOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUtBLE1BQU1DLG9CQUFvQiwwQkFBZUMsZUFBZixDQUErQjtBQUN2REMsT0FBSyxHQURrRDtBQUV2REMsVUFBUSxTQUFTQyxrQkFBVCxDQUE0QkMsTUFBNUIsRUFBZ0RDLE1BQWhELEVBQXNFQyxXQUF0RSxFQUE0RkMsV0FBNUYsRUFBK0g7QUFDckk7QUFDQTtBQUNBO0FBQ0EsUUFBSUMsZ0JBQWdCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLQyxZQUF2QixFQUFxQ1AsT0FBT1EsVUFBNUMsQ0FBcEI7QUFDQSxVQUFNQyxVQUFVLHFCQUFXO0FBQ3pCQywwQkFEeUI7QUFFekJDLGFBQVEsSUFBRVIsV0FBWSxLQUFFSCxPQUFPWSxVQUFQLEVBQW9CLEdBRm5CO0FBR3pCQyxhQUFPLDJCQUFTYixNQUFULEVBQWlCSSxhQUFqQjtBQUhrQixLQUFYLEVBSWIsS0FBS1UsT0FKUSxDQUFoQjtBQUtBLFVBQU1DLFNBQVMsd0JBQWNDLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsR0FBekIsRUFBOEJoQixNQUE5QixFQUFzQyxzQkFBdEMsRUFBOEMsSUFBOUMsQ0FBZjs7QUFFQUksb0JBQWdCQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLQyxZQUF2QixFQUFxQ1AsT0FBT1EsVUFBNUMsQ0FBaEI7QUFDQSxVQUFNUyxVQUFVLHFCQUFXO0FBQ3pCUCwwQkFEeUI7QUFFekJDLGFBQU9YLE9BQU9ZLFVBQVAsRUFGa0I7QUFHekJDLGFBQU8sMkJBQVNiLE1BQVQsRUFBaUJJLGFBQWpCO0FBSGtCLEtBQVgsRUFJYixLQUFLVSxPQUpRLENBQWhCO0FBS0EsV0FBT0MsT0FBT0csT0FBUCxDQUFlVCxPQUFmLEVBQXdCVSxJQUF4QixDQUE2QkYsT0FBN0IsQ0FBUDtBQUNEO0FBckJzRCxDQUEvQixFQXNCdkI7QUFDRG5CLFVBQVEsU0FBU3NCLFdBQVQsQ0FBcUJwQixNQUFyQixFQUF5Q0MsTUFBekMsRUFBK0RDLFdBQS9ELEVBQXFGQyxXQUFyRixFQUE2SDtBQUNuSTtBQUNBLGlDQUFzQmEsSUFBdEIsQ0FBMkIsSUFBM0IsRUFBaUNoQixNQUFqQztBQUNBO0FBQ0Q7QUFMQSxDQXRCdUIsQ0FBMUI7O0FBOEJlLFNBQVNOLFlBQVQsQ0FBc0JNLE1BQXRCLEVBQTBDQyxNQUExQyxFQUFnRUMsV0FBaEUsRUFBd0g7QUFDckksUUFBTUMsY0FBY0gsT0FBT1ksVUFBUCxFQUFwQjtBQUNBLFFBQU1TLGdCQUFnQjFCLGtCQUFrQjJCLFFBQWxCLENBQTJCdEIsT0FBT3VCLElBQVAsRUFBM0IsQ0FBdEI7QUFDQSxRQUFNUixTQUFTTSxjQUFjdkIsTUFBZCxDQUFxQmtCLElBQXJCLENBQTBCLElBQTFCLEVBQWdDaEIsTUFBaEMsRUFBd0NDLE1BQXhDLEVBQWdEQyxXQUFoRCxFQUE2REMsV0FBN0QsQ0FBZjtBQUNBLFNBQU9ZLE1BQVA7QUFDRCIsImZpbGUiOiJyZWFkLWRpc3BhdGNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHsgRW1wdHlSZWFkdGFibGUgfSBmcm9tICcuL3JlYWR0YWJsZSc7XG5pbXBvcnQgcmVhZERlbGltaXRlciBmcm9tICcuL3JlYWQtZGVsaW1pdGVyJztcbmltcG9ydCB7IExTWU5UQVgsIFJTWU5UQVggfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgZ2V0U2xpY2UgfSBmcm9tICcuL3Rva2VuLXJlYWRlcic7XG5pbXBvcnQgU3ludGF4IGZyb20gJy4uL3N5bnRheCc7XG5pbXBvcnQgeyBFbXB0eVRva2VuIH0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IHNraXBTaW5nbGVMaW5lQ29tbWVudCB9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSBDaGFyU3RyZWFtIGZyb20gJy4vY2hhci1zdHJlYW0nO1xuXG5jb25zdCBkaXNwYXRjaFJlYWR0YWJsZSA9IEVtcHR5UmVhZHRhYmxlLmV4dGVuZFJlYWR0YWJsZSh7XG4gIGtleTogJ2AnLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWRTeW50YXhUZW1wbGF0ZShzdHJlYW06IENoYXJTdHJlYW0sIHByZWZpeDogTGlzdDxTeW50YXg+LCBleHByQWxsb3dlZDogYm9vbGVhbiwgZGlzcGF0Y2hLZXk6IHN0cmluZyk6IExpc3Q8U3ludGF4PiB7XG4gICAgLy8gcmV0dXJuIHJlYWQoJ3N5bnRheFRlbXBsYXRlJykuZmlyc3QoKS50b2tlbjtcbiAgICAvLyBUT0RPOiBDYW4gd2Ugc2ltcGx5IHRhY2sgJ3N5bnRheFRlbXBsYXRlJyBvbiB0aGUgZnJvbnQgYW5kIHByb2Nlc3MgaXQgYXMgYVxuICAgIC8vICAgICAgIHN5bnRheCBtYWNybz9cbiAgICBsZXQgc3RhcnRMb2NhdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9jYXRpb25JbmZvLCBzdHJlYW0uc291cmNlSW5mbyk7XG4gICAgY29uc3Qgb3BlbmluZyA9IG5ldyBTeW50YXgoe1xuICAgICAgdHlwZTogTFNZTlRBWCxcbiAgICAgIHZhbHVlOiBgJHtkaXNwYXRjaEtleX0ke3N0cmVhbS5yZWFkU3RyaW5nKCl9YCxcbiAgICAgIHNsaWNlOiBnZXRTbGljZShzdHJlYW0sIHN0YXJ0TG9jYXRpb24pXG4gICAgfSwgdGhpcy5jb250ZXh0KTtcbiAgICBjb25zdCByZXN1bHQgPSByZWFkRGVsaW1pdGVyLmNhbGwodGhpcywgJ2AnLCBzdHJlYW0sIExpc3QoKSwgdHJ1ZSk7XG5cbiAgICBzdGFydExvY2F0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2NhdGlvbkluZm8sIHN0cmVhbS5zb3VyY2VJbmZvKTtcbiAgICBjb25zdCBjbG9zaW5nID0gbmV3IFN5bnRheCh7XG4gICAgICB0eXBlOiBSU1lOVEFYLFxuICAgICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKCksXG4gICAgICBzbGljZTogZ2V0U2xpY2Uoc3RyZWFtLCBzdGFydExvY2F0aW9uKVxuICAgIH0sIHRoaXMuY29udGV4dCk7XG4gICAgcmV0dXJuIHJlc3VsdC51bnNoaWZ0KG9wZW5pbmcpLnB1c2goY2xvc2luZyk7XG4gIH1cbn0sIHtcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkRGVmYXVsdChzdHJlYW06IENoYXJTdHJlYW0sIHByZWZpeDogTGlzdDxTeW50YXg+LCBleHByQWxsb3dlZDogYm9vbGVhbiwgZGlzcGF0Y2hLZXk6IHN0cmluZyk6IHR5cGVvZiBFbXB0eVRva2VuIHtcbiAgICAvLyB0cmVhdGluZyB0aGVtIGFzIHNpbmdsZSBsaW5lIGNvbW1lbnRzXG4gICAgc2tpcFNpbmdsZUxpbmVDb21tZW50LmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICByZXR1cm4gRW1wdHlUb2tlbjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWREaXNwYXRjaChzdHJlYW06IENoYXJTdHJlYW0sIHByZWZpeDogTGlzdDxTeW50YXg+LCBleHByQWxsb3dlZDogYm9vbGVhbik6IExpc3Q8U3ludGF4PiB8IHR5cGVvZiBFbXB0eVRva2VuIHtcbiAgY29uc3QgZGlzcGF0Y2hLZXkgPSBzdHJlYW0ucmVhZFN0cmluZygpO1xuICBjb25zdCBkaXNwYXRjaEVudHJ5ID0gZGlzcGF0Y2hSZWFkdGFibGUuZ2V0RW50cnkoc3RyZWFtLnBlZWsoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IGRpc3BhdGNoRW50cnkuYWN0aW9uLmNhbGwodGhpcywgc3RyZWFtLCBwcmVmaXgsIGV4cHJBbGxvd2VkLCBkaXNwYXRjaEtleSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ALL_PHASES = exports.Types = undefined;

	var _immutable = __webpack_require__(10);

	var _errors = __webpack_require__(39);

	var _bindingMap = __webpack_require__(40);

	var _bindingMap2 = _interopRequireDefault(_bindingMap);

	var _ramdaFantasy = __webpack_require__(19);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _sweetSpec = __webpack_require__(41);

	var T = _interopRequireWildcard(_sweetSpec);

	var _tokens = __webpack_require__(30);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getFirstSlice(stx) {
	  if (!stx || typeof stx.isDelimiter !== 'function') return null; // TODO: should not have to do this
	  if (!stx.isDelimiter()) {
	    return stx.token.slice;
	  }
	  return stx.token.get(0).token.slice;
	}


	function sizeDecending(a, b) {
	  if (a.scopes.size > b.scopes.size) {
	    return -1;
	  } else if (b.scopes.size > a.scopes.size) {
	    return 1;
	  } else {
	    return 0;
	  }
	}

	let Types = exports.Types = {
	  null: {
	    match: token => !Types.delimiter.match(token) && token.type === _tokens.TokenType.NULL,
	    create: (value, stx) => new Syntax({
	      type: _tokens.TokenType.NULL,
	      value: null
	    }, stx)
	  },
	  number: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.NumericLiteral,
	    create: (value, stx) => new Syntax({
	      type: _tokens.TokenType.NUMBER,
	      value
	    }, stx)
	  },
	  string: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.StringLiteral,
	    create: (value, stx) => new Syntax({
	      type: _tokens.TokenType.STRING,
	      str: value
	    }, stx)
	  },
	  punctuator: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.Punctuator,
	    create: (value, stx) => new Syntax({
	      type: {
	        klass: _tokens.TokenClass.Punctuator,
	        name: value
	      },
	      value
	    }, stx)
	  },
	  keyword: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.Keyword,
	    create: (value, stx) => new Syntax({
	      type: {
	        klass: _tokens.TokenClass.Keyword,
	        name: value
	      },
	      value
	    }, stx)
	  },
	  identifier: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.Ident,
	    create: (value, stx) => new Syntax({
	      type: _tokens.TokenType.IDENTIFIER,
	      value
	    }, stx)
	  },
	  regularExpression: {
	    match: token => !Types.delimiter.match(token) && token.type.klass === _tokens.TokenClass.RegularExpression,
	    create: (value, stx) => new Syntax({
	      type: _tokens.TokenType.REGEXP,
	      value
	    }, stx)
	  },
	  braces: {
	    match: token => Types.delimiter.match(token) && token.get(0).token.type === _tokens.TokenType.LBRACE,
	    create: (inner, stx) => {
	      let left = new Syntax({
	        type: _tokens.TokenType.LBRACE,
	        value: '{',
	        slice: getFirstSlice(stx)
	      });
	      let right = new Syntax({
	        type: _tokens.TokenType.RBRACE,
	        value: '}',
	        slice: getFirstSlice(stx)
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx);
	    }
	  },
	  brackets: {
	    match: token => Types.delimiter.match(token) && token.get(0).token.type === _tokens.TokenType.LBRACK,
	    create: (inner, stx) => {
	      let left = new Syntax({
	        type: _tokens.TokenType.LBRACK,
	        value: '[',
	        slice: getFirstSlice(stx)
	      });
	      let right = new Syntax({
	        type: _tokens.TokenType.RBRACK,
	        value: ']',
	        slice: getFirstSlice(stx)
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx);
	    }
	  },
	  parens: {
	    match: token => Types.delimiter.match(token) && token.get(0).token.type === _tokens.TokenType.LPAREN,
	    create: (inner, stx) => {
	      let left = new Syntax({
	        type: _tokens.TokenType.LPAREN,
	        value: '(',
	        slice: getFirstSlice(stx)
	      });
	      let right = new Syntax({
	        type: _tokens.TokenType.RPAREN,
	        value: ')',
	        slice: getFirstSlice(stx)
	      });
	      return new Syntax(_immutable.List.of(left).concat(inner).push(right), stx);
	    }
	  },

	  assign: {
	    match: token => {
	      if (Types.punctuator.match(token)) {
	        switch (token.value) {
	          case '=':
	          case '|=':
	          case '^=':
	          case '&=':
	          case '<<=':
	          case '>>=':
	          case '>>>=':
	          case '+=':
	          case '-=':
	          case '*=':
	          case '/=':
	          case '%=':
	            return true;
	          default:
	            return false;
	        }
	      }
	      return false;
	    }
	  },

	  boolean: {
	    match: token => !Types.delimiter.match(token) && token.type === _tokens.TokenType.TRUE || token.type === _tokens.TokenType.FALSE
	  },

	  template: {
	    match: token => !Types.delimiter.match(token) && token.type === _tokens.TokenType.TEMPLATE
	  },

	  delimiter: {
	    match: token => _immutable.List.isList(token)
	  },

	  syntaxTemplate: {
	    match: token => Types.delimiter.match(token) && token.get(0).val() === '#`'
	  },

	  eof: {
	    match: token => !Types.delimiter.match(token) && token.type === _tokens.TokenType.EOS
	  }
	};
	const ALL_PHASES = exports.ALL_PHASES = {};

	class Syntax {

	  constructor(token, oldstx) {
	    this.token = token;
	    this.bindings = oldstx && oldstx.bindings != null ? oldstx.bindings : new _bindingMap2.default();
	    this.scopesets = oldstx && oldstx.scopesets != null ? oldstx.scopesets : {
	      all: (0, _immutable.List)(),
	      phase: (0, _immutable.Map)()
	    };
	    Object.freeze(this);
	  }
	  // token: Token | List<Token>;


	  static of(token, stx) {
	    return new Syntax(token, stx);
	  }

	  static from(type, value, stx) {
	    if (!Types[type]) {
	      throw new Error(type + ' is not a valid type');
	    } else if (!Types[type].create) {
	      throw new Error('Cannot create a syntax from type ' + type);
	    }
	    let newstx = Types[type].create(value, stx);
	    let slice = getFirstSlice(stx);
	    if (slice != null) {
	      newstx.token.slice = slice;
	    }
	    return newstx;
	  }

	  from(type, value) {
	    return new T.RawSyntax({ value: Syntax.from(type, value, this) });
	  }

	  fromNull() {
	    return this.from('null', null);
	  }

	  fromNumber(value) {
	    return this.from('number', value);
	  }

	  fromString(value) {
	    return this.from('string', value);
	  }

	  fromPunctuator(value) {
	    return this.from('punctuator', value);
	  }

	  fromKeyword(value) {
	    return this.from('keyword', value);
	  }

	  fromIdentifier(value) {
	    return this.from('identifier', value);
	  }

	  fromRegularExpression(value) {
	    return this.from('regularExpression', value);
	  }

	  static fromNull(stx) {
	    return Syntax.from('null', null, stx);
	  }

	  static fromNumber(value, stx) {
	    return Syntax.from('number', value, stx);
	  }

	  static fromString(value, stx) {
	    return Syntax.from('string', value, stx);
	  }

	  static fromPunctuator(value, stx) {
	    return Syntax.from('punctuator', value, stx);
	  }

	  static fromKeyword(value, stx) {
	    return Syntax.from('keyword', value, stx);
	  }

	  static fromIdentifier(value, stx) {
	    return Syntax.from('identifier', value, stx);
	  }

	  static fromRegularExpression(value, stx) {
	    return Syntax.from('regularExpression', value, stx);
	  }

	  // () -> string
	  resolve(phase) {
	    (0, _errors.assert)(phase != null, 'must provide a phase to resolve');
	    let allScopes = this.scopesets.all;
	    let stxScopes = this.scopesets.phase.has(phase) ? this.scopesets.phase.get(phase) : (0, _immutable.List)();
	    stxScopes = allScopes.concat(stxScopes);
	    if (stxScopes.size === 0 || !(this.match('identifier') || this.match('keyword'))) {
	      return this.token.value;
	    }
	    let scope = stxScopes.last();
	    let bindings = this.bindings;
	    if (scope) {
	      // List<{ scopes: List<Scope>, binding: Symbol }>
	      let scopesetBindingList = bindings.get(this);

	      if (scopesetBindingList) {
	        // { scopes: List<Scope>, binding: Symbol }
	        let biggestBindingPair = scopesetBindingList.filter(({ scopes }) => {
	          return scopes.isSubset(stxScopes);
	        }).sort(sizeDecending);

	        if (biggestBindingPair.size >= 2 && biggestBindingPair.get(0).scopes.size === biggestBindingPair.get(1).scopes.size) {
	          let debugBase = '{' + stxScopes.map(s => s.toString()).join(', ') + '}';
	          let debugAmbigousScopesets = biggestBindingPair.map(({ scopes }) => {
	            return '{' + scopes.map(s => s.toString()).join(', ') + '}';
	          }).join(', ');
	          throw new Error('Scopeset ' + debugBase + ' has ambiguous subsets ' + debugAmbigousScopesets);
	        } else if (biggestBindingPair.size !== 0) {
	          let bindingStr = biggestBindingPair.get(0).binding.toString();
	          if (_ramdaFantasy.Maybe.isJust(biggestBindingPair.get(0).alias)) {
	            // null never happens because we just checked if it is a Just
	            return biggestBindingPair.get(0).alias.getOrElse(null).resolve(phase);
	          }
	          return bindingStr;
	        }
	      }
	    }
	    return this.token.value;
	  }

	  val() {
	    (0, _errors.assert)(!this.match('delimiter'), 'cannot get the val of a delimiter');
	    if (this.match('string')) {
	      return this.token.str;
	    }
	    if (this.match('template')) {
	      if (!this.token.items) return this.token.value;
	      return this.token.items.map(el => {
	        if (typeof el.match === 'function' && el.match('delimiter')) {
	          return '${...}';
	        }
	        return el.slice.text;
	      }).join('');
	    }
	    return this.token.value;
	  }

	  lineNumber() {
	    if (!this.match('delimiter')) {
	      return this.token.slice.startLocation.line;
	    } else {
	      return this.token.get(0).lineNumber();
	    }
	  }

	  setLineNumber(line) {
	    let newTok = {};
	    if (this.isDelimiter()) {
	      newTok = this.token.map(s => s.setLineNumber(line));
	    } else {
	      for (let key of Object.keys(this.token)) {
	        newTok[key] = this.token[key];
	      }
	      (0, _errors.assert)(newTok.slice && newTok.slice.startLocation, 'all tokens must have line info');
	      newTok.slice.startLocation.line = line;
	    }
	    return new Syntax(newTok, this);
	  }

	  // () -> List<Syntax>
	  // inner() {
	  //   assert(this.match("delimiter"), "can only get the inner of a delimiter");
	  //   return this.token.slice(1, this.token.size - 1);
	  // }

	  addScope(scope, bindings, phase, options = { flip: false }) {
	    let token = this.match('delimiter') ? this.token.map(s => s.addScope(scope, bindings, phase, options)) : this.token;
	    if (this.match('template')) {
	      token = _.merge(token, {
	        items: token.items.map(it => {
	          if (it instanceof Syntax && it.match('delimiter')) {
	            return it.addScope(scope, bindings, phase, options);
	          }
	          return it;
	        })
	      });
	    }
	    let oldScopeset;
	    if (phase === ALL_PHASES) {
	      oldScopeset = this.scopesets.all;
	    } else {
	      oldScopeset = this.scopesets.phase.has(phase) ? this.scopesets.phase.get(phase) : (0, _immutable.List)();
	    }
	    let newScopeset;
	    if (options.flip) {
	      let index = oldScopeset.indexOf(scope);
	      if (index !== -1) {
	        newScopeset = oldScopeset.remove(index);
	      } else {
	        newScopeset = oldScopeset.push(scope);
	      }
	    } else {
	      newScopeset = oldScopeset.push(scope);
	    }
	    let newstx = {
	      bindings,
	      scopesets: {
	        all: this.scopesets.all,
	        phase: this.scopesets.phase
	      }
	    };

	    if (phase === ALL_PHASES) {
	      newstx.scopesets.all = newScopeset;
	    } else {
	      newstx.scopesets.phase = newstx.scopesets.phase.set(phase, newScopeset);
	    }
	    return new Syntax(token, newstx);
	  }

	  removeScope(scope, phase) {
	    let token = this.match('delimiter') ? this.token.map(s => s.removeScope(scope, phase)) : this.token;
	    let phaseScopeset = this.scopesets.phase.has(phase) ? this.scopesets.phase.get(phase) : (0, _immutable.List)();
	    let allScopeset = this.scopesets.all;
	    let newstx = {
	      bindings: this.bindings,
	      scopesets: {
	        all: this.scopesets.all,
	        phase: this.scopesets.phase
	      }
	    };

	    let phaseIndex = phaseScopeset.indexOf(scope);
	    let allIndex = allScopeset.indexOf(scope);
	    if (phaseIndex !== -1) {
	      newstx.scopesets.phase = this.scopesets.phase.set(phase, phaseScopeset.remove(phaseIndex));
	    } else if (allIndex !== -1) {
	      newstx.scopesets.all = allScopeset.remove(allIndex);
	    }
	    return new Syntax(token, newstx);
	  }

	  match(type, value) {
	    if (!Types[type]) {
	      throw new Error(type + ' is an invalid type');
	    }
	    return Types[type].match(this.token) && (value == null || (value instanceof RegExp ? value.test(this.val()) : this.val() == value));
	  }

	  isIdentifier(value) {
	    return this.match('identifier', value);
	  }

	  isAssign(value) {
	    return this.match('assign', value);
	  }

	  isBooleanLiteral(value) {
	    return this.match('boolean', value);
	  }

	  isKeyword(value) {
	    return this.match('keyword', value);
	  }

	  isNullLiteral(value) {
	    return this.match('null', value);
	  }

	  isNumericLiteral(value) {
	    return this.match('number', value);
	  }

	  isPunctuator(value) {
	    return this.match('punctuator', value);
	  }

	  isStringLiteral(value) {
	    return this.match('string', value);
	  }

	  isRegularExpression(value) {
	    return this.match('regularExpression', value);
	  }

	  isTemplate(value) {
	    return this.match('template', value);
	  }

	  isDelimiter(value) {
	    return this.match('delimiter', value);
	  }

	  isParens(value) {
	    return this.match('parens', value);
	  }

	  isBraces(value) {
	    return this.match('braces', value);
	  }

	  isBrackets(value) {
	    return this.match('brackets', value);
	  }

	  isSyntaxTemplate(value) {
	    return this.match('syntaxTemplate', value);
	  }

	  isEOF(value) {
	    return this.match('eof', value);
	  }

	  toString() {
	    if (this.match('delimiter')) {
	      return this.token.map(s => s.toString()).join(' ');
	    }
	    if (this.match('string')) {
	      return '\'' + this.token.str;
	    }
	    if (this.match('template')) {
	      return this.val();
	    }
	    return this.token.value;
	  }
	}
	exports.default = Syntax;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zeW50YXguanMiXSwibmFtZXMiOlsiXyIsIlQiLCJnZXRGaXJzdFNsaWNlIiwic3R4IiwiaXNEZWxpbWl0ZXIiLCJ0b2tlbiIsInNsaWNlIiwiZ2V0Iiwic2l6ZURlY2VuZGluZyIsImEiLCJiIiwic2NvcGVzIiwic2l6ZSIsIlR5cGVzIiwibnVsbCIsIm1hdGNoIiwiZGVsaW1pdGVyIiwidHlwZSIsIk5VTEwiLCJjcmVhdGUiLCJ2YWx1ZSIsIlN5bnRheCIsIm51bWJlciIsImtsYXNzIiwiTnVtZXJpY0xpdGVyYWwiLCJOVU1CRVIiLCJzdHJpbmciLCJTdHJpbmdMaXRlcmFsIiwiU1RSSU5HIiwic3RyIiwicHVuY3R1YXRvciIsIlB1bmN0dWF0b3IiLCJuYW1lIiwia2V5d29yZCIsIktleXdvcmQiLCJpZGVudGlmaWVyIiwiSWRlbnQiLCJJREVOVElGSUVSIiwicmVndWxhckV4cHJlc3Npb24iLCJSZWd1bGFyRXhwcmVzc2lvbiIsIlJFR0VYUCIsImJyYWNlcyIsIkxCUkFDRSIsImlubmVyIiwibGVmdCIsInJpZ2h0IiwiUkJSQUNFIiwib2YiLCJjb25jYXQiLCJwdXNoIiwiYnJhY2tldHMiLCJMQlJBQ0siLCJSQlJBQ0siLCJwYXJlbnMiLCJMUEFSRU4iLCJSUEFSRU4iLCJhc3NpZ24iLCJib29sZWFuIiwiVFJVRSIsIkZBTFNFIiwidGVtcGxhdGUiLCJURU1QTEFURSIsImlzTGlzdCIsInN5bnRheFRlbXBsYXRlIiwidmFsIiwiZW9mIiwiRU9TIiwiQUxMX1BIQVNFUyIsImNvbnN0cnVjdG9yIiwib2xkc3R4IiwiYmluZGluZ3MiLCJzY29wZXNldHMiLCJhbGwiLCJwaGFzZSIsIk9iamVjdCIsImZyZWV6ZSIsImZyb20iLCJFcnJvciIsIm5ld3N0eCIsIlJhd1N5bnRheCIsImZyb21OdWxsIiwiZnJvbU51bWJlciIsImZyb21TdHJpbmciLCJmcm9tUHVuY3R1YXRvciIsImZyb21LZXl3b3JkIiwiZnJvbUlkZW50aWZpZXIiLCJmcm9tUmVndWxhckV4cHJlc3Npb24iLCJyZXNvbHZlIiwiYWxsU2NvcGVzIiwic3R4U2NvcGVzIiwiaGFzIiwic2NvcGUiLCJsYXN0Iiwic2NvcGVzZXRCaW5kaW5nTGlzdCIsImJpZ2dlc3RCaW5kaW5nUGFpciIsImZpbHRlciIsImlzU3Vic2V0Iiwic29ydCIsImRlYnVnQmFzZSIsIm1hcCIsInMiLCJ0b1N0cmluZyIsImpvaW4iLCJkZWJ1Z0FtYmlnb3VzU2NvcGVzZXRzIiwiYmluZGluZ1N0ciIsImJpbmRpbmciLCJpc0p1c3QiLCJhbGlhcyIsImdldE9yRWxzZSIsIml0ZW1zIiwiZWwiLCJ0ZXh0IiwibGluZU51bWJlciIsInN0YXJ0TG9jYXRpb24iLCJsaW5lIiwic2V0TGluZU51bWJlciIsIm5ld1RvayIsImtleSIsImtleXMiLCJhZGRTY29wZSIsIm9wdGlvbnMiLCJmbGlwIiwibWVyZ2UiLCJpdCIsIm9sZFNjb3Blc2V0IiwibmV3U2NvcGVzZXQiLCJpbmRleCIsImluZGV4T2YiLCJyZW1vdmUiLCJzZXQiLCJyZW1vdmVTY29wZSIsInBoYXNlU2NvcGVzZXQiLCJhbGxTY29wZXNldCIsInBoYXNlSW5kZXgiLCJhbGxJbmRleCIsIlJlZ0V4cCIsInRlc3QiLCJpc0lkZW50aWZpZXIiLCJpc0Fzc2lnbiIsImlzQm9vbGVhbkxpdGVyYWwiLCJpc0tleXdvcmQiLCJpc051bGxMaXRlcmFsIiwiaXNOdW1lcmljTGl0ZXJhbCIsImlzUHVuY3R1YXRvciIsImlzU3RyaW5nTGl0ZXJhbCIsImlzUmVndWxhckV4cHJlc3Npb24iLCJpc1RlbXBsYXRlIiwiaXNQYXJlbnMiLCJpc0JyYWNlcyIsImlzQnJhY2tldHMiLCJpc1N5bnRheFRlbXBsYXRlIiwiaXNFT0YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztJQUFZQSxDOztBQUNaOztJQUFZQyxDOztBQUVaOzs7Ozs7QUEwQkEsU0FBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBcUM7QUFDbkMsTUFBSyxDQUFD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QUFXakksS0FBWCxFQUF1QjtBQUNyQixXQUFPLEtBQUtMLEtBQUwsQ0FBVyxVQUFYLEVBQXVCSyxLQUF2QixDQUFQO0FBQ0Q7O0FBRURrSSxtQkFBaUJsSSxLQUFqQixFQUE2QjtBQUMzQixXQUFPLEtBQUtMLEtBQUwsQ0FBVyxnQkFBWCxFQUE2QkssS0FBN0IsQ0FBUDtBQUNEOztBQUVEbUksUUFBTW5JLEtBQU4sRUFBa0I7QUFDaEIsV0FBTyxLQUFLTCxLQUFMLENBQVcsS0FBWCxFQUFrQkssS0FBbEIsQ0FBUDtBQUNEOztBQUVEaUYsYUFBVztBQUNULFFBQUksS0FBS3RGLEtBQUwsQ0FBVyxXQUFYLENBQUosRUFBNkI7QUFDM0IsYUFBTyxLQUFLVixLQUFMLENBQVc4RixHQUFYLENBQWVDLEtBQUtBLEVBQUVDLFFBQUYsRUFBcEIsRUFBa0NDLElBQWxDLENBQXVDLEdBQXZDLENBQVA7QUFDRDtBQUNELFFBQUksS0FBS3ZGLEtBQUwsQ0FBVyxRQUFYLENBQUosRUFBMEI7QUFDeEIsYUFBTyxPQUFPLEtBQUtWLEtBQUwsQ0FBV3dCLEdBQXpCO0FBQ0Q7QUFDRCxRQUFJLEtBQUtkLEtBQUwsQ0FBVyxVQUFYLENBQUosRUFBNEI7QUFDMUIsYUFBTyxLQUFLaUQsR0FBTCxFQUFQO0FBQ0Q7QUFDRCxXQUFPLEtBQUszRCxLQUFMLENBQVdlLEtBQWxCO0FBQ0Q7QUEzVXlCO2tCQUFQQyxNIiwiZmlsZSI6InN5bnRheC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBMaXN0LCBNYXAgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IEJpbmRpbmdNYXAgZnJvbSAnLi9iaW5kaW5nLW1hcCc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJ3JhbWRhLWZhbnRhc3knO1xuaW1wb3J0ICogYXMgXyBmcm9tICdyYW1kYSc7XG5pbXBvcnQgKiBhcyBUIGZyb20gJ3N3ZWV0LXNwZWMnO1xuXG5pbXBvcnQgeyBUb2tlblR5cGUsIFRva2VuQ2xhc3MgfSBmcm9tICcuL3Rva2Vucyc7XG5cbnR5cGUgVG9rZW4gPSB7XG4gIHR5cGU6IGFueTtcbiAgdmFsdWU6IGFueTtcbiAgc2xpY2U6IGFueTtcbn07XG5cbnR5cGUgVG9rZW5UYWcgPVxuICAnbnVsbCcgfFxuICAnbnVtYmVyJyB8XG4gICdzdHJpbmcnIHxcbiAgJ3B1bmN0dWF0b3InIHxcbiAgJ2tleXdvcmQnIHxcbiAgJ2lkZW50aWZpZXInIHxcbiAgJ3JlZ3VsYXJFeHByZXNzaW9uJyB8XG4gICdib29sZWFuJyB8XG4gICdicmFjZXMnIHxcbiAgJ3BhcmVucycgfFxuICAnZGVsaW1pdGVyJyB8XG4gICdlb2YnIHxcbiAgJ3RlbXBsYXRlJyB8XG4gICdhc3NpZ24nIHxcbiAgJ3N5bnRheFRlbXBsYXRlJyB8XG4gICdicmFja2V0cydcblxuZnVuY3Rpb24gZ2V0Rmlyc3RTbGljZShzdHg6ID9TeW50YXgpIHtcbiAgaWYgKCghc3R4KSB8fCB0eXBlb2Ygc3R4LmlzRGVsaW1pdGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDsgLy8gVE9ETzogc2hvdWxkIG5vdCBoYXZlIHRvIGRvIHRoaXNcbiAgaWYgKCFzdHguaXNEZWxpbWl0ZXIoKSkge1xuICAgIHJldHVybiBzdHgudG9rZW4uc2xpY2U7XG4gIH1cbiAgcmV0dXJuIHN0eC50b2tlbi5nZXQoMCkudG9rZW4uc2xpY2U7XG59XG5cbmZ1bmN0aW9uIHNpemVEZWNlbmRpbmcoYSwgYikge1xuICBpZiAoYS5zY29wZXMuc2l6ZSA+IGIuc2NvcGVzLnNpemUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYi5zY29wZXMuc2l6ZSA+IGEuc2NvcGVzLnNpemUpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG50eXBlIFR5cGVzSGVscGVyID0ge1xuICBba2V5OiBUb2tlblRhZ106IHtcbiAgICBtYXRjaCh0b2tlbjogYW55KTogYm9vbGVhbjtcbiAgICBjcmVhdGU/OiAodmFsdWU6IGFueSwgc3R4OiA/U3ludGF4KSA9PiBTeW50YXg7XG4gIH1cbn1cblxuZXhwb3J0IGxldCBUeXBlczogVHlwZXNIZWxwZXIgPSB7XG4gIG51bGw6IHtcbiAgICBtYXRjaDogdG9rZW4gPT4gIVR5cGVzLmRlbGltaXRlci5tYXRjaCh0b2tlbikgJiYgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk5VTEwsXG4gICAgY3JlYXRlOiAodmFsdWUsIHN0eCkgPT4gbmV3IFN5bnRheCh7XG4gICAgICB0eXBlOiBUb2tlblR5cGUuTlVMTCxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSwgc3R4KVxuICB9LFxuICBudW1iZXI6IHtcbiAgICBtYXRjaDogdG9rZW4gPT4gIVR5cGVzLmRlbGltaXRlci5tYXRjaCh0b2tlbikgJiYgdG9rZW4udHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5OdW1lcmljTGl0ZXJhbCxcbiAgICBjcmVhdGU6ICh2YWx1ZSwgc3R4KSA9PiBuZXcgU3ludGF4KHtcbiAgICAgIHR5cGU6IFRva2VuVHlwZS5OVU1CRVIsXG4gICAgICB2YWx1ZVxuICAgIH0sIHN0eClcbiAgfSxcbiAgc3RyaW5nOiB7XG5cdFx0bWF0Y2g6IHRva2VuID0+ICFUeXBlcy5kZWxpbWl0ZXIubWF0Y2godG9rZW4pICYmIHRva2VuLnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuU3RyaW5nTGl0ZXJhbCxcbiAgICBjcmVhdGU6ICh2YWx1ZSwgc3R4KSA9PiBuZXcgU3ludGF4KHtcbiAgICAgIHR5cGU6IFRva2VuVHlwZS5TVFJJTkcsXG4gICAgICBzdHI6IHZhbHVlXG4gICAgfSwgc3R4KVxuICB9LFxuICBwdW5jdHVhdG9yOiB7XG5cdFx0bWF0Y2g6IHRva2VuID0+ICFUeXBlcy5kZWxpbWl0ZXIubWF0Y2godG9rZW4pICYmIHRva2VuLnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuUHVuY3R1YXRvcixcbiAgICBjcmVhdGU6ICh2YWx1ZSwgc3R4KSA9PiBuZXcgU3ludGF4KHtcbiAgICAgIHR5cGU6IHtcbiAgICAgICAga2xhc3M6IFRva2VuQ2xhc3MuUHVuY3R1YXRvcixcbiAgICAgICAgbmFtZTogdmFsdWVcbiAgICAgIH0sXG4gICAgICB2YWx1ZVxuICAgIH0sIHN0eClcbiAgfSxcbiAga2V5d29yZDoge1xuXHRcdG1hdGNoOiB0b2tlbiA9PiAhVHlwZXMuZGVsaW1pdGVyLm1hdGNoKHRva2VuKSAmJiB0b2tlbi50eXBlLmtsYXNzID09PSBUb2tlbkNsYXNzLktleXdvcmQsXG4gICAgY3JlYXRlOiAodmFsdWUsIHN0eCkgPT4gbmV3IFN5bnRheCh7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIGtsYXNzOiBUb2tlbkNsYXNzLktleXdvcmQsXG4gICAgICAgIG5hbWU6IHZhbHVlXG4gICAgICB9LFxuICAgICAgdmFsdWVcbiAgICB9LCBzdHgpXG4gIH0sXG4gIGlkZW50aWZpZXI6IHtcblx0XHRtYXRjaDogdG9rZW4gPT4gIVR5cGVzLmRlbGltaXRlci5tYXRjaCh0b2tlbikgJiYgdG9rZW4udHlwZS5rbGFzcyA9PT0gVG9rZW5DbGFzcy5JZGVudCxcbiAgICBjcmVhdGU6ICh2YWx1ZSwgc3R4KSA9PiBuZXcgU3ludGF4KHtcbiAgICAgIHR5cGU6IFRva2VuVHlwZS5JREVOVElGSUVSLFxuICAgICAgdmFsdWVcbiAgICB9LCBzdHgpXG4gIH0sXG4gIHJlZ3VsYXJFeHByZXNzaW9uOiB7XG5cdFx0bWF0Y2g6IHRva2VuID0+ICFUeXBlcy5kZWxpbWl0ZXIubWF0Y2godG9rZW4pICYmIHRva2VuLnR5cGUua2xhc3MgPT09IFRva2VuQ2xhc3MuUmVndWxhckV4cHJlc3Npb24sXG4gICAgY3JlYXRlOiAodmFsdWUsIHN0eCkgPT4gbmV3IFN5bnRheCh7XG4gICAgICB0eXBlOiBUb2tlblR5cGUuUkVHRVhQLFxuICAgICAgdmFsdWVcbiAgICB9LCBzdHgpXG4gIH0sXG4gIGJyYWNlczoge1xuXHRcdG1hdGNoOiB0b2tlbiA9PiBUeXBlcy5kZWxpbWl0ZXIubWF0Y2godG9rZW4pICYmXG4gICAgICAgICAgIHRva2VuLmdldCgwKS50b2tlbi50eXBlID09PSBUb2tlblR5cGUuTEJSQUNFLFxuICAgIGNyZWF0ZTogKGlubmVyLCBzdHgpID0+IHtcbiAgICAgIGxldCBsZWZ0ID0gbmV3IFN5bnRheCh7XG4gICAgICAgIHR5cGU6IFRva2VuVHlwZS5MQlJBQ0UsXG4gICAgICAgIHZhbHVlOiAneycsXG4gICAgICAgIHNsaWNlOiBnZXRGaXJzdFNsaWNlKHN0eClcbiAgICAgIH0pO1xuICAgICAgbGV0IHJpZ2h0ID0gbmV3IFN5bnRheCh7XG4gICAgICAgIHR5cGU6IFRva2VuVHlwZS5SQlJBQ0UsXG4gICAgICAgIHZhbHVlOiAnfScsXG4gICAgICAgIHNsaWNlOiBnZXRGaXJzdFNsaWNlKHN0eClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBTeW50YXgoTGlzdC5vZihsZWZ0KS5jb25jYXQoaW5uZXIpLnB1c2gocmlnaHQpLCBzdHgpO1xuICAgIH1cbiAgfSxcbiAgYnJhY2tldHM6IHtcblx0XHRtYXRjaDogdG9rZW4gPT4gVHlwZXMuZGVsaW1pdGVyLm1hdGNoKHRva2VuKSAmJlxuICAgICAgICAgICB0b2tlbi5nZXQoMCkudG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkxCUkFDSyxcbiAgICBjcmVhdGU6IChpbm5lciwgc3R4KSA9PiB7XG4gICAgICBsZXQgbGVmdCA9IG5ldyBTeW50YXgoe1xuICAgICAgICB0eXBlOiBUb2tlblR5cGUuTEJSQUNLLFxuICAgICAgICB2YWx1ZTogJ1snLFxuICAgICAgICBzbGljZTogZ2V0Rmlyc3RTbGljZShzdHgpXG4gICAgICB9KTtcbiAgICAgIGxldCByaWdodCA9IG5ldyBTeW50YXgoe1xuICAgICAgICB0eXBlOiBUb2tlblR5cGUuUkJSQUNLLFxuICAgICAgICB2YWx1ZTogJ10nLFxuICAgICAgICBzbGljZTogZ2V0Rmlyc3RTbGljZShzdHgpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgU3ludGF4KExpc3Qub2YobGVmdCkuY29uY2F0KGlubmVyKS5wdXNoKHJpZ2h0KSwgc3R4KTtcbiAgICB9XG4gIH0sXG4gIHBhcmVuczoge1xuXHRcdG1hdGNoOiB0b2tlbiA9PiBUeXBlcy5kZWxpbWl0ZXIubWF0Y2godG9rZW4pICYmXG4gICAgICAgICAgIHRva2VuLmdldCgwKS50b2tlbi50eXBlID09PSBUb2tlblR5cGUuTFBBUkVOLFxuICAgIGNyZWF0ZTogKGlubmVyLCBzdHgpID0+IHtcbiAgICAgIGxldCBsZWZ0ID0gbmV3IFN5bnRheCh7XG4gICAgICAgIHR5cGU6IFRva2VuVHlwZS5MUEFSRU4sXG4gICAgICAgIHZhbHVlOiAnKCcsXG4gICAgICAgIHNsaWNlOiBnZXRGaXJzdFNsaWNlKHN0eClcbiAgICAgIH0pO1xuICAgICAgbGV0IHJpZ2h0ID0gbmV3IFN5bnRheCh7XG4gICAgICAgIHR5cGU6IFRva2VuVHlwZS5SUEFSRU4sXG4gICAgICAgIHZhbHVlOiAnKScsXG4gICAgICAgIHNsaWNlOiBnZXRGaXJzdFNsaWNlKHN0eClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBTeW50YXgoTGlzdC5vZihsZWZ0KS5jb25jYXQoaW5uZXIpLnB1c2gocmlnaHQpLCBzdHgpO1xuICAgIH1cbiAgfSxcblxuICBhc3NpZ246IHtcbiAgICBtYXRjaDogdG9rZW4gPT4ge1xuICAgICAgaWYgKFR5cGVzLnB1bmN0dWF0b3IubWF0Y2godG9rZW4pKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICBjYXNlICd8PSc6XG4gICAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgIGNhc2UgJyY9JzpcbiAgICAgICAgICBjYXNlICc8PD0nOlxuICAgICAgICAgIGNhc2UgJz4+PSc6XG4gICAgICAgICAgY2FzZSAnPj4+PSc6XG4gICAgICAgICAgY2FzZSAnKz0nOlxuICAgICAgICAgIGNhc2UgJy09JzpcbiAgICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgY2FzZSAnLz0nOlxuICAgICAgICAgIGNhc2UgJyU9JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgYm9vbGVhbjoge1xuICAgIG1hdGNoOiB0b2tlbiA9PiAhVHlwZXMuZGVsaW1pdGVyLm1hdGNoKHRva2VuKSAmJiB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuVFJVRSB8fFxuICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRkFMU0VcbiAgfSxcblxuICB0ZW1wbGF0ZToge1xuICAgIG1hdGNoOiB0b2tlbiA9PiAhVHlwZXMuZGVsaW1pdGVyLm1hdGNoKHRva2VuKSAmJiB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuVEVNUExBVEVcbiAgfSxcblxuICBkZWxpbWl0ZXI6IHtcbiAgICBtYXRjaDogdG9rZW4gPT4gTGlzdC5pc0xpc3QodG9rZW4pXG4gIH0sXG5cbiAgc3ludGF4VGVtcGxhdGU6IHtcbiAgICBtYXRjaDogdG9rZW4gPT4gVHlwZXMuZGVsaW1pdGVyLm1hdGNoKHRva2VuKSAmJiB0b2tlbi5nZXQoMCkudmFsKCkgPT09ICcjYCdcbiAgfSxcblxuICBlb2Y6IHtcbiAgICBtYXRjaDogdG9rZW4gPT4gIVR5cGVzLmRlbGltaXRlci5tYXRjaCh0b2tlbikgJiYgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkVPU1xuICB9LFxufTtcbmV4cG9ydCBjb25zdCBBTExfUEhBU0VTID0ge307XG5cbnR5cGUgU2NvcGVzZXQgPSB7XG4gIGFsbDogTGlzdDxhbnk+O1xuICBwaGFzZTogTWFwPG51bWJlciB8IHt9LCBhbnk+O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW50YXgge1xuICAvLyB0b2tlbjogVG9rZW4gfCBMaXN0PFRva2VuPjtcbiAgdG9rZW46IGFueTtcbiAgYmluZGluZ3M6IEJpbmRpbmdNYXA7XG4gIHNjb3Blc2V0czogU2NvcGVzZXQ7XG5cbiAgY29uc3RydWN0b3IodG9rZW46IGFueSwgb2xkc3R4OiA/eyBiaW5kaW5nczogYW55OyBzY29wZXNldHM6IGFueX0pIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5iaW5kaW5ncyA9IG9sZHN0eCAmJiAob2xkc3R4LmJpbmRpbmdzICE9IG51bGwpID8gb2xkc3R4LmJpbmRpbmdzIDogbmV3IEJpbmRpbmdNYXAoKTtcbiAgICB0aGlzLnNjb3Blc2V0cyA9IG9sZHN0eCAmJiAob2xkc3R4LnNjb3Blc2V0cyAhPSBudWxsKSA/IG9sZHN0eC5zY29wZXNldHMgOiB7XG4gICAgICBhbGw6IExpc3QoKSxcbiAgICAgIHBoYXNlOiBNYXAoKVxuICAgIH07XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBvZih0b2tlbjogVG9rZW4sIHN0eDogP1N5bnRheCkge1xuICAgIHJldHVybiBuZXcgU3ludGF4KHRva2VuLCBzdHgpO1xuICB9XG5cbiAgc3RhdGljIGZyb20odHlwZSwgdmFsdWUsIHN0eDogP1N5bnRheCkge1xuICAgIGlmICghVHlwZXNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgJyBpcyBub3QgYSB2YWxpZCB0eXBlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFUeXBlc1t0eXBlXS5jcmVhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhIHN5bnRheCBmcm9tIHR5cGUgJyArIHR5cGUpO1xuICAgIH1cbiAgICBsZXQgbmV3c3R4ID0gVHlwZXNbdHlwZV0uY3JlYXRlKHZhbHVlLCBzdHgpO1xuICAgIGxldCBzbGljZSA9IGdldEZpcnN0U2xpY2Uoc3R4KTtcbiAgICBpZiAoc2xpY2UgIT0gbnVsbCkge1xuICAgICAgbmV3c3R4LnRva2VuLnNsaWNlID0gc2xpY2U7XG4gICAgfVxuICAgIHJldHVybiBuZXdzdHg7XG4gIH1cblxuICBmcm9tKHR5cGU6IFRva2VuVGFnLCB2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIG5ldyBULlJhd1N5bnRheCh7IHZhbHVlOiBTeW50YXguZnJvbSh0eXBlLCB2YWx1ZSwgdGhpcykgfSk7XG4gIH1cblxuICBmcm9tTnVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKCdudWxsJywgbnVsbCk7XG4gIH1cblxuICBmcm9tTnVtYmVyKHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKCdudW1iZXInLCB2YWx1ZSk7XG4gIH1cblxuICBmcm9tU3RyaW5nKHZhbHVlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKCdzdHJpbmcnLCB2YWx1ZSk7XG4gIH1cblxuICBmcm9tUHVuY3R1YXRvcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSgncHVuY3R1YXRvcicsIHZhbHVlKTtcbiAgfVxuXG4gIGZyb21LZXl3b3JkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKCdrZXl3b3JkJywgdmFsdWUpO1xuICB9XG5cbiAgZnJvbUlkZW50aWZpZXIodmFsdWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmZyb20oJ2lkZW50aWZpZXInLCB2YWx1ZSk7XG4gIH1cblxuICBmcm9tUmVndWxhckV4cHJlc3Npb24odmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLmZyb20oJ3JlZ3VsYXJFeHByZXNzaW9uJywgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGZyb21OdWxsKHN0eDogU3ludGF4KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKCdudWxsJywgbnVsbCwgc3R4KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlLCBzdHgpIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oJ251bWJlcicsIHZhbHVlLCBzdHgpO1xuICB9XG5cbiAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIHN0eCkge1xuICAgIHJldHVybiBTeW50YXguZnJvbSgnc3RyaW5nJywgdmFsdWUsIHN0eCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVB1bmN0dWF0b3IodmFsdWUsIHN0eCkge1xuICAgIHJldHVybiBTeW50YXguZnJvbSgncHVuY3R1YXRvcicsIHZhbHVlLCBzdHgpO1xuICB9XG5cbiAgc3RhdGljIGZyb21LZXl3b3JkKHZhbHVlLCBzdHgpIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oJ2tleXdvcmQnLCB2YWx1ZSwgc3R4KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSWRlbnRpZmllcih2YWx1ZSwgc3R4KSB7XG4gICAgcmV0dXJuIFN5bnRheC5mcm9tKCdpZGVudGlmaWVyJywgdmFsdWUsIHN0eCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlZ3VsYXJFeHByZXNzaW9uKHZhbHVlLCBzdHgpIHtcbiAgICByZXR1cm4gU3ludGF4LmZyb20oJ3JlZ3VsYXJFeHByZXNzaW9uJywgdmFsdWUsIHN0eCk7XG4gIH1cblxuICAvLyAoKSAtPiBzdHJpbmdcbiAgcmVzb2x2ZShwaGFzZTogYW55KSB7XG4gICAgYXNzZXJ0KHBoYXNlICE9IG51bGwsICdtdXN0IHByb3ZpZGUgYSBwaGFzZSB0byByZXNvbHZlJyk7XG4gICAgbGV0IGFsbFNjb3BlcyA9IHRoaXMuc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgc3R4U2NvcGVzID0gdGhpcy5zY29wZXNldHMucGhhc2UuaGFzKHBoYXNlKSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgc3R4U2NvcGVzID0gYWxsU2NvcGVzLmNvbmNhdChzdHhTY29wZXMpO1xuICAgIGlmIChzdHhTY29wZXMuc2l6ZSA9PT0gMCB8fCAhKHRoaXMubWF0Y2goJ2lkZW50aWZpZXInKSB8fCB0aGlzLm1hdGNoKCdrZXl3b3JkJykpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi52YWx1ZTtcbiAgICB9XG4gICAgbGV0IHNjb3BlID0gc3R4U2NvcGVzLmxhc3QoKTtcbiAgICBsZXQgYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgLy8gTGlzdDx7IHNjb3BlczogTGlzdDxTY29wZT4sIGJpbmRpbmc6IFN5bWJvbCB9PlxuICAgICAgbGV0IHNjb3Blc2V0QmluZGluZ0xpc3QgPSBiaW5kaW5ncy5nZXQodGhpcyk7XG5cbiAgICAgIGlmIChzY29wZXNldEJpbmRpbmdMaXN0KSB7XG4gICAgICAgIC8vIHsgc2NvcGVzOiBMaXN0PFNjb3BlPiwgYmluZGluZzogU3ltYm9sIH1cbiAgICAgICAgbGV0IGJpZ2dlc3RCaW5kaW5nUGFpciA9IHNjb3Blc2V0QmluZGluZ0xpc3QuZmlsdGVyKCh7c2NvcGVzfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBzY29wZXMuaXNTdWJzZXQoc3R4U2NvcGVzKTtcbiAgICAgICAgfSkuc29ydChzaXplRGVjZW5kaW5nKTtcblxuICAgICAgICBpZiAoYmlnZ2VzdEJpbmRpbmdQYWlyLnNpemUgPj0gMiAmJlxuICAgICAgICAgICAgYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5zY29wZXMuc2l6ZSA9PT0gYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgxKS5zY29wZXMuc2l6ZSkge1xuICAgICAgICAgIGxldCBkZWJ1Z0Jhc2UgPSAneycgKyBzdHhTY29wZXMubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKCcsICcpICsgJ30nO1xuICAgICAgICAgIGxldCBkZWJ1Z0FtYmlnb3VzU2NvcGVzZXRzID0gYmlnZ2VzdEJpbmRpbmdQYWlyLm1hcCgoe3Njb3Blc30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAneycgKyBzY29wZXMubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKCcsICcpICsgJ30nO1xuICAgICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY29wZXNldCAnICsgZGVidWdCYXNlICsgJyBoYXMgYW1iaWd1b3VzIHN1YnNldHMgJyArIGRlYnVnQW1iaWdvdXNTY29wZXNldHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGJpZ2dlc3RCaW5kaW5nUGFpci5zaXplICE9PSAwKSB7XG4gICAgICAgICAgbGV0IGJpbmRpbmdTdHIgPSBiaWdnZXN0QmluZGluZ1BhaXIuZ2V0KDApLmJpbmRpbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoTWF5YmUuaXNKdXN0KGJpZ2dlc3RCaW5kaW5nUGFpci5nZXQoMCkuYWxpYXMpKSB7XG4gICAgICAgICAgICAvLyBudWxsIG5ldmVyIGhhcHBlbnMgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaWYgaXQgaXMgYSBKdXN0XG4gICAgICAgICAgICByZXR1cm4gYmlnZ2VzdEJpbmRpbmdQYWlyLmdldCgwKS5hbGlhcy5nZXRPckVsc2UobnVsbCkucmVzb2x2ZShwaGFzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiaW5kaW5nU3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG5cbiAgdmFsKCk6IGFueSB7XG4gICAgYXNzZXJ0KCF0aGlzLm1hdGNoKCdkZWxpbWl0ZXInKSwgJ2Nhbm5vdCBnZXQgdGhlIHZhbCBvZiBhIGRlbGltaXRlcicpO1xuICAgIGlmICh0aGlzLm1hdGNoKCdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW4uc3RyO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgndGVtcGxhdGUnKSkge1xuICAgICAgaWYgKCF0aGlzLnRva2VuLml0ZW1zKSByZXR1cm4gdGhpcy50b2tlbi52YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLml0ZW1zLm1hcChlbCA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZWwubWF0Y2ggPT09ICdmdW5jdGlvbicgJiYgZWwubWF0Y2goJ2RlbGltaXRlcicpKSB7XG4gICAgICAgICAgcmV0dXJuICckey4uLn0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5zbGljZS50ZXh0O1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuLnZhbHVlO1xuICB9XG5cbiAgbGluZU51bWJlcigpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goJ2RlbGltaXRlcicpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5zbGljZS5zdGFydExvY2F0aW9uLmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuLmdldCgwKS5saW5lTnVtYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0TGluZU51bWJlcihsaW5lOiBudW1iZXIpIHtcbiAgICBsZXQgbmV3VG9rID0ge307XG4gICAgaWYgKHRoaXMuaXNEZWxpbWl0ZXIoKSkge1xuICAgICAgbmV3VG9rID0gdGhpcy50b2tlbi5tYXAocyA9PiBzLnNldExpbmVOdW1iZXIobGluZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy50b2tlbikpIHtcbiAgICAgICAgbmV3VG9rW2tleV0gPSB0aGlzLnRva2VuW2tleV07XG4gICAgICB9XG4gICAgICBhc3NlcnQobmV3VG9rLnNsaWNlICYmIG5ld1Rvay5zbGljZS5zdGFydExvY2F0aW9uLCAnYWxsIHRva2VucyBtdXN0IGhhdmUgbGluZSBpbmZvJyk7XG4gICAgICBuZXdUb2suc2xpY2Uuc3RhcnRMb2NhdGlvbi5saW5lID0gbGluZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTeW50YXgobmV3VG9rLCB0aGlzKTtcbiAgfVxuXG4gIC8vICgpIC0+IExpc3Q8U3ludGF4PlxuICAvLyBpbm5lcigpIHtcbiAgLy8gICBhc3NlcnQodGhpcy5tYXRjaChcImRlbGltaXRlclwiKSwgXCJjYW4gb25seSBnZXQgdGhlIGlubmVyIG9mIGEgZGVsaW1pdGVyXCIpO1xuICAvLyAgIHJldHVybiB0aGlzLnRva2VuLnNsaWNlKDEsIHRoaXMudG9rZW4uc2l6ZSAtIDEpO1xuICAvLyB9XG5cbiAgYWRkU2NvcGUoc2NvcGU6IGFueSwgYmluZGluZ3M6IGFueSwgcGhhc2U6IG51bWJlciB8IHt9LCBvcHRpb25zOiBhbnkgPSB7IGZsaXA6IGZhbHNlIH0pIHtcbiAgICBsZXQgdG9rZW4gPSB0aGlzLm1hdGNoKCdkZWxpbWl0ZXInKSA/IHRoaXMudG9rZW4ubWFwKHMgPT4gcy5hZGRTY29wZShzY29wZSwgYmluZGluZ3MsIHBoYXNlLCBvcHRpb25zKSkgOiB0aGlzLnRva2VuO1xuICAgIGlmICh0aGlzLm1hdGNoKCd0ZW1wbGF0ZScpKSB7XG4gICAgICB0b2tlbiA9IF8ubWVyZ2UodG9rZW4sIHtcbiAgICAgICAgaXRlbXM6IHRva2VuLml0ZW1zLm1hcChpdCA9PiB7XG4gICAgICAgICAgaWYgKGl0IGluc3RhbmNlb2YgU3ludGF4ICYmIGl0Lm1hdGNoKCdkZWxpbWl0ZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0LmFkZFNjb3BlKHNjb3BlLCBiaW5kaW5ncywgcGhhc2UsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG9sZFNjb3Blc2V0O1xuICAgIGlmIChwaGFzZSA9PT0gQUxMX1BIQVNFUykge1xuICAgICAgb2xkU2NvcGVzZXQgPSB0aGlzLnNjb3Blc2V0cy5hbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFNjb3Blc2V0ID0gdGhpcy5zY29wZXNldHMucGhhc2UuaGFzKHBoYXNlKSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgfVxuICAgIGxldCBuZXdTY29wZXNldDtcbiAgICBpZiAob3B0aW9ucy5mbGlwKSB7XG4gICAgICBsZXQgaW5kZXggPSBvbGRTY29wZXNldC5pbmRleE9mKHNjb3BlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbmV3U2NvcGVzZXQgPSBvbGRTY29wZXNldC5yZW1vdmUoaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2NvcGVzZXQgPSBvbGRTY29wZXNldC5wdXNoKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2NvcGVzZXQgPSBvbGRTY29wZXNldC5wdXNoKHNjb3BlKTtcbiAgICB9XG4gICAgbGV0IG5ld3N0eCA9IHtcbiAgICAgIGJpbmRpbmdzLFxuICAgICAgc2NvcGVzZXRzOiB7XG4gICAgICAgIGFsbDogdGhpcy5zY29wZXNldHMuYWxsLFxuICAgICAgICBwaGFzZTogdGhpcy5zY29wZXNldHMucGhhc2VcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHBoYXNlID09PSBBTExfUEhBU0VTKSB7XG4gICAgICBuZXdzdHguc2NvcGVzZXRzLmFsbCA9IG5ld1Njb3Blc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdzdHguc2NvcGVzZXRzLnBoYXNlID0gbmV3c3R4LnNjb3Blc2V0cy5waGFzZS5zZXQocGhhc2UsIG5ld1Njb3Blc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTeW50YXgodG9rZW4sIG5ld3N0eCk7XG4gIH1cblxuICByZW1vdmVTY29wZShzY29wZTogYW55LCBwaGFzZTogbnVtYmVyKSB7XG4gICAgbGV0IHRva2VuID0gdGhpcy5tYXRjaCgnZGVsaW1pdGVyJykgPyB0aGlzLnRva2VuLm1hcChzID0+IHMucmVtb3ZlU2NvcGUoc2NvcGUsIHBoYXNlKSkgOiB0aGlzLnRva2VuO1xuICAgIGxldCBwaGFzZVNjb3Blc2V0ID0gdGhpcy5zY29wZXNldHMucGhhc2UuaGFzKHBoYXNlKSA/IHRoaXMuc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgbGV0IGFsbFNjb3Blc2V0ID0gdGhpcy5zY29wZXNldHMuYWxsO1xuICAgIGxldCBuZXdzdHggPSB7XG4gICAgICBiaW5kaW5nczogdGhpcy5iaW5kaW5ncyxcbiAgICAgIHNjb3Blc2V0czoge1xuICAgICAgICBhbGw6IHRoaXMuc2NvcGVzZXRzLmFsbCxcbiAgICAgICAgcGhhc2U6IHRoaXMuc2NvcGVzZXRzLnBoYXNlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBwaGFzZUluZGV4ID0gcGhhc2VTY29wZXNldC5pbmRleE9mKHNjb3BlKTtcbiAgICBsZXQgYWxsSW5kZXggPSBhbGxTY29wZXNldC5pbmRleE9mKHNjb3BlKTtcbiAgICBpZiAocGhhc2VJbmRleCAhPT0gLTEpIHtcbiAgICAgIG5ld3N0eC5zY29wZXNldHMucGhhc2UgPSB0aGlzLnNjb3Blc2V0cy5waGFzZS5zZXQocGhhc2UsIHBoYXNlU2NvcGVzZXQucmVtb3ZlKHBoYXNlSW5kZXgpKTtcbiAgICB9IGVsc2UgaWYgKGFsbEluZGV4ICE9PSAtMSkge1xuICAgICAgbmV3c3R4LnNjb3Blc2V0cy5hbGwgPSBhbGxTY29wZXNldC5yZW1vdmUoYWxsSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN5bnRheCh0b2tlbiwgbmV3c3R4KTtcbiAgfVxuXG4gIG1hdGNoKHR5cGU6IFRva2VuVGFnLCB2YWx1ZTogYW55KSB7XG4gICAgaWYgKCFUeXBlc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyAnIGlzIGFuIGludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZXNbdHlwZV0ubWF0Y2godGhpcy50b2tlbikgJiYgKHZhbHVlID09IG51bGwgfHxcbiAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IHZhbHVlLnRlc3QodGhpcy52YWwoKSkgOiB0aGlzLnZhbCgpID09IHZhbHVlKSk7XG4gIH1cblxuICBpc0lkZW50aWZpZXIodmFsdWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdpZGVudGlmaWVyJywgdmFsdWUpO1xuICB9XG5cbiAgaXNBc3NpZ24odmFsdWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdhc3NpZ24nLCB2YWx1ZSk7XG4gIH1cblxuICBpc0Jvb2xlYW5MaXRlcmFsKHZhbHVlOiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2Jvb2xlYW4nLCB2YWx1ZSk7XG4gIH1cblxuICBpc0tleXdvcmQodmFsdWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdrZXl3b3JkJywgdmFsdWUpO1xuICB9XG5cbiAgaXNOdWxsTGl0ZXJhbCh2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ251bGwnLCB2YWx1ZSk7XG4gIH1cblxuICBpc051bWVyaWNMaXRlcmFsKHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnbnVtYmVyJywgdmFsdWUpO1xuICB9XG5cbiAgaXNQdW5jdHVhdG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgncHVuY3R1YXRvcicsIHZhbHVlKTtcbiAgfVxuXG4gIGlzU3RyaW5nTGl0ZXJhbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ3N0cmluZycsIHZhbHVlKTtcbiAgfVxuXG4gIGlzUmVndWxhckV4cHJlc3Npb24odmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdyZWd1bGFyRXhwcmVzc2lvbicsIHZhbHVlKTtcbiAgfVxuXG4gIGlzVGVtcGxhdGUodmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCd0ZW1wbGF0ZScsIHZhbHVlKTtcbiAgfVxuXG4gIGlzRGVsaW1pdGVyKHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnZGVsaW1pdGVyJywgdmFsdWUpO1xuICB9XG5cbiAgaXNQYXJlbnModmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdwYXJlbnMnLCB2YWx1ZSk7XG4gIH1cblxuICBpc0JyYWNlcyh2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2JyYWNlcycsIHZhbHVlKTtcbiAgfVxuXG4gIGlzQnJhY2tldHModmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdicmFja2V0cycsIHZhbHVlKTtcbiAgfVxuXG4gIGlzU3ludGF4VGVtcGxhdGUodmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdzeW50YXhUZW1wbGF0ZScsIHZhbHVlKTtcbiAgfVxuXG4gIGlzRU9GKHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnZW9mJywgdmFsdWUpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goJ2RlbGltaXRlcicpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbi5tYXAocyA9PiBzLnRvU3RyaW5nKCkpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm4gJ1xcJycgKyB0aGlzLnRva2VuLnN0cjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goJ3RlbXBsYXRlJykpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbi52YWx1ZTtcbiAgfVxufVxuIl19

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.expect = expect;
	exports.assert = assert;
	function expect(cond, message, offendingSyntax, rest) {
	  if (!cond) {
	    let ctx = '';
	    if (rest) {
	      ctx = rest.slice(0, 20).map(s => {
	        let val = s.isDelimiter() ? '( ... )' : s.val();
	        if (s === offendingSyntax) {
	          return '__' + val + '__';
	        }
	        return val;
	      }).join(' ');
	    }
	    throw new Error('[error]: ' + message + '\n' + ctx);
	  }
	}

	function assert(cond, message) {
	  if (!cond) {
	    throw new Error('[assertion error]: ' + message);
	  }
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMuanMiXSwibmFtZXMiOlsiZXhwZWN0IiwiYXNzZXJ0IiwiY29uZCIsIm1lc3NhZ2UiLCJvZmZlbmRpbmdTeW50YXgiLCJyZXN0IiwiY3R4Iiwic2xpY2UiLCJtYXAiLCJzIiwidmFsIiwiaXNEZWxpbWl0ZXIiLCJqb2luIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7O1FBQWdCQSxNLEdBQUFBLE07UUFnQkFDLE0sR0FBQUEsTTtBQWhCVCxTQUFTRCxNQUFULENBQWdCRSxJQUFoQixFQUFzQkMsT0FBdEIsRUFBK0JDLGVBQS9CLEVBQWdEQyxJQUFoRCxFQUFzRDtBQUMzRCxNQUFJLENBQUNILElBQUwsRUFBVztBQUNULFFBQUlJLE1BQU0sRUFBVjtBQUNBLFFBQUlELElBQUosRUFBVTtBQUNSQyxZQUFNRCxLQUFLRSxLQUFMLENBQVcsQ0FBWCxFQUFjLEVBQWQsRUFBa0JDLEdBQWxCLENBQXNCQyxLQUFLO0FBQy9CLFlBQUlDLE1BQU1ELEVBQUVFLFdBQUYsS0FBa0IsU0FBbEIsR0FBOEJGLEVBQUVDLEdBQUYsRUFBeEM7QUFDQSxZQUFJRCxNQUFNTCxlQUFWLEVBQTJCO0FBQ3pCLGlCQUFPLE9BQU9NLEdBQVAsR0FBYSxJQUFwQjtBQUNEO0FBQ0QsZUFBT0EsR0FBUDtBQUNELE9BTkssRUFNSEUsSUFORyxDQU1FLEdBTkYsQ0FBTjtBQU9EO0FBQ0QsVUFBTSxJQUFJQyxLQUFKLENBQVUsY0FBY1YsT0FBZCxHQUF3QixJQUF4QixHQUErQkcsR0FBekMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU0wsTUFBVCxDQUFnQkMsSUFBaEIsRUFBc0JDLE9BQXRCLEVBQStCO0FBQ3BDLE1BQUksQ0FBQ0QsSUFBTCxFQUFXO0FBQ1QsVUFBTSxJQUFJVyxLQUFKLENBQVUsd0JBQXdCVixPQUFsQyxDQUFOO0FBQ0Q7QUFDRiIsImZpbGUiOiJlcnJvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZXhwZWN0KGNvbmQsIG1lc3NhZ2UsIG9mZmVuZGluZ1N5bnRheCwgcmVzdCkge1xuICBpZiAoIWNvbmQpIHtcbiAgICBsZXQgY3R4ID0gJyc7XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGN0eCA9IHJlc3Quc2xpY2UoMCwgMjApLm1hcChzID0+IHtcbiAgICAgICAgbGV0IHZhbCA9IHMuaXNEZWxpbWl0ZXIoKSA/ICcoIC4uLiApJyA6IHMudmFsKCk7XG4gICAgICAgIGlmIChzID09PSBvZmZlbmRpbmdTeW50YXgpIHtcbiAgICAgICAgICByZXR1cm4gJ19fJyArIHZhbCArICdfXyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXJyb3JdOiAnICsgbWVzc2FnZSArICdcXG4nICsgY3R4KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbYXNzZXJ0aW9uIGVycm9yXTogJyArIG1lc3NhZ2UpO1xuICB9XG59XG4iXX0=

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(10);

	var _errors = __webpack_require__(39);

	var _ramdaFantasy = __webpack_require__(19);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class BindingMap {

	  constructor() {
	    this._map = new Map();
	  }

	  // given a syntax object and a binding,
	  // add the binding to the map associating the binding with the syntax object's
	  // scope set
	  add(stx, { binding, phase, skipDup = false }) {
	    let stxName = stx.val();
	    let allScopeset = stx.scopesets.all;
	    let scopeset = stx.scopesets.phase.has(phase) ? stx.scopesets.phase.get(phase) : (0, _immutable.List)();
	    scopeset = allScopeset.concat(scopeset);
	    (0, _errors.assert)(phase != null, 'must provide a phase for binding add');

	    let scopesetBindingList = this._map.get(stxName);
	    if (scopesetBindingList) {
	      if (skipDup && scopesetBindingList.some(s => s.scopes.equals(scopeset))) {
	        return;
	      }
	      this._map.set(stxName, scopesetBindingList.push({
	        scopes: scopeset,
	        binding: binding,
	        alias: _ramdaFantasy.Maybe.Nothing()
	      }));
	    } else {
	      this._map.set(stxName, _immutable.List.of({
	        scopes: scopeset,
	        binding: binding,
	        alias: _ramdaFantasy.Maybe.Nothing()
	      }));
	    }
	  }

	  addForward(stx, forwardStx, binding, phase) {
	    let stxName = stx.token.value;
	    let allScopeset = stx.scopesets.all;
	    let scopeset = stx.scopesets.phase.has(phase) ? stx.scopesets.phase.get(phase) : (0, _immutable.List)();
	    scopeset = allScopeset.concat(scopeset);
	    (0, _errors.assert)(phase != null, 'must provide a phase for binding add');

	    let scopesetBindingList = this._map.get(stxName);
	    if (scopesetBindingList) {
	      this._map.set(stxName, scopesetBindingList.push({
	        scopes: scopeset,
	        binding: binding,
	        alias: _ramdaFantasy.Maybe.of(forwardStx)
	      }));
	    } else {
	      this._map.set(stxName, _immutable.List.of({
	        scopes: scopeset,
	        binding: binding,
	        alias: _ramdaFantasy.Maybe.of(forwardStx)
	      }));
	    }
	  }

	  get(stx) {
	    return this._map.get(stx.token.value);
	  }
	}
	exports.default = BindingMap;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaW5kaW5nLW1hcC5qcyJdLCJuYW1lcyI6WyJCaW5kaW5nTWFwIiwiY29uc3RydWN0b3IiLCJfbWFwIiwiTWFwIiwiYWRkIiwic3R4IiwiYmluZGluZyIsInBoYXNlIiwic2tpcER1cCIsInN0eE5hbWUiLCJ2YWwiLCJhbGxTY29wZXNldCIsInNjb3Blc2V0cyIsImFsbCIsInNjb3Blc2V0IiwiaGFzIiwiZ2V0IiwiY29uY2F0Iiwic2NvcGVzZXRCaW5kaW5nTGlzdCIsInNvbWUiLCJzIiwic2NvcGVzIiwiZXF1YWxzIiwic2V0IiwicHVzaCIsImFsaWFzIiwiTm90aGluZyIsIm9mIiwiYWRkRm9yd2FyZCIsImZvcndhcmRTdHgiLCJ0b2tlbiIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7O0FBVWUsTUFBTUEsVUFBTixDQUFpQjs7QUFHOUJDLGdCQUFjO0FBQ1osU0FBS0MsSUFBTCxHQUFZLElBQUlDLEdBQUosRUFBWjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBQyxNQUFJQyxHQUFKLEVBQWlCLEVBQUVDLE9BQUYsRUFBV0MsS0FBWCxFQUFrQkMsVUFBVSxLQUE1QixFQUFqQixFQUFxSDtBQUNuSCxRQUFJQyxVQUFVSixJQUFJSyxHQUFKLEVBQWQ7QUFDQSxRQUFJQyxjQUFjTixJQUFJTyxTQUFKLENBQWNDLEdBQWhDO0FBQ0EsUUFBSUMsV0FBV1QsSUFBSU8sU0FBSixDQUFjTCxLQUFkLENBQW9CUSxHQUFwQixDQUF3QlIsS0FBeEIsSUFBaUNGLElBQUlPLFNBQUosQ0FBY0wsS0FBZCxDQUFvQlMsR0FBcEIsQ0FBd0JULEtBQXhCLENBQWpDLEdBQWtFLHNCQUFqRjtBQUNBTyxlQUFXSCxZQUFZTSxNQUFaLENBQW1CSCxRQUFuQixDQUFYO0FBQ0Esd0JBQU9QLFNBQVMsSUFBaEIsRUFBc0Isc0NBQXRCOztBQUVBLFFBQUlXLHNCQUFzQixLQUFLaEIsSUFBTCxDQUFVYyxHQUFWLENBQWNQLE9BQWQsQ0FBMUI7QUFDQSxRQUFJUyxtQkFBSixFQUF5QjtBQUN2QixVQUFJVixXQUFXVSxvQkFBb0JDLElBQXBCLENBQXlCQyxLQUFLQSxFQUFFQyxNQUFGLENBQVNDLE1BQVQsQ0FBZ0JSLFFBQWhCLENBQTlCLENBQWYsRUFBeUU7QUFDdkU7QUFDRDtBQUNELFdBQUtaLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QlMsb0JBQW9CTSxJQUFwQixDQUF5QjtBQUM5Q0gsZ0JBQVFQLFFBRHNDO0FBRTlDUixpQkFBU0EsT0FGcUM7QUFHOUNtQixlQUFPLG9CQUFNQyxPQUFOO0FBSHVDLE9BQXpCLENBQXZCO0FBS0QsS0FURCxNQVNPO0FBQ0wsV0FBS3hCLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QixnQkFBS2tCLEVBQUwsQ0FBUTtBQUM3Qk4sZ0JBQVFQLFFBRHFCO0FBRTdCUixpQkFBU0EsT0FGb0I7QUFHN0JtQixlQUFPLG9CQUFNQyxPQUFOO0FBSHNCLE9BQVIsQ0FBdkI7QUFLRDtBQUNGOztBQUVERSxhQUFXdkIsR0FBWCxFQUF3QndCLFVBQXhCLEVBQTRDdkIsT0FBNUMsRUFBa0VDLEtBQWxFLEVBQXNGO0FBQ3BGLFFBQUlFLFVBQVVKLElBQUl5QixLQUFKLENBQVVDLEtBQXhCO0FBQ0EsUUFBSXBCLGNBQWNOLElBQUlPLFNBQUosQ0FBY0MsR0FBaEM7QUFDQSxRQUFJQyxXQUFXVCxJQUFJTyxTQUFKLENBQWNMLEtBQWQsQ0FBb0JRLEdBQXBCLENBQXdCUixLQUF4QixJQUFpQ0YsSUFBSU8sU0FBSixDQUFjTCxLQUFkLENBQW9CUyxHQUFwQixDQUF3QlQsS0FBeEIsQ0FBakMsR0FBa0Usc0JBQWpGO0FBQ0FPLGVBQVdILFlBQVlNLE1BQVosQ0FBbUJILFFBQW5CLENBQVg7QUFDQSx3QkFBT1AsU0FBUyxJQUFoQixFQUFzQixzQ0FBdEI7O0FBRUEsUUFBSVcsc0JBQXNCLEtBQUtoQixJQUFMLENBQVVjLEdBQVYsQ0FBY1AsT0FBZCxDQUExQjtBQUNBLFFBQUlTLG1CQUFKLEVBQXlCO0FBQ3ZCLFdBQUtoQixJQUFMLENBQVVxQixHQUFWLENBQWNkLE9BQWQsRUFBdUJTLG9CQUFvQk0sSUFBcEIsQ0FBeUI7QUFDOUNILGdCQUFRUCxRQURzQztBQUU5Q1IsaUJBQVNBLE9BRnFDO0FBRzlDbUIsZUFBTyxvQkFBTUUsRUFBTixDQUFTRSxVQUFUO0FBSHVDLE9BQXpCLENBQXZCO0FBS0QsS0FORCxNQU1PO0FBQ0wsV0FBSzNCLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QixnQkFBS2tCLEVBQUwsQ0FBUTtBQUM3Qk4sZ0JBQVFQLFFBRHFCO0FBRTdCUixpQkFBU0EsT0FGb0I7QUFHN0JtQixlQUFPLG9CQUFNRSxFQUFOLENBQVNFLFVBQVQ7QUFIc0IsT0FBUixDQUF2QjtBQUtEO0FBRUY7O0FBRURiLE1BQUlYLEdBQUosRUFBaUI7QUFDZixXQUFPLEtBQUtILElBQUwsQ0FBVWMsR0FBVixDQUFjWCxJQUFJeUIsS0FBSixDQUFVQyxLQUF4QixDQUFQO0FBQ0Q7QUE5RDZCO2tCQUFYL0IsVSIsImZpbGUiOiJiaW5kaW5nLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAncmFtZGEtZmFudGFzeSc7XG5pbXBvcnQgdHlwZSB7IFN5bWJvbENsYXNzIH0gZnJvbSAnLi9zeW1ib2wnO1xuaW1wb3J0IFN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5cbnR5cGUgU2NvcGVzZXQgPSBhbnk7XG5cbnR5cGUgU2NvcGVzZXRCaW5kaW5nID0ge1xuICBzY29wZXM6IFNjb3Blc2V0O1xuICBiaW5kaW5nOiBTeW1ib2xDbGFzcztcbiAgYWxpYXM6IE1heWJlPFN5bnRheD5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmluZGluZ01hcCB7XG4gIF9tYXA6IE1hcDxzdHJpbmcsIExpc3Q8U2NvcGVzZXRCaW5kaW5nPj47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLy8gZ2l2ZW4gYSBzeW50YXggb2JqZWN0IGFuZCBhIGJpbmRpbmcsXG4gIC8vIGFkZCB0aGUgYmluZGluZyB0byB0aGUgbWFwIGFzc29jaWF0aW5nIHRoZSBiaW5kaW5nIHdpdGggdGhlIHN5bnRheCBvYmplY3Qnc1xuICAvLyBzY29wZSBzZXRcbiAgYWRkKHN0eDogU3ludGF4LCB7IGJpbmRpbmcsIHBoYXNlLCBza2lwRHVwID0gZmFsc2UgfTogeyBiaW5kaW5nOiBTeW1ib2xDbGFzcywgcGhhc2U6IG51bWJlciB8IHt9LCBza2lwRHVwOiBib29sZWFufSkge1xuICAgIGxldCBzdHhOYW1lID0gc3R4LnZhbCgpO1xuICAgIGxldCBhbGxTY29wZXNldCA9IHN0eC5zY29wZXNldHMuYWxsO1xuICAgIGxldCBzY29wZXNldCA9IHN0eC5zY29wZXNldHMucGhhc2UuaGFzKHBoYXNlKSA/IHN0eC5zY29wZXNldHMucGhhc2UuZ2V0KHBoYXNlKSA6IExpc3QoKTtcbiAgICBzY29wZXNldCA9IGFsbFNjb3Blc2V0LmNvbmNhdChzY29wZXNldCk7XG4gICAgYXNzZXJ0KHBoYXNlICE9IG51bGwsICdtdXN0IHByb3ZpZGUgYSBwaGFzZSBmb3IgYmluZGluZyBhZGQnKTtcblxuICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gdGhpcy5fbWFwLmdldChzdHhOYW1lKTtcbiAgICBpZiAoc2NvcGVzZXRCaW5kaW5nTGlzdCkge1xuICAgICAgaWYgKHNraXBEdXAgJiYgc2NvcGVzZXRCaW5kaW5nTGlzdC5zb21lKHMgPT4gcy5zY29wZXMuZXF1YWxzKHNjb3Blc2V0KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChzdHhOYW1lLCBzY29wZXNldEJpbmRpbmdMaXN0LnB1c2goe1xuICAgICAgICBzY29wZXM6IHNjb3Blc2V0LFxuICAgICAgICBiaW5kaW5nOiBiaW5kaW5nLFxuICAgICAgICBhbGlhczogTWF5YmUuTm90aGluZygpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgTGlzdC5vZih7XG4gICAgICAgIHNjb3Blczogc2NvcGVzZXQsXG4gICAgICAgIGJpbmRpbmc6IGJpbmRpbmcsXG4gICAgICAgIGFsaWFzOiBNYXliZS5Ob3RoaW5nKClcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBhZGRGb3J3YXJkKHN0eDogU3ludGF4LCBmb3J3YXJkU3R4OiBTeW50YXgsIGJpbmRpbmc6IFN5bWJvbENsYXNzLCBwaGFzZTogbnVtYmVyIHwge30pIHtcbiAgICBsZXQgc3R4TmFtZSA9IHN0eC50b2tlbi52YWx1ZTtcbiAgICBsZXQgYWxsU2NvcGVzZXQgPSBzdHguc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgc2NvcGVzZXQgPSBzdHguc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZSkgPyBzdHguc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgc2NvcGVzZXQgPSBhbGxTY29wZXNldC5jb25jYXQoc2NvcGVzZXQpO1xuICAgIGFzc2VydChwaGFzZSAhPSBudWxsLCAnbXVzdCBwcm92aWRlIGEgcGhhc2UgZm9yIGJpbmRpbmcgYWRkJyk7XG5cbiAgICBsZXQgc2NvcGVzZXRCaW5kaW5nTGlzdCA9IHRoaXMuX21hcC5nZXQoc3R4TmFtZSk7XG4gICAgaWYgKHNjb3Blc2V0QmluZGluZ0xpc3QpIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgc2NvcGVzZXRCaW5kaW5nTGlzdC5wdXNoKHtcbiAgICAgICAgc2NvcGVzOiBzY29wZXNldCxcbiAgICAgICAgYmluZGluZzogYmluZGluZyxcbiAgICAgICAgYWxpYXM6IE1heWJlLm9mKGZvcndhcmRTdHgpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgTGlzdC5vZih7XG4gICAgICAgIHNjb3Blczogc2NvcGVzZXQsXG4gICAgICAgIGJpbmRpbmc6IGJpbmRpbmcsXG4gICAgICAgIGFsaWFzOiBNYXliZS5vZihmb3J3YXJkU3R4KVxuICAgICAgfSkpO1xuICAgIH1cblxuICB9XG5cbiAgZ2V0KHN0eDogU3ludGF4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc3R4LnRva2VuLnZhbHVlKTtcbiAgfVxufVxuIl19

/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class Term {
	  constructor(attrs_63, type_64) {
	    Object.assign(this, attrs_63);
	    this.type = type_64 || "Term";
	    this.loc = null;
	    Object.freeze(this);
	  }
	  _reduceState(reducer_65, state_66 = {}) {
	    return state_66;
	  }
	  _cloneAttrs() {
	    return {};
	  }
	  reduce(reducer_67) {
	    let state_68 = this._reduceState(reducer_67);
	    return reducer_67.reduceTerm(this, state_68);
	  }
	  extend(attrs_69) {
	    return new Term(Object.assign(this._cloneAttrs(), attrs_69));
	  }
	  from(type_70, value_71) {
	    if (this.value && typeof this.value.from === "function") {
	      return this.value.from(type_70, value_71);
	    }
	    throw new Error("Not implemented yet");
	  }
	  fromNull() {
	    return this.from("null", null);
	  }
	  fromNumber(value_72) {
	    return this.from("number", value_72);
	  }
	  fromString(value_73) {
	    return this.from("string", value_73);
	  }
	  fromPunctuator(value_74) {
	    return this.from("punctuator", value_74);
	  }
	  fromKeyword(value_75) {
	    return this.from("keyword", value_75);
	  }
	  fromIdentifier(value_76) {
	    return this.from("identifier", value_76);
	  }
	  fromRegularExpression(value_77) {
	    return this.from("regularExpression", value_77);
	  }
	  fromBraces(inner_78) {
	    return this.from("braces", inner_78);
	  }
	  fromBrackets(inner_79) {
	    return this.from("brackets", inner_79);
	  }
	  fromParens(inner_80) {
	    return this.from("parens", inner_80);
	  }
	}
	Term.CloneReducer = class {
	  reduceTerm(term_81, state_82) {
	    return new Term(state_82);
	  }
	};
	exports.default = Term;

	class SyntaxTerm extends Term {
	  constructor(attrs_83, type_84) {
	    super(attrs_83, type_84 || "SyntaxTerm");
	  }
	  _reduceState(reducer_85, state_86 = {}) {
	    ;
	    return super._reduceState(reducer_85, state_86);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_87) {
	    let state_88 = this._reduceState(reducer_87);
	    return reducer_87.reduceSyntaxTerm(this, state_88);
	  }
	  extend(attrs_89) {
	    return new SyntaxTerm(Object.assign(this._cloneAttrs(), attrs_89));
	  }
	}
	Term.CloneReducer.prototype.reduceSyntaxTerm = function (term_90, state_91) {
	  return new SyntaxTerm(state_91);
	};
	exports.SyntaxTerm = SyntaxTerm;

	class RawDelimiter extends SyntaxTerm {
	  constructor(attrs_92, type_93) {
	    super(attrs_92, type_93 || "RawDelimiter");
	    if (!{}.hasOwnProperty.call(attrs_92, "kind")) {
	      throw new Error("Missing attribute: " + "kind");
	    }
	    if (!{}.hasOwnProperty.call(attrs_92, "inner")) {
	      throw new Error("Missing attribute: " + "inner");
	    }
	  }
	  _reduceState(reducer_94, state_95 = {}) {
	    state_95.kind = this.kind;
	    state_95.inner = this.inner.map(a_96 => a_96 instanceof Term ? a_96.reduce(reducer_94) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_96));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_94, state_95);
	  }
	  _cloneAttrs() {
	    return Object.assign({ kind: this.kind, inner: this.inner }, super._cloneAttrs());
	  }
	  reduce(reducer_97) {
	    let state_98 = this._reduceState(reducer_97);
	    return reducer_97.reduceRawDelimiter(this, state_98);
	  }
	  extend(attrs_99) {
	    return new RawDelimiter(Object.assign(this._cloneAttrs(), attrs_99));
	  }
	}
	SyntaxTerm.CloneReducer.prototype.reduceRawDelimiter = function (term_100, state_101) {
	  return new RawDelimiter(state_101);
	};
	exports.RawDelimiter = RawDelimiter;

	class RawSyntax extends SyntaxTerm {
	  constructor(attrs_102, type_103) {
	    super(attrs_102, type_103 || "RawSyntax");
	    if (!{}.hasOwnProperty.call(attrs_102, "value")) {
	      throw new Error("Missing attribute: " + "value");
	    }
	  }
	  _reduceState(reducer_104, state_105 = {}) {
	    state_105.value = this.value;
	    ;
	    return super._reduceState(reducer_104, state_105);
	  }
	  _cloneAttrs() {
	    return Object.assign({ value: this.value }, super._cloneAttrs());
	  }
	  reduce(reducer_106) {
	    let state_107 = this._reduceState(reducer_106);
	    return reducer_106.reduceRawSyntax(this, state_107);
	  }
	  extend(attrs_108) {
	    return new RawSyntax(Object.assign(this._cloneAttrs(), attrs_108));
	  }
	}
	SyntaxTerm.CloneReducer.prototype.reduceRawSyntax = function (term_109, state_110) {
	  return new RawSyntax(state_110);
	};
	exports.RawSyntax = RawSyntax;

	class Statement extends Term {
	  constructor(attrs_111, type_112) {
	    super(attrs_111, type_112 || "Statement");
	  }
	  _reduceState(reducer_113, state_114 = {}) {
	    ;
	    return super._reduceState(reducer_113, state_114);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_115) {
	    let state_116 = this._reduceState(reducer_115);
	    return reducer_115.reduceStatement(this, state_116);
	  }
	  extend(attrs_117) {
	    return new Statement(Object.assign(this._cloneAttrs(), attrs_117));
	  }
	}
	Term.CloneReducer.prototype.reduceStatement = function (term_118, state_119) {
	  return new Statement(state_119);
	};
	exports.Statement = Statement;

	class IterationStatement extends Statement {
	  constructor(attrs_120, type_121) {
	    super(attrs_120, type_121 || "IterationStatement");
	    if (!{}.hasOwnProperty.call(attrs_120, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_122, state_123 = {}) {
	    state_123.body = this.body instanceof Statement ? this.body.reduce(reducer_122) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_122, state_123);
	  }
	  _cloneAttrs() {
	    return Object.assign({ body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_124) {
	    let state_125 = this._reduceState(reducer_124);
	    return reducer_124.reduceIterationStatement(this, state_125);
	  }
	  extend(attrs_126) {
	    return new IterationStatement(Object.assign(this._cloneAttrs(), attrs_126));
	  }
	}
	Statement.CloneReducer.prototype.reduceIterationStatement = function (term_127, state_128) {
	  return new IterationStatement(state_128);
	};
	exports.IterationStatement = IterationStatement;

	class Expression extends Term {
	  constructor(attrs_129, type_130) {
	    super(attrs_129, type_130 || "Expression");
	  }
	  _reduceState(reducer_131, state_132 = {}) {
	    ;
	    return super._reduceState(reducer_131, state_132);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_133) {
	    let state_134 = this._reduceState(reducer_133);
	    return reducer_133.reduceExpression(this, state_134);
	  }
	  extend(attrs_135) {
	    return new Expression(Object.assign(this._cloneAttrs(), attrs_135));
	  }
	}
	Term.CloneReducer.prototype.reduceExpression = function (term_136, state_137) {
	  return new Expression(state_137);
	};
	exports.Expression = Expression;

	class MemberExpression extends Expression {
	  constructor(attrs_138, type_139) {
	    super(attrs_138, type_139 || "MemberExpression");
	    if (!{}.hasOwnProperty.call(attrs_138, "object")) {
	      throw new Error("Missing attribute: " + "object");
	    }
	  }
	  _reduceState(reducer_140, state_141 = {}) {
	    state_141.object = this.object instanceof Expression ? this.object.reduce(reducer_140) : this.object instanceof Super ? this.object.reduce(reducer_140) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.object));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_140, state_141);
	  }
	  _cloneAttrs() {
	    return Object.assign({ object: this.object }, super._cloneAttrs());
	  }
	  reduce(reducer_142) {
	    let state_143 = this._reduceState(reducer_142);
	    return reducer_142.reduceMemberExpression(this, state_143);
	  }
	  extend(attrs_144) {
	    return new MemberExpression(Object.assign(this._cloneAttrs(), attrs_144));
	  }
	}
	Expression.CloneReducer.prototype.reduceMemberExpression = function (term_145, state_146) {
	  return new MemberExpression(state_146);
	};
	exports.MemberExpression = MemberExpression;

	class PropertyName extends Term {
	  constructor(attrs_147, type_148) {
	    super(attrs_147, type_148 || "PropertyName");
	  }
	  _reduceState(reducer_149, state_150 = {}) {
	    ;
	    return super._reduceState(reducer_149, state_150);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_151) {
	    let state_152 = this._reduceState(reducer_151);
	    return reducer_151.reducePropertyName(this, state_152);
	  }
	  extend(attrs_153) {
	    return new PropertyName(Object.assign(this._cloneAttrs(), attrs_153));
	  }
	}
	Term.CloneReducer.prototype.reducePropertyName = function (term_154, state_155) {
	  return new PropertyName(state_155);
	};
	exports.PropertyName = PropertyName;

	class ObjectProperty extends Term {
	  constructor(attrs_156, type_157) {
	    super(attrs_156, type_157 || "ObjectProperty");
	  }
	  _reduceState(reducer_158, state_159 = {}) {
	    ;
	    return super._reduceState(reducer_158, state_159);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_160) {
	    let state_161 = this._reduceState(reducer_160);
	    return reducer_160.reduceObjectProperty(this, state_161);
	  }
	  extend(attrs_162) {
	    return new ObjectProperty(Object.assign(this._cloneAttrs(), attrs_162));
	  }
	}
	Term.CloneReducer.prototype.reduceObjectProperty = function (term_163, state_164) {
	  return new ObjectProperty(state_164);
	};
	exports.ObjectProperty = ObjectProperty;

	class NamedObjectProperty extends ObjectProperty {
	  constructor(attrs_165, type_166) {
	    super(attrs_165, type_166 || "NamedObjectProperty");
	    if (!{}.hasOwnProperty.call(attrs_165, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	  }
	  _reduceState(reducer_167, state_168 = {}) {
	    state_168.name = this.name instanceof PropertyName ? this.name.reduce(reducer_167) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_167, state_168);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name }, super._cloneAttrs());
	  }
	  reduce(reducer_169) {
	    let state_170 = this._reduceState(reducer_169);
	    return reducer_169.reduceNamedObjectProperty(this, state_170);
	  }
	  extend(attrs_171) {
	    return new NamedObjectProperty(Object.assign(this._cloneAttrs(), attrs_171));
	  }
	}
	ObjectProperty.CloneReducer.prototype.reduceNamedObjectProperty = function (term_172, state_173) {
	  return new NamedObjectProperty(state_173);
	};
	exports.NamedObjectProperty = NamedObjectProperty;

	class MethodDefinition extends NamedObjectProperty {
	  constructor(attrs_174, type_175) {
	    super(attrs_174, type_175 || "MethodDefinition");
	    if (!{}.hasOwnProperty.call(attrs_174, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_176, state_177 = {}) {
	    state_177.body = this.body instanceof FunctionBody ? this.body.reduce(reducer_176) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_176, state_177);
	  }
	  _cloneAttrs() {
	    return Object.assign({ body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_178) {
	    let state_179 = this._reduceState(reducer_178);
	    return reducer_178.reduceMethodDefinition(this, state_179);
	  }
	  extend(attrs_180) {
	    return new MethodDefinition(Object.assign(this._cloneAttrs(), attrs_180));
	  }
	}
	NamedObjectProperty.CloneReducer.prototype.reduceMethodDefinition = function (term_181, state_182) {
	  return new MethodDefinition(state_182);
	};
	exports.MethodDefinition = MethodDefinition;

	class BindingWithDefault extends Term {
	  constructor(attrs_183, type_184) {
	    super(attrs_183, type_184 || "BindingWithDefault");
	    if (!{}.hasOwnProperty.call(attrs_183, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_183, "init")) {
	      throw new Error("Missing attribute: " + "init");
	    }
	  }
	  _reduceState(reducer_185, state_186 = {}) {
	    state_186.binding = this.binding instanceof ObjectBinding ? this.binding.reduce(reducer_185) : this.binding instanceof ArrayBinding ? this.binding.reduce(reducer_185) : this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_185) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_185) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_186.init = this.init instanceof Expression ? this.init.reduce(reducer_185) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.init));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_185, state_186);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, init: this.init }, super._cloneAttrs());
	  }
	  reduce(reducer_187) {
	    let state_188 = this._reduceState(reducer_187);
	    return reducer_187.reduceBindingWithDefault(this, state_188);
	  }
	  extend(attrs_189) {
	    return new BindingWithDefault(Object.assign(this._cloneAttrs(), attrs_189));
	  }
	}
	Term.CloneReducer.prototype.reduceBindingWithDefault = function (term_190, state_191) {
	  return new BindingWithDefault(state_191);
	};
	exports.BindingWithDefault = BindingWithDefault;

	class BindingIdentifier extends Term {
	  constructor(attrs_192, type_193) {
	    super(attrs_192, type_193 || "BindingIdentifier");
	    if (!{}.hasOwnProperty.call(attrs_192, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	  }
	  _reduceState(reducer_194, state_195 = {}) {
	    state_195.name = this.name;
	    ;
	    return super._reduceState(reducer_194, state_195);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name }, super._cloneAttrs());
	  }
	  reduce(reducer_196) {
	    let state_197 = this._reduceState(reducer_196);
	    return reducer_196.reduceBindingIdentifier(this, state_197);
	  }
	  extend(attrs_198) {
	    return new BindingIdentifier(Object.assign(this._cloneAttrs(), attrs_198));
	  }
	}
	Term.CloneReducer.prototype.reduceBindingIdentifier = function (term_199, state_200) {
	  return new BindingIdentifier(state_200);
	};
	exports.BindingIdentifier = BindingIdentifier;

	class ArrayBinding extends Term {
	  constructor(attrs_201, type_202) {
	    super(attrs_201, type_202 || "ArrayBinding");
	    if (!{}.hasOwnProperty.call(attrs_201, "elements")) {
	      throw new Error("Missing attribute: " + "elements");
	    }
	    if (!{}.hasOwnProperty.call(attrs_201, "restElement")) {
	      throw new Error("Missing attribute: " + "restElement");
	    }
	  }
	  _reduceState(reducer_203, state_204 = {}) {
	    state_204.elements = this.elements.map(a_205 => a_205 instanceof ObjectBinding ? a_205.reduce(reducer_203) : a_205 instanceof ArrayBinding ? a_205.reduce(reducer_203) : a_205 instanceof BindingIdentifier ? a_205.reduce(reducer_203) : a_205 instanceof MemberExpression ? a_205.reduce(reducer_203) : a_205 instanceof BindingWithDefault ? a_205.reduce(reducer_203) : a_205 == null ? null : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_205));
	    }.call(this));
	    state_204.restElement = this.restElement == null ? null : this.restElement instanceof ObjectBinding ? this.restElement.reduce(reducer_203) : this.restElement instanceof ArrayBinding ? this.restElement.reduce(reducer_203) : this.restElement instanceof BindingIdentifier ? this.restElement.reduce(reducer_203) : this.restElement instanceof MemberExpression ? this.restElement.reduce(reducer_203) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.restElement));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_203, state_204);
	  }
	  _cloneAttrs() {
	    return Object.assign({ elements: this.elements, restElement: this.restElement }, super._cloneAttrs());
	  }
	  reduce(reducer_206) {
	    let state_207 = this._reduceState(reducer_206);
	    return reducer_206.reduceArrayBinding(this, state_207);
	  }
	  extend(attrs_208) {
	    return new ArrayBinding(Object.assign(this._cloneAttrs(), attrs_208));
	  }
	}
	Term.CloneReducer.prototype.reduceArrayBinding = function (term_209, state_210) {
	  return new ArrayBinding(state_210);
	};
	exports.ArrayBinding = ArrayBinding;

	class ObjectBinding extends Term {
	  constructor(attrs_211, type_212) {
	    super(attrs_211, type_212 || "ObjectBinding");
	    if (!{}.hasOwnProperty.call(attrs_211, "properties")) {
	      throw new Error("Missing attribute: " + "properties");
	    }
	  }
	  _reduceState(reducer_213, state_214 = {}) {
	    state_214.properties = this.properties.map(a_215 => a_215 instanceof BindingProperty ? a_215.reduce(reducer_213) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_215));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_213, state_214);
	  }
	  _cloneAttrs() {
	    return Object.assign({ properties: this.properties }, super._cloneAttrs());
	  }
	  reduce(reducer_216) {
	    let state_217 = this._reduceState(reducer_216);
	    return reducer_216.reduceObjectBinding(this, state_217);
	  }
	  extend(attrs_218) {
	    return new ObjectBinding(Object.assign(this._cloneAttrs(), attrs_218));
	  }
	}
	Term.CloneReducer.prototype.reduceObjectBinding = function (term_219, state_220) {
	  return new ObjectBinding(state_220);
	};
	exports.ObjectBinding = ObjectBinding;

	class BindingProperty extends Term {
	  constructor(attrs_221, type_222) {
	    super(attrs_221, type_222 || "BindingProperty");
	  }
	  _reduceState(reducer_223, state_224 = {}) {
	    ;
	    return super._reduceState(reducer_223, state_224);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_225) {
	    let state_226 = this._reduceState(reducer_225);
	    return reducer_225.reduceBindingProperty(this, state_226);
	  }
	  extend(attrs_227) {
	    return new BindingProperty(Object.assign(this._cloneAttrs(), attrs_227));
	  }
	}
	Term.CloneReducer.prototype.reduceBindingProperty = function (term_228, state_229) {
	  return new BindingProperty(state_229);
	};
	exports.BindingProperty = BindingProperty;

	class BindingPropertyIdentifier extends BindingProperty {
	  constructor(attrs_230, type_231) {
	    super(attrs_230, type_231 || "BindingPropertyIdentifier");
	    if (!{}.hasOwnProperty.call(attrs_230, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_230, "init")) {
	      throw new Error("Missing attribute: " + "init");
	    }
	  }
	  _reduceState(reducer_232, state_233 = {}) {
	    state_233.binding = this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_232) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_233.init = this.init == null ? null : this.init instanceof Expression ? this.init.reduce(reducer_232) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.init));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_232, state_233);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, init: this.init }, super._cloneAttrs());
	  }
	  reduce(reducer_234) {
	    let state_235 = this._reduceState(reducer_234);
	    return reducer_234.reduceBindingPropertyIdentifier(this, state_235);
	  }
	  extend(attrs_236) {
	    return new BindingPropertyIdentifier(Object.assign(this._cloneAttrs(), attrs_236));
	  }
	}
	BindingProperty.CloneReducer.prototype.reduceBindingPropertyIdentifier = function (term_237, state_238) {
	  return new BindingPropertyIdentifier(state_238);
	};
	exports.BindingPropertyIdentifier = BindingPropertyIdentifier;

	class BindingPropertyProperty extends BindingProperty {
	  constructor(attrs_239, type_240) {
	    super(attrs_239, type_240 || "BindingPropertyProperty");
	    if (!{}.hasOwnProperty.call(attrs_239, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_239, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	  }
	  _reduceState(reducer_241, state_242 = {}) {
	    state_242.name = this.name instanceof PropertyName ? this.name.reduce(reducer_241) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_242.binding = this.binding instanceof ObjectBinding ? this.binding.reduce(reducer_241) : this.binding instanceof ArrayBinding ? this.binding.reduce(reducer_241) : this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_241) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_241) : this.binding instanceof BindingWithDefault ? this.binding.reduce(reducer_241) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_241, state_242);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, binding: this.binding }, super._cloneAttrs());
	  }
	  reduce(reducer_243) {
	    let state_244 = this._reduceState(reducer_243);
	    return reducer_243.reduceBindingPropertyProperty(this, state_244);
	  }
	  extend(attrs_245) {
	    return new BindingPropertyProperty(Object.assign(this._cloneAttrs(), attrs_245));
	  }
	}
	BindingProperty.CloneReducer.prototype.reduceBindingPropertyProperty = function (term_246, state_247) {
	  return new BindingPropertyProperty(state_247);
	};
	exports.BindingPropertyProperty = BindingPropertyProperty;

	class ClassExpression extends Expression {
	  constructor(attrs_248, type_249) {
	    super(attrs_248, type_249 || "ClassExpression");
	    if (!{}.hasOwnProperty.call(attrs_248, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_248, "super")) {
	      throw new Error("Missing attribute: " + "super");
	    }
	    if (!{}.hasOwnProperty.call(attrs_248, "elements")) {
	      throw new Error("Missing attribute: " + "elements");
	    }
	  }
	  _reduceState(reducer_250, state_251 = {}) {
	    state_251.name = this.name == null ? null : this.name instanceof BindingIdentifier ? this.name.reduce(reducer_250) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_251.super = this.super == null ? null : this.super instanceof Expression ? this.super.reduce(reducer_250) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.super));
	    }.call(this);
	    state_251.elements = this.elements.map(a_252 => a_252 instanceof ClassElement ? a_252.reduce(reducer_250) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_252));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_250, state_251);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, super: this.super, elements: this.elements }, super._cloneAttrs());
	  }
	  reduce(reducer_253) {
	    let state_254 = this._reduceState(reducer_253);
	    return reducer_253.reduceClassExpression(this, state_254);
	  }
	  extend(attrs_255) {
	    return new ClassExpression(Object.assign(this._cloneAttrs(), attrs_255));
	  }
	}
	Expression.CloneReducer.prototype.reduceClassExpression = function (term_256, state_257) {
	  return new ClassExpression(state_257);
	};
	exports.ClassExpression = ClassExpression;

	class ClassDeclaration extends Statement {
	  constructor(attrs_258, type_259) {
	    super(attrs_258, type_259 || "ClassDeclaration");
	    if (!{}.hasOwnProperty.call(attrs_258, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_258, "super")) {
	      throw new Error("Missing attribute: " + "super");
	    }
	    if (!{}.hasOwnProperty.call(attrs_258, "elements")) {
	      throw new Error("Missing attribute: " + "elements");
	    }
	  }
	  _reduceState(reducer_260, state_261 = {}) {
	    state_261.name = this.name instanceof BindingIdentifier ? this.name.reduce(reducer_260) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_261.super = this.super == null ? null : this.super instanceof Expression ? this.super.reduce(reducer_260) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.super));
	    }.call(this);
	    state_261.elements = this.elements.map(a_262 => a_262 instanceof ClassElement ? a_262.reduce(reducer_260) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_262));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_260, state_261);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, super: this.super, elements: this.elements }, super._cloneAttrs());
	  }
	  reduce(reducer_263) {
	    let state_264 = this._reduceState(reducer_263);
	    return reducer_263.reduceClassDeclaration(this, state_264);
	  }
	  extend(attrs_265) {
	    return new ClassDeclaration(Object.assign(this._cloneAttrs(), attrs_265));
	  }
	}
	Statement.CloneReducer.prototype.reduceClassDeclaration = function (term_266, state_267) {
	  return new ClassDeclaration(state_267);
	};
	exports.ClassDeclaration = ClassDeclaration;

	class ClassElement extends Term {
	  constructor(attrs_268, type_269) {
	    super(attrs_268, type_269 || "ClassElement");
	    if (!{}.hasOwnProperty.call(attrs_268, "isStatic")) {
	      throw new Error("Missing attribute: " + "isStatic");
	    }
	    if (!{}.hasOwnProperty.call(attrs_268, "method")) {
	      throw new Error("Missing attribute: " + "method");
	    }
	  }
	  _reduceState(reducer_270, state_271 = {}) {
	    state_271.isStatic = this.isStatic;
	    state_271.method = this.method instanceof MethodDefinition ? this.method.reduce(reducer_270) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.method));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_270, state_271);
	  }
	  _cloneAttrs() {
	    return Object.assign({ isStatic: this.isStatic, method: this.method }, super._cloneAttrs());
	  }
	  reduce(reducer_272) {
	    let state_273 = this._reduceState(reducer_272);
	    return reducer_272.reduceClassElement(this, state_273);
	  }
	  extend(attrs_274) {
	    return new ClassElement(Object.assign(this._cloneAttrs(), attrs_274));
	  }
	}
	Term.CloneReducer.prototype.reduceClassElement = function (term_275, state_276) {
	  return new ClassElement(state_276);
	};
	exports.ClassElement = ClassElement;

	class Module extends Term {
	  constructor(attrs_277, type_278) {
	    super(attrs_277, type_278 || "Module");
	    if (!{}.hasOwnProperty.call(attrs_277, "directives")) {
	      throw new Error("Missing attribute: " + "directives");
	    }
	    if (!{}.hasOwnProperty.call(attrs_277, "items")) {
	      throw new Error("Missing attribute: " + "items");
	    }
	  }
	  _reduceState(reducer_279, state_280 = {}) {
	    state_280.directives = this.directives.map(a_281 => a_281);
	    state_280.items = this.items.map(a_282 => a_282 instanceof Term ? a_282.reduce(reducer_279) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_282));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_279, state_280);
	  }
	  _cloneAttrs() {
	    return Object.assign({ directives: this.directives, items: this.items }, super._cloneAttrs());
	  }
	  reduce(reducer_283) {
	    let state_284 = this._reduceState(reducer_283);
	    return reducer_283.reduceModule(this, state_284);
	  }
	  extend(attrs_285) {
	    return new Module(Object.assign(this._cloneAttrs(), attrs_285));
	  }
	}
	Term.CloneReducer.prototype.reduceModule = function (term_286, state_287) {
	  return new Module(state_287);
	};
	exports.Module = Module;

	class Import extends Term {
	  constructor(attrs_288, type_289) {
	    super(attrs_288, type_289 || "Import");
	    if (!{}.hasOwnProperty.call(attrs_288, "moduleSpecifier")) {
	      throw new Error("Missing attribute: " + "moduleSpecifier");
	    }
	    if (!{}.hasOwnProperty.call(attrs_288, "defaultBinding")) {
	      throw new Error("Missing attribute: " + "defaultBinding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_288, "namedImports")) {
	      throw new Error("Missing attribute: " + "namedImports");
	    }
	    if (!{}.hasOwnProperty.call(attrs_288, "forSyntax")) {
	      throw new Error("Missing attribute: " + "forSyntax");
	    }
	  }
	  _reduceState(reducer_290, state_291 = {}) {
	    state_291.moduleSpecifier = this.moduleSpecifier;
	    state_291.defaultBinding = this.defaultBinding == null ? null : this.defaultBinding instanceof BindingIdentifier ? this.defaultBinding.reduce(reducer_290) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.defaultBinding));
	    }.call(this);
	    state_291.namedImports = this.namedImports.map(a_292 => a_292 instanceof ImportSpecifier ? a_292.reduce(reducer_290) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_292));
	    }.call(this));
	    state_291.forSyntax = this.forSyntax;
	    ;
	    return super._reduceState(reducer_290, state_291);
	  }
	  _cloneAttrs() {
	    return Object.assign({ moduleSpecifier: this.moduleSpecifier, defaultBinding: this.defaultBinding, namedImports: this.namedImports, forSyntax: this.forSyntax }, super._cloneAttrs());
	  }
	  reduce(reducer_293) {
	    let state_294 = this._reduceState(reducer_293);
	    return reducer_293.reduceImport(this, state_294);
	  }
	  extend(attrs_295) {
	    return new Import(Object.assign(this._cloneAttrs(), attrs_295));
	  }
	}
	Term.CloneReducer.prototype.reduceImport = function (term_296, state_297) {
	  return new Import(state_297);
	};
	exports.Import = Import;

	class ImportNamespace extends Term {
	  constructor(attrs_298, type_299) {
	    super(attrs_298, type_299 || "ImportNamespace");
	    if (!{}.hasOwnProperty.call(attrs_298, "moduleSpecifier")) {
	      throw new Error("Missing attribute: " + "moduleSpecifier");
	    }
	    if (!{}.hasOwnProperty.call(attrs_298, "defaultBinding")) {
	      throw new Error("Missing attribute: " + "defaultBinding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_298, "namespaceBinding")) {
	      throw new Error("Missing attribute: " + "namespaceBinding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_298, "forSyntax")) {
	      throw new Error("Missing attribute: " + "forSyntax");
	    }
	  }
	  _reduceState(reducer_300, state_301 = {}) {
	    state_301.moduleSpecifier = this.moduleSpecifier;
	    state_301.defaultBinding = this.defaultBinding == null ? null : this.defaultBinding instanceof BindingIdentifier ? this.defaultBinding.reduce(reducer_300) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.defaultBinding));
	    }.call(this);
	    state_301.namespaceBinding = this.namespaceBinding instanceof BindingIdentifier ? this.namespaceBinding.reduce(reducer_300) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.namespaceBinding));
	    }.call(this);
	    state_301.forSyntax = this.forSyntax;
	    ;
	    return super._reduceState(reducer_300, state_301);
	  }
	  _cloneAttrs() {
	    return Object.assign({ moduleSpecifier: this.moduleSpecifier, defaultBinding: this.defaultBinding, namespaceBinding: this.namespaceBinding, forSyntax: this.forSyntax }, super._cloneAttrs());
	  }
	  reduce(reducer_302) {
	    let state_303 = this._reduceState(reducer_302);
	    return reducer_302.reduceImportNamespace(this, state_303);
	  }
	  extend(attrs_304) {
	    return new ImportNamespace(Object.assign(this._cloneAttrs(), attrs_304));
	  }
	}
	Term.CloneReducer.prototype.reduceImportNamespace = function (term_305, state_306) {
	  return new ImportNamespace(state_306);
	};
	exports.ImportNamespace = ImportNamespace;

	class ImportSpecifier extends Term {
	  constructor(attrs_307, type_308) {
	    super(attrs_307, type_308 || "ImportSpecifier");
	    if (!{}.hasOwnProperty.call(attrs_307, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_307, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	  }
	  _reduceState(reducer_309, state_310 = {}) {
	    state_310.name = this.name == null ? null : this.name;
	    state_310.binding = this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_309) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_309, state_310);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, binding: this.binding }, super._cloneAttrs());
	  }
	  reduce(reducer_311) {
	    let state_312 = this._reduceState(reducer_311);
	    return reducer_311.reduceImportSpecifier(this, state_312);
	  }
	  extend(attrs_313) {
	    return new ImportSpecifier(Object.assign(this._cloneAttrs(), attrs_313));
	  }
	}
	Term.CloneReducer.prototype.reduceImportSpecifier = function (term_314, state_315) {
	  return new ImportSpecifier(state_315);
	};
	exports.ImportSpecifier = ImportSpecifier;

	class ExportAllFrom extends Term {
	  constructor(attrs_316, type_317) {
	    super(attrs_316, type_317 || "ExportAllFrom");
	    if (!{}.hasOwnProperty.call(attrs_316, "moduleSpecifier")) {
	      throw new Error("Missing attribute: " + "moduleSpecifier");
	    }
	  }
	  _reduceState(reducer_318, state_319 = {}) {
	    state_319.moduleSpecifier = this.moduleSpecifier;
	    ;
	    return super._reduceState(reducer_318, state_319);
	  }
	  _cloneAttrs() {
	    return Object.assign({ moduleSpecifier: this.moduleSpecifier }, super._cloneAttrs());
	  }
	  reduce(reducer_320) {
	    let state_321 = this._reduceState(reducer_320);
	    return reducer_320.reduceExportAllFrom(this, state_321);
	  }
	  extend(attrs_322) {
	    return new ExportAllFrom(Object.assign(this._cloneAttrs(), attrs_322));
	  }
	}
	Term.CloneReducer.prototype.reduceExportAllFrom = function (term_323, state_324) {
	  return new ExportAllFrom(state_324);
	};
	exports.ExportAllFrom = ExportAllFrom;

	class ExportFrom extends Term {
	  constructor(attrs_325, type_326) {
	    super(attrs_325, type_326 || "ExportFrom");
	    if (!{}.hasOwnProperty.call(attrs_325, "namedExports")) {
	      throw new Error("Missing attribute: " + "namedExports");
	    }
	    if (!{}.hasOwnProperty.call(attrs_325, "moduleSpecifier")) {
	      throw new Error("Missing attribute: " + "moduleSpecifier");
	    }
	  }
	  _reduceState(reducer_327, state_328 = {}) {
	    state_328.namedExports = this.namedExports.map(a_329 => a_329 instanceof ExportSpecifier ? a_329.reduce(reducer_327) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_329));
	    }.call(this));
	    state_328.moduleSpecifier = this.moduleSpecifier == null ? null : this.moduleSpecifier;
	    ;
	    return super._reduceState(reducer_327, state_328);
	  }
	  _cloneAttrs() {
	    return Object.assign({ namedExports: this.namedExports, moduleSpecifier: this.moduleSpecifier }, super._cloneAttrs());
	  }
	  reduce(reducer_330) {
	    let state_331 = this._reduceState(reducer_330);
	    return reducer_330.reduceExportFrom(this, state_331);
	  }
	  extend(attrs_332) {
	    return new ExportFrom(Object.assign(this._cloneAttrs(), attrs_332));
	  }
	}
	Term.CloneReducer.prototype.reduceExportFrom = function (term_333, state_334) {
	  return new ExportFrom(state_334);
	};
	exports.ExportFrom = ExportFrom;

	class Export extends Term {
	  constructor(attrs_335, type_336) {
	    super(attrs_335, type_336 || "Export");
	    if (!{}.hasOwnProperty.call(attrs_335, "declaration")) {
	      throw new Error("Missing attribute: " + "declaration");
	    }
	  }
	  _reduceState(reducer_337, state_338 = {}) {
	    state_338.declaration = this.declaration instanceof FunctionDeclaration ? this.declaration.reduce(reducer_337) : this.declaration instanceof ClassDeclaration ? this.declaration.reduce(reducer_337) : this.declaration instanceof VariableDeclaration ? this.declaration.reduce(reducer_337) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.declaration));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_337, state_338);
	  }
	  _cloneAttrs() {
	    return Object.assign({ declaration: this.declaration }, super._cloneAttrs());
	  }
	  reduce(reducer_339) {
	    let state_340 = this._reduceState(reducer_339);
	    return reducer_339.reduceExport(this, state_340);
	  }
	  extend(attrs_341) {
	    return new Export(Object.assign(this._cloneAttrs(), attrs_341));
	  }
	}
	Term.CloneReducer.prototype.reduceExport = function (term_342, state_343) {
	  return new Export(state_343);
	};
	exports.Export = Export;

	class ExportDefault extends Term {
	  constructor(attrs_344, type_345) {
	    super(attrs_344, type_345 || "ExportDefault");
	    if (!{}.hasOwnProperty.call(attrs_344, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_346, state_347 = {}) {
	    state_347.body = this.body instanceof FunctionDeclaration ? this.body.reduce(reducer_346) : this.body instanceof ClassDeclaration ? this.body.reduce(reducer_346) : this.body instanceof Expression ? this.body.reduce(reducer_346) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_346, state_347);
	  }
	  _cloneAttrs() {
	    return Object.assign({ body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_348) {
	    let state_349 = this._reduceState(reducer_348);
	    return reducer_348.reduceExportDefault(this, state_349);
	  }
	  extend(attrs_350) {
	    return new ExportDefault(Object.assign(this._cloneAttrs(), attrs_350));
	  }
	}
	Term.CloneReducer.prototype.reduceExportDefault = function (term_351, state_352) {
	  return new ExportDefault(state_352);
	};
	exports.ExportDefault = ExportDefault;

	class ExportSpecifier extends Term {
	  constructor(attrs_353, type_354) {
	    super(attrs_353, type_354 || "ExportSpecifier");
	    if (!{}.hasOwnProperty.call(attrs_353, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_353, "exportedName")) {
	      throw new Error("Missing attribute: " + "exportedName");
	    }
	  }
	  _reduceState(reducer_355, state_356 = {}) {
	    state_356.name = this.name == null ? null : this.name;
	    state_356.exportedName = this.exportedName;
	    ;
	    return super._reduceState(reducer_355, state_356);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, exportedName: this.exportedName }, super._cloneAttrs());
	  }
	  reduce(reducer_357) {
	    let state_358 = this._reduceState(reducer_357);
	    return reducer_357.reduceExportSpecifier(this, state_358);
	  }
	  extend(attrs_359) {
	    return new ExportSpecifier(Object.assign(this._cloneAttrs(), attrs_359));
	  }
	}
	Term.CloneReducer.prototype.reduceExportSpecifier = function (term_360, state_361) {
	  return new ExportSpecifier(state_361);
	};
	exports.ExportSpecifier = ExportSpecifier;

	class Method extends MethodDefinition {
	  constructor(attrs_362, type_363) {
	    super(attrs_362, type_363 || "Method");
	    if (!{}.hasOwnProperty.call(attrs_362, "isGenerator")) {
	      throw new Error("Missing attribute: " + "isGenerator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_362, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	  }
	  _reduceState(reducer_364, state_365 = {}) {
	    state_365.isGenerator = this.isGenerator;
	    state_365.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_364) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_364, state_365);
	  }
	  _cloneAttrs() {
	    return Object.assign({ isGenerator: this.isGenerator, params: this.params }, super._cloneAttrs());
	  }
	  reduce(reducer_366) {
	    let state_367 = this._reduceState(reducer_366);
	    return reducer_366.reduceMethod(this, state_367);
	  }
	  extend(attrs_368) {
	    return new Method(Object.assign(this._cloneAttrs(), attrs_368));
	  }
	}
	MethodDefinition.CloneReducer.prototype.reduceMethod = function (term_369, state_370) {
	  return new Method(state_370);
	};
	exports.Method = Method;

	class Getter extends MethodDefinition {
	  constructor(attrs_371, type_372) {
	    super(attrs_371, type_372 || "Getter");
	  }
	  _reduceState(reducer_373, state_374 = {}) {
	    ;
	    return super._reduceState(reducer_373, state_374);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_375) {
	    let state_376 = this._reduceState(reducer_375);
	    return reducer_375.reduceGetter(this, state_376);
	  }
	  extend(attrs_377) {
	    return new Getter(Object.assign(this._cloneAttrs(), attrs_377));
	  }
	}
	MethodDefinition.CloneReducer.prototype.reduceGetter = function (term_378, state_379) {
	  return new Getter(state_379);
	};
	exports.Getter = Getter;

	class Setter extends MethodDefinition {
	  constructor(attrs_380, type_381) {
	    super(attrs_380, type_381 || "Setter");
	    if (!{}.hasOwnProperty.call(attrs_380, "param")) {
	      throw new Error("Missing attribute: " + "param");
	    }
	  }
	  _reduceState(reducer_382, state_383 = {}) {
	    state_383.param = this.param instanceof ObjectBinding ? this.param.reduce(reducer_382) : this.param instanceof ArrayBinding ? this.param.reduce(reducer_382) : this.param instanceof BindingIdentifier ? this.param.reduce(reducer_382) : this.param instanceof MemberExpression ? this.param.reduce(reducer_382) : this.param instanceof BindingWithDefault ? this.param.reduce(reducer_382) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.param));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_382, state_383);
	  }
	  _cloneAttrs() {
	    return Object.assign({ param: this.param }, super._cloneAttrs());
	  }
	  reduce(reducer_384) {
	    let state_385 = this._reduceState(reducer_384);
	    return reducer_384.reduceSetter(this, state_385);
	  }
	  extend(attrs_386) {
	    return new Setter(Object.assign(this._cloneAttrs(), attrs_386));
	  }
	}
	MethodDefinition.CloneReducer.prototype.reduceSetter = function (term_387, state_388) {
	  return new Setter(state_388);
	};
	exports.Setter = Setter;

	class DataProperty extends NamedObjectProperty {
	  constructor(attrs_389, type_390) {
	    super(attrs_389, type_390 || "DataProperty");
	    if (!{}.hasOwnProperty.call(attrs_389, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_391, state_392 = {}) {
	    state_392.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_391) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_391, state_392);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_393) {
	    let state_394 = this._reduceState(reducer_393);
	    return reducer_393.reduceDataProperty(this, state_394);
	  }
	  extend(attrs_395) {
	    return new DataProperty(Object.assign(this._cloneAttrs(), attrs_395));
	  }
	}
	NamedObjectProperty.CloneReducer.prototype.reduceDataProperty = function (term_396, state_397) {
	  return new DataProperty(state_397);
	};
	exports.DataProperty = DataProperty;

	class ShorthandProperty extends ObjectProperty {
	  constructor(attrs_398, type_399) {
	    super(attrs_398, type_399 || "ShorthandProperty");
	    if (!{}.hasOwnProperty.call(attrs_398, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	  }
	  _reduceState(reducer_400, state_401 = {}) {
	    state_401.name = this.name;
	    ;
	    return super._reduceState(reducer_400, state_401);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name }, super._cloneAttrs());
	  }
	  reduce(reducer_402) {
	    let state_403 = this._reduceState(reducer_402);
	    return reducer_402.reduceShorthandProperty(this, state_403);
	  }
	  extend(attrs_404) {
	    return new ShorthandProperty(Object.assign(this._cloneAttrs(), attrs_404));
	  }
	}
	ObjectProperty.CloneReducer.prototype.reduceShorthandProperty = function (term_405, state_406) {
	  return new ShorthandProperty(state_406);
	};
	exports.ShorthandProperty = ShorthandProperty;

	class StaticPropertyName extends PropertyName {
	  constructor(attrs_407, type_408) {
	    super(attrs_407, type_408 || "StaticPropertyName");
	    if (!{}.hasOwnProperty.call(attrs_407, "value")) {
	      throw new Error("Missing attribute: " + "value");
	    }
	  }
	  _reduceState(reducer_409, state_410 = {}) {
	    state_410.value = this.value;
	    ;
	    return super._reduceState(reducer_409, state_410);
	  }
	  _cloneAttrs() {
	    return Object.assign({ value: this.value }, super._cloneAttrs());
	  }
	  reduce(reducer_411) {
	    let state_412 = this._reduceState(reducer_411);
	    return reducer_411.reduceStaticPropertyName(this, state_412);
	  }
	  extend(attrs_413) {
	    return new StaticPropertyName(Object.assign(this._cloneAttrs(), attrs_413));
	  }
	}
	PropertyName.CloneReducer.prototype.reduceStaticPropertyName = function (term_414, state_415) {
	  return new StaticPropertyName(state_415);
	};
	exports.StaticPropertyName = StaticPropertyName;

	class ComputedPropertyName extends PropertyName {
	  constructor(attrs_416, type_417) {
	    super(attrs_416, type_417 || "ComputedPropertyName");
	    if (!{}.hasOwnProperty.call(attrs_416, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_418, state_419 = {}) {
	    state_419.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_418) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_418, state_419);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_420) {
	    let state_421 = this._reduceState(reducer_420);
	    return reducer_420.reduceComputedPropertyName(this, state_421);
	  }
	  extend(attrs_422) {
	    return new ComputedPropertyName(Object.assign(this._cloneAttrs(), attrs_422));
	  }
	}
	PropertyName.CloneReducer.prototype.reduceComputedPropertyName = function (term_423, state_424) {
	  return new ComputedPropertyName(state_424);
	};
	exports.ComputedPropertyName = ComputedPropertyName;

	class LiteralBooleanExpression extends Expression {
	  constructor(attrs_425, type_426) {
	    super(attrs_425, type_426 || "LiteralBooleanExpression");
	    if (!{}.hasOwnProperty.call(attrs_425, "value")) {
	      throw new Error("Missing attribute: " + "value");
	    }
	  }
	  _reduceState(reducer_427, state_428 = {}) {
	    state_428.value = this.value;
	    ;
	    return super._reduceState(reducer_427, state_428);
	  }
	  _cloneAttrs() {
	    return Object.assign({ value: this.value }, super._cloneAttrs());
	  }
	  reduce(reducer_429) {
	    let state_430 = this._reduceState(reducer_429);
	    return reducer_429.reduceLiteralBooleanExpression(this, state_430);
	  }
	  extend(attrs_431) {
	    return new LiteralBooleanExpression(Object.assign(this._cloneAttrs(), attrs_431));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralBooleanExpression = function (term_432, state_433) {
	  return new LiteralBooleanExpression(state_433);
	};
	exports.LiteralBooleanExpression = LiteralBooleanExpression;

	class LiteralInfinityExpression extends Expression {
	  constructor(attrs_434, type_435) {
	    super(attrs_434, type_435 || "LiteralInfinityExpression");
	  }
	  _reduceState(reducer_436, state_437 = {}) {
	    ;
	    return super._reduceState(reducer_436, state_437);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_438) {
	    let state_439 = this._reduceState(reducer_438);
	    return reducer_438.reduceLiteralInfinityExpression(this, state_439);
	  }
	  extend(attrs_440) {
	    return new LiteralInfinityExpression(Object.assign(this._cloneAttrs(), attrs_440));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralInfinityExpression = function (term_441, state_442) {
	  return new LiteralInfinityExpression(state_442);
	};
	exports.LiteralInfinityExpression = LiteralInfinityExpression;

	class LiteralNullExpression extends Expression {
	  constructor(attrs_443, type_444) {
	    super(attrs_443, type_444 || "LiteralNullExpression");
	  }
	  _reduceState(reducer_445, state_446 = {}) {
	    ;
	    return super._reduceState(reducer_445, state_446);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_447) {
	    let state_448 = this._reduceState(reducer_447);
	    return reducer_447.reduceLiteralNullExpression(this, state_448);
	  }
	  extend(attrs_449) {
	    return new LiteralNullExpression(Object.assign(this._cloneAttrs(), attrs_449));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralNullExpression = function (term_450, state_451) {
	  return new LiteralNullExpression(state_451);
	};
	exports.LiteralNullExpression = LiteralNullExpression;

	class LiteralNumericExpression extends Expression {
	  constructor(attrs_452, type_453) {
	    super(attrs_452, type_453 || "LiteralNumericExpression");
	    if (!{}.hasOwnProperty.call(attrs_452, "value")) {
	      throw new Error("Missing attribute: " + "value");
	    }
	  }
	  _reduceState(reducer_454, state_455 = {}) {
	    state_455.value = this.value;
	    ;
	    return super._reduceState(reducer_454, state_455);
	  }
	  _cloneAttrs() {
	    return Object.assign({ value: this.value }, super._cloneAttrs());
	  }
	  reduce(reducer_456) {
	    let state_457 = this._reduceState(reducer_456);
	    return reducer_456.reduceLiteralNumericExpression(this, state_457);
	  }
	  extend(attrs_458) {
	    return new LiteralNumericExpression(Object.assign(this._cloneAttrs(), attrs_458));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralNumericExpression = function (term_459, state_460) {
	  return new LiteralNumericExpression(state_460);
	};
	exports.LiteralNumericExpression = LiteralNumericExpression;

	class LiteralRegExpExpression extends Expression {
	  constructor(attrs_461, type_462) {
	    super(attrs_461, type_462 || "LiteralRegExpExpression");
	    if (!{}.hasOwnProperty.call(attrs_461, "pattern")) {
	      throw new Error("Missing attribute: " + "pattern");
	    }
	    if (!{}.hasOwnProperty.call(attrs_461, "flags")) {
	      throw new Error("Missing attribute: " + "flags");
	    }
	  }
	  _reduceState(reducer_463, state_464 = {}) {
	    state_464.pattern = this.pattern;
	    state_464.flags = this.flags;
	    ;
	    return super._reduceState(reducer_463, state_464);
	  }
	  _cloneAttrs() {
	    return Object.assign({ pattern: this.pattern, flags: this.flags }, super._cloneAttrs());
	  }
	  reduce(reducer_465) {
	    let state_466 = this._reduceState(reducer_465);
	    return reducer_465.reduceLiteralRegExpExpression(this, state_466);
	  }
	  extend(attrs_467) {
	    return new LiteralRegExpExpression(Object.assign(this._cloneAttrs(), attrs_467));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralRegExpExpression = function (term_468, state_469) {
	  return new LiteralRegExpExpression(state_469);
	};
	exports.LiteralRegExpExpression = LiteralRegExpExpression;

	class LiteralStringExpression extends Expression {
	  constructor(attrs_470, type_471) {
	    super(attrs_470, type_471 || "LiteralStringExpression");
	    if (!{}.hasOwnProperty.call(attrs_470, "value")) {
	      throw new Error("Missing attribute: " + "value");
	    }
	  }
	  _reduceState(reducer_472, state_473 = {}) {
	    state_473.value = this.value;
	    ;
	    return super._reduceState(reducer_472, state_473);
	  }
	  _cloneAttrs() {
	    return Object.assign({ value: this.value }, super._cloneAttrs());
	  }
	  reduce(reducer_474) {
	    let state_475 = this._reduceState(reducer_474);
	    return reducer_474.reduceLiteralStringExpression(this, state_475);
	  }
	  extend(attrs_476) {
	    return new LiteralStringExpression(Object.assign(this._cloneAttrs(), attrs_476));
	  }
	}
	Expression.CloneReducer.prototype.reduceLiteralStringExpression = function (term_477, state_478) {
	  return new LiteralStringExpression(state_478);
	};
	exports.LiteralStringExpression = LiteralStringExpression;

	class ArrayExpression extends Expression {
	  constructor(attrs_479, type_480) {
	    super(attrs_479, type_480 || "ArrayExpression");
	    if (!{}.hasOwnProperty.call(attrs_479, "elements")) {
	      throw new Error("Missing attribute: " + "elements");
	    }
	  }
	  _reduceState(reducer_481, state_482 = {}) {
	    state_482.elements = this.elements.map(a_483 => a_483 instanceof SpreadElement ? a_483.reduce(reducer_481) : a_483 instanceof Expression ? a_483.reduce(reducer_481) : a_483 == null ? null : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_483));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_481, state_482);
	  }
	  _cloneAttrs() {
	    return Object.assign({ elements: this.elements }, super._cloneAttrs());
	  }
	  reduce(reducer_484) {
	    let state_485 = this._reduceState(reducer_484);
	    return reducer_484.reduceArrayExpression(this, state_485);
	  }
	  extend(attrs_486) {
	    return new ArrayExpression(Object.assign(this._cloneAttrs(), attrs_486));
	  }
	}
	Expression.CloneReducer.prototype.reduceArrayExpression = function (term_487, state_488) {
	  return new ArrayExpression(state_488);
	};
	exports.ArrayExpression = ArrayExpression;

	class ArrowExpression extends Expression {
	  constructor(attrs_489, type_490) {
	    super(attrs_489, type_490 || "ArrowExpression");
	    if (!{}.hasOwnProperty.call(attrs_489, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_489, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_491, state_492 = {}) {
	    state_492.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_491) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_492.body = this.body instanceof FunctionBody ? this.body.reduce(reducer_491) : this.body instanceof Expression ? this.body.reduce(reducer_491) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_491, state_492);
	  }
	  _cloneAttrs() {
	    return Object.assign({ params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_493) {
	    let state_494 = this._reduceState(reducer_493);
	    return reducer_493.reduceArrowExpression(this, state_494);
	  }
	  extend(attrs_495) {
	    return new ArrowExpression(Object.assign(this._cloneAttrs(), attrs_495));
	  }
	}
	Expression.CloneReducer.prototype.reduceArrowExpression = function (term_496, state_497) {
	  return new ArrowExpression(state_497);
	};
	exports.ArrowExpression = ArrowExpression;

	class ArrowExpressionE extends Expression {
	  constructor(attrs_498, type_499) {
	    super(attrs_498, type_499 || "ArrowExpressionE");
	    if (!{}.hasOwnProperty.call(attrs_498, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_498, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_500, state_501 = {}) {
	    state_501.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_500) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_501.body = this.body.map(a_502 => a_502 instanceof Term ? a_502.reduce(reducer_500) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_502));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_500, state_501);
	  }
	  _cloneAttrs() {
	    return Object.assign({ params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_503) {
	    let state_504 = this._reduceState(reducer_503);
	    return reducer_503.reduceArrowExpressionE(this, state_504);
	  }
	  extend(attrs_505) {
	    return new ArrowExpressionE(Object.assign(this._cloneAttrs(), attrs_505));
	  }
	}
	Expression.CloneReducer.prototype.reduceArrowExpressionE = function (term_506, state_507) {
	  return new ArrowExpressionE(state_507);
	};
	exports.ArrowExpressionE = ArrowExpressionE;

	class AssignmentExpression extends Expression {
	  constructor(attrs_508, type_509) {
	    super(attrs_508, type_509 || "AssignmentExpression");
	    if (!{}.hasOwnProperty.call(attrs_508, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_508, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_510, state_511 = {}) {
	    state_511.binding = this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_510) : this.binding instanceof BindingPropertyProperty ? this.binding.reduce(reducer_510) : this.binding instanceof BindingPropertyIdentifier ? this.binding.reduce(reducer_510) : this.binding instanceof ObjectBinding ? this.binding.reduce(reducer_510) : this.binding instanceof ArrayBinding ? this.binding.reduce(reducer_510) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_510) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_511.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_510) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_510, state_511);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_512) {
	    let state_513 = this._reduceState(reducer_512);
	    return reducer_512.reduceAssignmentExpression(this, state_513);
	  }
	  extend(attrs_514) {
	    return new AssignmentExpression(Object.assign(this._cloneAttrs(), attrs_514));
	  }
	}
	Expression.CloneReducer.prototype.reduceAssignmentExpression = function (term_515, state_516) {
	  return new AssignmentExpression(state_516);
	};
	exports.AssignmentExpression = AssignmentExpression;

	class BinaryExpression extends Expression {
	  constructor(attrs_517, type_518) {
	    super(attrs_517, type_518 || "BinaryExpression");
	    if (!{}.hasOwnProperty.call(attrs_517, "operator")) {
	      throw new Error("Missing attribute: " + "operator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_517, "left")) {
	      throw new Error("Missing attribute: " + "left");
	    }
	    if (!{}.hasOwnProperty.call(attrs_517, "right")) {
	      throw new Error("Missing attribute: " + "right");
	    }
	  }
	  _reduceState(reducer_519, state_520 = {}) {
	    state_520.operator = this.operator;
	    state_520.left = this.left instanceof Expression ? this.left.reduce(reducer_519) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.left));
	    }.call(this);
	    state_520.right = this.right instanceof Expression ? this.right.reduce(reducer_519) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.right));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_519, state_520);
	  }
	  _cloneAttrs() {
	    return Object.assign({ operator: this.operator, left: this.left, right: this.right }, super._cloneAttrs());
	  }
	  reduce(reducer_521) {
	    let state_522 = this._reduceState(reducer_521);
	    return reducer_521.reduceBinaryExpression(this, state_522);
	  }
	  extend(attrs_523) {
	    return new BinaryExpression(Object.assign(this._cloneAttrs(), attrs_523));
	  }
	}
	Expression.CloneReducer.prototype.reduceBinaryExpression = function (term_524, state_525) {
	  return new BinaryExpression(state_525);
	};
	exports.BinaryExpression = BinaryExpression;

	class CallExpression extends Expression {
	  constructor(attrs_526, type_527) {
	    super(attrs_526, type_527 || "CallExpression");
	    if (!{}.hasOwnProperty.call(attrs_526, "callee")) {
	      throw new Error("Missing attribute: " + "callee");
	    }
	    if (!{}.hasOwnProperty.call(attrs_526, "arguments")) {
	      throw new Error("Missing attribute: " + "arguments");
	    }
	  }
	  _reduceState(reducer_528, state_529 = {}) {
	    state_529.callee = this.callee instanceof Expression ? this.callee.reduce(reducer_528) : this.callee instanceof Super ? this.callee.reduce(reducer_528) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.callee));
	    }.call(this);
	    state_529.arguments = this.arguments.map(a_530 => a_530 instanceof SpreadElement ? a_530.reduce(reducer_528) : a_530 instanceof Expression ? a_530.reduce(reducer_528) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_530));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_528, state_529);
	  }
	  _cloneAttrs() {
	    return Object.assign({ callee: this.callee, arguments: this.arguments }, super._cloneAttrs());
	  }
	  reduce(reducer_531) {
	    let state_532 = this._reduceState(reducer_531);
	    return reducer_531.reduceCallExpression(this, state_532);
	  }
	  extend(attrs_533) {
	    return new CallExpression(Object.assign(this._cloneAttrs(), attrs_533));
	  }
	}
	Expression.CloneReducer.prototype.reduceCallExpression = function (term_534, state_535) {
	  return new CallExpression(state_535);
	};
	exports.CallExpression = CallExpression;

	class CompoundAssignmentExpression extends Expression {
	  constructor(attrs_536, type_537) {
	    super(attrs_536, type_537 || "CompoundAssignmentExpression");
	    if (!{}.hasOwnProperty.call(attrs_536, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_536, "operator")) {
	      throw new Error("Missing attribute: " + "operator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_536, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_538, state_539 = {}) {
	    state_539.binding = this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_538) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_538) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_539.operator = this.operator;
	    state_539.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_538) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_538, state_539);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, operator: this.operator, expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_540) {
	    let state_541 = this._reduceState(reducer_540);
	    return reducer_540.reduceCompoundAssignmentExpression(this, state_541);
	  }
	  extend(attrs_542) {
	    return new CompoundAssignmentExpression(Object.assign(this._cloneAttrs(), attrs_542));
	  }
	}
	Expression.CloneReducer.prototype.reduceCompoundAssignmentExpression = function (term_543, state_544) {
	  return new CompoundAssignmentExpression(state_544);
	};
	exports.CompoundAssignmentExpression = CompoundAssignmentExpression;

	class ComputedMemberExpression extends MemberExpression {
	  constructor(attrs_545, type_546) {
	    super(attrs_545, type_546 || "ComputedMemberExpression");
	    if (!{}.hasOwnProperty.call(attrs_545, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_547, state_548 = {}) {
	    state_548.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_547) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_547, state_548);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_549) {
	    let state_550 = this._reduceState(reducer_549);
	    return reducer_549.reduceComputedMemberExpression(this, state_550);
	  }
	  extend(attrs_551) {
	    return new ComputedMemberExpression(Object.assign(this._cloneAttrs(), attrs_551));
	  }
	}
	MemberExpression.CloneReducer.prototype.reduceComputedMemberExpression = function (term_552, state_553) {
	  return new ComputedMemberExpression(state_553);
	};
	exports.ComputedMemberExpression = ComputedMemberExpression;

	class ConditionalExpression extends Expression {
	  constructor(attrs_554, type_555) {
	    super(attrs_554, type_555 || "ConditionalExpression");
	    if (!{}.hasOwnProperty.call(attrs_554, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	    if (!{}.hasOwnProperty.call(attrs_554, "consequent")) {
	      throw new Error("Missing attribute: " + "consequent");
	    }
	    if (!{}.hasOwnProperty.call(attrs_554, "alternate")) {
	      throw new Error("Missing attribute: " + "alternate");
	    }
	  }
	  _reduceState(reducer_556, state_557 = {}) {
	    state_557.test = this.test instanceof Expression ? this.test.reduce(reducer_556) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    state_557.consequent = this.consequent instanceof Expression ? this.consequent.reduce(reducer_556) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.consequent));
	    }.call(this);
	    state_557.alternate = this.alternate instanceof Expression ? this.alternate.reduce(reducer_556) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.alternate));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_556, state_557);
	  }
	  _cloneAttrs() {
	    return Object.assign({ test: this.test, consequent: this.consequent, alternate: this.alternate }, super._cloneAttrs());
	  }
	  reduce(reducer_558) {
	    let state_559 = this._reduceState(reducer_558);
	    return reducer_558.reduceConditionalExpression(this, state_559);
	  }
	  extend(attrs_560) {
	    return new ConditionalExpression(Object.assign(this._cloneAttrs(), attrs_560));
	  }
	}
	Expression.CloneReducer.prototype.reduceConditionalExpression = function (term_561, state_562) {
	  return new ConditionalExpression(state_562);
	};
	exports.ConditionalExpression = ConditionalExpression;

	class FunctionExpression extends Expression {
	  constructor(attrs_563, type_564) {
	    super(attrs_563, type_564 || "FunctionExpression");
	    if (!{}.hasOwnProperty.call(attrs_563, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_563, "isGenerator")) {
	      throw new Error("Missing attribute: " + "isGenerator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_563, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_563, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_565, state_566 = {}) {
	    state_566.name = this.name == null ? null : this.name instanceof BindingIdentifier ? this.name.reduce(reducer_565) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_566.isGenerator = this.isGenerator;
	    state_566.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_565) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_566.body = this.body instanceof FunctionBody ? this.body.reduce(reducer_565) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_565, state_566);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, isGenerator: this.isGenerator, params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_567) {
	    let state_568 = this._reduceState(reducer_567);
	    return reducer_567.reduceFunctionExpression(this, state_568);
	  }
	  extend(attrs_569) {
	    return new FunctionExpression(Object.assign(this._cloneAttrs(), attrs_569));
	  }
	}
	Expression.CloneReducer.prototype.reduceFunctionExpression = function (term_570, state_571) {
	  return new FunctionExpression(state_571);
	};
	exports.FunctionExpression = FunctionExpression;

	class FunctionExpressionE extends Expression {
	  constructor(attrs_572, type_573) {
	    super(attrs_572, type_573 || "FunctionExpressionE");
	    if (!{}.hasOwnProperty.call(attrs_572, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_572, "isGenerator")) {
	      throw new Error("Missing attribute: " + "isGenerator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_572, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_572, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_574, state_575 = {}) {
	    state_575.name = this.name == null ? null : this.name instanceof BindingIdentifier ? this.name.reduce(reducer_574) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_575.isGenerator = this.isGenerator;
	    state_575.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_574) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_575.body = this.body.map(a_576 => a_576 instanceof Term ? a_576.reduce(reducer_574) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_576));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_574, state_575);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, isGenerator: this.isGenerator, params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_577) {
	    let state_578 = this._reduceState(reducer_577);
	    return reducer_577.reduceFunctionExpressionE(this, state_578);
	  }
	  extend(attrs_579) {
	    return new FunctionExpressionE(Object.assign(this._cloneAttrs(), attrs_579));
	  }
	}
	Expression.CloneReducer.prototype.reduceFunctionExpressionE = function (term_580, state_581) {
	  return new FunctionExpressionE(state_581);
	};
	exports.FunctionExpressionE = FunctionExpressionE;

	class IdentifierExpression extends Expression {
	  constructor(attrs_582, type_583) {
	    super(attrs_582, type_583 || "IdentifierExpression");
	    if (!{}.hasOwnProperty.call(attrs_582, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	  }
	  _reduceState(reducer_584, state_585 = {}) {
	    state_585.name = this.name;
	    ;
	    return super._reduceState(reducer_584, state_585);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name }, super._cloneAttrs());
	  }
	  reduce(reducer_586) {
	    let state_587 = this._reduceState(reducer_586);
	    return reducer_586.reduceIdentifierExpression(this, state_587);
	  }
	  extend(attrs_588) {
	    return new IdentifierExpression(Object.assign(this._cloneAttrs(), attrs_588));
	  }
	}
	Expression.CloneReducer.prototype.reduceIdentifierExpression = function (term_589, state_590) {
	  return new IdentifierExpression(state_590);
	};
	exports.IdentifierExpression = IdentifierExpression;

	class NewExpression extends Expression {
	  constructor(attrs_591, type_592) {
	    super(attrs_591, type_592 || "NewExpression");
	    if (!{}.hasOwnProperty.call(attrs_591, "callee")) {
	      throw new Error("Missing attribute: " + "callee");
	    }
	    if (!{}.hasOwnProperty.call(attrs_591, "arguments")) {
	      throw new Error("Missing attribute: " + "arguments");
	    }
	  }
	  _reduceState(reducer_593, state_594 = {}) {
	    state_594.callee = this.callee instanceof Expression ? this.callee.reduce(reducer_593) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.callee));
	    }.call(this);
	    state_594.arguments = this.arguments.map(a_595 => a_595 instanceof SpreadElement ? a_595.reduce(reducer_593) : a_595 instanceof Expression ? a_595.reduce(reducer_593) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_595));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_593, state_594);
	  }
	  _cloneAttrs() {
	    return Object.assign({ callee: this.callee, arguments: this.arguments }, super._cloneAttrs());
	  }
	  reduce(reducer_596) {
	    let state_597 = this._reduceState(reducer_596);
	    return reducer_596.reduceNewExpression(this, state_597);
	  }
	  extend(attrs_598) {
	    return new NewExpression(Object.assign(this._cloneAttrs(), attrs_598));
	  }
	}
	Expression.CloneReducer.prototype.reduceNewExpression = function (term_599, state_600) {
	  return new NewExpression(state_600);
	};
	exports.NewExpression = NewExpression;

	class NewTargetExpression extends Expression {
	  constructor(attrs_601, type_602) {
	    super(attrs_601, type_602 || "NewTargetExpression");
	  }
	  _reduceState(reducer_603, state_604 = {}) {
	    ;
	    return super._reduceState(reducer_603, state_604);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_605) {
	    let state_606 = this._reduceState(reducer_605);
	    return reducer_605.reduceNewTargetExpression(this, state_606);
	  }
	  extend(attrs_607) {
	    return new NewTargetExpression(Object.assign(this._cloneAttrs(), attrs_607));
	  }
	}
	Expression.CloneReducer.prototype.reduceNewTargetExpression = function (term_608, state_609) {
	  return new NewTargetExpression(state_609);
	};
	exports.NewTargetExpression = NewTargetExpression;

	class ObjectExpression extends Expression {
	  constructor(attrs_610, type_611) {
	    super(attrs_610, type_611 || "ObjectExpression");
	    if (!{}.hasOwnProperty.call(attrs_610, "properties")) {
	      throw new Error("Missing attribute: " + "properties");
	    }
	  }
	  _reduceState(reducer_612, state_613 = {}) {
	    state_613.properties = this.properties.map(a_614 => a_614 instanceof ObjectProperty ? a_614.reduce(reducer_612) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_614));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_612, state_613);
	  }
	  _cloneAttrs() {
	    return Object.assign({ properties: this.properties }, super._cloneAttrs());
	  }
	  reduce(reducer_615) {
	    let state_616 = this._reduceState(reducer_615);
	    return reducer_615.reduceObjectExpression(this, state_616);
	  }
	  extend(attrs_617) {
	    return new ObjectExpression(Object.assign(this._cloneAttrs(), attrs_617));
	  }
	}
	Expression.CloneReducer.prototype.reduceObjectExpression = function (term_618, state_619) {
	  return new ObjectExpression(state_619);
	};
	exports.ObjectExpression = ObjectExpression;

	class UnaryExpression extends Expression {
	  constructor(attrs_620, type_621) {
	    super(attrs_620, type_621 || "UnaryExpression");
	    if (!{}.hasOwnProperty.call(attrs_620, "operator")) {
	      throw new Error("Missing attribute: " + "operator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_620, "operand")) {
	      throw new Error("Missing attribute: " + "operand");
	    }
	  }
	  _reduceState(reducer_622, state_623 = {}) {
	    state_623.operator = this.operator;
	    state_623.operand = this.operand instanceof Expression ? this.operand.reduce(reducer_622) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.operand));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_622, state_623);
	  }
	  _cloneAttrs() {
	    return Object.assign({ operator: this.operator, operand: this.operand }, super._cloneAttrs());
	  }
	  reduce(reducer_624) {
	    let state_625 = this._reduceState(reducer_624);
	    return reducer_624.reduceUnaryExpression(this, state_625);
	  }
	  extend(attrs_626) {
	    return new UnaryExpression(Object.assign(this._cloneAttrs(), attrs_626));
	  }
	}
	Expression.CloneReducer.prototype.reduceUnaryExpression = function (term_627, state_628) {
	  return new UnaryExpression(state_628);
	};
	exports.UnaryExpression = UnaryExpression;

	class StaticMemberExpression extends MemberExpression {
	  constructor(attrs_629, type_630) {
	    super(attrs_629, type_630 || "StaticMemberExpression");
	    if (!{}.hasOwnProperty.call(attrs_629, "property")) {
	      throw new Error("Missing attribute: " + "property");
	    }
	  }
	  _reduceState(reducer_631, state_632 = {}) {
	    state_632.property = this.property;
	    ;
	    return super._reduceState(reducer_631, state_632);
	  }
	  _cloneAttrs() {
	    return Object.assign({ property: this.property }, super._cloneAttrs());
	  }
	  reduce(reducer_633) {
	    let state_634 = this._reduceState(reducer_633);
	    return reducer_633.reduceStaticMemberExpression(this, state_634);
	  }
	  extend(attrs_635) {
	    return new StaticMemberExpression(Object.assign(this._cloneAttrs(), attrs_635));
	  }
	}
	MemberExpression.CloneReducer.prototype.reduceStaticMemberExpression = function (term_636, state_637) {
	  return new StaticMemberExpression(state_637);
	};
	exports.StaticMemberExpression = StaticMemberExpression;

	class TemplateExpression extends Expression {
	  constructor(attrs_638, type_639) {
	    super(attrs_638, type_639 || "TemplateExpression");
	    if (!{}.hasOwnProperty.call(attrs_638, "tag")) {
	      throw new Error("Missing attribute: " + "tag");
	    }
	    if (!{}.hasOwnProperty.call(attrs_638, "elements")) {
	      throw new Error("Missing attribute: " + "elements");
	    }
	  }
	  _reduceState(reducer_640, state_641 = {}) {
	    state_641.tag = this.tag == null ? null : this.tag instanceof Expression ? this.tag.reduce(reducer_640) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.tag));
	    }.call(this);
	    state_641.elements = this.elements.map(a_642 => a_642 instanceof Expression ? a_642.reduce(reducer_640) : a_642 instanceof TemplateElement ? a_642.reduce(reducer_640) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_642));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_640, state_641);
	  }
	  _cloneAttrs() {
	    return Object.assign({ tag: this.tag, elements: this.elements }, super._cloneAttrs());
	  }
	  reduce(reducer_643) {
	    let state_644 = this._reduceState(reducer_643);
	    return reducer_643.reduceTemplateExpression(this, state_644);
	  }
	  extend(attrs_645) {
	    return new TemplateExpression(Object.assign(this._cloneAttrs(), attrs_645));
	  }
	}
	Expression.CloneReducer.prototype.reduceTemplateExpression = function (term_646, state_647) {
	  return new TemplateExpression(state_647);
	};
	exports.TemplateExpression = TemplateExpression;

	class ThisExpression extends Expression {
	  constructor(attrs_648, type_649) {
	    super(attrs_648, type_649 || "ThisExpression");
	    if (!{}.hasOwnProperty.call(attrs_648, "stx")) {
	      throw new Error("Missing attribute: " + "stx");
	    }
	  }
	  _reduceState(reducer_650, state_651 = {}) {
	    state_651.stx = this.stx;
	    ;
	    return super._reduceState(reducer_650, state_651);
	  }
	  _cloneAttrs() {
	    return Object.assign({ stx: this.stx }, super._cloneAttrs());
	  }
	  reduce(reducer_652) {
	    let state_653 = this._reduceState(reducer_652);
	    return reducer_652.reduceThisExpression(this, state_653);
	  }
	  extend(attrs_654) {
	    return new ThisExpression(Object.assign(this._cloneAttrs(), attrs_654));
	  }
	}
	Expression.CloneReducer.prototype.reduceThisExpression = function (term_655, state_656) {
	  return new ThisExpression(state_656);
	};
	exports.ThisExpression = ThisExpression;

	class UpdateExpression extends Expression {
	  constructor(attrs_657, type_658) {
	    super(attrs_657, type_658 || "UpdateExpression");
	    if (!{}.hasOwnProperty.call(attrs_657, "isPrefix")) {
	      throw new Error("Missing attribute: " + "isPrefix");
	    }
	    if (!{}.hasOwnProperty.call(attrs_657, "operator")) {
	      throw new Error("Missing attribute: " + "operator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_657, "operand")) {
	      throw new Error("Missing attribute: " + "operand");
	    }
	  }
	  _reduceState(reducer_659, state_660 = {}) {
	    state_660.isPrefix = this.isPrefix;
	    state_660.operator = this.operator;
	    state_660.operand = this.operand instanceof BindingIdentifier ? this.operand.reduce(reducer_659) : this.operand instanceof MemberExpression ? this.operand.reduce(reducer_659) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.operand));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_659, state_660);
	  }
	  _cloneAttrs() {
	    return Object.assign({ isPrefix: this.isPrefix, operator: this.operator, operand: this.operand }, super._cloneAttrs());
	  }
	  reduce(reducer_661) {
	    let state_662 = this._reduceState(reducer_661);
	    return reducer_661.reduceUpdateExpression(this, state_662);
	  }
	  extend(attrs_663) {
	    return new UpdateExpression(Object.assign(this._cloneAttrs(), attrs_663));
	  }
	}
	Expression.CloneReducer.prototype.reduceUpdateExpression = function (term_664, state_665) {
	  return new UpdateExpression(state_665);
	};
	exports.UpdateExpression = UpdateExpression;

	class YieldExpression extends Expression {
	  constructor(attrs_666, type_667) {
	    super(attrs_666, type_667 || "YieldExpression");
	    if (!{}.hasOwnProperty.call(attrs_666, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_668, state_669 = {}) {
	    state_669.expression = this.expression == null ? null : this.expression instanceof Expression ? this.expression.reduce(reducer_668) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_668, state_669);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_670) {
	    let state_671 = this._reduceState(reducer_670);
	    return reducer_670.reduceYieldExpression(this, state_671);
	  }
	  extend(attrs_672) {
	    return new YieldExpression(Object.assign(this._cloneAttrs(), attrs_672));
	  }
	}
	Expression.CloneReducer.prototype.reduceYieldExpression = function (term_673, state_674) {
	  return new YieldExpression(state_674);
	};
	exports.YieldExpression = YieldExpression;

	class YieldGeneratorExpression extends Expression {
	  constructor(attrs_675, type_676) {
	    super(attrs_675, type_676 || "YieldGeneratorExpression");
	    if (!{}.hasOwnProperty.call(attrs_675, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_677, state_678 = {}) {
	    state_678.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_677) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_677, state_678);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_679) {
	    let state_680 = this._reduceState(reducer_679);
	    return reducer_679.reduceYieldGeneratorExpression(this, state_680);
	  }
	  extend(attrs_681) {
	    return new YieldGeneratorExpression(Object.assign(this._cloneAttrs(), attrs_681));
	  }
	}
	Expression.CloneReducer.prototype.reduceYieldGeneratorExpression = function (term_682, state_683) {
	  return new YieldGeneratorExpression(state_683);
	};
	exports.YieldGeneratorExpression = YieldGeneratorExpression;

	class ParenthesizedExpression extends Expression {
	  constructor(attrs_684, type_685) {
	    super(attrs_684, type_685 || "ParenthesizedExpression");
	    if (!{}.hasOwnProperty.call(attrs_684, "inner")) {
	      throw new Error("Missing attribute: " + "inner");
	    }
	  }
	  _reduceState(reducer_686, state_687 = {}) {
	    state_687.inner = this.inner;
	    ;
	    return super._reduceState(reducer_686, state_687);
	  }
	  _cloneAttrs() {
	    return Object.assign({ inner: this.inner }, super._cloneAttrs());
	  }
	  reduce(reducer_688) {
	    let state_689 = this._reduceState(reducer_688);
	    return reducer_688.reduceParenthesizedExpression(this, state_689);
	  }
	  extend(attrs_690) {
	    return new ParenthesizedExpression(Object.assign(this._cloneAttrs(), attrs_690));
	  }
	}
	Expression.CloneReducer.prototype.reduceParenthesizedExpression = function (term_691, state_692) {
	  return new ParenthesizedExpression(state_692);
	};
	exports.ParenthesizedExpression = ParenthesizedExpression;

	class BlockStatement extends Statement {
	  constructor(attrs_693, type_694) {
	    super(attrs_693, type_694 || "BlockStatement");
	    if (!{}.hasOwnProperty.call(attrs_693, "block")) {
	      throw new Error("Missing attribute: " + "block");
	    }
	  }
	  _reduceState(reducer_695, state_696 = {}) {
	    state_696.block = this.block instanceof Block ? this.block.reduce(reducer_695) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.block));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_695, state_696);
	  }
	  _cloneAttrs() {
	    return Object.assign({ block: this.block }, super._cloneAttrs());
	  }
	  reduce(reducer_697) {
	    let state_698 = this._reduceState(reducer_697);
	    return reducer_697.reduceBlockStatement(this, state_698);
	  }
	  extend(attrs_699) {
	    return new BlockStatement(Object.assign(this._cloneAttrs(), attrs_699));
	  }
	}
	Statement.CloneReducer.prototype.reduceBlockStatement = function (term_700, state_701) {
	  return new BlockStatement(state_701);
	};
	exports.BlockStatement = BlockStatement;

	class BreakStatement extends Statement {
	  constructor(attrs_702, type_703) {
	    super(attrs_702, type_703 || "BreakStatement");
	    if (!{}.hasOwnProperty.call(attrs_702, "label")) {
	      throw new Error("Missing attribute: " + "label");
	    }
	  }
	  _reduceState(reducer_704, state_705 = {}) {
	    state_705.label = this.label == null ? null : this.label;
	    ;
	    return super._reduceState(reducer_704, state_705);
	  }
	  _cloneAttrs() {
	    return Object.assign({ label: this.label }, super._cloneAttrs());
	  }
	  reduce(reducer_706) {
	    let state_707 = this._reduceState(reducer_706);
	    return reducer_706.reduceBreakStatement(this, state_707);
	  }
	  extend(attrs_708) {
	    return new BreakStatement(Object.assign(this._cloneAttrs(), attrs_708));
	  }
	}
	Statement.CloneReducer.prototype.reduceBreakStatement = function (term_709, state_710) {
	  return new BreakStatement(state_710);
	};
	exports.BreakStatement = BreakStatement;

	class ContinueStatement extends Statement {
	  constructor(attrs_711, type_712) {
	    super(attrs_711, type_712 || "ContinueStatement");
	    if (!{}.hasOwnProperty.call(attrs_711, "label")) {
	      throw new Error("Missing attribute: " + "label");
	    }
	  }
	  _reduceState(reducer_713, state_714 = {}) {
	    state_714.label = this.label == null ? null : this.label;
	    ;
	    return super._reduceState(reducer_713, state_714);
	  }
	  _cloneAttrs() {
	    return Object.assign({ label: this.label }, super._cloneAttrs());
	  }
	  reduce(reducer_715) {
	    let state_716 = this._reduceState(reducer_715);
	    return reducer_715.reduceContinueStatement(this, state_716);
	  }
	  extend(attrs_717) {
	    return new ContinueStatement(Object.assign(this._cloneAttrs(), attrs_717));
	  }
	}
	Statement.CloneReducer.prototype.reduceContinueStatement = function (term_718, state_719) {
	  return new ContinueStatement(state_719);
	};
	exports.ContinueStatement = ContinueStatement;

	class DebuggerStatement extends Statement {
	  constructor(attrs_720, type_721) {
	    super(attrs_720, type_721 || "DebuggerStatement");
	  }
	  _reduceState(reducer_722, state_723 = {}) {
	    ;
	    return super._reduceState(reducer_722, state_723);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_724) {
	    let state_725 = this._reduceState(reducer_724);
	    return reducer_724.reduceDebuggerStatement(this, state_725);
	  }
	  extend(attrs_726) {
	    return new DebuggerStatement(Object.assign(this._cloneAttrs(), attrs_726));
	  }
	}
	Statement.CloneReducer.prototype.reduceDebuggerStatement = function (term_727, state_728) {
	  return new DebuggerStatement(state_728);
	};
	exports.DebuggerStatement = DebuggerStatement;

	class DoWhileStatement extends IterationStatement {
	  constructor(attrs_729, type_730) {
	    super(attrs_729, type_730 || "DoWhileStatement");
	    if (!{}.hasOwnProperty.call(attrs_729, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	  }
	  _reduceState(reducer_731, state_732 = {}) {
	    state_732.test = this.test instanceof Expression ? this.test.reduce(reducer_731) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_731, state_732);
	  }
	  _cloneAttrs() {
	    return Object.assign({ test: this.test }, super._cloneAttrs());
	  }
	  reduce(reducer_733) {
	    let state_734 = this._reduceState(reducer_733);
	    return reducer_733.reduceDoWhileStatement(this, state_734);
	  }
	  extend(attrs_735) {
	    return new DoWhileStatement(Object.assign(this._cloneAttrs(), attrs_735));
	  }
	}
	IterationStatement.CloneReducer.prototype.reduceDoWhileStatement = function (term_736, state_737) {
	  return new DoWhileStatement(state_737);
	};
	exports.DoWhileStatement = DoWhileStatement;

	class EmptyStatement extends Statement {
	  constructor(attrs_738, type_739) {
	    super(attrs_738, type_739 || "EmptyStatement");
	  }
	  _reduceState(reducer_740, state_741 = {}) {
	    ;
	    return super._reduceState(reducer_740, state_741);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_742) {
	    let state_743 = this._reduceState(reducer_742);
	    return reducer_742.reduceEmptyStatement(this, state_743);
	  }
	  extend(attrs_744) {
	    return new EmptyStatement(Object.assign(this._cloneAttrs(), attrs_744));
	  }
	}
	Statement.CloneReducer.prototype.reduceEmptyStatement = function (term_745, state_746) {
	  return new EmptyStatement(state_746);
	};
	exports.EmptyStatement = EmptyStatement;

	class ExpressionStatement extends Statement {
	  constructor(attrs_747, type_748) {
	    super(attrs_747, type_748 || "ExpressionStatement");
	    if (!{}.hasOwnProperty.call(attrs_747, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_749, state_750 = {}) {
	    state_750.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_749) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_749, state_750);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_751) {
	    let state_752 = this._reduceState(reducer_751);
	    return reducer_751.reduceExpressionStatement(this, state_752);
	  }
	  extend(attrs_753) {
	    return new ExpressionStatement(Object.assign(this._cloneAttrs(), attrs_753));
	  }
	}
	Statement.CloneReducer.prototype.reduceExpressionStatement = function (term_754, state_755) {
	  return new ExpressionStatement(state_755);
	};
	exports.ExpressionStatement = ExpressionStatement;

	class ForInStatement extends IterationStatement {
	  constructor(attrs_756, type_757) {
	    super(attrs_756, type_757 || "ForInStatement");
	    if (!{}.hasOwnProperty.call(attrs_756, "left")) {
	      throw new Error("Missing attribute: " + "left");
	    }
	    if (!{}.hasOwnProperty.call(attrs_756, "right")) {
	      throw new Error("Missing attribute: " + "right");
	    }
	  }
	  _reduceState(reducer_758, state_759 = {}) {
	    state_759.left = this.left instanceof VariableDeclaration ? this.left.reduce(reducer_758) : this.left instanceof ObjectBinding ? this.left.reduce(reducer_758) : this.left instanceof ArrayBinding ? this.left.reduce(reducer_758) : this.left instanceof BindingIdentifier ? this.left.reduce(reducer_758) : this.left instanceof MemberExpression ? this.left.reduce(reducer_758) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.left));
	    }.call(this);
	    state_759.right = this.right instanceof Expression ? this.right.reduce(reducer_758) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.right));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_758, state_759);
	  }
	  _cloneAttrs() {
	    return Object.assign({ left: this.left, right: this.right }, super._cloneAttrs());
	  }
	  reduce(reducer_760) {
	    let state_761 = this._reduceState(reducer_760);
	    return reducer_760.reduceForInStatement(this, state_761);
	  }
	  extend(attrs_762) {
	    return new ForInStatement(Object.assign(this._cloneAttrs(), attrs_762));
	  }
	}
	IterationStatement.CloneReducer.prototype.reduceForInStatement = function (term_763, state_764) {
	  return new ForInStatement(state_764);
	};
	exports.ForInStatement = ForInStatement;

	class ForOfStatement extends IterationStatement {
	  constructor(attrs_765, type_766) {
	    super(attrs_765, type_766 || "ForOfStatement");
	    if (!{}.hasOwnProperty.call(attrs_765, "left")) {
	      throw new Error("Missing attribute: " + "left");
	    }
	    if (!{}.hasOwnProperty.call(attrs_765, "right")) {
	      throw new Error("Missing attribute: " + "right");
	    }
	  }
	  _reduceState(reducer_767, state_768 = {}) {
	    state_768.left = this.left instanceof VariableDeclaration ? this.left.reduce(reducer_767) : this.left instanceof ObjectBinding ? this.left.reduce(reducer_767) : this.left instanceof ArrayBinding ? this.left.reduce(reducer_767) : this.left instanceof BindingIdentifier ? this.left.reduce(reducer_767) : this.left instanceof MemberExpression ? this.left.reduce(reducer_767) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.left));
	    }.call(this);
	    state_768.right = this.right instanceof Expression ? this.right.reduce(reducer_767) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.right));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_767, state_768);
	  }
	  _cloneAttrs() {
	    return Object.assign({ left: this.left, right: this.right }, super._cloneAttrs());
	  }
	  reduce(reducer_769) {
	    let state_770 = this._reduceState(reducer_769);
	    return reducer_769.reduceForOfStatement(this, state_770);
	  }
	  extend(attrs_771) {
	    return new ForOfStatement(Object.assign(this._cloneAttrs(), attrs_771));
	  }
	}
	IterationStatement.CloneReducer.prototype.reduceForOfStatement = function (term_772, state_773) {
	  return new ForOfStatement(state_773);
	};
	exports.ForOfStatement = ForOfStatement;

	class ForStatement extends IterationStatement {
	  constructor(attrs_774, type_775) {
	    super(attrs_774, type_775 || "ForStatement");
	    if (!{}.hasOwnProperty.call(attrs_774, "init")) {
	      throw new Error("Missing attribute: " + "init");
	    }
	    if (!{}.hasOwnProperty.call(attrs_774, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	    if (!{}.hasOwnProperty.call(attrs_774, "update")) {
	      throw new Error("Missing attribute: " + "update");
	    }
	  }
	  _reduceState(reducer_776, state_777 = {}) {
	    state_777.init = this.init == null ? null : this.init instanceof VariableDeclaration ? this.init.reduce(reducer_776) : this.init instanceof Expression ? this.init.reduce(reducer_776) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.init));
	    }.call(this);
	    state_777.test = this.test == null ? null : this.test instanceof Expression ? this.test.reduce(reducer_776) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    state_777.update = this.update == null ? null : this.update instanceof Expression ? this.update.reduce(reducer_776) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.update));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_776, state_777);
	  }
	  _cloneAttrs() {
	    return Object.assign({ init: this.init, test: this.test, update: this.update }, super._cloneAttrs());
	  }
	  reduce(reducer_778) {
	    let state_779 = this._reduceState(reducer_778);
	    return reducer_778.reduceForStatement(this, state_779);
	  }
	  extend(attrs_780) {
	    return new ForStatement(Object.assign(this._cloneAttrs(), attrs_780));
	  }
	}
	IterationStatement.CloneReducer.prototype.reduceForStatement = function (term_781, state_782) {
	  return new ForStatement(state_782);
	};
	exports.ForStatement = ForStatement;

	class IfStatement extends Statement {
	  constructor(attrs_783, type_784) {
	    super(attrs_783, type_784 || "IfStatement");
	    if (!{}.hasOwnProperty.call(attrs_783, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	    if (!{}.hasOwnProperty.call(attrs_783, "consequent")) {
	      throw new Error("Missing attribute: " + "consequent");
	    }
	    if (!{}.hasOwnProperty.call(attrs_783, "alternate")) {
	      throw new Error("Missing attribute: " + "alternate");
	    }
	  }
	  _reduceState(reducer_785, state_786 = {}) {
	    state_786.test = this.test instanceof Expression ? this.test.reduce(reducer_785) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    state_786.consequent = this.consequent instanceof Statement ? this.consequent.reduce(reducer_785) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.consequent));
	    }.call(this);
	    state_786.alternate = this.alternate == null ? null : this.alternate instanceof Statement ? this.alternate.reduce(reducer_785) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.alternate));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_785, state_786);
	  }
	  _cloneAttrs() {
	    return Object.assign({ test: this.test, consequent: this.consequent, alternate: this.alternate }, super._cloneAttrs());
	  }
	  reduce(reducer_787) {
	    let state_788 = this._reduceState(reducer_787);
	    return reducer_787.reduceIfStatement(this, state_788);
	  }
	  extend(attrs_789) {
	    return new IfStatement(Object.assign(this._cloneAttrs(), attrs_789));
	  }
	}
	Statement.CloneReducer.prototype.reduceIfStatement = function (term_790, state_791) {
	  return new IfStatement(state_791);
	};
	exports.IfStatement = IfStatement;

	class LabeledStatement extends Statement {
	  constructor(attrs_792, type_793) {
	    super(attrs_792, type_793 || "LabeledStatement");
	    if (!{}.hasOwnProperty.call(attrs_792, "label")) {
	      throw new Error("Missing attribute: " + "label");
	    }
	    if (!{}.hasOwnProperty.call(attrs_792, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_794, state_795 = {}) {
	    state_795.label = this.label;
	    state_795.body = this.body instanceof Statement ? this.body.reduce(reducer_794) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_794, state_795);
	  }
	  _cloneAttrs() {
	    return Object.assign({ label: this.label, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_796) {
	    let state_797 = this._reduceState(reducer_796);
	    return reducer_796.reduceLabeledStatement(this, state_797);
	  }
	  extend(attrs_798) {
	    return new LabeledStatement(Object.assign(this._cloneAttrs(), attrs_798));
	  }
	}
	Statement.CloneReducer.prototype.reduceLabeledStatement = function (term_799, state_800) {
	  return new LabeledStatement(state_800);
	};
	exports.LabeledStatement = LabeledStatement;

	class ReturnStatement extends Statement {
	  constructor(attrs_801, type_802) {
	    super(attrs_801, type_802 || "ReturnStatement");
	    if (!{}.hasOwnProperty.call(attrs_801, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_803, state_804 = {}) {
	    state_804.expression = this.expression == null ? null : this.expression instanceof Expression ? this.expression.reduce(reducer_803) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_803, state_804);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_805) {
	    let state_806 = this._reduceState(reducer_805);
	    return reducer_805.reduceReturnStatement(this, state_806);
	  }
	  extend(attrs_807) {
	    return new ReturnStatement(Object.assign(this._cloneAttrs(), attrs_807));
	  }
	}
	Statement.CloneReducer.prototype.reduceReturnStatement = function (term_808, state_809) {
	  return new ReturnStatement(state_809);
	};
	exports.ReturnStatement = ReturnStatement;

	class SwitchStatement extends Statement {
	  constructor(attrs_810, type_811) {
	    super(attrs_810, type_811 || "SwitchStatement");
	    if (!{}.hasOwnProperty.call(attrs_810, "discriminant")) {
	      throw new Error("Missing attribute: " + "discriminant");
	    }
	    if (!{}.hasOwnProperty.call(attrs_810, "cases")) {
	      throw new Error("Missing attribute: " + "cases");
	    }
	  }
	  _reduceState(reducer_812, state_813 = {}) {
	    state_813.discriminant = this.discriminant instanceof Expression ? this.discriminant.reduce(reducer_812) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.discriminant));
	    }.call(this);
	    state_813.cases = this.cases.map(a_814 => a_814 instanceof SwitchCase ? a_814.reduce(reducer_812) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_814));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_812, state_813);
	  }
	  _cloneAttrs() {
	    return Object.assign({ discriminant: this.discriminant, cases: this.cases }, super._cloneAttrs());
	  }
	  reduce(reducer_815) {
	    let state_816 = this._reduceState(reducer_815);
	    return reducer_815.reduceSwitchStatement(this, state_816);
	  }
	  extend(attrs_817) {
	    return new SwitchStatement(Object.assign(this._cloneAttrs(), attrs_817));
	  }
	}
	Statement.CloneReducer.prototype.reduceSwitchStatement = function (term_818, state_819) {
	  return new SwitchStatement(state_819);
	};
	exports.SwitchStatement = SwitchStatement;

	class SwitchStatementWithDefault extends Statement {
	  constructor(attrs_820, type_821) {
	    super(attrs_820, type_821 || "SwitchStatementWithDefault");
	    if (!{}.hasOwnProperty.call(attrs_820, "discriminant")) {
	      throw new Error("Missing attribute: " + "discriminant");
	    }
	    if (!{}.hasOwnProperty.call(attrs_820, "preDefaultCases")) {
	      throw new Error("Missing attribute: " + "preDefaultCases");
	    }
	    if (!{}.hasOwnProperty.call(attrs_820, "defaultCase")) {
	      throw new Error("Missing attribute: " + "defaultCase");
	    }
	    if (!{}.hasOwnProperty.call(attrs_820, "postDefaultCases")) {
	      throw new Error("Missing attribute: " + "postDefaultCases");
	    }
	  }
	  _reduceState(reducer_822, state_823 = {}) {
	    state_823.discriminant = this.discriminant instanceof Expression ? this.discriminant.reduce(reducer_822) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.discriminant));
	    }.call(this);
	    state_823.preDefaultCases = this.preDefaultCases.map(a_824 => a_824 instanceof SwitchCase ? a_824.reduce(reducer_822) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_824));
	    }.call(this));
	    state_823.defaultCase = this.defaultCase instanceof SwitchDefault ? this.defaultCase.reduce(reducer_822) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.defaultCase));
	    }.call(this);
	    state_823.postDefaultCases = this.postDefaultCases.map(a_825 => a_825 instanceof SwitchCase ? a_825.reduce(reducer_822) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_825));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_822, state_823);
	  }
	  _cloneAttrs() {
	    return Object.assign({ discriminant: this.discriminant, preDefaultCases: this.preDefaultCases, defaultCase: this.defaultCase, postDefaultCases: this.postDefaultCases }, super._cloneAttrs());
	  }
	  reduce(reducer_826) {
	    let state_827 = this._reduceState(reducer_826);
	    return reducer_826.reduceSwitchStatementWithDefault(this, state_827);
	  }
	  extend(attrs_828) {
	    return new SwitchStatementWithDefault(Object.assign(this._cloneAttrs(), attrs_828));
	  }
	}
	Statement.CloneReducer.prototype.reduceSwitchStatementWithDefault = function (term_829, state_830) {
	  return new SwitchStatementWithDefault(state_830);
	};
	exports.SwitchStatementWithDefault = SwitchStatementWithDefault;

	class ThrowStatement extends Statement {
	  constructor(attrs_831, type_832) {
	    super(attrs_831, type_832 || "ThrowStatement");
	    if (!{}.hasOwnProperty.call(attrs_831, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_833, state_834 = {}) {
	    state_834.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_833) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_833, state_834);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_835) {
	    let state_836 = this._reduceState(reducer_835);
	    return reducer_835.reduceThrowStatement(this, state_836);
	  }
	  extend(attrs_837) {
	    return new ThrowStatement(Object.assign(this._cloneAttrs(), attrs_837));
	  }
	}
	Statement.CloneReducer.prototype.reduceThrowStatement = function (term_838, state_839) {
	  return new ThrowStatement(state_839);
	};
	exports.ThrowStatement = ThrowStatement;

	class TryCatchStatement extends Statement {
	  constructor(attrs_840, type_841) {
	    super(attrs_840, type_841 || "TryCatchStatement");
	    if (!{}.hasOwnProperty.call(attrs_840, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	    if (!{}.hasOwnProperty.call(attrs_840, "catchClause")) {
	      throw new Error("Missing attribute: " + "catchClause");
	    }
	  }
	  _reduceState(reducer_842, state_843 = {}) {
	    state_843.body = this.body instanceof Block ? this.body.reduce(reducer_842) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    state_843.catchClause = this.catchClause instanceof CatchClause ? this.catchClause.reduce(reducer_842) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.catchClause));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_842, state_843);
	  }
	  _cloneAttrs() {
	    return Object.assign({ body: this.body, catchClause: this.catchClause }, super._cloneAttrs());
	  }
	  reduce(reducer_844) {
	    let state_845 = this._reduceState(reducer_844);
	    return reducer_844.reduceTryCatchStatement(this, state_845);
	  }
	  extend(attrs_846) {
	    return new TryCatchStatement(Object.assign(this._cloneAttrs(), attrs_846));
	  }
	}
	Statement.CloneReducer.prototype.reduceTryCatchStatement = function (term_847, state_848) {
	  return new TryCatchStatement(state_848);
	};
	exports.TryCatchStatement = TryCatchStatement;

	class TryFinallyStatement extends Statement {
	  constructor(attrs_849, type_850) {
	    super(attrs_849, type_850 || "TryFinallyStatement");
	    if (!{}.hasOwnProperty.call(attrs_849, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	    if (!{}.hasOwnProperty.call(attrs_849, "catchClause")) {
	      throw new Error("Missing attribute: " + "catchClause");
	    }
	    if (!{}.hasOwnProperty.call(attrs_849, "finalizer")) {
	      throw new Error("Missing attribute: " + "finalizer");
	    }
	  }
	  _reduceState(reducer_851, state_852 = {}) {
	    state_852.body = this.body instanceof Block ? this.body.reduce(reducer_851) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    state_852.catchClause = this.catchClause == null ? null : this.catchClause instanceof CatchClause ? this.catchClause.reduce(reducer_851) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.catchClause));
	    }.call(this);
	    state_852.finalizer = this.finalizer instanceof Block ? this.finalizer.reduce(reducer_851) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.finalizer));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_851, state_852);
	  }
	  _cloneAttrs() {
	    return Object.assign({ body: this.body, catchClause: this.catchClause, finalizer: this.finalizer }, super._cloneAttrs());
	  }
	  reduce(reducer_853) {
	    let state_854 = this._reduceState(reducer_853);
	    return reducer_853.reduceTryFinallyStatement(this, state_854);
	  }
	  extend(attrs_855) {
	    return new TryFinallyStatement(Object.assign(this._cloneAttrs(), attrs_855));
	  }
	}
	Statement.CloneReducer.prototype.reduceTryFinallyStatement = function (term_856, state_857) {
	  return new TryFinallyStatement(state_857);
	};
	exports.TryFinallyStatement = TryFinallyStatement;

	class VariableDeclarationStatement extends Statement {
	  constructor(attrs_858, type_859) {
	    super(attrs_858, type_859 || "VariableDeclarationStatement");
	    if (!{}.hasOwnProperty.call(attrs_858, "declaration")) {
	      throw new Error("Missing attribute: " + "declaration");
	    }
	  }
	  _reduceState(reducer_860, state_861 = {}) {
	    state_861.declaration = this.declaration instanceof VariableDeclaration ? this.declaration.reduce(reducer_860) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.declaration));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_860, state_861);
	  }
	  _cloneAttrs() {
	    return Object.assign({ declaration: this.declaration }, super._cloneAttrs());
	  }
	  reduce(reducer_862) {
	    let state_863 = this._reduceState(reducer_862);
	    return reducer_862.reduceVariableDeclarationStatement(this, state_863);
	  }
	  extend(attrs_864) {
	    return new VariableDeclarationStatement(Object.assign(this._cloneAttrs(), attrs_864));
	  }
	}
	Statement.CloneReducer.prototype.reduceVariableDeclarationStatement = function (term_865, state_866) {
	  return new VariableDeclarationStatement(state_866);
	};
	exports.VariableDeclarationStatement = VariableDeclarationStatement;

	class WithStatement extends Statement {
	  constructor(attrs_867, type_868) {
	    super(attrs_867, type_868 || "WithStatement");
	    if (!{}.hasOwnProperty.call(attrs_867, "object")) {
	      throw new Error("Missing attribute: " + "object");
	    }
	    if (!{}.hasOwnProperty.call(attrs_867, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_869, state_870 = {}) {
	    state_870.object = this.object instanceof Expression ? this.object.reduce(reducer_869) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.object));
	    }.call(this);
	    state_870.body = this.body instanceof Statement ? this.body.reduce(reducer_869) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_869, state_870);
	  }
	  _cloneAttrs() {
	    return Object.assign({ object: this.object, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_871) {
	    let state_872 = this._reduceState(reducer_871);
	    return reducer_871.reduceWithStatement(this, state_872);
	  }
	  extend(attrs_873) {
	    return new WithStatement(Object.assign(this._cloneAttrs(), attrs_873));
	  }
	}
	Statement.CloneReducer.prototype.reduceWithStatement = function (term_874, state_875) {
	  return new WithStatement(state_875);
	};
	exports.WithStatement = WithStatement;

	class WhileStatement extends IterationStatement {
	  constructor(attrs_876, type_877) {
	    super(attrs_876, type_877 || "WhileStatement");
	    if (!{}.hasOwnProperty.call(attrs_876, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	  }
	  _reduceState(reducer_878, state_879 = {}) {
	    state_879.test = this.test instanceof Expression ? this.test.reduce(reducer_878) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_878, state_879);
	  }
	  _cloneAttrs() {
	    return Object.assign({ test: this.test }, super._cloneAttrs());
	  }
	  reduce(reducer_880) {
	    let state_881 = this._reduceState(reducer_880);
	    return reducer_880.reduceWhileStatement(this, state_881);
	  }
	  extend(attrs_882) {
	    return new WhileStatement(Object.assign(this._cloneAttrs(), attrs_882));
	  }
	}
	IterationStatement.CloneReducer.prototype.reduceWhileStatement = function (term_883, state_884) {
	  return new WhileStatement(state_884);
	};
	exports.WhileStatement = WhileStatement;

	class Pragma extends Term {
	  constructor(attrs_885, type_886) {
	    super(attrs_885, type_886 || "Pragma");
	    if (!{}.hasOwnProperty.call(attrs_885, "kind")) {
	      throw new Error("Missing attribute: " + "kind");
	    }
	    if (!{}.hasOwnProperty.call(attrs_885, "items")) {
	      throw new Error("Missing attribute: " + "items");
	    }
	  }
	  _reduceState(reducer_887, state_888 = {}) {
	    state_888.kind = this.kind;
	    state_888.items = this.items;
	    ;
	    return super._reduceState(reducer_887, state_888);
	  }
	  _cloneAttrs() {
	    return Object.assign({ kind: this.kind, items: this.items }, super._cloneAttrs());
	  }
	  reduce(reducer_889) {
	    let state_890 = this._reduceState(reducer_889);
	    return reducer_889.reducePragma(this, state_890);
	  }
	  extend(attrs_891) {
	    return new Pragma(Object.assign(this._cloneAttrs(), attrs_891));
	  }
	}
	Term.CloneReducer.prototype.reducePragma = function (term_892, state_893) {
	  return new Pragma(state_893);
	};
	exports.Pragma = Pragma;

	class Block extends Term {
	  constructor(attrs_894, type_895) {
	    super(attrs_894, type_895 || "Block");
	    if (!{}.hasOwnProperty.call(attrs_894, "statements")) {
	      throw new Error("Missing attribute: " + "statements");
	    }
	  }
	  _reduceState(reducer_896, state_897 = {}) {
	    state_897.statements = this.statements.map(a_898 => a_898 instanceof Statement ? a_898.reduce(reducer_896) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_898));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_896, state_897);
	  }
	  _cloneAttrs() {
	    return Object.assign({ statements: this.statements }, super._cloneAttrs());
	  }
	  reduce(reducer_899) {
	    let state_900 = this._reduceState(reducer_899);
	    return reducer_899.reduceBlock(this, state_900);
	  }
	  extend(attrs_901) {
	    return new Block(Object.assign(this._cloneAttrs(), attrs_901));
	  }
	}
	Term.CloneReducer.prototype.reduceBlock = function (term_902, state_903) {
	  return new Block(state_903);
	};
	exports.Block = Block;

	class CatchClause extends Term {
	  constructor(attrs_904, type_905) {
	    super(attrs_904, type_905 || "CatchClause");
	    if (!{}.hasOwnProperty.call(attrs_904, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_904, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_906, state_907 = {}) {
	    state_907.binding = this.binding instanceof ObjectBinding ? this.binding.reduce(reducer_906) : this.binding instanceof ArrayBinding ? this.binding.reduce(reducer_906) : this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_906) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_906) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_907.body = this.body instanceof Block ? this.body.reduce(reducer_906) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_906, state_907);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_908) {
	    let state_909 = this._reduceState(reducer_908);
	    return reducer_908.reduceCatchClause(this, state_909);
	  }
	  extend(attrs_910) {
	    return new CatchClause(Object.assign(this._cloneAttrs(), attrs_910));
	  }
	}
	Term.CloneReducer.prototype.reduceCatchClause = function (term_911, state_912) {
	  return new CatchClause(state_912);
	};
	exports.CatchClause = CatchClause;

	class Directive extends Term {
	  constructor(attrs_913, type_914) {
	    super(attrs_913, type_914 || "Directive");
	    if (!{}.hasOwnProperty.call(attrs_913, "rawValue")) {
	      throw new Error("Missing attribute: " + "rawValue");
	    }
	  }
	  _reduceState(reducer_915, state_916 = {}) {
	    state_916.rawValue = this.rawValue;
	    ;
	    return super._reduceState(reducer_915, state_916);
	  }
	  _cloneAttrs() {
	    return Object.assign({ rawValue: this.rawValue }, super._cloneAttrs());
	  }
	  reduce(reducer_917) {
	    let state_918 = this._reduceState(reducer_917);
	    return reducer_917.reduceDirective(this, state_918);
	  }
	  extend(attrs_919) {
	    return new Directive(Object.assign(this._cloneAttrs(), attrs_919));
	  }
	}
	Term.CloneReducer.prototype.reduceDirective = function (term_920, state_921) {
	  return new Directive(state_921);
	};
	exports.Directive = Directive;

	class FormalParameters extends Term {
	  constructor(attrs_922, type_923) {
	    super(attrs_922, type_923 || "FormalParameters");
	    if (!{}.hasOwnProperty.call(attrs_922, "items")) {
	      throw new Error("Missing attribute: " + "items");
	    }
	    if (!{}.hasOwnProperty.call(attrs_922, "rest")) {
	      throw new Error("Missing attribute: " + "rest");
	    }
	  }
	  _reduceState(reducer_924, state_925 = {}) {
	    state_925.items = this.items.map(a_926 => a_926 instanceof ObjectBinding ? a_926.reduce(reducer_924) : a_926 instanceof ArrayBinding ? a_926.reduce(reducer_924) : a_926 instanceof BindingIdentifier ? a_926.reduce(reducer_924) : a_926 instanceof MemberExpression ? a_926.reduce(reducer_924) : a_926 instanceof BindingWithDefault ? a_926.reduce(reducer_924) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_926));
	    }.call(this));
	    state_925.rest = this.rest == null ? null : this.rest instanceof BindingIdentifier ? this.rest.reduce(reducer_924) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.rest));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_924, state_925);
	  }
	  _cloneAttrs() {
	    return Object.assign({ items: this.items, rest: this.rest }, super._cloneAttrs());
	  }
	  reduce(reducer_927) {
	    let state_928 = this._reduceState(reducer_927);
	    return reducer_927.reduceFormalParameters(this, state_928);
	  }
	  extend(attrs_929) {
	    return new FormalParameters(Object.assign(this._cloneAttrs(), attrs_929));
	  }
	}
	Term.CloneReducer.prototype.reduceFormalParameters = function (term_930, state_931) {
	  return new FormalParameters(state_931);
	};
	exports.FormalParameters = FormalParameters;

	class FunctionBody extends Term {
	  constructor(attrs_932, type_933) {
	    super(attrs_932, type_933 || "FunctionBody");
	    if (!{}.hasOwnProperty.call(attrs_932, "directives")) {
	      throw new Error("Missing attribute: " + "directives");
	    }
	    if (!{}.hasOwnProperty.call(attrs_932, "statements")) {
	      throw new Error("Missing attribute: " + "statements");
	    }
	  }
	  _reduceState(reducer_934, state_935 = {}) {
	    state_935.directives = this.directives.map(a_936 => a_936);
	    state_935.statements = this.statements.map(a_937 => a_937 instanceof Statement ? a_937.reduce(reducer_934) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_937));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_934, state_935);
	  }
	  _cloneAttrs() {
	    return Object.assign({ directives: this.directives, statements: this.statements }, super._cloneAttrs());
	  }
	  reduce(reducer_938) {
	    let state_939 = this._reduceState(reducer_938);
	    return reducer_938.reduceFunctionBody(this, state_939);
	  }
	  extend(attrs_940) {
	    return new FunctionBody(Object.assign(this._cloneAttrs(), attrs_940));
	  }
	}
	Term.CloneReducer.prototype.reduceFunctionBody = function (term_941, state_942) {
	  return new FunctionBody(state_942);
	};
	exports.FunctionBody = FunctionBody;

	class FunctionDeclaration extends Statement {
	  constructor(attrs_943, type_944) {
	    super(attrs_943, type_944 || "FunctionDeclaration");
	    if (!{}.hasOwnProperty.call(attrs_943, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_943, "isGenerator")) {
	      throw new Error("Missing attribute: " + "isGenerator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_943, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_943, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_945, state_946 = {}) {
	    state_946.name = this.name instanceof BindingIdentifier ? this.name.reduce(reducer_945) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_946.isGenerator = this.isGenerator;
	    state_946.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_945) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_946.body = this.body instanceof FunctionBody ? this.body.reduce(reducer_945) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.body));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_945, state_946);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, isGenerator: this.isGenerator, params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_947) {
	    let state_948 = this._reduceState(reducer_947);
	    return reducer_947.reduceFunctionDeclaration(this, state_948);
	  }
	  extend(attrs_949) {
	    return new FunctionDeclaration(Object.assign(this._cloneAttrs(), attrs_949));
	  }
	}
	Statement.CloneReducer.prototype.reduceFunctionDeclaration = function (term_950, state_951) {
	  return new FunctionDeclaration(state_951);
	};
	exports.FunctionDeclaration = FunctionDeclaration;

	class FunctionDeclarationE extends Statement {
	  constructor(attrs_952, type_953) {
	    super(attrs_952, type_953 || "FunctionDeclarationE");
	    if (!{}.hasOwnProperty.call(attrs_952, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_952, "isGenerator")) {
	      throw new Error("Missing attribute: " + "isGenerator");
	    }
	    if (!{}.hasOwnProperty.call(attrs_952, "params")) {
	      throw new Error("Missing attribute: " + "params");
	    }
	    if (!{}.hasOwnProperty.call(attrs_952, "body")) {
	      throw new Error("Missing attribute: " + "body");
	    }
	  }
	  _reduceState(reducer_954, state_955 = {}) {
	    state_955.name = this.name instanceof BindingIdentifier ? this.name.reduce(reducer_954) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.name));
	    }.call(this);
	    state_955.isGenerator = this.isGenerator;
	    state_955.params = this.params instanceof FormalParameters ? this.params.reduce(reducer_954) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.params));
	    }.call(this);
	    state_955.body = this.body.map(a_956 => a_956 instanceof Term ? a_956.reduce(reducer_954) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_956));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_954, state_955);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, isGenerator: this.isGenerator, params: this.params, body: this.body }, super._cloneAttrs());
	  }
	  reduce(reducer_957) {
	    let state_958 = this._reduceState(reducer_957);
	    return reducer_957.reduceFunctionDeclarationE(this, state_958);
	  }
	  extend(attrs_959) {
	    return new FunctionDeclarationE(Object.assign(this._cloneAttrs(), attrs_959));
	  }
	}
	Statement.CloneReducer.prototype.reduceFunctionDeclarationE = function (term_960, state_961) {
	  return new FunctionDeclarationE(state_961);
	};
	exports.FunctionDeclarationE = FunctionDeclarationE;

	class Script extends Term {
	  constructor(attrs_962, type_963) {
	    super(attrs_962, type_963 || "Script");
	    if (!{}.hasOwnProperty.call(attrs_962, "directives")) {
	      throw new Error("Missing attribute: " + "directives");
	    }
	    if (!{}.hasOwnProperty.call(attrs_962, "statements")) {
	      throw new Error("Missing attribute: " + "statements");
	    }
	  }
	  _reduceState(reducer_964, state_965 = {}) {
	    state_965.directives = this.directives.map(a_966 => a_966);
	    state_965.statements = this.statements.map(a_967 => a_967 instanceof Statement ? a_967.reduce(reducer_964) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_967));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_964, state_965);
	  }
	  _cloneAttrs() {
	    return Object.assign({ directives: this.directives, statements: this.statements }, super._cloneAttrs());
	  }
	  reduce(reducer_968) {
	    let state_969 = this._reduceState(reducer_968);
	    return reducer_968.reduceScript(this, state_969);
	  }
	  extend(attrs_970) {
	    return new Script(Object.assign(this._cloneAttrs(), attrs_970));
	  }
	}
	Term.CloneReducer.prototype.reduceScript = function (term_971, state_972) {
	  return new Script(state_972);
	};
	exports.Script = Script;

	class SpreadElement extends Term {
	  constructor(attrs_973, type_974) {
	    super(attrs_973, type_974 || "SpreadElement");
	    if (!{}.hasOwnProperty.call(attrs_973, "expression")) {
	      throw new Error("Missing attribute: " + "expression");
	    }
	  }
	  _reduceState(reducer_975, state_976 = {}) {
	    state_976.expression = this.expression instanceof Expression ? this.expression.reduce(reducer_975) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.expression));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_975, state_976);
	  }
	  _cloneAttrs() {
	    return Object.assign({ expression: this.expression }, super._cloneAttrs());
	  }
	  reduce(reducer_977) {
	    let state_978 = this._reduceState(reducer_977);
	    return reducer_977.reduceSpreadElement(this, state_978);
	  }
	  extend(attrs_979) {
	    return new SpreadElement(Object.assign(this._cloneAttrs(), attrs_979));
	  }
	}
	Term.CloneReducer.prototype.reduceSpreadElement = function (term_980, state_981) {
	  return new SpreadElement(state_981);
	};
	exports.SpreadElement = SpreadElement;

	class Super extends Term {
	  constructor(attrs_982, type_983) {
	    super(attrs_982, type_983 || "Super");
	  }
	  _reduceState(reducer_984, state_985 = {}) {
	    ;
	    return super._reduceState(reducer_984, state_985);
	  }
	  _cloneAttrs() {
	    return Object.assign({}, super._cloneAttrs());
	  }
	  reduce(reducer_986) {
	    let state_987 = this._reduceState(reducer_986);
	    return reducer_986.reduceSuper(this, state_987);
	  }
	  extend(attrs_988) {
	    return new Super(Object.assign(this._cloneAttrs(), attrs_988));
	  }
	}
	Term.CloneReducer.prototype.reduceSuper = function (term_989, state_990) {
	  return new Super(state_990);
	};
	exports.Super = Super;

	class SwitchCase extends Term {
	  constructor(attrs_991, type_992) {
	    super(attrs_991, type_992 || "SwitchCase");
	    if (!{}.hasOwnProperty.call(attrs_991, "test")) {
	      throw new Error("Missing attribute: " + "test");
	    }
	    if (!{}.hasOwnProperty.call(attrs_991, "consequent")) {
	      throw new Error("Missing attribute: " + "consequent");
	    }
	  }
	  _reduceState(reducer_993, state_994 = {}) {
	    state_994.test = this.test instanceof Expression ? this.test.reduce(reducer_993) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.test));
	    }.call(this);
	    state_994.consequent = this.consequent.map(a_995 => a_995 instanceof Statement ? a_995.reduce(reducer_993) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_995));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_993, state_994);
	  }
	  _cloneAttrs() {
	    return Object.assign({ test: this.test, consequent: this.consequent }, super._cloneAttrs());
	  }
	  reduce(reducer_996) {
	    let state_997 = this._reduceState(reducer_996);
	    return reducer_996.reduceSwitchCase(this, state_997);
	  }
	  extend(attrs_998) {
	    return new SwitchCase(Object.assign(this._cloneAttrs(), attrs_998));
	  }
	}
	Term.CloneReducer.prototype.reduceSwitchCase = function (term_999, state_1000) {
	  return new SwitchCase(state_1000);
	};
	exports.SwitchCase = SwitchCase;

	class SwitchDefault extends Term {
	  constructor(attrs_1001, type_1002) {
	    super(attrs_1001, type_1002 || "SwitchDefault");
	    if (!{}.hasOwnProperty.call(attrs_1001, "consequent")) {
	      throw new Error("Missing attribute: " + "consequent");
	    }
	  }
	  _reduceState(reducer_1003, state_1004 = {}) {
	    state_1004.consequent = this.consequent.map(a_1005 => a_1005 instanceof Statement ? a_1005.reduce(reducer_1003) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_1005));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_1003, state_1004);
	  }
	  _cloneAttrs() {
	    return Object.assign({ consequent: this.consequent }, super._cloneAttrs());
	  }
	  reduce(reducer_1006) {
	    let state_1007 = this._reduceState(reducer_1006);
	    return reducer_1006.reduceSwitchDefault(this, state_1007);
	  }
	  extend(attrs_1008) {
	    return new SwitchDefault(Object.assign(this._cloneAttrs(), attrs_1008));
	  }
	}
	Term.CloneReducer.prototype.reduceSwitchDefault = function (term_1009, state_1010) {
	  return new SwitchDefault(state_1010);
	};
	exports.SwitchDefault = SwitchDefault;

	class TemplateElement extends Term {
	  constructor(attrs_1011, type_1012) {
	    super(attrs_1011, type_1012 || "TemplateElement");
	    if (!{}.hasOwnProperty.call(attrs_1011, "rawValue")) {
	      throw new Error("Missing attribute: " + "rawValue");
	    }
	  }
	  _reduceState(reducer_1013, state_1014 = {}) {
	    state_1014.rawValue = this.rawValue;
	    ;
	    return super._reduceState(reducer_1013, state_1014);
	  }
	  _cloneAttrs() {
	    return Object.assign({ rawValue: this.rawValue }, super._cloneAttrs());
	  }
	  reduce(reducer_1015) {
	    let state_1016 = this._reduceState(reducer_1015);
	    return reducer_1015.reduceTemplateElement(this, state_1016);
	  }
	  extend(attrs_1017) {
	    return new TemplateElement(Object.assign(this._cloneAttrs(), attrs_1017));
	  }
	}
	Term.CloneReducer.prototype.reduceTemplateElement = function (term_1018, state_1019) {
	  return new TemplateElement(state_1019);
	};
	exports.TemplateElement = TemplateElement;

	class SyntaxTemplate extends Expression {
	  constructor(attrs_1020, type_1021) {
	    super(attrs_1020, type_1021 || "SyntaxTemplate");
	    if (!{}.hasOwnProperty.call(attrs_1020, "template")) {
	      throw new Error("Missing attribute: " + "template");
	    }
	  }
	  _reduceState(reducer_1022, state_1023 = {}) {
	    state_1023.template = this.template.map(a_1024 => a_1024 instanceof SyntaxTerm ? a_1024.reduce(reducer_1022) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_1024));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_1022, state_1023);
	  }
	  _cloneAttrs() {
	    return Object.assign({ template: this.template }, super._cloneAttrs());
	  }
	  reduce(reducer_1025) {
	    let state_1026 = this._reduceState(reducer_1025);
	    return reducer_1025.reduceSyntaxTemplate(this, state_1026);
	  }
	  extend(attrs_1027) {
	    return new SyntaxTemplate(Object.assign(this._cloneAttrs(), attrs_1027));
	  }
	}
	Expression.CloneReducer.prototype.reduceSyntaxTemplate = function (term_1028, state_1029) {
	  return new SyntaxTemplate(state_1029);
	};
	exports.SyntaxTemplate = SyntaxTemplate;

	class SyntaxQuote extends Term {
	  constructor(attrs_1030, type_1031) {
	    super(attrs_1030, type_1031 || "SyntaxQuote");
	    if (!{}.hasOwnProperty.call(attrs_1030, "name")) {
	      throw new Error("Missing attribute: " + "name");
	    }
	    if (!{}.hasOwnProperty.call(attrs_1030, "template")) {
	      throw new Error("Missing attribute: " + "template");
	    }
	  }
	  _reduceState(reducer_1032, state_1033 = {}) {
	    state_1033.name = this.name;
	    state_1033.template = this.template;
	    ;
	    return super._reduceState(reducer_1032, state_1033);
	  }
	  _cloneAttrs() {
	    return Object.assign({ name: this.name, template: this.template }, super._cloneAttrs());
	  }
	  reduce(reducer_1034) {
	    let state_1035 = this._reduceState(reducer_1034);
	    return reducer_1034.reduceSyntaxQuote(this, state_1035);
	  }
	  extend(attrs_1036) {
	    return new SyntaxQuote(Object.assign(this._cloneAttrs(), attrs_1036));
	  }
	}
	Term.CloneReducer.prototype.reduceSyntaxQuote = function (term_1037, state_1038) {
	  return new SyntaxQuote(state_1038);
	};
	exports.SyntaxQuote = SyntaxQuote;

	class VariableDeclaration extends Term {
	  constructor(attrs_1039, type_1040) {
	    super(attrs_1039, type_1040 || "VariableDeclaration");
	    if (!{}.hasOwnProperty.call(attrs_1039, "kind")) {
	      throw new Error("Missing attribute: " + "kind");
	    }
	    if (!{}.hasOwnProperty.call(attrs_1039, "declarators")) {
	      throw new Error("Missing attribute: " + "declarators");
	    }
	  }
	  _reduceState(reducer_1041, state_1042 = {}) {
	    state_1042.kind = this.kind;
	    state_1042.declarators = this.declarators.map(a_1043 => a_1043 instanceof VariableDeclarator ? a_1043.reduce(reducer_1041) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(a_1043));
	    }.call(this));
	    ;
	    return super._reduceState(reducer_1041, state_1042);
	  }
	  _cloneAttrs() {
	    return Object.assign({ kind: this.kind, declarators: this.declarators }, super._cloneAttrs());
	  }
	  reduce(reducer_1044) {
	    let state_1045 = this._reduceState(reducer_1044);
	    return reducer_1044.reduceVariableDeclaration(this, state_1045);
	  }
	  extend(attrs_1046) {
	    return new VariableDeclaration(Object.assign(this._cloneAttrs(), attrs_1046));
	  }
	}
	Term.CloneReducer.prototype.reduceVariableDeclaration = function (term_1047, state_1048) {
	  return new VariableDeclaration(state_1048);
	};
	exports.VariableDeclaration = VariableDeclaration;

	class VariableDeclarator extends Term {
	  constructor(attrs_1049, type_1050) {
	    super(attrs_1049, type_1050 || "VariableDeclarator");
	    if (!{}.hasOwnProperty.call(attrs_1049, "binding")) {
	      throw new Error("Missing attribute: " + "binding");
	    }
	    if (!{}.hasOwnProperty.call(attrs_1049, "init")) {
	      throw new Error("Missing attribute: " + "init");
	    }
	  }
	  _reduceState(reducer_1051, state_1052 = {}) {
	    state_1052.binding = this.binding instanceof ObjectBinding ? this.binding.reduce(reducer_1051) : this.binding instanceof ArrayBinding ? this.binding.reduce(reducer_1051) : this.binding instanceof BindingIdentifier ? this.binding.reduce(reducer_1051) : this.binding instanceof MemberExpression ? this.binding.reduce(reducer_1051) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.binding));
	    }.call(this);
	    state_1052.init = this.init == null ? null : this.init instanceof Expression ? this.init.reduce(reducer_1051) : function () {
	      throw new Error("Unknown object: " + JSON.stringify(this.init));
	    }.call(this);
	    ;
	    return super._reduceState(reducer_1051, state_1052);
	  }
	  _cloneAttrs() {
	    return Object.assign({ binding: this.binding, init: this.init }, super._cloneAttrs());
	  }
	  reduce(reducer_1053) {
	    let state_1054 = this._reduceState(reducer_1053);
	    return reducer_1053.reduceVariableDeclarator(this, state_1054);
	  }
	  extend(attrs_1055) {
	    return new VariableDeclarator(Object.assign(this._cloneAttrs(), attrs_1055));
	  }
	}
	Term.CloneReducer.prototype.reduceVariableDeclarator = function (term_1056, state_1057) {
	  return new VariableDeclarator(state_1057);
	};
	exports.VariableDeclarator = VariableDeclarator;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2J1aWxkL3Rlcm0tc3BlYy5qcyJdLCJuYW1lcyI6WyJUZXJtIiwiY29uc3RydWN0b3IiLCJhdHRyc182MyIsInR5cGVfNjQiLCJPYmplY3QiLCJhc3NpZ24iLCJ0eXBlIiwibG9jIiwiZnJlZXplIiwiX3JlZHVjZVN0YXRlIiwicmVkdWNlcl82NSIsInN0YXRlXzY2IiwiX2Nsb25lQXR0cnMiLCJyZWR1Y2UiLCJyZWR1Y2VyXzY3Iiwic3RhdGVfNjgiLCJyZWR1Y2VUZXJtIiwiZXh0ZW5kIiwiYXR0cnNfNjkiLCJmcm9tIiwidHlwZV83MCIsInZhbHVlXzcxIiwidmFsdWUiLCJFcnJvciIsImZyb21OdWxsIiwiZnJvbU51bWJlciIsInZhbHVlXzcyIiwiZnJvbVN0cmluZyIsInZhbHVlXzczIiwiZnJvbVB1bmN0dWF0b3IiLCJ2YWx1ZV83NCIsImZyb21LZXl3b3JkIiwidmFsdWVfNzUiLCJmcm9tSWRlbnRpZmllciIsInZhbHVlXzc2IiwiZnJvbVJlZ3VsYXJFeHByZXNzaW9uIiwidmFsdWVfNzciLCJmcm9tQnJhY2VzIiwiaW5uZXJfNzgiLCJmcm9tQnJhY2tldHMiLCJpbm5lcl83OSIsImZyb21QYXJlbnMiLCJpbm5lcl84MCIsIkNsb25lUmVkdWNlciIsInRlcm1fODEiLCJzdGF0ZV84MiIsIlN5bnRheFRlcm0iLCJhdHRyc184MyIsInR5cGVfODQiLCJyZWR1Y2VyXzg1Iiwic3RhdGVfODYiLCJyZWR1Y2VyXzg3Iiwic3RhdGVfODgiLCJyZWR1Y2VTeW50YXhUZXJtIiwiYXR0cnNfODkiLCJwcm90b3R5cGUiLCJ0ZXJtXzkwIiwic3RhdGVfOTEiLCJSYXdEZWxpbWl0ZXIiLCJhdHRyc185MiIsInR5cGVfOTMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyZWR1Y2VyXzk0Iiwic3RhdGVfOTUiLCJraW5kIiwiaW5uZXIiLCJtYXAiLCJhXzk2IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlZHVjZXJfOTciLCJzdGF0ZV85OCIsInJlZHVjZVJhd0RlbGltaXRlciIsImF0dHJzXzk5IiwidGVybV8xMDAiLCJzdGF0ZV8xMDEiLCJSYXdTeW50YXgiLCJhdHRyc18xMDIiLCJ0eXBlXzEwMyIsInJlZHVjZXJfMTA0Iiwic3RhdGVfMTA1IiwicmVkdWNlcl8xMDYiLCJzdGF0ZV8xMDciLCJyZWR1Y2VSYXdTeW50YXgiLCJhdHRyc18xMDgiLCJ0ZXJtXzEwOSIsInN0YXRlXzExMCIsIlN0YXRlbWVudCIsImF0dHJzXzExMSIsInR5cGVfMTEyIiwicmVkdWNlcl8xMTMiLCJzdGF0ZV8xMTQiLCJyZWR1Y2VyXzExNSIsInN0YXRlXzExNiIsInJlZHVjZVN0YXRlbWVudCIsImF0dHJzXzExNyIsInRlcm1fMTE4Iiwic3RhdGVfMTE5IiwiSXRlcmF0aW9uU3RhdGVtZW50IiwiYXR0cnNfMTIwIiwidHlwZV8xMjEiLCJyZWR1Y2VyXzEyMiIsInN0YXRlXzEyMyIsImJvZHkiLCJyZWR1Y2VyXzEyNCIsInN0YXRlXzEyNSIsInJlZHVjZUl0ZXJhdGlvblN0YXRlbWVudCIsImF0dHJzXzEyNiIsInRlcm1fMTI3Iiwic3RhdGVfMTI4IiwiRXhwcmVzc2lvbiIsImF0dHJzXzEyOSIsInR5cGVfMTMwIiwicmVkdWNlcl8xMzEiLCJzdGF0ZV8xMzIiLCJyZWR1Y2VyXzEzMyIsInN0YXRlXzEzNCIsInJlZHVjZUV4cHJlc3Npb24iLCJhdHRyc18xMzUiLCJ0ZXJtXzEzNiIsInN0YXRlXzEzNyIsIk1lbWJlckV4cHJlc3Npb24iLCJhdHRyc18xMzgiLCJ0eXBlXzEzOSIsInJlZHVjZXJfMTQwIiwic3RhdGVfMTQxIiwib2JqZWN0IiwiU3VwZXIiLCJyZWR1Y2VyXzE0MiIsInN0YXRlXzE0MyIsInJlZHVjZU1lbWJlckV4cHJlc3Npb24iLCJhdHRyc18xNDQiLCJ0ZXJtXzE0NSIsInN0YXRlXzE0NiIsIlByb3BlcnR5TmFtZSIsImF0dHJzXzE0NyIsInR5cGVfMTQ4IiwicmVkdWNlcl8xNDkiLCJzdGF0ZV8xNTAiLCJyZWR1Y2VyXzE1MSIsInN0YXRlXzE1MiIsInJlZHVjZVByb3BlcnR5TmFtZSIsImF0dHJzXzE1MyIsInRlcm1fMTU0Iiwic3RhdGVfMTU1IiwiT2JqZWN0UHJvcGVydHkiLCJhdHRyc18xNTYiLCJ0eXBlXzE1NyIsInJlZHVjZXJfMTU4Iiwic3RhdGVfMTU5IiwicmVkdWNlcl8xNjAiLCJzdGF0ZV8xNjEiLCJyZWR1Y2VPYmplY3RQcm9wZXJ0eSIsImF0dHJzXzE2MiIsInRlcm1fMTYzIiwic3RhdGVfMTY0IiwiTmFtZWRPYmplY3RQcm9wZXJ0eSIsImF0dHJzXzE2NSIsInR5cGVfMTY2IiwicmVkdWNlcl8xNjciLCJzdGF0ZV8xNjgiLCJuYW1lIiwicmVkdWNlcl8xNjkiLCJzdGF0ZV8xNzAiLCJyZWR1Y2VOYW1lZE9iamVjdFByb3BlcnR5IiwiYXR0cnNfMTcxIiwidGVybV8xNzIiLCJzdGF0ZV8xNzMiLCJNZXRob2REZWZpbml0aW9uIiwiYXR0cnNfMTc0IiwidHlwZV8xNzUiLCJyZWR1Y2VyXzE3NiIsInN0YXRlXzE3NyIsIkZ1bmN0aW9uQm9keSIsInJlZHVjZXJfMTc4Iiwic3RhdGVfMTc5IiwicmVkdWNlTWV0aG9kRGVmaW5pdGlvbiIsImF0dHJzXzE4MCIsInRlcm1fMTgxIiwic3RhdGVfMTgyIiwiQmluZGluZ1dpdGhEZWZhdWx0IiwiYXR0cnNfMTgzIiwidHlwZV8xODQiLCJyZWR1Y2VyXzE4NSIsInN0YXRlXzE4NiIsImJpbmRpbmciLCJPYmplY3RCaW5kaW5nIiwiQXJyYXlCaW5kaW5nIiwiQmluZGluZ0lkZW50aWZpZXIiLCJpbml0IiwicmVkdWNlcl8xODciLCJzdGF0ZV8xODgiLCJyZWR1Y2VCaW5kaW5nV2l0aERlZmF1bHQiLCJhdHRyc18xODkiLCJ0ZXJtXzE5MCIsInN0YXRlXzE5MSIsImF0dHJzXzE5MiIsInR5cGVfMTkzIiwicmVkdWNlcl8xOTQiLCJzdGF0ZV8xOTUiLCJyZWR1Y2VyXzE5NiIsInN0YXRlXzE5NyIsInJlZHVjZUJpbmRpbmdJZGVudGlmaWVyIiwiYXR0cnNfMTk4IiwidGVybV8xOTkiLCJzdGF0ZV8yMDAiLCJhdHRyc18yMDEiLCJ0eXBlXzIwMiIsInJlZHVjZXJfMjAzIiwic3RhdGVfMjA0IiwiZWxlbWVudHMiLCJhXzIwNSIsInJlc3RFbGVtZW50IiwicmVkdWNlcl8yMDYiLCJzdGF0ZV8yMDciLCJyZWR1Y2VBcnJheUJpbmRpbmciLCJhdHRyc18yMDgiLCJ0ZXJtXzIwOSIsInN0YXRlXzIxMCIsImF0dHJzXzIxMSIsInR5cGVfMjEyIiwicmVkdWNlcl8yMTMiLCJzdGF0ZV8yMTQiLCJwcm9wZXJ0aWVzIiwiYV8yMTUiLCJCaW5kaW5nUHJvcGVydHkiLCJyZWR1Y2VyXzIxNiIsInN0YXRlXzIxNyIsInJlZHVjZU9iamVjdEJpbmRpbmciLCJhdHRyc18yMTgiLCJ0ZXJtXzIxOSIsInN0YXRlXzIyMCIsImF0dHJzXzIyMSIsInR5cGVfMjIyIiwicmVkdWNlcl8yMjMiLCJzdGF0ZV8yMjQiLCJyZWR1Y2VyXzIyNSIsInN0YXRlXzIyNiIsInJlZHVjZUJpbmRpbmdQcm9wZXJ0eSIsImF0dHJzXzIyNyIsInRlcm1fMjI4Iiwic3RhdGVfMjI5IiwiQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllciIsImF0dHJzXzIzMCIsInR5cGVfMjMxIiwicmVkdWNlcl8yMzIiLCJzdGF0ZV8yMzMiLCJyZWR1Y2VyXzIzNCIsInN0YXRlXzIzNSIsInJlZHVjZUJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIiLCJhdHRyc18yMzYiLCJ0ZXJtXzIzNyIsInN0YXRlXzIzOCIsIkJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5IiwiYXR0cnNfMjM5IiwidHlwZV8yNDAiLCJyZWR1Y2VyXzI0MSIsInN0YXRlXzI0MiIsInJlZHVjZXJfMjQzIiwic3RhdGVfMjQ0IiwicmVkdWNlQmluZGluZ1Byb3BlcnR5UHJvcGVydHkiLCJhdHRyc18yNDUiLCJ0ZXJtXzI0NiIsInN0YXRlXzI0NyIsIkNsYXNzRXhwcmVzc2lvbiIsImF0dHJzXzI0OCIsInR5cGVfMjQ5IiwicmVkdWNlcl8yNTAiLCJzdGF0ZV8yNTEiLCJzdXBlciIsImFfMjUyIiwiQ2xhc3NFbGVtZW50IiwicmVkdWNlcl8yNTMiLCJzdGF0ZV8yNTQiLCJyZWR1Y2VDbGFzc0V4cHJlc3Npb24iLCJhdHRyc18yNTUiLCJ0ZXJtXzI1NiIsInN0YXRlXzI1NyIsIkNsYXNzRGVjbGFyYXRpb24iLCJhdHRyc18yNTgiLCJ0eXBlXzI1OSIsInJlZHVjZXJfMjYwIiwic3RhdGVfMjYxIiwiYV8yNjIiLCJyZWR1Y2VyXzI2MyIsInN0YXRlXzI2NCIsInJlZHVjZUNsYXNzRGVjbGFyYXRpb24iLCJhdHRyc18yNjUiLCJ0ZXJtXzI2NiIsInN0YXRlXzI2NyIsImF0dHJzXzI2OCIsInR5cGVfMjY5IiwicmVkdWNlcl8yNzAiLCJzdGF0ZV8yNzEiLCJpc1N0YXRpYyIsIm1ldGhvZCIsInJlZHVjZXJfMjcyIiwic3RhdGVfMjczIiwicmVkdWNlQ2xhc3NFbGVtZW50IiwiYXR0cnNfMjc0IiwidGVybV8yNzUiLCJzdGF0ZV8yNzYiLCJNb2R1bGUiLCJhdHRyc18yNzciLCJ0eXBlXzI3OCIsInJlZHVjZXJfMjc5Iiwic3RhdGVfMjgwIiwiZGlyZWN0aXZlcyIsImFfMjgxIiwiaXRlbXMiLCJhXzI4MiIsInJlZHVjZXJfMjgzIiwic3RhdGVfMjg0IiwicmVkdWNlTW9kdWxlIiwiYXR0cnNfMjg1IiwidGVybV8yODYiLCJzdGF0ZV8yODciLCJJbXBvcnQiLCJhdHRyc18yODgiLCJ0eXBlXzI4OSIsInJlZHVjZXJfMjkwIiwic3RhdGVfMjkxIiwibW9kdWxlU3BlY2lmaWVyIiwiZGVmYXVsdEJpbmRpbmciLCJuYW1lZEltcG9ydHMiLCJhXzI5MiIsIkltcG9ydFNwZWNpZmllciIsImZvclN5bnRheCIsInJlZHVjZXJfMjkzIiwic3RhdGVfMjk0IiwicmVkdWNlSW1wb3J0IiwiYXR0cnNfMjk1IiwidGVybV8yOTYiLCJzdGF0ZV8yOTciLCJJbXBvcnROYW1lc3BhY2UiLCJhdHRyc18yOTgiLCJ0eXBlXzI5OSIsInJlZHVjZXJfMzAwIiwic3RhdGVfMzAxIiwibmFtZXNwYWNlQmluZGluZyIsInJlZHVjZXJfMzAyIiwic3RhdGVfMzAzIiwicmVkdWNlSW1wb3J0TmFtZXNwYWNlIiwiYXR0cnNfMzA0IiwidGVybV8zMDUiLCJzdGF0ZV8zMDYiLCJhdHRyc18zMDciLCJ0eXBlXzMwOCIsInJlZHVjZXJfMzA5Iiwic3RhdGVfMzEwIiwicmVkdWNlcl8zMTEiLCJzdGF0ZV8zMTIiLCJyZWR1Y2VJbXBvcnRTcGVjaWZpZXIiLCJhdHRyc18zMTMiLCJ0ZXJtXzMxNCIsInN0YXRlXzMxNSIsIkV4cG9ydEFsbEZyb20iLCJhdHRyc18zMTYiLCJ0eXBlXzMxNyIsInJlZHVjZXJfMzE4Iiwic3RhdGVfMzE5IiwicmVkdWNlcl8zMjAiLCJzdGF0ZV8zMjEiLCJyZWR1Y2VFeHBvcnRBbGxGcm9tIiwiYXR0cnNfMzIyIiwidGVybV8zMjMiLCJzdGF0ZV8zMjQiLCJFeHBvcnRGcm9tIiwiYXR0cnNfMzI1IiwidHlwZV8zMjYiLCJyZWR1Y2VyXzMyNyIsInN0YXRlXzMyOCIsIm5hbWVkRXhwb3J0cyIsImFfMzI5IiwiRXhwb3J0U3BlY2lmaWVyIiwicmVkdWNlcl8zMzAiLCJzdGF0ZV8zMzEiLCJyZWR1Y2VFeHBvcnRGcm9tIiwiYXR0cnNfMzMyIiwidGVybV8zMzMiLCJzdGF0ZV8zMzQiLCJFeHBvcnQiLCJhdHRyc18zMzUiLCJ0eXBlXzMzNiIsInJlZHVjZXJfMzM3Iiwic3RhdGVfMzM4IiwiZGVjbGFyYXRpb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWNsYXJhdGlvbiIsInJlZHVjZXJfMzM5Iiwic3RhdGVfMzQwIiwicmVkdWNlRXhwb3J0IiwiYXR0cnNfMzQxIiwidGVybV8zNDIiLCJzdGF0ZV8zNDMiLCJFeHBvcnREZWZhdWx0IiwiYXR0cnNfMzQ0IiwidHlwZV8zNDUiLCJyZWR1Y2VyXzM0NiIsInN0YXRlXzM0NyIsInJlZHVjZXJfMzQ4Iiwic3RhdGVfMzQ5IiwicmVkdWNlRXhwb3J0RGVmYXVsdCIsImF0dHJzXzM1MCIsInRlcm1fMzUxIiwic3RhdGVfMzUyIiwiYXR0cnNfMzUzIiwidHlwZV8zNTQiLCJyZWR1Y2VyXzM1NSIsInN0YXRlXzM1NiIsImV4cG9ydGVkTmFtZSIsInJlZHVjZXJfMzU3Iiwic3RhdGVfMzU4IiwicmVkdWNlRXhwb3J0U3BlY2lmaWVyIiwiYXR0cnNfMzU5IiwidGVybV8zNjAiLCJzdGF0ZV8zNjEiLCJNZXRob2QiLCJhdHRyc18zNjIiLCJ0eXBlXzM2MyIsInJlZHVjZXJfMzY0Iiwic3RhdGVfMzY1IiwiaXNHZW5lcmF0b3IiLCJwYXJhbXMiLCJGb3JtYWxQYXJhbWV0ZXJzIiwicmVkdWNlcl8zNjYiLCJzdGF0ZV8zNjciLCJyZWR1Y2VNZXRob2QiLCJhdHRyc18zNjgiLCJ0ZXJtXzM2OSIsInN0YXRlXzM3MCIsIkdldHRlciIsImF0dHJzXzM3MSIsInR5cGVfMzcyIiwicmVkdWNlcl8zNzMiLCJzdGF0ZV8zNzQiLCJyZWR1Y2VyXzM3NSIsInN0YXRlXzM3NiIsInJlZHVjZUdldHRlciIsImF0dHJzXzM3NyIsInRlcm1fMzc4Iiwic3RhdGVfMzc5IiwiU2V0dGVyIiwiYXR0cnNfMzgwIiwidHlwZV8zODEiLCJyZWR1Y2VyXzM4MiIsInN0YXRlXzM4MyIsInBhcmFtIiwicmVkdWNlcl8zODQiLCJzdGF0ZV8zODUiLCJyZWR1Y2VTZXR0ZXIiLCJhdHRyc18zODYiLCJ0ZXJtXzM4NyIsInN0YXRlXzM4OCIsIkRhdGFQcm9wZXJ0eSIsImF0dHJzXzM4OSIsInR5cGVfMzkwIiwicmVkdWNlcl8zOTEiLCJzdGF0ZV8zOTIiLCJleHByZXNzaW9uIiwicmVkdWNlcl8zOTMiLCJzdGF0ZV8zOTQiLCJyZWR1Y2VEYXRhUHJvcGVydHkiLCJhdHRyc18zOTUiLCJ0ZXJtXzM5NiIsInN0YXRlXzM5NyIsIlNob3J0aGFuZFByb3BlcnR5IiwiYXR0cnNfMzk4IiwidHlwZV8zOTkiLCJyZWR1Y2VyXzQwMCIsInN0YXRlXzQwMSIsInJlZHVjZXJfNDAyIiwic3RhdGVfNDAzIiwicmVkdWNlU2hvcnRoYW5kUHJvcGVydHkiLCJhdHRyc180MDQiLCJ0ZXJtXzQwNSIsInN0YXRlXzQwNiIsIlN0YXRpY1Byb3BlcnR5TmFtZSIsImF0dHJzXzQwNyIsInR5cGVfNDA4IiwicmVkdWNlcl80MDkiLCJzdGF0ZV80MTAiLCJyZWR1Y2VyXzQxMSIsInN0YXRlXzQxMiIsInJlZHVjZVN0YXRpY1Byb3BlcnR5TmFtZSIsImF0dHJzXzQxMyIsInRlcm1fNDE0Iiwic3RhdGVfNDE1IiwiQ29tcHV0ZWRQcm9wZXJ0eU5hbWUiLCJhdHRyc180MTYiLCJ0eXBlXzQxNyIsInJlZHVjZXJfNDE4Iiwic3RhdGVfNDE5IiwicmVkdWNlcl80MjAiLCJzdGF0ZV80MjEiLCJyZWR1Y2VDb21wdXRlZFByb3BlcnR5TmFtZSIsImF0dHJzXzQyMiIsInRlcm1fNDIzIiwic3RhdGVfNDI0IiwiTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uIiwiYXR0cnNfNDI1IiwidHlwZV80MjYiLCJyZWR1Y2VyXzQyNyIsInN0YXRlXzQyOCIsInJlZHVjZXJfNDI5Iiwic3RhdGVfNDMwIiwicmVkdWNlTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uIiwiYXR0cnNfNDMxIiwidGVybV80MzIiLCJzdGF0ZV80MzMiLCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uIiwiYXR0cnNfNDM0IiwidHlwZV80MzUiLCJyZWR1Y2VyXzQzNiIsInN0YXRlXzQzNyIsInJlZHVjZXJfNDM4Iiwic3RhdGVfNDM5IiwicmVkdWNlTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbiIsImF0dHJzXzQ0MCIsInRlcm1fNDQxIiwic3RhdGVfNDQyIiwiTGl0ZXJhbE51bGxFeHByZXNzaW9uIiwiYXR0cnNfNDQzIiwidHlwZV80NDQiLCJyZWR1Y2VyXzQ0NSIsInN0YXRlXzQ0NiIsInJlZHVjZXJfNDQ3Iiwic3RhdGVfNDQ4IiwicmVkdWNlTGl0ZXJhbE51bGxFeHByZXNzaW9uIiwiYXR0cnNfNDQ5IiwidGVybV80NTAiLCJzdGF0ZV80NTEiLCJMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24iLCJhdHRyc180NTIiLCJ0eXBlXzQ1MyIsInJlZHVjZXJfNDU0Iiwic3RhdGVfNDU1IiwicmVkdWNlcl80NTYiLCJzdGF0ZV80NTciLCJyZWR1Y2VMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24iLCJhdHRyc180NTgiLCJ0ZXJtXzQ1OSIsInN0YXRlXzQ2MCIsIkxpdGVyYWxSZWdFeHBFeHByZXNzaW9uIiwiYXR0cnNfNDYxIiwidHlwZV80NjIiLCJyZWR1Y2VyXzQ2MyIsInN0YXRlXzQ2NCIsInBhdHRlcm4iLCJmbGFncyIsInJlZHVjZXJfNDY1Iiwic3RhdGVfNDY2IiwicmVkdWNlTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb24iLCJhdHRyc180NjciLCJ0ZXJtXzQ2OCIsInN0YXRlXzQ2OSIsIkxpdGVyYWxTdHJpbmdFeHByZXNzaW9uIiwiYXR0cnNfNDcwIiwidHlwZV80NzEiLCJyZWR1Y2VyXzQ3MiIsInN0YXRlXzQ3MyIsInJlZHVjZXJfNDc0Iiwic3RhdGVfNDc1IiwicmVkdWNlTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24iLCJhdHRyc180NzYiLCJ0ZXJtXzQ3NyIsInN0YXRlXzQ3OCIsIkFycmF5RXhwcmVzc2lvbiIsImF0dHJzXzQ3OSIsInR5cGVfNDgwIiwicmVkdWNlcl80ODEiLCJzdGF0ZV80ODIiLCJhXzQ4MyIsIlNwcmVhZEVsZW1lbnQiLCJyZWR1Y2VyXzQ4NCIsInN0YXRlXzQ4NSIsInJlZHVjZUFycmF5RXhwcmVzc2lvbiIsImF0dHJzXzQ4NiIsInRlcm1fNDg3Iiwic3RhdGVfNDg4IiwiQXJyb3dFeHByZXNzaW9uIiwiYXR0cnNfNDg5IiwidHlwZV80OTAiLCJyZWR1Y2VyXzQ5MSIsInN0YXRlXzQ5MiIsInJlZHVjZXJfNDkzIiwic3RhdGVfNDk0IiwicmVkdWNlQXJyb3dFeHByZXNzaW9uIiwiYXR0cnNfNDk1IiwidGVybV80OTYiLCJzdGF0ZV80OTciLCJBcnJvd0V4cHJlc3Npb25FIiwiYXR0cnNfNDk4IiwidHlwZV80OTkiLCJyZWR1Y2VyXzUwMCIsInN0YXRlXzUwMSIsImFfNTAyIiwicmVkdWNlcl81MDMiLCJzdGF0ZV81MDQiLCJyZWR1Y2VBcnJvd0V4cHJlc3Npb25FIiwiYXR0cnNfNTA1IiwidGVybV81MDYiLCJzdGF0ZV81MDciLCJBc3NpZ25tZW50RXhwcmVzc2lvbiIsImF0dHJzXzUwOCIsInR5cGVfNTA5IiwicmVkdWNlcl81MTAiLCJzdGF0ZV81MTEiLCJyZWR1Y2VyXzUxMiIsInN0YXRlXzUxMyIsInJlZHVjZUFzc2lnbm1lbnRFeHByZXNzaW9uIiwiYXR0cnNfNTE0IiwidGVybV81MTUiLCJzdGF0ZV81MTYiLCJCaW5hcnlFeHByZXNzaW9uIiwiYXR0cnNfNTE3IiwidHlwZV81MTgiLCJyZWR1Y2VyXzUxOSIsInN0YXRlXzUyMCIsIm9wZXJhdG9yIiwibGVmdCIsInJpZ2h0IiwicmVkdWNlcl81MjEiLCJzdGF0ZV81MjIiLCJyZWR1Y2VCaW5hcnlFeHByZXNzaW9uIiwiYXR0cnNfNTIzIiwidGVybV81MjQiLCJzdGF0ZV81MjUiLCJDYWxsRXhwcmVzc2lvbiIsImF0dHJzXzUyNiIsInR5cGVfNTI3IiwicmVkdWNlcl81MjgiLCJzdGF0ZV81MjkiLCJjYWxsZWUiLCJhcmd1bWVudHMiLCJhXzUzMCIsInJlZHVjZXJfNTMxIiwic3RhdGVfNTMyIiwicmVkdWNlQ2FsbEV4cHJlc3Npb24iLCJhdHRyc181MzMiLCJ0ZXJtXzUzNCIsInN0YXRlXzUzNSIsIkNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24iLCJhdHRyc181MzYiLCJ0eXBlXzUzNyIsInJlZHVjZXJfNTM4Iiwic3RhdGVfNTM5IiwicmVkdWNlcl81NDAiLCJzdGF0ZV81NDEiLCJyZWR1Y2VDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uIiwiYXR0cnNfNTQyIiwidGVybV81NDMiLCJzdGF0ZV81NDQiLCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb24iLCJhdHRyc181NDUiLCJ0eXBlXzU0NiIsInJlZHVjZXJfNTQ3Iiwic3RhdGVfNTQ4IiwicmVkdWNlcl81NDkiLCJzdGF0ZV81NTAiLCJyZWR1Y2VDb21wdXRlZE1lbWJlckV4cHJlc3Npb24iLCJhdHRyc181NTEiLCJ0ZXJtXzU1MiIsInN0YXRlXzU1MyIsIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImF0dHJzXzU1NCIsInR5cGVfNTU1IiwicmVkdWNlcl81NTYiLCJzdGF0ZV81NTciLCJ0ZXN0IiwiY29uc2VxdWVudCIsImFsdGVybmF0ZSIsInJlZHVjZXJfNTU4Iiwic3RhdGVfNTU5IiwicmVkdWNlQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiYXR0cnNfNTYwIiwidGVybV81NjEiLCJzdGF0ZV81NjIiLCJGdW5jdGlvbkV4cHJlc3Npb24iLCJhdHRyc181NjMiLCJ0eXBlXzU2NCIsInJlZHVjZXJfNTY1Iiwic3RhdGVfNTY2IiwicmVkdWNlcl81NjciLCJzdGF0ZV81NjgiLCJyZWR1Y2VGdW5jdGlvbkV4cHJlc3Npb24iLCJhdHRyc181NjkiLCJ0ZXJtXzU3MCIsInN0YXRlXzU3MSIsIkZ1bmN0aW9uRXhwcmVzc2lvbkUiLCJhdHRyc181NzIiLCJ0eXBlXzU3MyIsInJlZHVjZXJfNTc0Iiwic3RhdGVfNTc1IiwiYV81NzYiLCJyZWR1Y2VyXzU3NyIsInN0YXRlXzU3OCIsInJlZHVjZUZ1bmN0aW9uRXhwcmVzc2lvbkUiLCJhdHRyc181NzkiLCJ0ZXJtXzU4MCIsInN0YXRlXzU4MSIsIklkZW50aWZpZXJFeHByZXNzaW9uIiwiYXR0cnNfNTgyIiwidHlwZV81ODMiLCJyZWR1Y2VyXzU4NCIsInN0YXRlXzU4NSIsInJlZHVjZXJfNTg2Iiwic3RhdGVfNTg3IiwicmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24iLCJhdHRyc181ODgiLCJ0ZXJtXzU4OSIsInN0YXRlXzU5MCIsIk5ld0V4cHJlc3Npb24iLCJhdHRyc181OTEiLCJ0eXBlXzU5MiIsInJlZHVjZXJfNTkzIiwic3RhdGVfNTk0IiwiYV81OTUiLCJyZWR1Y2VyXzU5NiIsInN0YXRlXzU5NyIsInJlZHVjZU5ld0V4cHJlc3Npb24iLCJhdHRyc181OTgiLCJ0ZXJtXzU5OSIsInN0YXRlXzYwMCIsIk5ld1RhcmdldEV4cHJlc3Npb24iLCJhdHRyc182MDEiLCJ0eXBlXzYwMiIsInJlZHVjZXJfNjAzIiwic3RhdGVfNjA0IiwicmVkdWNlcl82MDUiLCJzdGF0ZV82MDYiLCJyZWR1Y2VOZXdUYXJnZXRFeHByZXNzaW9uIiwiYXR0cnNfNjA3IiwidGVybV82MDgiLCJzdGF0ZV82MDkiLCJPYmplY3RFeHByZXNzaW9uIiwiYXR0cnNfNjEwIiwidHlwZV82MTEiLCJyZWR1Y2VyXzYxMiIsInN0YXRlXzYxMyIsImFfNjE0IiwicmVkdWNlcl82MTUiLCJzdGF0ZV82MTYiLCJyZWR1Y2VPYmplY3RFeHByZXNzaW9uIiwiYXR0cnNfNjE3IiwidGVybV82MTgiLCJzdGF0ZV82MTkiLCJVbmFyeUV4cHJlc3Npb24iLCJhdHRyc182MjAiLCJ0eXBlXzYyMSIsInJlZHVjZXJfNjIyIiwic3RhdGVfNjIzIiwib3BlcmFuZCIsInJlZHVjZXJfNjI0Iiwic3RhdGVfNjI1IiwicmVkdWNlVW5hcnlFeHByZXNzaW9uIiwiYXR0cnNfNjI2IiwidGVybV82MjciLCJzdGF0ZV82MjgiLCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uIiwiYXR0cnNfNjI5IiwidHlwZV82MzAiLCJyZWR1Y2VyXzYzMSIsInN0YXRlXzYzMiIsInByb3BlcnR5IiwicmVkdWNlcl82MzMiLCJzdGF0ZV82MzQiLCJyZWR1Y2VTdGF0aWNNZW1iZXJFeHByZXNzaW9uIiwiYXR0cnNfNjM1IiwidGVybV82MzYiLCJzdGF0ZV82MzciLCJUZW1wbGF0ZUV4cHJlc3Npb24iLCJhdHRyc182MzgiLCJ0eXBlXzYzOSIsInJlZHVjZXJfNjQwIiwic3RhdGVfNjQxIiwidGFnIiwiYV82NDIiLCJUZW1wbGF0ZUVsZW1lbnQiLCJyZWR1Y2VyXzY0MyIsInN0YXRlXzY0NCIsInJlZHVjZVRlbXBsYXRlRXhwcmVzc2lvbiIsImF0dHJzXzY0NSIsInRlcm1fNjQ2Iiwic3RhdGVfNjQ3IiwiVGhpc0V4cHJlc3Npb24iLCJhdHRyc182NDgiLCJ0eXBlXzY0OSIsInJlZHVjZXJfNjUwIiwic3RhdGVfNjUxIiwic3R4IiwicmVkdWNlcl82NTIiLCJzdGF0ZV82NTMiLCJyZWR1Y2VUaGlzRXhwcmVzc2lvbiIsImF0dHJzXzY1NCIsInRlcm1fNjU1Iiwic3RhdGVfNjU2IiwiVXBkYXRlRXhwcmVzc2lvbiIsImF0dHJzXzY1NyIsInR5cGVfNjU4IiwicmVkdWNlcl82NTkiLCJzdGF0ZV82NjAiLCJpc1ByZWZpeCIsInJlZHVjZXJfNjYxIiwic3RhdGVfNjYyIiwicmVkdWNlVXBkYXRlRXhwcmVzc2lvbiIsImF0dHJzXzY2MyIsInRlcm1fNjY0Iiwic3RhdGVfNjY1IiwiWWllbGRFeHByZXNzaW9uIiwiYXR0cnNfNjY2IiwidHlwZV82NjciLCJyZWR1Y2VyXzY2OCIsInN0YXRlXzY2OSIsInJlZHVjZXJfNjcwIiwic3RhdGVfNjcxIiwicmVkdWNlWWllbGRFeHByZXNzaW9uIiwiYXR0cnNfNjcyIiwidGVybV82NzMiLCJzdGF0ZV82NzQiLCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24iLCJhdHRyc182NzUiLCJ0eXBlXzY3NiIsInJlZHVjZXJfNjc3Iiwic3RhdGVfNjc4IiwicmVkdWNlcl82NzkiLCJzdGF0ZV82ODAiLCJyZWR1Y2VZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24iLCJhdHRyc182ODEiLCJ0ZXJtXzY4MiIsInN0YXRlXzY4MyIsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwiYXR0cnNfNjg0IiwidHlwZV82ODUiLCJyZWR1Y2VyXzY4NiIsInN0YXRlXzY4NyIsInJlZHVjZXJfNjg4Iiwic3RhdGVfNjg5IiwicmVkdWNlUGFyZW50aGVzaXplZEV4cHJlc3Npb24iLCJhdHRyc182OTAiLCJ0ZXJtXzY5MSIsInN0YXRlXzY5MiIsIkJsb2NrU3RhdGVtZW50IiwiYXR0cnNfNjkzIiwidHlwZV82OTQiLCJyZWR1Y2VyXzY5NSIsInN0YXRlXzY5NiIsImJsb2NrIiwiQmxvY2siLCJyZWR1Y2VyXzY5NyIsInN0YXRlXzY5OCIsInJlZHVjZUJsb2NrU3RhdGVtZW50IiwiYXR0cnNfNjk5IiwidGVybV83MDAiLCJzdGF0ZV83MDEiLCJCcmVha1N0YXRlbWVudCIsImF0dHJzXzcwMiIsInR5cGVfNzAzIiwicmVkdWNlcl83MDQiLCJzdGF0ZV83MDUiLCJsYWJlbCIsInJlZHVjZXJfNzA2Iiwic3RhdGVfNzA3IiwicmVkdWNlQnJlYWtTdGF0ZW1lbnQiLCJhdHRyc183MDgiLCJ0ZXJtXzcwOSIsInN0YXRlXzcxMCIsIkNvbnRpbnVlU3RhdGVtZW50IiwiYXR0cnNfNzExIiwidHlwZV83MTIiLCJyZWR1Y2VyXzcxMyIsInN0YXRlXzcxNCIsInJlZHVjZXJfNzE1Iiwic3RhdGVfNzE2IiwicmVkdWNlQ29udGludWVTdGF0ZW1lbnQiLCJhdHRyc183MTciLCJ0ZXJtXzcxOCIsInN0YXRlXzcxOSIsIkRlYnVnZ2VyU3RhdGVtZW50IiwiYXR0cnNfNzIwIiwidHlwZV83MjEiLCJyZWR1Y2VyXzcyMiIsInN0YXRlXzcyMyIsInJlZHVjZXJfNzI0Iiwic3RhdGVfNzI1IiwicmVkdWNlRGVidWdnZXJTdGF0ZW1lbnQiLCJhdHRyc183MjYiLCJ0ZXJtXzcyNyIsInN0YXRlXzcyOCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJhdHRyc183MjkiLCJ0eXBlXzczMCIsInJlZHVjZXJfNzMxIiwic3RhdGVfNzMyIiwicmVkdWNlcl83MzMiLCJzdGF0ZV83MzQiLCJyZWR1Y2VEb1doaWxlU3RhdGVtZW50IiwiYXR0cnNfNzM1IiwidGVybV83MzYiLCJzdGF0ZV83MzciLCJFbXB0eVN0YXRlbWVudCIsImF0dHJzXzczOCIsInR5cGVfNzM5IiwicmVkdWNlcl83NDAiLCJzdGF0ZV83NDEiLCJyZWR1Y2VyXzc0MiIsInN0YXRlXzc0MyIsInJlZHVjZUVtcHR5U3RhdGVtZW50IiwiYXR0cnNfNzQ0IiwidGVybV83NDUiLCJzdGF0ZV83NDYiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwiYXR0cnNfNzQ3IiwidHlwZV83NDgiLCJyZWR1Y2VyXzc0OSIsInN0YXRlXzc1MCIsInJlZHVjZXJfNzUxIiwic3RhdGVfNzUyIiwicmVkdWNlRXhwcmVzc2lvblN0YXRlbWVudCIsImF0dHJzXzc1MyIsInRlcm1fNzU0Iiwic3RhdGVfNzU1IiwiRm9ySW5TdGF0ZW1lbnQiLCJhdHRyc183NTYiLCJ0eXBlXzc1NyIsInJlZHVjZXJfNzU4Iiwic3RhdGVfNzU5IiwicmVkdWNlcl83NjAiLCJzdGF0ZV83NjEiLCJyZWR1Y2VGb3JJblN0YXRlbWVudCIsImF0dHJzXzc2MiIsInRlcm1fNzYzIiwic3RhdGVfNzY0IiwiRm9yT2ZTdGF0ZW1lbnQiLCJhdHRyc183NjUiLCJ0eXBlXzc2NiIsInJlZHVjZXJfNzY3Iiwic3RhdGVfNzY4IiwicmVkdWNlcl83NjkiLCJzdGF0ZV83NzAiLCJyZWR1Y2VGb3JPZlN0YXRlbWVudCIsImF0dHJzXzc3MSIsInRlcm1fNzcyIiwic3RhdGVfNzczIiwiRm9yU3RhdGVtZW50IiwiYXR0cnNfNzc0IiwidHlwZV83NzUiLCJyZWR1Y2VyXzc3NiIsInN0YXRlXzc3NyIsInVwZGF0ZSIsInJlZHVjZXJfNzc4Iiwic3RhdGVfNzc5IiwicmVkdWNlRm9yU3RhdGVtZW50IiwiYXR0cnNfNzgwIiwidGVybV83ODEiLCJzdGF0ZV83ODIiLCJJZlN0YXRlbWVudCIsImF0dHJzXzc4MyIsInR5cGVfNzg0IiwicmVkdWNlcl83ODUiLCJzdGF0ZV83ODYiLCJyZWR1Y2VyXzc4NyIsInN0YXRlXzc4OCIsInJlZHVjZUlmU3RhdGVtZW50IiwiYXR0cnNfNzg5IiwidGVybV83OTAiLCJzdGF0ZV83OTEiLCJMYWJlbGVkU3RhdGVtZW50IiwiYXR0cnNfNzkyIiwidHlwZV83OTMiLCJyZWR1Y2VyXzc5NCIsInN0YXRlXzc5NSIsInJlZHVjZXJfNzk2Iiwic3RhdGVfNzk3IiwicmVkdWNlTGFiZWxlZFN0YXRlbWVudCIsImF0dHJzXzc5OCIsInRlcm1fNzk5Iiwic3RhdGVfODAwIiwiUmV0dXJuU3RhdGVtZW50IiwiYXR0cnNfODAxIiwidHlwZV84MDIiLCJyZWR1Y2VyXzgwMyIsInN0YXRlXzgwNCIsInJlZHVjZXJfODA1Iiwic3RhdGVfODA2IiwicmVkdWNlUmV0dXJuU3RhdGVtZW50IiwiYXR0cnNfODA3IiwidGVybV84MDgiLCJzdGF0ZV84MDkiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJhdHRyc184MTAiLCJ0eXBlXzgxMSIsInJlZHVjZXJfODEyIiwic3RhdGVfODEzIiwiZGlzY3JpbWluYW50IiwiY2FzZXMiLCJhXzgxNCIsIlN3aXRjaENhc2UiLCJyZWR1Y2VyXzgxNSIsInN0YXRlXzgxNiIsInJlZHVjZVN3aXRjaFN0YXRlbWVudCIsImF0dHJzXzgxNyIsInRlcm1fODE4Iiwic3RhdGVfODE5IiwiU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQiLCJhdHRyc184MjAiLCJ0eXBlXzgyMSIsInJlZHVjZXJfODIyIiwic3RhdGVfODIzIiwicHJlRGVmYXVsdENhc2VzIiwiYV84MjQiLCJkZWZhdWx0Q2FzZSIsIlN3aXRjaERlZmF1bHQiLCJwb3N0RGVmYXVsdENhc2VzIiwiYV84MjUiLCJyZWR1Y2VyXzgyNiIsInN0YXRlXzgyNyIsInJlZHVjZVN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0IiwiYXR0cnNfODI4IiwidGVybV84MjkiLCJzdGF0ZV84MzAiLCJUaHJvd1N0YXRlbWVudCIsImF0dHJzXzgzMSIsInR5cGVfODMyIiwicmVkdWNlcl84MzMiLCJzdGF0ZV84MzQiLCJyZWR1Y2VyXzgzNSIsInN0YXRlXzgzNiIsInJlZHVjZVRocm93U3RhdGVtZW50IiwiYXR0cnNfODM3IiwidGVybV84MzgiLCJzdGF0ZV84MzkiLCJUcnlDYXRjaFN0YXRlbWVudCIsImF0dHJzXzg0MCIsInR5cGVfODQxIiwicmVkdWNlcl84NDIiLCJzdGF0ZV84NDMiLCJjYXRjaENsYXVzZSIsIkNhdGNoQ2xhdXNlIiwicmVkdWNlcl84NDQiLCJzdGF0ZV84NDUiLCJyZWR1Y2VUcnlDYXRjaFN0YXRlbWVudCIsImF0dHJzXzg0NiIsInRlcm1fODQ3Iiwic3RhdGVfODQ4IiwiVHJ5RmluYWxseVN0YXRlbWVudCIsImF0dHJzXzg0OSIsInR5cGVfODUwIiwicmVkdWNlcl84NTEiLCJzdGF0ZV84NTIiLCJmaW5hbGl6ZXIiLCJyZWR1Y2VyXzg1MyIsInN0YXRlXzg1NCIsInJlZHVjZVRyeUZpbmFsbHlTdGF0ZW1lbnQiLCJhdHRyc184NTUiLCJ0ZXJtXzg1NiIsInN0YXRlXzg1NyIsIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQiLCJhdHRyc184NTgiLCJ0eXBlXzg1OSIsInJlZHVjZXJfODYwIiwic3RhdGVfODYxIiwicmVkdWNlcl84NjIiLCJzdGF0ZV84NjMiLCJyZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50IiwiYXR0cnNfODY0IiwidGVybV84NjUiLCJzdGF0ZV84NjYiLCJXaXRoU3RhdGVtZW50IiwiYXR0cnNfODY3IiwidHlwZV84NjgiLCJyZWR1Y2VyXzg2OSIsInN0YXRlXzg3MCIsInJlZHVjZXJfODcxIiwic3RhdGVfODcyIiwicmVkdWNlV2l0aFN0YXRlbWVudCIsImF0dHJzXzg3MyIsInRlcm1fODc0Iiwic3RhdGVfODc1IiwiV2hpbGVTdGF0ZW1lbnQiLCJhdHRyc184NzYiLCJ0eXBlXzg3NyIsInJlZHVjZXJfODc4Iiwic3RhdGVfODc5IiwicmVkdWNlcl84ODAiLCJzdGF0ZV84ODEiLCJyZWR1Y2VXaGlsZVN0YXRlbWVudCIsImF0dHJzXzg4MiIsInRlcm1fODgzIiwic3RhdGVfODg0IiwiUHJhZ21hIiwiYXR0cnNfODg1IiwidHlwZV84ODYiLCJyZWR1Y2VyXzg4NyIsInN0YXRlXzg4OCIsInJlZHVjZXJfODg5Iiwic3RhdGVfODkwIiwicmVkdWNlUHJhZ21hIiwiYXR0cnNfODkxIiwidGVybV84OTIiLCJzdGF0ZV84OTMiLCJhdHRyc184OTQiLCJ0eXBlXzg5NSIsInJlZHVjZXJfODk2Iiwic3RhdGVfODk3Iiwic3RhdGVtZW50cyIsImFfODk4IiwicmVkdWNlcl84OTkiLCJzdGF0ZV85MDAiLCJyZWR1Y2VCbG9jayIsImF0dHJzXzkwMSIsInRlcm1fOTAyIiwic3RhdGVfOTAzIiwiYXR0cnNfOTA0IiwidHlwZV85MDUiLCJyZWR1Y2VyXzkwNiIsInN0YXRlXzkwNyIsInJlZHVjZXJfOTA4Iiwic3RhdGVfOTA5IiwicmVkdWNlQ2F0Y2hDbGF1c2UiLCJhdHRyc185MTAiLCJ0ZXJtXzkxMSIsInN0YXRlXzkxMiIsIkRpcmVjdGl2ZSIsImF0dHJzXzkxMyIsInR5cGVfOTE0IiwicmVkdWNlcl85MTUiLCJzdGF0ZV85MTYiLCJyYXdWYWx1ZSIsInJlZHVjZXJfOTE3Iiwic3RhdGVfOTE4IiwicmVkdWNlRGlyZWN0aXZlIiwiYXR0cnNfOTE5IiwidGVybV85MjAiLCJzdGF0ZV85MjEiLCJhdHRyc185MjIiLCJ0eXBlXzkyMyIsInJlZHVjZXJfOTI0Iiwic3RhdGVfOTI1IiwiYV85MjYiLCJyZXN0IiwicmVkdWNlcl85MjciLCJzdGF0ZV85MjgiLCJyZWR1Y2VGb3JtYWxQYXJhbWV0ZXJzIiwiYXR0cnNfOTI5IiwidGVybV85MzAiLCJzdGF0ZV85MzEiLCJhdHRyc185MzIiLCJ0eXBlXzkzMyIsInJlZHVjZXJfOTM0Iiwic3RhdGVfOTM1IiwiYV85MzYiLCJhXzkzNyIsInJlZHVjZXJfOTM4Iiwic3RhdGVfOTM5IiwicmVkdWNlRnVuY3Rpb25Cb2R5IiwiYXR0cnNfOTQwIiwidGVybV85NDEiLCJzdGF0ZV85NDIiLCJhdHRyc185NDMiLCJ0eXBlXzk0NCIsInJlZHVjZXJfOTQ1Iiwic3RhdGVfOTQ2IiwicmVkdWNlcl85NDciLCJzdGF0ZV85NDgiLCJyZWR1Y2VGdW5jdGlvbkRlY2xhcmF0aW9uIiwiYXR0cnNfOTQ5IiwidGVybV85NTAiLCJzdGF0ZV85NTEiLCJGdW5jdGlvbkRlY2xhcmF0aW9uRSIsImF0dHJzXzk1MiIsInR5cGVfOTUzIiwicmVkdWNlcl85NTQiLCJzdGF0ZV85NTUiLCJhXzk1NiIsInJlZHVjZXJfOTU3Iiwic3RhdGVfOTU4IiwicmVkdWNlRnVuY3Rpb25EZWNsYXJhdGlvbkUiLCJhdHRyc185NTkiLCJ0ZXJtXzk2MCIsInN0YXRlXzk2MSIsIlNjcmlwdCIsImF0dHJzXzk2MiIsInR5cGVfOTYzIiwicmVkdWNlcl85NjQiLCJzdGF0ZV85NjUiLCJhXzk2NiIsImFfOTY3IiwicmVkdWNlcl85NjgiLCJzdGF0ZV85NjkiLCJyZWR1Y2VTY3JpcHQiLCJhdHRyc185NzAiLCJ0ZXJtXzk3MSIsInN0YXRlXzk3MiIsImF0dHJzXzk3MyIsInR5cGVfOTc0IiwicmVkdWNlcl85NzUiLCJzdGF0ZV85NzYiLCJyZWR1Y2VyXzk3NyIsInN0YXRlXzk3OCIsInJlZHVjZVNwcmVhZEVsZW1lbnQiLCJhdHRyc185NzkiLCJ0ZXJtXzk4MCIsInN0YXRlXzk4MSIsImF0dHJzXzk4MiIsInR5cGVfOTgzIiwicmVkdWNlcl85ODQiLCJzdGF0ZV85ODUiLCJyZWR1Y2VyXzk4NiIsInN0YXRlXzk4NyIsInJlZHVjZVN1cGVyIiwiYXR0cnNfOTg4IiwidGVybV85ODkiLCJzdGF0ZV85OTAiLCJhdHRyc185OTEiLCJ0eXBlXzk5MiIsInJlZHVjZXJfOTkzIiwic3RhdGVfOTk0IiwiYV85OTUiLCJyZWR1Y2VyXzk5NiIsInN0YXRlXzk5NyIsInJlZHVjZVN3aXRjaENhc2UiLCJhdHRyc185OTgiLCJ0ZXJtXzk5OSIsInN0YXRlXzEwMDAiLCJhdHRyc18xMDAxIiwidHlwZV8xMDAyIiwicmVkdWNlcl8xMDAzIiwic3RhdGVfMTAwNCIsImFfMTAwNSIsInJlZHVjZXJfMTAwNiIsInN0YXRlXzEwMDciLCJyZWR1Y2VTd2l0Y2hEZWZhdWx0IiwiYXR0cnNfMTAwOCIsInRlcm1fMTAwOSIsInN0YXRlXzEwMTAiLCJhdHRyc18xMDExIiwidHlwZV8xMDEyIiwicmVkdWNlcl8xMDEzIiwic3RhdGVfMTAxNCIsInJlZHVjZXJfMTAxNSIsInN0YXRlXzEwMTYiLCJyZWR1Y2VUZW1wbGF0ZUVsZW1lbnQiLCJhdHRyc18xMDE3IiwidGVybV8xMDE4Iiwic3RhdGVfMTAxOSIsIlN5bnRheFRlbXBsYXRlIiwiYXR0cnNfMTAyMCIsInR5cGVfMTAyMSIsInJlZHVjZXJfMTAyMiIsInN0YXRlXzEwMjMiLCJ0ZW1wbGF0ZSIsImFfMTAyNCIsInJlZHVjZXJfMTAyNSIsInN0YXRlXzEwMjYiLCJyZWR1Y2VTeW50YXhUZW1wbGF0ZSIsImF0dHJzXzEwMjciLCJ0ZXJtXzEwMjgiLCJzdGF0ZV8xMDI5IiwiU3ludGF4UXVvdGUiLCJhdHRyc18xMDMwIiwidHlwZV8xMDMxIiwicmVkdWNlcl8xMDMyIiwic3RhdGVfMTAzMyIsInJlZHVjZXJfMTAzNCIsInN0YXRlXzEwMzUiLCJyZWR1Y2VTeW50YXhRdW90ZSIsImF0dHJzXzEwMzYiLCJ0ZXJtXzEwMzciLCJzdGF0ZV8xMDM4IiwiYXR0cnNfMTAzOSIsInR5cGVfMTA0MCIsInJlZHVjZXJfMTA0MSIsInN0YXRlXzEwNDIiLCJkZWNsYXJhdG9ycyIsImFfMTA0MyIsIlZhcmlhYmxlRGVjbGFyYXRvciIsInJlZHVjZXJfMTA0NCIsInN0YXRlXzEwNDUiLCJyZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uIiwiYXR0cnNfMTA0NiIsInRlcm1fMTA0NyIsInN0YXRlXzEwNDgiLCJhdHRyc18xMDQ5IiwidHlwZV8xMDUwIiwicmVkdWNlcl8xMDUxIiwic3RhdGVfMTA1MiIsInJlZHVjZXJfMTA1MyIsInN0YXRlXzEwNTQiLCJyZWR1Y2VWYXJpYWJsZURlY2xhcmF0b3IiLCJhdHRyc18xMDU1IiwidGVybV8xMDU2Iiwic3RhdGVfMTA1NyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxJQUFOLENBQVc7QUFDVEMsY0FBWUMsUUFBWixFQUFzQkMsT0FBdEIsRUFBK0I7QUFDN0JDLFdBQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CSCxRQUFwQjtBQUNBLFNBQUtJLElBQUwsR0FBWUgsV0FBVyxNQUF2QjtBQUNBLFNBQUtJLEdBQUwsR0FBVyxJQUFYO0FBQ0FILFdBQU9JLE1BQVAsQ0FBYyxJQUFkO0FBQ0Q7QUFDREMsZUFBYUMsVUFBYixFQUF5QkMsV0FBVyxFQUFwQyxFQUF3QztBQUN0QyxXQUFPQSxRQUFQO0FBQ0Q7QUFDREMsZ0JBQWM7QUFDWixXQUFPLEVBQVA7QUFDRDtBQUNEQyxTQUFPQyxVQUFQLEVBQW1CO0FBQ2pCLFFBQUlDLFdBQVcsS0FBS04sWUFBTCxDQUFrQkssVUFBbEIsQ0FBZjtBQUNBLFdBQU9BLFdBQVdFLFVBQVgs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QUNELENBRkQ7UUFHOEJoQixrQixHQUF0QkEsa0IiLCJmaWxlIjoidGVybS1zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzYzLCB0eXBlXzY0KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRyc182Myk7XG4gICAgdGhpcy50eXBlID0gdHlwZV82NCB8fCBcIlRlcm1cIjtcbiAgICB0aGlzLmxvYyA9IG51bGw7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl82NSwgc3RhdGVfNjYgPSB7fSkge1xuICAgIHJldHVybiBzdGF0ZV82NjtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNjcpIHtcbiAgICBsZXQgc3RhdGVfNjggPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY3KTtcbiAgICByZXR1cm4gcmVkdWNlcl82Ny5yZWR1Y2VUZXJtKHRoaXMsIHN0YXRlXzY4KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNjkpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzY5KSk7XG4gIH1cbiAgZnJvbSh0eXBlXzcwLCB2YWx1ZV83MSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmIHR5cGVvZiB0aGlzLnZhbHVlLmZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZnJvbSh0eXBlXzcwLCB2YWx1ZV83MSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIH1cbiAgZnJvbU51bGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShcIm51bGxcIiwgbnVsbCk7XG4gIH1cbiAgZnJvbU51bWJlcih2YWx1ZV83Mikge1xuICAgIHJldHVybiB0aGlzLmZyb20oXCJudW1iZXJcIiwgdmFsdWVfNzIpO1xuICB9XG4gIGZyb21TdHJpbmcodmFsdWVfNzMpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKFwic3RyaW5nXCIsIHZhbHVlXzczKTtcbiAgfVxuICBmcm9tUHVuY3R1YXRvcih2YWx1ZV83NCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oXCJwdW5jdHVhdG9yXCIsIHZhbHVlXzc0KTtcbiAgfVxuICBmcm9tS2V5d29yZCh2YWx1ZV83NSkge1xuICAgIHJldHVybiB0aGlzLmZyb20oXCJrZXl3b3JkXCIsIHZhbHVlXzc1KTtcbiAgfVxuICBmcm9tSWRlbnRpZmllcih2YWx1ZV83Nikge1xuICAgIHJldHVybiB0aGlzLmZyb20oXCJpZGVudGlmaWVyXCIsIHZhbHVlXzc2KTtcbiAgfVxuICBmcm9tUmVndWxhckV4cHJlc3Npb24odmFsdWVfNzcpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKFwicmVndWxhckV4cHJlc3Npb25cIiwgdmFsdWVfNzcpO1xuICB9XG4gIGZyb21CcmFjZXMoaW5uZXJfNzgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKFwiYnJhY2VzXCIsIGlubmVyXzc4KTtcbiAgfVxuICBmcm9tQnJhY2tldHMoaW5uZXJfNzkpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKFwiYnJhY2tldHNcIiwgaW5uZXJfNzkpO1xuICB9XG4gIGZyb21QYXJlbnMoaW5uZXJfODApIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKFwicGFyZW5zXCIsIGlubmVyXzgwKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIgPSBjbGFzcyB7XG4gIHJlZHVjZVRlcm0odGVybV84MSwgc3RhdGVfODIpIHtcbiAgICByZXR1cm4gbmV3IFRlcm0oc3RhdGVfODIpO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgVGVybTtcbmNsYXNzIFN5bnRheFRlcm0gZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfODMsIHR5cGVfODQpIHtcbiAgICBzdXBlcihhdHRyc184MywgdHlwZV84NCB8fCBcIlN5bnRheFRlcm1cIik7XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODUsIHN0YXRlXzg2ID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg1LCBzdGF0ZV84Nik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzg3KSB7XG4gICAgbGV0IHN0YXRlXzg4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84Nyk7XG4gICAgcmV0dXJuIHJlZHVjZXJfODcucmVkdWNlU3ludGF4VGVybSh0aGlzLCBzdGF0ZV84OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzg5KSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXhUZXJtKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184OSkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU3ludGF4VGVybSA9IGZ1bmN0aW9uICh0ZXJtXzkwLCBzdGF0ZV85MSkge1xuICByZXR1cm4gbmV3IFN5bnRheFRlcm0oc3RhdGVfOTEpO1xufTtcbmV4cG9ydCB7U3ludGF4VGVybSBhcyBTeW50YXhUZXJtfTtcbmNsYXNzIFJhd0RlbGltaXRlciBleHRlbmRzIFN5bnRheFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc185MiwgdHlwZV85Mykge1xuICAgIHN1cGVyKGF0dHJzXzkyLCB0eXBlXzkzIHx8IFwiUmF3RGVsaW1pdGVyXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185MiwgXCJraW5kXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImtpbmRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185MiwgXCJpbm5lclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJpbm5lclwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTQsIHN0YXRlXzk1ID0ge30pIHtcbiAgICBzdGF0ZV85NS5raW5kID0gdGhpcy5raW5kO1xuICAgIHN0YXRlXzk1LmlubmVyID0gdGhpcy5pbm5lci5tYXAoYV85NiA9PiBhXzk2IGluc3RhbmNlb2YgVGVybSA/IGFfOTYucmVkdWNlKHJlZHVjZXJfOTQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85NikpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl85NCwgc3RhdGVfOTUpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtraW5kOiB0aGlzLmtpbmQsIGlubmVyOiB0aGlzLmlubmVyfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfOTcpIHtcbiAgICBsZXQgc3RhdGVfOTggPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk3KTtcbiAgICByZXR1cm4gcmVkdWNlcl85Ny5yZWR1Y2VSYXdEZWxpbWl0ZXIodGhpcywgc3RhdGVfOTgpO1xuICB9XG4gIGV4dGVuZChhdHRyc185OSkge1xuICAgIHJldHVybiBuZXcgUmF3RGVsaW1pdGVyKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc185OSkpO1xuICB9XG59XG5TeW50YXhUZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlUmF3RGVsaW1pdGVyID0gZnVuY3Rpb24gKHRlcm1fMTAwLCBzdGF0ZV8xMDEpIHtcbiAgcmV0dXJuIG5ldyBSYXdEZWxpbWl0ZXIoc3RhdGVfMTAxKTtcbn07XG5leHBvcnQge1Jhd0RlbGltaXRlciBhcyBSYXdEZWxpbWl0ZXJ9O1xuY2xhc3MgUmF3U3ludGF4IGV4dGVuZHMgU3ludGF4VGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzEwMiwgdHlwZV8xMDMpIHtcbiAgICBzdXBlcihhdHRyc18xMDIsIHR5cGVfMTAzIHx8IFwiUmF3U3ludGF4XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xMDIsIFwidmFsdWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidmFsdWVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwNCwgc3RhdGVfMTA1ID0ge30pIHtcbiAgICBzdGF0ZV8xMDUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTA0LCBzdGF0ZV8xMDUpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt2YWx1ZTogdGhpcy52YWx1ZX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzEwNikge1xuICAgIGxldCBzdGF0ZV8xMDcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwNik7XG4gICAgcmV0dXJuIHJlZHVjZXJfMTA2LnJlZHVjZVJhd1N5bnRheCh0aGlzLCBzdGF0ZV8xMDcpO1xuICB9XG4gIGV4dGVuZChhdHRyc18xMDgpIHtcbiAgICByZXR1cm4gbmV3IFJhd1N5bnRheChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMTA4KSk7XG4gIH1cbn1cblN5bnRheFRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VSYXdTeW50YXggPSBmdW5jdGlvbiAodGVybV8xMDksIHN0YXRlXzExMCkge1xuICByZXR1cm4gbmV3IFJhd1N5bnRheChzdGF0ZV8xMTApO1xufTtcbmV4cG9ydCB7UmF3U3ludGF4IGFzIFJhd1N5bnRheH07XG5jbGFzcyBTdGF0ZW1lbnQgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTExLCB0eXBlXzExMikge1xuICAgIHN1cGVyKGF0dHJzXzExMSwgdHlwZV8xMTIgfHwgXCJTdGF0ZW1lbnRcIik7XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTEzLCBzdGF0ZV8xMTQgPSB7fSkge1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTEzLCBzdGF0ZV8xMTQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xMTUpIHtcbiAgICBsZXQgc3RhdGVfMTE2ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMTUpO1xuICAgIHJldHVybiByZWR1Y2VyXzExNS5yZWR1Y2VTdGF0ZW1lbnQodGhpcywgc3RhdGVfMTE2KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMTE3KSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzExNykpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU3RhdGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fMTE4LCBzdGF0ZV8xMTkpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZW1lbnQoc3RhdGVfMTE5KTtcbn07XG5leHBvcnQge1N0YXRlbWVudCBhcyBTdGF0ZW1lbnR9O1xuY2xhc3MgSXRlcmF0aW9uU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTIwLCB0eXBlXzEyMSkge1xuICAgIHN1cGVyKGF0dHJzXzEyMCwgdHlwZV8xMjEgfHwgXCJJdGVyYXRpb25TdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzEyMCwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEyMiwgc3RhdGVfMTIzID0ge30pIHtcbiAgICBzdGF0ZV8xMjMuYm9keSA9IHRoaXMuYm9keSBpbnN0YW5jZW9mIFN0YXRlbWVudCA/IHRoaXMuYm9keS5yZWR1Y2UocmVkdWNlcl8xMjIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTIyLCBzdGF0ZV8xMjMpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtib2R5OiB0aGlzLmJvZHl9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xMjQpIHtcbiAgICBsZXQgc3RhdGVfMTI1ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMjQpO1xuICAgIHJldHVybiByZWR1Y2VyXzEyNC5yZWR1Y2VJdGVyYXRpb25TdGF0ZW1lbnQodGhpcywgc3RhdGVfMTI1KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMTI2KSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRpb25TdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzEyNikpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VJdGVyYXRpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV8xMjcsIHN0YXRlXzEyOCkge1xuICByZXR1cm4gbmV3IEl0ZXJhdGlvblN0YXRlbWVudChzdGF0ZV8xMjgpO1xufTtcbmV4cG9ydCB7SXRlcmF0aW9uU3RhdGVtZW50IGFzIEl0ZXJhdGlvblN0YXRlbWVudH07XG5jbGFzcyBFeHByZXNzaW9uIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzEyOSwgdHlwZV8xMzApIHtcbiAgICBzdXBlcihhdHRyc18xMjksIHR5cGVfMTMwIHx8IFwiRXhwcmVzc2lvblwiKTtcbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8xMzEsIHN0YXRlXzEzMiA9IHt9KSB7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMzEsIHN0YXRlXzEzMik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzEzMykge1xuICAgIGxldCBzdGF0ZV8xMzQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEzMyk7XG4gICAgcmV0dXJuIHJlZHVjZXJfMTMzLnJlZHVjZUV4cHJlc3Npb24odGhpcywgc3RhdGVfMTM0KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMTM1KSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xMzUpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV8xMzYsIHN0YXRlXzEzNykge1xuICByZXR1cm4gbmV3IEV4cHJlc3Npb24oc3RhdGVfMTM3KTtcbn07XG5leHBvcnQge0V4cHJlc3Npb24gYXMgRXhwcmVzc2lvbn07XG5jbGFzcyBNZW1iZXJFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzEzOCwgdHlwZV8xMzkpIHtcbiAgICBzdXBlcihhdHRyc18xMzgsIHR5cGVfMTM5IHx8IFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMTM4LCBcIm9iamVjdFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJvYmplY3RcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE0MCwgc3RhdGVfMTQxID0ge30pIHtcbiAgICBzdGF0ZV8xNDEub2JqZWN0ID0gdGhpcy5vYmplY3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5vYmplY3QucmVkdWNlKHJlZHVjZXJfMTQwKSA6IHRoaXMub2JqZWN0IGluc3RhbmNlb2YgU3VwZXIgPyB0aGlzLm9iamVjdC5yZWR1Y2UocmVkdWNlcl8xNDApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xNDAsIHN0YXRlXzE0MSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe29iamVjdDogdGhpcy5vYmplY3R9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xNDIpIHtcbiAgICBsZXQgc3RhdGVfMTQzID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xNDIpO1xuICAgIHJldHVybiByZWR1Y2VyXzE0Mi5yZWR1Y2VNZW1iZXJFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzE0Myk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzE0NCkge1xuICAgIHJldHVybiBuZXcgTWVtYmVyRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMTQ0KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VNZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fMTQ1LCBzdGF0ZV8xNDYpIHtcbiAgcmV0dXJuIG5ldyBNZW1iZXJFeHByZXNzaW9uKHN0YXRlXzE0Nik7XG59O1xuZXhwb3J0IHtNZW1iZXJFeHByZXNzaW9uIGFzIE1lbWJlckV4cHJlc3Npb259O1xuY2xhc3MgUHJvcGVydHlOYW1lIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzE0NywgdHlwZV8xNDgpIHtcbiAgICBzdXBlcihhdHRyc18xNDcsIHR5cGVfMTQ4IHx8IFwiUHJvcGVydHlOYW1lXCIpO1xuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE0OSwgc3RhdGVfMTUwID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE0OSwgc3RhdGVfMTUwKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTUxKSB7XG4gICAgbGV0IHN0YXRlXzE1MiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTUxKTtcbiAgICByZXR1cm4gcmVkdWNlcl8xNTEucmVkdWNlUHJvcGVydHlOYW1lKHRoaXMsIHN0YXRlXzE1Mik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzE1Mykge1xuICAgIHJldHVybiBuZXcgUHJvcGVydHlOYW1lKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xNTMpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICh0ZXJtXzE1NCwgc3RhdGVfMTU1KSB7XG4gIHJldHVybiBuZXcgUHJvcGVydHlOYW1lKHN0YXRlXzE1NSk7XG59O1xuZXhwb3J0IHtQcm9wZXJ0eU5hbWUgYXMgUHJvcGVydHlOYW1lfTtcbmNsYXNzIE9iamVjdFByb3BlcnR5IGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzE1NiwgdHlwZV8xNTcpIHtcbiAgICBzdXBlcihhdHRyc18xNTYsIHR5cGVfMTU3IHx8IFwiT2JqZWN0UHJvcGVydHlcIik7XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTU4LCBzdGF0ZV8xNTkgPSB7fSkge1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTU4LCBzdGF0ZV8xNTkpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xNjApIHtcbiAgICBsZXQgc3RhdGVfMTYxID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xNjApO1xuICAgIHJldHVybiByZWR1Y2VyXzE2MC5yZWR1Y2VPYmplY3RQcm9wZXJ0eSh0aGlzLCBzdGF0ZV8xNjEpO1xuICB9XG4gIGV4dGVuZChhdHRyc18xNjIpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFByb3BlcnR5KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xNjIpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZU9iamVjdFByb3BlcnR5ID0gZnVuY3Rpb24gKHRlcm1fMTYzLCBzdGF0ZV8xNjQpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RQcm9wZXJ0eShzdGF0ZV8xNjQpO1xufTtcbmV4cG9ydCB7T2JqZWN0UHJvcGVydHkgYXMgT2JqZWN0UHJvcGVydHl9O1xuY2xhc3MgTmFtZWRPYmplY3RQcm9wZXJ0eSBleHRlbmRzIE9iamVjdFByb3BlcnR5IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTY1LCB0eXBlXzE2Nikge1xuICAgIHN1cGVyKGF0dHJzXzE2NSwgdHlwZV8xNjYgfHwgXCJOYW1lZE9iamVjdFByb3BlcnR5XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xNjUsIFwibmFtZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJuYW1lXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8xNjcsIHN0YXRlXzE2OCA9IHt9KSB7XG4gICAgc3RhdGVfMTY4Lm5hbWUgPSB0aGlzLm5hbWUgaW5zdGFuY2VvZiBQcm9wZXJ0eU5hbWUgPyB0aGlzLm5hbWUucmVkdWNlKHJlZHVjZXJfMTY3KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMubmFtZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE2Nywgc3RhdGVfMTY4KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTY5KSB7XG4gICAgbGV0IHN0YXRlXzE3MCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTY5KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xNjkucmVkdWNlTmFtZWRPYmplY3RQcm9wZXJ0eSh0aGlzLCBzdGF0ZV8xNzApO1xuICB9XG4gIGV4dGVuZChhdHRyc18xNzEpIHtcbiAgICByZXR1cm4gbmV3IE5hbWVkT2JqZWN0UHJvcGVydHkoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzE3MSkpO1xuICB9XG59XG5PYmplY3RQcm9wZXJ0eS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZU5hbWVkT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAodGVybV8xNzIsIHN0YXRlXzE3Mykge1xuICByZXR1cm4gbmV3IE5hbWVkT2JqZWN0UHJvcGVydHkoc3RhdGVfMTczKTtcbn07XG5leHBvcnQge05hbWVkT2JqZWN0UHJvcGVydHkgYXMgTmFtZWRPYmplY3RQcm9wZXJ0eX07XG5jbGFzcyBNZXRob2REZWZpbml0aW9uIGV4dGVuZHMgTmFtZWRPYmplY3RQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzE3NCwgdHlwZV8xNzUpIHtcbiAgICBzdXBlcihhdHRyc18xNzQsIHR5cGVfMTc1IHx8IFwiTWV0aG9kRGVmaW5pdGlvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMTc0LCBcImJvZHlcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYm9keVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTc2LCBzdGF0ZV8xNzcgPSB7fSkge1xuICAgIHN0YXRlXzE3Ny5ib2R5ID0gdGhpcy5ib2R5IGluc3RhbmNlb2YgRnVuY3Rpb25Cb2R5ID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzE3NikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xNzYsIHN0YXRlXzE3Nyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JvZHk6IHRoaXMuYm9keX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzE3OCkge1xuICAgIGxldCBzdGF0ZV8xNzkgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE3OCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfMTc4LnJlZHVjZU1ldGhvZERlZmluaXRpb24odGhpcywgc3RhdGVfMTc5KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMTgwKSB7XG4gICAgcmV0dXJuIG5ldyBNZXRob2REZWZpbml0aW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xODApKTtcbiAgfVxufVxuTmFtZWRPYmplY3RQcm9wZXJ0eS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZU1ldGhvZERlZmluaXRpb24gPSBmdW5jdGlvbiAodGVybV8xODEsIHN0YXRlXzE4Mikge1xuICByZXR1cm4gbmV3IE1ldGhvZERlZmluaXRpb24oc3RhdGVfMTgyKTtcbn07XG5leHBvcnQge01ldGhvZERlZmluaXRpb24gYXMgTWV0aG9kRGVmaW5pdGlvbn07XG5jbGFzcyBCaW5kaW5nV2l0aERlZmF1bHQgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTgzLCB0eXBlXzE4NCkge1xuICAgIHN1cGVyKGF0dHJzXzE4MywgdHlwZV8xODQgfHwgXCJCaW5kaW5nV2l0aERlZmF1bHRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzE4MywgXCJiaW5kaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJpbmRpbmdcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xODMsIFwiaW5pdFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJpbml0XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8xODUsIHN0YXRlXzE4NiA9IHt9KSB7XG4gICAgc3RhdGVfMTg2LmJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBPYmplY3RCaW5kaW5nID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzE4NSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBBcnJheUJpbmRpbmcgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfMTg1KSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzE4NSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzE4NSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJpbmRpbmcpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMTg2LmluaXQgPSB0aGlzLmluaXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5pbml0LnJlZHVjZShyZWR1Y2VyXzE4NSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xODUsIHN0YXRlXzE4Nik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmRpbmc6IHRoaXMuYmluZGluZywgaW5pdDogdGhpcy5pbml0fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTg3KSB7XG4gICAgbGV0IHN0YXRlXzE4OCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTg3KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xODcucmVkdWNlQmluZGluZ1dpdGhEZWZhdWx0KHRoaXMsIHN0YXRlXzE4OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzE4OSkge1xuICAgIHJldHVybiBuZXcgQmluZGluZ1dpdGhEZWZhdWx0KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xODkpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUJpbmRpbmdXaXRoRGVmYXVsdCA9IGZ1bmN0aW9uICh0ZXJtXzE5MCwgc3RhdGVfMTkxKSB7XG4gIHJldHVybiBuZXcgQmluZGluZ1dpdGhEZWZhdWx0KHN0YXRlXzE5MSk7XG59O1xuZXhwb3J0IHtCaW5kaW5nV2l0aERlZmF1bHQgYXMgQmluZGluZ1dpdGhEZWZhdWx0fTtcbmNsYXNzIEJpbmRpbmdJZGVudGlmaWVyIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzE5MiwgdHlwZV8xOTMpIHtcbiAgICBzdXBlcihhdHRyc18xOTIsIHR5cGVfMTkzIHx8IFwiQmluZGluZ0lkZW50aWZpZXJcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzE5MiwgXCJuYW1lXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE5NCwgc3RhdGVfMTk1ID0ge30pIHtcbiAgICBzdGF0ZV8xOTUubmFtZSA9IHRoaXMubmFtZTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzE5NCwgc3RhdGVfMTk1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTk2KSB7XG4gICAgbGV0IHN0YXRlXzE5NyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTk2KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xOTYucmVkdWNlQmluZGluZ0lkZW50aWZpZXIodGhpcywgc3RhdGVfMTk3KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMTk4KSB7XG4gICAgcmV0dXJuIG5ldyBCaW5kaW5nSWRlbnRpZmllcihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMTk4KSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VCaW5kaW5nSWRlbnRpZmllciA9IGZ1bmN0aW9uICh0ZXJtXzE5OSwgc3RhdGVfMjAwKSB7XG4gIHJldHVybiBuZXcgQmluZGluZ0lkZW50aWZpZXIoc3RhdGVfMjAwKTtcbn07XG5leHBvcnQge0JpbmRpbmdJZGVudGlmaWVyIGFzIEJpbmRpbmdJZGVudGlmaWVyfTtcbmNsYXNzIEFycmF5QmluZGluZyBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18yMDEsIHR5cGVfMjAyKSB7XG4gICAgc3VwZXIoYXR0cnNfMjAxLCB0eXBlXzIwMiB8fCBcIkFycmF5QmluZGluZ1wiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjAxLCBcImVsZW1lbnRzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImVsZW1lbnRzXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjAxLCBcInJlc3RFbGVtZW50XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInJlc3RFbGVtZW50XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8yMDMsIHN0YXRlXzIwNCA9IHt9KSB7XG4gICAgc3RhdGVfMjA0LmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoYV8yMDUgPT4gYV8yMDUgaW5zdGFuY2VvZiBPYmplY3RCaW5kaW5nID8gYV8yMDUucmVkdWNlKHJlZHVjZXJfMjAzKSA6IGFfMjA1IGluc3RhbmNlb2YgQXJyYXlCaW5kaW5nID8gYV8yMDUucmVkdWNlKHJlZHVjZXJfMjAzKSA6IGFfMjA1IGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyBhXzIwNS5yZWR1Y2UocmVkdWNlcl8yMDMpIDogYV8yMDUgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uID8gYV8yMDUucmVkdWNlKHJlZHVjZXJfMjAzKSA6IGFfMjA1IGluc3RhbmNlb2YgQmluZGluZ1dpdGhEZWZhdWx0ID8gYV8yMDUucmVkdWNlKHJlZHVjZXJfMjAzKSA6IGFfMjA1ID09IG51bGwgPyBudWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV8yMDUpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIHN0YXRlXzIwNC5yZXN0RWxlbWVudCA9IHRoaXMucmVzdEVsZW1lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnJlc3RFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0QmluZGluZyA/IHRoaXMucmVzdEVsZW1lbnQucmVkdWNlKHJlZHVjZXJfMjAzKSA6IHRoaXMucmVzdEVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJpbmRpbmcgPyB0aGlzLnJlc3RFbGVtZW50LnJlZHVjZShyZWR1Y2VyXzIwMykgOiB0aGlzLnJlc3RFbGVtZW50IGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLnJlc3RFbGVtZW50LnJlZHVjZShyZWR1Y2VyXzIwMykgOiB0aGlzLnJlc3RFbGVtZW50IGluc3RhbmNlb2YgTWVtYmVyRXhwcmVzc2lvbiA/IHRoaXMucmVzdEVsZW1lbnQucmVkdWNlKHJlZHVjZXJfMjAzKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucmVzdEVsZW1lbnQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8yMDMsIHN0YXRlXzIwNCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2VsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLCByZXN0RWxlbWVudDogdGhpcy5yZXN0RWxlbWVudH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzIwNikge1xuICAgIGxldCBzdGF0ZV8yMDcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzIwNik7XG4gICAgcmV0dXJuIHJlZHVjZXJfMjA2LnJlZHVjZUFycmF5QmluZGluZyh0aGlzLCBzdGF0ZV8yMDcpO1xuICB9XG4gIGV4dGVuZChhdHRyc18yMDgpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QmluZGluZyhPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMjA4KSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VBcnJheUJpbmRpbmcgPSBmdW5jdGlvbiAodGVybV8yMDksIHN0YXRlXzIxMCkge1xuICByZXR1cm4gbmV3IEFycmF5QmluZGluZyhzdGF0ZV8yMTApO1xufTtcbmV4cG9ydCB7QXJyYXlCaW5kaW5nIGFzIEFycmF5QmluZGluZ307XG5jbGFzcyBPYmplY3RCaW5kaW5nIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzIxMSwgdHlwZV8yMTIpIHtcbiAgICBzdXBlcihhdHRyc18yMTEsIHR5cGVfMjEyIHx8IFwiT2JqZWN0QmluZGluZ1wiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjExLCBcInByb3BlcnRpZXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicHJvcGVydGllc1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjEzLCBzdGF0ZV8yMTQgPSB7fSkge1xuICAgIHN0YXRlXzIxNC5wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLm1hcChhXzIxNSA9PiBhXzIxNSBpbnN0YW5jZW9mIEJpbmRpbmdQcm9wZXJ0eSA/IGFfMjE1LnJlZHVjZShyZWR1Y2VyXzIxMykgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShhXzIxNSkpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8yMTMsIHN0YXRlXzIxNCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3Byb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzIxNikge1xuICAgIGxldCBzdGF0ZV8yMTcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzIxNik7XG4gICAgcmV0dXJuIHJlZHVjZXJfMjE2LnJlZHVjZU9iamVjdEJpbmRpbmcodGhpcywgc3RhdGVfMjE3KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMjE4KSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RCaW5kaW5nKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18yMTgpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZU9iamVjdEJpbmRpbmcgPSBmdW5jdGlvbiAodGVybV8yMTksIHN0YXRlXzIyMCkge1xuICByZXR1cm4gbmV3IE9iamVjdEJpbmRpbmcoc3RhdGVfMjIwKTtcbn07XG5leHBvcnQge09iamVjdEJpbmRpbmcgYXMgT2JqZWN0QmluZGluZ307XG5jbGFzcyBCaW5kaW5nUHJvcGVydHkgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMjIxLCB0eXBlXzIyMikge1xuICAgIHN1cGVyKGF0dHJzXzIyMSwgdHlwZV8yMjIgfHwgXCJCaW5kaW5nUHJvcGVydHlcIik7XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjIzLCBzdGF0ZV8yMjQgPSB7fSkge1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjIzLCBzdGF0ZV8yMjQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8yMjUpIHtcbiAgICBsZXQgc3RhdGVfMjI2ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8yMjUpO1xuICAgIHJldHVybiByZWR1Y2VyXzIyNS5yZWR1Y2VCaW5kaW5nUHJvcGVydHkodGhpcywgc3RhdGVfMjI2KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMjI3KSB7XG4gICAgcmV0dXJuIG5ldyBCaW5kaW5nUHJvcGVydHkoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzIyNykpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQmluZGluZ1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRlcm1fMjI4LCBzdGF0ZV8yMjkpIHtcbiAgcmV0dXJuIG5ldyBCaW5kaW5nUHJvcGVydHkoc3RhdGVfMjI5KTtcbn07XG5leHBvcnQge0JpbmRpbmdQcm9wZXJ0eSBhcyBCaW5kaW5nUHJvcGVydHl9O1xuY2xhc3MgQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllciBleHRlbmRzIEJpbmRpbmdQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzIzMCwgdHlwZV8yMzEpIHtcbiAgICBzdXBlcihhdHRyc18yMzAsIHR5cGVfMjMxIHx8IFwiQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllclwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjMwLCBcImJpbmRpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYmluZGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzIzMCwgXCJpbml0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImluaXRcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzIzMiwgc3RhdGVfMjMzID0ge30pIHtcbiAgICBzdGF0ZV8yMzMuYmluZGluZyA9IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzIzMikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJpbmRpbmcpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMjMzLmluaXQgPSB0aGlzLmluaXQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmluaXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5pbml0LnJlZHVjZShyZWR1Y2VyXzIzMikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8yMzIsIHN0YXRlXzIzMyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmRpbmc6IHRoaXMuYmluZGluZywgaW5pdDogdGhpcy5pbml0fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMjM0KSB7XG4gICAgbGV0IHN0YXRlXzIzNSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjM0KTtcbiAgICByZXR1cm4gcmVkdWNlcl8yMzQucmVkdWNlQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcih0aGlzLCBzdGF0ZV8yMzUpO1xuICB9XG4gIGV4dGVuZChhdHRyc18yMzYpIHtcbiAgICByZXR1cm4gbmV3IEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzIzNikpO1xuICB9XG59XG5CaW5kaW5nUHJvcGVydHkuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyID0gZnVuY3Rpb24gKHRlcm1fMjM3LCBzdGF0ZV8yMzgpIHtcbiAgcmV0dXJuIG5ldyBCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyKHN0YXRlXzIzOCk7XG59O1xuZXhwb3J0IHtCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyIGFzIEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXJ9O1xuY2xhc3MgQmluZGluZ1Byb3BlcnR5UHJvcGVydHkgZXh0ZW5kcyBCaW5kaW5nUHJvcGVydHkge1xuICBjb25zdHJ1Y3RvcihhdHRyc18yMzksIHR5cGVfMjQwKSB7XG4gICAgc3VwZXIoYXR0cnNfMjM5LCB0eXBlXzI0MCB8fCBcIkJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yMzksIFwibmFtZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJuYW1lXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjM5LCBcImJpbmRpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYmluZGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjQxLCBzdGF0ZV8yNDIgPSB7fSkge1xuICAgIHN0YXRlXzI0Mi5uYW1lID0gdGhpcy5uYW1lIGluc3RhbmNlb2YgUHJvcGVydHlOYW1lID8gdGhpcy5uYW1lLnJlZHVjZShyZWR1Y2VyXzI0MSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMjQyLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBPYmplY3RCaW5kaW5nID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzI0MSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBBcnJheUJpbmRpbmcgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfMjQxKSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzI0MSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzI0MSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBCaW5kaW5nV2l0aERlZmF1bHQgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfMjQxKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYmluZGluZykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzI0MSwgc3RhdGVfMjQyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lLCBiaW5kaW5nOiB0aGlzLmJpbmRpbmd9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8yNDMpIHtcbiAgICBsZXQgc3RhdGVfMjQ0ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8yNDMpO1xuICAgIHJldHVybiByZWR1Y2VyXzI0My5yZWR1Y2VCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSh0aGlzLCBzdGF0ZV8yNDQpO1xuICB9XG4gIGV4dGVuZChhdHRyc18yNDUpIHtcbiAgICByZXR1cm4gbmV3IEJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18yNDUpKTtcbiAgfVxufVxuQmluZGluZ1Byb3BlcnR5LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQmluZGluZ1Byb3BlcnR5UHJvcGVydHkgPSBmdW5jdGlvbiAodGVybV8yNDYsIHN0YXRlXzI0Nykge1xuICByZXR1cm4gbmV3IEJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5KHN0YXRlXzI0Nyk7XG59O1xuZXhwb3J0IHtCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSBhcyBCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eX07XG5jbGFzcyBDbGFzc0V4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMjQ4LCB0eXBlXzI0OSkge1xuICAgIHN1cGVyKGF0dHJzXzI0OCwgdHlwZV8yNDkgfHwgXCJDbGFzc0V4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzI0OCwgXCJuYW1lXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNDgsIFwic3VwZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwic3VwZXJcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNDgsIFwiZWxlbWVudHNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZWxlbWVudHNcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzI1MCwgc3RhdGVfMjUxID0ge30pIHtcbiAgICBzdGF0ZV8yNTEubmFtZSA9IHRoaXMubmFtZSA9PSBudWxsID8gbnVsbCA6IHRoaXMubmFtZSBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5uYW1lLnJlZHVjZShyZWR1Y2VyXzI1MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMjUxLnN1cGVyID0gdGhpcy5zdXBlciA9PSBudWxsID8gbnVsbCA6IHRoaXMuc3VwZXIgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5zdXBlci5yZWR1Y2UocmVkdWNlcl8yNTApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5zdXBlcikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV8yNTEuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcChhXzI1MiA9PiBhXzI1MiBpbnN0YW5jZW9mIENsYXNzRWxlbWVudCA/IGFfMjUyLnJlZHVjZShyZWR1Y2VyXzI1MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShhXzI1MikpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8yNTAsIHN0YXRlXzI1MSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe25hbWU6IHRoaXMubmFtZSwgc3VwZXI6IHRoaXMuc3VwZXIsIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMjUzKSB7XG4gICAgbGV0IHN0YXRlXzI1NCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjUzKTtcbiAgICByZXR1cm4gcmVkdWNlcl8yNTMucmVkdWNlQ2xhc3NFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzI1NCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzI1NSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3NFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18yNTUpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzI1Niwgc3RhdGVfMjU3KSB7XG4gIHJldHVybiBuZXcgQ2xhc3NFeHByZXNzaW9uKHN0YXRlXzI1Nyk7XG59O1xuZXhwb3J0IHtDbGFzc0V4cHJlc3Npb24gYXMgQ2xhc3NFeHByZXNzaW9ufTtcbmNsYXNzIENsYXNzRGVjbGFyYXRpb24gZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc18yNTgsIHR5cGVfMjU5KSB7XG4gICAgc3VwZXIoYXR0cnNfMjU4LCB0eXBlXzI1OSB8fCBcIkNsYXNzRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzI1OCwgXCJuYW1lXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNTgsIFwic3VwZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwic3VwZXJcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNTgsIFwiZWxlbWVudHNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZWxlbWVudHNcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzI2MCwgc3RhdGVfMjYxID0ge30pIHtcbiAgICBzdGF0ZV8yNjEubmFtZSA9IHRoaXMubmFtZSBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5uYW1lLnJlZHVjZShyZWR1Y2VyXzI2MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMjYxLnN1cGVyID0gdGhpcy5zdXBlciA9PSBudWxsID8gbnVsbCA6IHRoaXMuc3VwZXIgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5zdXBlci5yZWR1Y2UocmVkdWNlcl8yNjApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5zdXBlcikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV8yNjEuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcChhXzI2MiA9PiBhXzI2MiBpbnN0YW5jZW9mIENsYXNzRWxlbWVudCA/IGFfMjYyLnJlZHVjZShyZWR1Y2VyXzI2MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShhXzI2MikpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8yNjAsIHN0YXRlXzI2MSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe25hbWU6IHRoaXMubmFtZSwgc3VwZXI6IHRoaXMuc3VwZXIsIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMjYzKSB7XG4gICAgbGV0IHN0YXRlXzI2NCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjYzKTtcbiAgICByZXR1cm4gcmVkdWNlcl8yNjMucmVkdWNlQ2xhc3NEZWNsYXJhdGlvbih0aGlzLCBzdGF0ZV8yNjQpO1xuICB9XG4gIGV4dGVuZChhdHRyc18yNjUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzRGVjbGFyYXRpb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzI2NSkpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKHRlcm1fMjY2LCBzdGF0ZV8yNjcpIHtcbiAgcmV0dXJuIG5ldyBDbGFzc0RlY2xhcmF0aW9uKHN0YXRlXzI2Nyk7XG59O1xuZXhwb3J0IHtDbGFzc0RlY2xhcmF0aW9uIGFzIENsYXNzRGVjbGFyYXRpb259O1xuY2xhc3MgQ2xhc3NFbGVtZW50IGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzI2OCwgdHlwZV8yNjkpIHtcbiAgICBzdXBlcihhdHRyc18yNjgsIHR5cGVfMjY5IHx8IFwiQ2xhc3NFbGVtZW50XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNjgsIFwiaXNTdGF0aWNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaXNTdGF0aWNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNjgsIFwibWV0aG9kXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm1ldGhvZFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjcwLCBzdGF0ZV8yNzEgPSB7fSkge1xuICAgIHN0YXRlXzI3MS5pc1N0YXRpYyA9IHRoaXMuaXNTdGF0aWM7XG4gICAgc3RhdGVfMjcxLm1ldGhvZCA9IHRoaXMubWV0aG9kIGluc3RhbmNlb2YgTWV0aG9kRGVmaW5pdGlvbiA/IHRoaXMubWV0aG9kLnJlZHVjZShyZWR1Y2VyXzI3MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGhvZCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzI3MCwgc3RhdGVfMjcxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7aXNTdGF0aWM6IHRoaXMuaXNTdGF0aWMsIG1ldGhvZDogdGhpcy5tZXRob2R9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8yNzIpIHtcbiAgICBsZXQgc3RhdGVfMjczID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8yNzIpO1xuICAgIHJldHVybiByZWR1Y2VyXzI3Mi5yZWR1Y2VDbGFzc0VsZW1lbnQodGhpcywgc3RhdGVfMjczKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMjc0KSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzc0VsZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzI3NCkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fMjc1LCBzdGF0ZV8yNzYpIHtcbiAgcmV0dXJuIG5ldyBDbGFzc0VsZW1lbnQoc3RhdGVfMjc2KTtcbn07XG5leHBvcnQge0NsYXNzRWxlbWVudCBhcyBDbGFzc0VsZW1lbnR9O1xuY2xhc3MgTW9kdWxlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzI3NywgdHlwZV8yNzgpIHtcbiAgICBzdXBlcihhdHRyc18yNzcsIHR5cGVfMjc4IHx8IFwiTW9kdWxlXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yNzcsIFwiZGlyZWN0aXZlc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJkaXJlY3RpdmVzXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjc3LCBcIml0ZW1zXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIml0ZW1zXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8yNzksIHN0YXRlXzI4MCA9IHt9KSB7XG4gICAgc3RhdGVfMjgwLmRpcmVjdGl2ZXMgPSB0aGlzLmRpcmVjdGl2ZXMubWFwKGFfMjgxID0+IGFfMjgxKTtcbiAgICBzdGF0ZV8yODAuaXRlbXMgPSB0aGlzLml0ZW1zLm1hcChhXzI4MiA9PiBhXzI4MiBpbnN0YW5jZW9mIFRlcm0gPyBhXzI4Mi5yZWR1Y2UocmVkdWNlcl8yNzkpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV8yODIpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjc5LCBzdGF0ZV8yODApO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsIGl0ZW1zOiB0aGlzLml0ZW1zfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMjgzKSB7XG4gICAgbGV0IHN0YXRlXzI4NCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMjgzKTtcbiAgICByZXR1cm4gcmVkdWNlcl8yODMucmVkdWNlTW9kdWxlKHRoaXMsIHN0YXRlXzI4NCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzI4NSkge1xuICAgIHJldHVybiBuZXcgTW9kdWxlKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18yODUpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZU1vZHVsZSA9IGZ1bmN0aW9uICh0ZXJtXzI4Niwgc3RhdGVfMjg3KSB7XG4gIHJldHVybiBuZXcgTW9kdWxlKHN0YXRlXzI4Nyk7XG59O1xuZXhwb3J0IHtNb2R1bGUgYXMgTW9kdWxlfTtcbmNsYXNzIEltcG9ydCBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18yODgsIHR5cGVfMjg5KSB7XG4gICAgc3VwZXIoYXR0cnNfMjg4LCB0eXBlXzI4OSB8fCBcIkltcG9ydFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMjg4LCBcIm1vZHVsZVNwZWNpZmllclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJtb2R1bGVTcGVjaWZpZXJcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yODgsIFwiZGVmYXVsdEJpbmRpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZGVmYXVsdEJpbmRpbmdcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yODgsIFwibmFtZWRJbXBvcnRzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVkSW1wb3J0c1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzI4OCwgXCJmb3JTeW50YXhcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZm9yU3ludGF4XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8yOTAsIHN0YXRlXzI5MSA9IHt9KSB7XG4gICAgc3RhdGVfMjkxLm1vZHVsZVNwZWNpZmllciA9IHRoaXMubW9kdWxlU3BlY2lmaWVyO1xuICAgIHN0YXRlXzI5MS5kZWZhdWx0QmluZGluZyA9IHRoaXMuZGVmYXVsdEJpbmRpbmcgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmRlZmF1bHRCaW5kaW5nIGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLmRlZmF1bHRCaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzI5MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRlZmF1bHRCaW5kaW5nKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzI5MS5uYW1lZEltcG9ydHMgPSB0aGlzLm5hbWVkSW1wb3J0cy5tYXAoYV8yOTIgPT4gYV8yOTIgaW5zdGFuY2VvZiBJbXBvcnRTcGVjaWZpZXIgPyBhXzI5Mi5yZWR1Y2UocmVkdWNlcl8yOTApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV8yOTIpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIHN0YXRlXzI5MS5mb3JTeW50YXggPSB0aGlzLmZvclN5bnRheDtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzI5MCwgc3RhdGVfMjkxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bW9kdWxlU3BlY2lmaWVyOiB0aGlzLm1vZHVsZVNwZWNpZmllciwgZGVmYXVsdEJpbmRpbmc6IHRoaXMuZGVmYXVsdEJpbmRpbmcsIG5hbWVkSW1wb3J0czogdGhpcy5uYW1lZEltcG9ydHMsIGZvclN5bnRheDogdGhpcy5mb3JTeW50YXh9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8yOTMpIHtcbiAgICBsZXQgc3RhdGVfMjk0ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8yOTMpO1xuICAgIHJldHVybiByZWR1Y2VyXzI5My5yZWR1Y2VJbXBvcnQodGhpcywgc3RhdGVfMjk0KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMjk1KSB7XG4gICAgcmV0dXJuIG5ldyBJbXBvcnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzI5NSkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlSW1wb3J0ID0gZnVuY3Rpb24gKHRlcm1fMjk2LCBzdGF0ZV8yOTcpIHtcbiAgcmV0dXJuIG5ldyBJbXBvcnQoc3RhdGVfMjk3KTtcbn07XG5leHBvcnQge0ltcG9ydCBhcyBJbXBvcnR9O1xuY2xhc3MgSW1wb3J0TmFtZXNwYWNlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzI5OCwgdHlwZV8yOTkpIHtcbiAgICBzdXBlcihhdHRyc18yOTgsIHR5cGVfMjk5IHx8IFwiSW1wb3J0TmFtZXNwYWNlXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yOTgsIFwibW9kdWxlU3BlY2lmaWVyXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm1vZHVsZVNwZWNpZmllclwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzI5OCwgXCJkZWZhdWx0QmluZGluZ1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJkZWZhdWx0QmluZGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzI5OCwgXCJuYW1lc3BhY2VCaW5kaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVzcGFjZUJpbmRpbmdcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18yOTgsIFwiZm9yU3ludGF4XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImZvclN5bnRheFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzAwLCBzdGF0ZV8zMDEgPSB7fSkge1xuICAgIHN0YXRlXzMwMS5tb2R1bGVTcGVjaWZpZXIgPSB0aGlzLm1vZHVsZVNwZWNpZmllcjtcbiAgICBzdGF0ZV8zMDEuZGVmYXVsdEJpbmRpbmcgPSB0aGlzLmRlZmF1bHRCaW5kaW5nID09IG51bGwgPyBudWxsIDogdGhpcy5kZWZhdWx0QmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5kZWZhdWx0QmluZGluZy5yZWR1Y2UocmVkdWNlcl8zMDApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZWZhdWx0QmluZGluZykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV8zMDEubmFtZXNwYWNlQmluZGluZyA9IHRoaXMubmFtZXNwYWNlQmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5uYW1lc3BhY2VCaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzMwMCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWVzcGFjZUJpbmRpbmcpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfMzAxLmZvclN5bnRheCA9IHRoaXMuZm9yU3ludGF4O1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzAwLCBzdGF0ZV8zMDEpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHttb2R1bGVTcGVjaWZpZXI6IHRoaXMubW9kdWxlU3BlY2lmaWVyLCBkZWZhdWx0QmluZGluZzogdGhpcy5kZWZhdWx0QmluZGluZywgbmFtZXNwYWNlQmluZGluZzogdGhpcy5uYW1lc3BhY2VCaW5kaW5nLCBmb3JTeW50YXg6IHRoaXMuZm9yU3ludGF4fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMzAyKSB7XG4gICAgbGV0IHN0YXRlXzMwMyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzAyKTtcbiAgICByZXR1cm4gcmVkdWNlcl8zMDIucmVkdWNlSW1wb3J0TmFtZXNwYWNlKHRoaXMsIHN0YXRlXzMwMyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzMwNCkge1xuICAgIHJldHVybiBuZXcgSW1wb3J0TmFtZXNwYWNlKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18zMDQpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUltcG9ydE5hbWVzcGFjZSA9IGZ1bmN0aW9uICh0ZXJtXzMwNSwgc3RhdGVfMzA2KSB7XG4gIHJldHVybiBuZXcgSW1wb3J0TmFtZXNwYWNlKHN0YXRlXzMwNik7XG59O1xuZXhwb3J0IHtJbXBvcnROYW1lc3BhY2UgYXMgSW1wb3J0TmFtZXNwYWNlfTtcbmNsYXNzIEltcG9ydFNwZWNpZmllciBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18zMDcsIHR5cGVfMzA4KSB7XG4gICAgc3VwZXIoYXR0cnNfMzA3LCB0eXBlXzMwOCB8fCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzA3LCBcIm5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzMwNywgXCJiaW5kaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJpbmRpbmdcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzMwOSwgc3RhdGVfMzEwID0ge30pIHtcbiAgICBzdGF0ZV8zMTAubmFtZSA9IHRoaXMubmFtZSA9PSBudWxsID8gbnVsbCA6IHRoaXMubmFtZTtcbiAgICBzdGF0ZV8zMTAuYmluZGluZyA9IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzMwOSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJpbmRpbmcpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8zMDksIHN0YXRlXzMxMCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe25hbWU6IHRoaXMubmFtZSwgYmluZGluZzogdGhpcy5iaW5kaW5nfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMzExKSB7XG4gICAgbGV0IHN0YXRlXzMxMiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzExKTtcbiAgICByZXR1cm4gcmVkdWNlcl8zMTEucmVkdWNlSW1wb3J0U3BlY2lmaWVyKHRoaXMsIHN0YXRlXzMxMik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzMxMykge1xuICAgIHJldHVybiBuZXcgSW1wb3J0U3BlY2lmaWVyKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18zMTMpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICh0ZXJtXzMxNCwgc3RhdGVfMzE1KSB7XG4gIHJldHVybiBuZXcgSW1wb3J0U3BlY2lmaWVyKHN0YXRlXzMxNSk7XG59O1xuZXhwb3J0IHtJbXBvcnRTcGVjaWZpZXIgYXMgSW1wb3J0U3BlY2lmaWVyfTtcbmNsYXNzIEV4cG9ydEFsbEZyb20gZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMzE2LCB0eXBlXzMxNykge1xuICAgIHN1cGVyKGF0dHJzXzMxNiwgdHlwZV8zMTcgfHwgXCJFeHBvcnRBbGxGcm9tXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18zMTYsIFwibW9kdWxlU3BlY2lmaWVyXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm1vZHVsZVNwZWNpZmllclwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzE4LCBzdGF0ZV8zMTkgPSB7fSkge1xuICAgIHN0YXRlXzMxOS5tb2R1bGVTcGVjaWZpZXIgPSB0aGlzLm1vZHVsZVNwZWNpZmllcjtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzMxOCwgc3RhdGVfMzE5KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bW9kdWxlU3BlY2lmaWVyOiB0aGlzLm1vZHVsZVNwZWNpZmllcn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzMyMCkge1xuICAgIGxldCBzdGF0ZV8zMjEgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzMyMCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfMzIwLnJlZHVjZUV4cG9ydEFsbEZyb20odGhpcywgc3RhdGVfMzIxKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMzIyKSB7XG4gICAgcmV0dXJuIG5ldyBFeHBvcnRBbGxGcm9tKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18zMjIpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUV4cG9ydEFsbEZyb20gPSBmdW5jdGlvbiAodGVybV8zMjMsIHN0YXRlXzMyNCkge1xuICByZXR1cm4gbmV3IEV4cG9ydEFsbEZyb20oc3RhdGVfMzI0KTtcbn07XG5leHBvcnQge0V4cG9ydEFsbEZyb20gYXMgRXhwb3J0QWxsRnJvbX07XG5jbGFzcyBFeHBvcnRGcm9tIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzMyNSwgdHlwZV8zMjYpIHtcbiAgICBzdXBlcihhdHRyc18zMjUsIHR5cGVfMzI2IHx8IFwiRXhwb3J0RnJvbVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzI1LCBcIm5hbWVkRXhwb3J0c1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJuYW1lZEV4cG9ydHNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18zMjUsIFwibW9kdWxlU3BlY2lmaWVyXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm1vZHVsZVNwZWNpZmllclwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzI3LCBzdGF0ZV8zMjggPSB7fSkge1xuICAgIHN0YXRlXzMyOC5uYW1lZEV4cG9ydHMgPSB0aGlzLm5hbWVkRXhwb3J0cy5tYXAoYV8zMjkgPT4gYV8zMjkgaW5zdGFuY2VvZiBFeHBvcnRTcGVjaWZpZXIgPyBhXzMyOS5yZWR1Y2UocmVkdWNlcl8zMjcpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV8zMjkpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIHN0YXRlXzMyOC5tb2R1bGVTcGVjaWZpZXIgPSB0aGlzLm1vZHVsZVNwZWNpZmllciA9PSBudWxsID8gbnVsbCA6IHRoaXMubW9kdWxlU3BlY2lmaWVyO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzI3LCBzdGF0ZV8zMjgpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lZEV4cG9ydHM6IHRoaXMubmFtZWRFeHBvcnRzLCBtb2R1bGVTcGVjaWZpZXI6IHRoaXMubW9kdWxlU3BlY2lmaWVyfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMzMwKSB7XG4gICAgbGV0IHN0YXRlXzMzMSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzMwKTtcbiAgICByZXR1cm4gcmVkdWNlcl8zMzAucmVkdWNlRXhwb3J0RnJvbSh0aGlzLCBzdGF0ZV8zMzEpO1xuICB9XG4gIGV4dGVuZChhdHRyc18zMzIpIHtcbiAgICByZXR1cm4gbmV3IEV4cG9ydEZyb20oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzMzMikpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRXhwb3J0RnJvbSA9IGZ1bmN0aW9uICh0ZXJtXzMzMywgc3RhdGVfMzM0KSB7XG4gIHJldHVybiBuZXcgRXhwb3J0RnJvbShzdGF0ZV8zMzQpO1xufTtcbmV4cG9ydCB7RXhwb3J0RnJvbSBhcyBFeHBvcnRGcm9tfTtcbmNsYXNzIEV4cG9ydCBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18zMzUsIHR5cGVfMzM2KSB7XG4gICAgc3VwZXIoYXR0cnNfMzM1LCB0eXBlXzMzNiB8fCBcIkV4cG9ydFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzM1LCBcImRlY2xhcmF0aW9uXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImRlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8zMzcsIHN0YXRlXzMzOCA9IHt9KSB7XG4gICAgc3RhdGVfMzM4LmRlY2xhcmF0aW9uID0gdGhpcy5kZWNsYXJhdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24gPyB0aGlzLmRlY2xhcmF0aW9uLnJlZHVjZShyZWR1Y2VyXzMzNykgOiB0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiA/IHRoaXMuZGVjbGFyYXRpb24ucmVkdWNlKHJlZHVjZXJfMzM3KSA6IHRoaXMuZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBWYXJpYWJsZURlY2xhcmF0aW9uID8gdGhpcy5kZWNsYXJhdGlvbi5yZWR1Y2UocmVkdWNlcl8zMzcpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZWNsYXJhdGlvbikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzMzNywgc3RhdGVfMzM4KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZGVjbGFyYXRpb246IHRoaXMuZGVjbGFyYXRpb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8zMzkpIHtcbiAgICBsZXQgc3RhdGVfMzQwID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8zMzkpO1xuICAgIHJldHVybiByZWR1Y2VyXzMzOS5yZWR1Y2VFeHBvcnQodGhpcywgc3RhdGVfMzQwKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMzQxKSB7XG4gICAgcmV0dXJuIG5ldyBFeHBvcnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzM0MSkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRXhwb3J0ID0gZnVuY3Rpb24gKHRlcm1fMzQyLCBzdGF0ZV8zNDMpIHtcbiAgcmV0dXJuIG5ldyBFeHBvcnQoc3RhdGVfMzQzKTtcbn07XG5leHBvcnQge0V4cG9ydCBhcyBFeHBvcnR9O1xuY2xhc3MgRXhwb3J0RGVmYXVsdCBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18zNDQsIHR5cGVfMzQ1KSB7XG4gICAgc3VwZXIoYXR0cnNfMzQ0LCB0eXBlXzM0NSB8fCBcIkV4cG9ydERlZmF1bHRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzM0NCwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM0Niwgc3RhdGVfMzQ3ID0ge30pIHtcbiAgICBzdGF0ZV8zNDcuYm9keSA9IHRoaXMuYm9keSBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24gPyB0aGlzLmJvZHkucmVkdWNlKHJlZHVjZXJfMzQ2KSA6IHRoaXMuYm9keSBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24gPyB0aGlzLmJvZHkucmVkdWNlKHJlZHVjZXJfMzQ2KSA6IHRoaXMuYm9keSBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLmJvZHkucmVkdWNlKHJlZHVjZXJfMzQ2KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM0Niwgc3RhdGVfMzQ3KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7Ym9keTogdGhpcy5ib2R5fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMzQ4KSB7XG4gICAgbGV0IHN0YXRlXzM0OSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzQ4KTtcbiAgICByZXR1cm4gcmVkdWNlcl8zNDgucmVkdWNlRXhwb3J0RGVmYXVsdCh0aGlzLCBzdGF0ZV8zNDkpO1xuICB9XG4gIGV4dGVuZChhdHRyc18zNTApIHtcbiAgICByZXR1cm4gbmV3IEV4cG9ydERlZmF1bHQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzM1MCkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRXhwb3J0RGVmYXVsdCA9IGZ1bmN0aW9uICh0ZXJtXzM1MSwgc3RhdGVfMzUyKSB7XG4gIHJldHVybiBuZXcgRXhwb3J0RGVmYXVsdChzdGF0ZV8zNTIpO1xufTtcbmV4cG9ydCB7RXhwb3J0RGVmYXVsdCBhcyBFeHBvcnREZWZhdWx0fTtcbmNsYXNzIEV4cG9ydFNwZWNpZmllciBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18zNTMsIHR5cGVfMzU0KSB7XG4gICAgc3VwZXIoYXR0cnNfMzUzLCB0eXBlXzM1NCB8fCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzUzLCBcIm5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzM1MywgXCJleHBvcnRlZE5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwb3J0ZWROYW1lXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8zNTUsIHN0YXRlXzM1NiA9IHt9KSB7XG4gICAgc3RhdGVfMzU2Lm5hbWUgPSB0aGlzLm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLm5hbWU7XG4gICAgc3RhdGVfMzU2LmV4cG9ydGVkTmFtZSA9IHRoaXMuZXhwb3J0ZWROYW1lO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzU1LCBzdGF0ZV8zNTYpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lOiB0aGlzLm5hbWUsIGV4cG9ydGVkTmFtZTogdGhpcy5leHBvcnRlZE5hbWV9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8zNTcpIHtcbiAgICBsZXQgc3RhdGVfMzU4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8zNTcpO1xuICAgIHJldHVybiByZWR1Y2VyXzM1Ny5yZWR1Y2VFeHBvcnRTcGVjaWZpZXIodGhpcywgc3RhdGVfMzU4KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMzU5KSB7XG4gICAgcmV0dXJuIG5ldyBFeHBvcnRTcGVjaWZpZXIoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzM1OSkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKHRlcm1fMzYwLCBzdGF0ZV8zNjEpIHtcbiAgcmV0dXJuIG5ldyBFeHBvcnRTcGVjaWZpZXIoc3RhdGVfMzYxKTtcbn07XG5leHBvcnQge0V4cG9ydFNwZWNpZmllciBhcyBFeHBvcnRTcGVjaWZpZXJ9O1xuY2xhc3MgTWV0aG9kIGV4dGVuZHMgTWV0aG9kRGVmaW5pdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzM2MiwgdHlwZV8zNjMpIHtcbiAgICBzdXBlcihhdHRyc18zNjIsIHR5cGVfMzYzIHx8IFwiTWV0aG9kXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18zNjIsIFwiaXNHZW5lcmF0b3JcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaXNHZW5lcmF0b3JcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18zNjIsIFwicGFyYW1zXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInBhcmFtc1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzY0LCBzdGF0ZV8zNjUgPSB7fSkge1xuICAgIHN0YXRlXzM2NS5pc0dlbmVyYXRvciA9IHRoaXMuaXNHZW5lcmF0b3I7XG4gICAgc3RhdGVfMzY1LnBhcmFtcyA9IHRoaXMucGFyYW1zIGluc3RhbmNlb2YgRm9ybWFsUGFyYW1ldGVycyA/IHRoaXMucGFyYW1zLnJlZHVjZShyZWR1Y2VyXzM2NCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtcykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM2NCwgc3RhdGVfMzY1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7aXNHZW5lcmF0b3I6IHRoaXMuaXNHZW5lcmF0b3IsIHBhcmFtczogdGhpcy5wYXJhbXN9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8zNjYpIHtcbiAgICBsZXQgc3RhdGVfMzY3ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8zNjYpO1xuICAgIHJldHVybiByZWR1Y2VyXzM2Ni5yZWR1Y2VNZXRob2QodGhpcywgc3RhdGVfMzY3KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMzY4KSB7XG4gICAgcmV0dXJuIG5ldyBNZXRob2QoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzM2OCkpO1xuICB9XG59XG5NZXRob2REZWZpbml0aW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlTWV0aG9kID0gZnVuY3Rpb24gKHRlcm1fMzY5LCBzdGF0ZV8zNzApIHtcbiAgcmV0dXJuIG5ldyBNZXRob2Qoc3RhdGVfMzcwKTtcbn07XG5leHBvcnQge01ldGhvZCBhcyBNZXRob2R9O1xuY2xhc3MgR2V0dGVyIGV4dGVuZHMgTWV0aG9kRGVmaW5pdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzM3MSwgdHlwZV8zNzIpIHtcbiAgICBzdXBlcihhdHRyc18zNzEsIHR5cGVfMzcyIHx8IFwiR2V0dGVyXCIpO1xuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM3Mywgc3RhdGVfMzc0ID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM3Mywgc3RhdGVfMzc0KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMzc1KSB7XG4gICAgbGV0IHN0YXRlXzM3NiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMzc1KTtcbiAgICByZXR1cm4gcmVkdWNlcl8zNzUucmVkdWNlR2V0dGVyKHRoaXMsIHN0YXRlXzM3Nik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzM3Nykge1xuICAgIHJldHVybiBuZXcgR2V0dGVyKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18zNzcpKTtcbiAgfVxufVxuTWV0aG9kRGVmaW5pdGlvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUdldHRlciA9IGZ1bmN0aW9uICh0ZXJtXzM3OCwgc3RhdGVfMzc5KSB7XG4gIHJldHVybiBuZXcgR2V0dGVyKHN0YXRlXzM3OSk7XG59O1xuZXhwb3J0IHtHZXR0ZXIgYXMgR2V0dGVyfTtcbmNsYXNzIFNldHRlciBleHRlbmRzIE1ldGhvZERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc18zODAsIHR5cGVfMzgxKSB7XG4gICAgc3VwZXIoYXR0cnNfMzgwLCB0eXBlXzM4MSB8fCBcIlNldHRlclwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzgwLCBcInBhcmFtXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInBhcmFtXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8zODIsIHN0YXRlXzM4MyA9IHt9KSB7XG4gICAgc3RhdGVfMzgzLnBhcmFtID0gdGhpcy5wYXJhbSBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyB0aGlzLnBhcmFtLnJlZHVjZShyZWR1Y2VyXzM4MikgOiB0aGlzLnBhcmFtIGluc3RhbmNlb2YgQXJyYXlCaW5kaW5nID8gdGhpcy5wYXJhbS5yZWR1Y2UocmVkdWNlcl8zODIpIDogdGhpcy5wYXJhbSBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5wYXJhbS5yZWR1Y2UocmVkdWNlcl8zODIpIDogdGhpcy5wYXJhbSBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gPyB0aGlzLnBhcmFtLnJlZHVjZShyZWR1Y2VyXzM4MikgOiB0aGlzLnBhcmFtIGluc3RhbmNlb2YgQmluZGluZ1dpdGhEZWZhdWx0ID8gdGhpcy5wYXJhbS5yZWR1Y2UocmVkdWNlcl8zODIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM4Miwgc3RhdGVfMzgzKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7cGFyYW06IHRoaXMucGFyYW19LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8zODQpIHtcbiAgICBsZXQgc3RhdGVfMzg1ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8zODQpO1xuICAgIHJldHVybiByZWR1Y2VyXzM4NC5yZWR1Y2VTZXR0ZXIodGhpcywgc3RhdGVfMzg1KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfMzg2KSB7XG4gICAgcmV0dXJuIG5ldyBTZXR0ZXIoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzM4NikpO1xuICB9XG59XG5NZXRob2REZWZpbml0aW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU2V0dGVyID0gZnVuY3Rpb24gKHRlcm1fMzg3LCBzdGF0ZV8zODgpIHtcbiAgcmV0dXJuIG5ldyBTZXR0ZXIoc3RhdGVfMzg4KTtcbn07XG5leHBvcnQge1NldHRlciBhcyBTZXR0ZXJ9O1xuY2xhc3MgRGF0YVByb3BlcnR5IGV4dGVuZHMgTmFtZWRPYmplY3RQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzM4OSwgdHlwZV8zOTApIHtcbiAgICBzdXBlcihhdHRyc18zODksIHR5cGVfMzkwIHx8IFwiRGF0YVByb3BlcnR5XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18zODksIFwiZXhwcmVzc2lvblwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJleHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8zOTEsIHN0YXRlXzM5MiA9IHt9KSB7XG4gICAgc3RhdGVfMzkyLmV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5leHByZXNzaW9uLnJlZHVjZShyZWR1Y2VyXzM5MSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4cHJlc3Npb24pKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8zOTEsIHN0YXRlXzM5Mik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2V4cHJlc3Npb246IHRoaXMuZXhwcmVzc2lvbn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzM5Mykge1xuICAgIGxldCBzdGF0ZV8zOTQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzM5Myk7XG4gICAgcmV0dXJuIHJlZHVjZXJfMzkzLnJlZHVjZURhdGFQcm9wZXJ0eSh0aGlzLCBzdGF0ZV8zOTQpO1xuICB9XG4gIGV4dGVuZChhdHRyc18zOTUpIHtcbiAgICByZXR1cm4gbmV3IERhdGFQcm9wZXJ0eShPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMzk1KSk7XG4gIH1cbn1cbk5hbWVkT2JqZWN0UHJvcGVydHkuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VEYXRhUHJvcGVydHkgPSBmdW5jdGlvbiAodGVybV8zOTYsIHN0YXRlXzM5Nykge1xuICByZXR1cm4gbmV3IERhdGFQcm9wZXJ0eShzdGF0ZV8zOTcpO1xufTtcbmV4cG9ydCB7RGF0YVByb3BlcnR5IGFzIERhdGFQcm9wZXJ0eX07XG5jbGFzcyBTaG9ydGhhbmRQcm9wZXJ0eSBleHRlbmRzIE9iamVjdFByb3BlcnR5IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMzk4LCB0eXBlXzM5OSkge1xuICAgIHN1cGVyKGF0dHJzXzM5OCwgdHlwZV8zOTkgfHwgXCJTaG9ydGhhbmRQcm9wZXJ0eVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMzk4LCBcIm5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDAwLCBzdGF0ZV80MDEgPSB7fSkge1xuICAgIHN0YXRlXzQwMS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDAwLCBzdGF0ZV80MDEpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lOiB0aGlzLm5hbWV9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl80MDIpIHtcbiAgICBsZXQgc3RhdGVfNDAzID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl80MDIpO1xuICAgIHJldHVybiByZWR1Y2VyXzQwMi5yZWR1Y2VTaG9ydGhhbmRQcm9wZXJ0eSh0aGlzLCBzdGF0ZV80MDMpO1xuICB9XG4gIGV4dGVuZChhdHRyc180MDQpIHtcbiAgICByZXR1cm4gbmV3IFNob3J0aGFuZFByb3BlcnR5KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc180MDQpKTtcbiAgfVxufVxuT2JqZWN0UHJvcGVydHkuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTaG9ydGhhbmRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0ZXJtXzQwNSwgc3RhdGVfNDA2KSB7XG4gIHJldHVybiBuZXcgU2hvcnRoYW5kUHJvcGVydHkoc3RhdGVfNDA2KTtcbn07XG5leHBvcnQge1Nob3J0aGFuZFByb3BlcnR5IGFzIFNob3J0aGFuZFByb3BlcnR5fTtcbmNsYXNzIFN0YXRpY1Byb3BlcnR5TmFtZSBleHRlbmRzIFByb3BlcnR5TmFtZSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzQwNywgdHlwZV80MDgpIHtcbiAgICBzdXBlcihhdHRyc180MDcsIHR5cGVfNDA4IHx8IFwiU3RhdGljUHJvcGVydHlOYW1lXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc180MDcsIFwidmFsdWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidmFsdWVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQwOSwgc3RhdGVfNDEwID0ge30pIHtcbiAgICBzdGF0ZV80MTAudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDA5LCBzdGF0ZV80MTApO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt2YWx1ZTogdGhpcy52YWx1ZX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzQxMSkge1xuICAgIGxldCBzdGF0ZV80MTIgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQxMSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNDExLnJlZHVjZVN0YXRpY1Byb3BlcnR5TmFtZSh0aGlzLCBzdGF0ZV80MTIpO1xuICB9XG4gIGV4dGVuZChhdHRyc180MTMpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1Byb3BlcnR5TmFtZShPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNDEzKSk7XG4gIH1cbn1cblByb3BlcnR5TmFtZS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVN0YXRpY1Byb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICh0ZXJtXzQxNCwgc3RhdGVfNDE1KSB7XG4gIHJldHVybiBuZXcgU3RhdGljUHJvcGVydHlOYW1lKHN0YXRlXzQxNSk7XG59O1xuZXhwb3J0IHtTdGF0aWNQcm9wZXJ0eU5hbWUgYXMgU3RhdGljUHJvcGVydHlOYW1lfTtcbmNsYXNzIENvbXB1dGVkUHJvcGVydHlOYW1lIGV4dGVuZHMgUHJvcGVydHlOYW1lIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNDE2LCB0eXBlXzQxNykge1xuICAgIHN1cGVyKGF0dHJzXzQxNiwgdHlwZV80MTcgfHwgXCJDb21wdXRlZFByb3BlcnR5TmFtZVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNDE2LCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDE4LCBzdGF0ZV80MTkgPSB7fSkge1xuICAgIHN0YXRlXzQxOS5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl80MTgpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDE4LCBzdGF0ZV80MTkpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl80MjApIHtcbiAgICBsZXQgc3RhdGVfNDIxID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl80MjApO1xuICAgIHJldHVybiByZWR1Y2VyXzQyMC5yZWR1Y2VDb21wdXRlZFByb3BlcnR5TmFtZSh0aGlzLCBzdGF0ZV80MjEpO1xuICB9XG4gIGV4dGVuZChhdHRyc180MjIpIHtcbiAgICByZXR1cm4gbmV3IENvbXB1dGVkUHJvcGVydHlOYW1lKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc180MjIpKTtcbiAgfVxufVxuUHJvcGVydHlOYW1lLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAodGVybV80MjMsIHN0YXRlXzQyNCkge1xuICByZXR1cm4gbmV3IENvbXB1dGVkUHJvcGVydHlOYW1lKHN0YXRlXzQyNCk7XG59O1xuZXhwb3J0IHtDb21wdXRlZFByb3BlcnR5TmFtZSBhcyBDb21wdXRlZFByb3BlcnR5TmFtZX07XG5jbGFzcyBMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNDI1LCB0eXBlXzQyNikge1xuICAgIHN1cGVyKGF0dHJzXzQyNSwgdHlwZV80MjYgfHwgXCJMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzQyNSwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDI3LCBzdGF0ZV80MjggPSB7fSkge1xuICAgIHN0YXRlXzQyOC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl80MjcsIHN0YXRlXzQyOCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3ZhbHVlOiB0aGlzLnZhbHVlfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNDI5KSB7XG4gICAgbGV0IHN0YXRlXzQzMCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDI5KTtcbiAgICByZXR1cm4gcmVkdWNlcl80MjkucmVkdWNlTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uKHRoaXMsIHN0YXRlXzQzMCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzQzMSkge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc180MzEpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUxpdGVyYWxCb29sZWFuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzQzMiwgc3RhdGVfNDMzKSB7XG4gIHJldHVybiBuZXcgTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uKHN0YXRlXzQzMyk7XG59O1xuZXhwb3J0IHtMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24gYXMgTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9ufTtcbmNsYXNzIExpdGVyYWxJbmZpbml0eUV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNDM0LCB0eXBlXzQzNSkge1xuICAgIHN1cGVyKGF0dHJzXzQzNCwgdHlwZV80MzUgfHwgXCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uXCIpO1xuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQzNiwgc3RhdGVfNDM3ID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQzNiwgc3RhdGVfNDM3KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNDM4KSB7XG4gICAgbGV0IHN0YXRlXzQzOSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDM4KTtcbiAgICByZXR1cm4gcmVkdWNlcl80MzgucmVkdWNlTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbih0aGlzLCBzdGF0ZV80MzkpO1xuICB9XG4gIGV4dGVuZChhdHRyc180NDApIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxJbmZpbml0eUV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzQ0MCkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzQ0MSwgc3RhdGVfNDQyKSB7XG4gIHJldHVybiBuZXcgTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbihzdGF0ZV80NDIpO1xufTtcbmV4cG9ydCB7TGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbiBhcyBMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9ufTtcbmNsYXNzIExpdGVyYWxOdWxsRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc180NDMsIHR5cGVfNDQ0KSB7XG4gICAgc3VwZXIoYXR0cnNfNDQzLCB0eXBlXzQ0NCB8fCBcIkxpdGVyYWxOdWxsRXhwcmVzc2lvblwiKTtcbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl80NDUsIHN0YXRlXzQ0NiA9IHt9KSB7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl80NDUsIHN0YXRlXzQ0Nik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzQ0Nykge1xuICAgIGxldCBzdGF0ZV80NDggPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQ0Nyk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNDQ3LnJlZHVjZUxpdGVyYWxOdWxsRXhwcmVzc2lvbih0aGlzLCBzdGF0ZV80NDgpO1xuICB9XG4gIGV4dGVuZChhdHRyc180NDkpIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxOdWxsRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNDQ5KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VMaXRlcmFsTnVsbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV80NTAsIHN0YXRlXzQ1MSkge1xuICByZXR1cm4gbmV3IExpdGVyYWxOdWxsRXhwcmVzc2lvbihzdGF0ZV80NTEpO1xufTtcbmV4cG9ydCB7TGl0ZXJhbE51bGxFeHByZXNzaW9uIGFzIExpdGVyYWxOdWxsRXhwcmVzc2lvbn07XG5jbGFzcyBMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNDUyLCB0eXBlXzQ1Mykge1xuICAgIHN1cGVyKGF0dHJzXzQ1MiwgdHlwZV80NTMgfHwgXCJMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzQ1MiwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDU0LCBzdGF0ZV80NTUgPSB7fSkge1xuICAgIHN0YXRlXzQ1NS52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl80NTQsIHN0YXRlXzQ1NSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3ZhbHVlOiB0aGlzLnZhbHVlfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNDU2KSB7XG4gICAgbGV0IHN0YXRlXzQ1NyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDU2KTtcbiAgICByZXR1cm4gcmVkdWNlcl80NTYucmVkdWNlTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzQ1Nyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzQ1OCkge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc180NTgpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUxpdGVyYWxOdW1lcmljRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzQ1OSwgc3RhdGVfNDYwKSB7XG4gIHJldHVybiBuZXcgTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uKHN0YXRlXzQ2MCk7XG59O1xuZXhwb3J0IHtMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24gYXMgTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9ufTtcbmNsYXNzIExpdGVyYWxSZWdFeHBFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzQ2MSwgdHlwZV80NjIpIHtcbiAgICBzdXBlcihhdHRyc180NjEsIHR5cGVfNDYyIHx8IFwiTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzQ2MSwgXCJwYXR0ZXJuXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInBhdHRlcm5cIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc180NjEsIFwiZmxhZ3NcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZmxhZ3NcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQ2Mywgc3RhdGVfNDY0ID0ge30pIHtcbiAgICBzdGF0ZV80NjQucGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICBzdGF0ZV80NjQuZmxhZ3MgPSB0aGlzLmZsYWdzO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDYzLCBzdGF0ZV80NjQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtwYXR0ZXJuOiB0aGlzLnBhdHRlcm4sIGZsYWdzOiB0aGlzLmZsYWdzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNDY1KSB7XG4gICAgbGV0IHN0YXRlXzQ2NiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDY1KTtcbiAgICByZXR1cm4gcmVkdWNlcl80NjUucmVkdWNlTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb24odGhpcywgc3RhdGVfNDY2KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNDY3KSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNDY3KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzQ2OCwgc3RhdGVfNDY5KSB7XG4gIHJldHVybiBuZXcgTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb24oc3RhdGVfNDY5KTtcbn07XG5leHBvcnQge0xpdGVyYWxSZWdFeHBFeHByZXNzaW9uIGFzIExpdGVyYWxSZWdFeHBFeHByZXNzaW9ufTtcbmNsYXNzIExpdGVyYWxTdHJpbmdFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzQ3MCwgdHlwZV80NzEpIHtcbiAgICBzdXBlcihhdHRyc180NzAsIHR5cGVfNDcxIHx8IFwiTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzQ3MCwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDcyLCBzdGF0ZV80NzMgPSB7fSkge1xuICAgIHN0YXRlXzQ3My52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl80NzIsIHN0YXRlXzQ3Myk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3ZhbHVlOiB0aGlzLnZhbHVlfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNDc0KSB7XG4gICAgbGV0IHN0YXRlXzQ3NSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNDc0KTtcbiAgICByZXR1cm4gcmVkdWNlcl80NzQucmVkdWNlTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24odGhpcywgc3RhdGVfNDc1KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNDc2KSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNDc2KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzQ3Nywgc3RhdGVfNDc4KSB7XG4gIHJldHVybiBuZXcgTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24oc3RhdGVfNDc4KTtcbn07XG5leHBvcnQge0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uIGFzIExpdGVyYWxTdHJpbmdFeHByZXNzaW9ufTtcbmNsYXNzIEFycmF5RXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc180NzksIHR5cGVfNDgwKSB7XG4gICAgc3VwZXIoYXR0cnNfNDc5LCB0eXBlXzQ4MCB8fCBcIkFycmF5RXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNDc5LCBcImVsZW1lbnRzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImVsZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl80ODEsIHN0YXRlXzQ4MiA9IHt9KSB7XG4gICAgc3RhdGVfNDgyLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoYV80ODMgPT4gYV80ODMgaW5zdGFuY2VvZiBTcHJlYWRFbGVtZW50ID8gYV80ODMucmVkdWNlKHJlZHVjZXJfNDgxKSA6IGFfNDgzIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IGFfNDgzLnJlZHVjZShyZWR1Y2VyXzQ4MSkgOiBhXzQ4MyA9PSBudWxsID8gbnVsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfNDgzKSk7XG4gICAgfS5jYWxsKHRoaXMpKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQ4MSwgc3RhdGVfNDgyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZWxlbWVudHM6IHRoaXMuZWxlbWVudHN9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl80ODQpIHtcbiAgICBsZXQgc3RhdGVfNDg1ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl80ODQpO1xuICAgIHJldHVybiByZWR1Y2VyXzQ4NC5yZWR1Y2VBcnJheUV4cHJlc3Npb24odGhpcywgc3RhdGVfNDg1KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNDg2KSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzQ4NikpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fNDg3LCBzdGF0ZV80ODgpIHtcbiAgcmV0dXJuIG5ldyBBcnJheUV4cHJlc3Npb24oc3RhdGVfNDg4KTtcbn07XG5leHBvcnQge0FycmF5RXhwcmVzc2lvbiBhcyBBcnJheUV4cHJlc3Npb259O1xuY2xhc3MgQXJyb3dFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzQ4OSwgdHlwZV80OTApIHtcbiAgICBzdXBlcihhdHRyc180ODksIHR5cGVfNDkwIHx8IFwiQXJyb3dFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc180ODksIFwicGFyYW1zXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInBhcmFtc1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzQ4OSwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQ5MSwgc3RhdGVfNDkyID0ge30pIHtcbiAgICBzdGF0ZV80OTIucGFyYW1zID0gdGhpcy5wYXJhbXMgaW5zdGFuY2VvZiBGb3JtYWxQYXJhbWV0ZXJzID8gdGhpcy5wYXJhbXMucmVkdWNlKHJlZHVjZXJfNDkxKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1zKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzQ5Mi5ib2R5ID0gdGhpcy5ib2R5IGluc3RhbmNlb2YgRnVuY3Rpb25Cb2R5ID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzQ5MSkgOiB0aGlzLmJvZHkgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzQ5MSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl80OTEsIHN0YXRlXzQ5Mik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3BhcmFtczogdGhpcy5wYXJhbXMsIGJvZHk6IHRoaXMuYm9keX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzQ5Mykge1xuICAgIGxldCBzdGF0ZV80OTQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzQ5Myk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNDkzLnJlZHVjZUFycm93RXhwcmVzc2lvbih0aGlzLCBzdGF0ZV80OTQpO1xuICB9XG4gIGV4dGVuZChhdHRyc180OTUpIHtcbiAgICByZXR1cm4gbmV3IEFycm93RXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNDk1KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV80OTYsIHN0YXRlXzQ5Nykge1xuICByZXR1cm4gbmV3IEFycm93RXhwcmVzc2lvbihzdGF0ZV80OTcpO1xufTtcbmV4cG9ydCB7QXJyb3dFeHByZXNzaW9uIGFzIEFycm93RXhwcmVzc2lvbn07XG5jbGFzcyBBcnJvd0V4cHJlc3Npb25FIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzQ5OCwgdHlwZV80OTkpIHtcbiAgICBzdXBlcihhdHRyc180OTgsIHR5cGVfNDk5IHx8IFwiQXJyb3dFeHByZXNzaW9uRVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNDk4LCBcInBhcmFtc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJwYXJhbXNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc180OTgsIFwiYm9keVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJib2R5XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81MDAsIHN0YXRlXzUwMSA9IHt9KSB7XG4gICAgc3RhdGVfNTAxLnBhcmFtcyA9IHRoaXMucGFyYW1zIGluc3RhbmNlb2YgRm9ybWFsUGFyYW1ldGVycyA/IHRoaXMucGFyYW1zLnJlZHVjZShyZWR1Y2VyXzUwMCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtcykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV81MDEuYm9keSA9IHRoaXMuYm9keS5tYXAoYV81MDIgPT4gYV81MDIgaW5zdGFuY2VvZiBUZXJtID8gYV81MDIucmVkdWNlKHJlZHVjZXJfNTAwKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfNTAyKSk7XG4gICAgfS5jYWxsKHRoaXMpKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzUwMCwgc3RhdGVfNTAxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7cGFyYW1zOiB0aGlzLnBhcmFtcywgYm9keTogdGhpcy5ib2R5fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTAzKSB7XG4gICAgbGV0IHN0YXRlXzUwNCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTAzKTtcbiAgICByZXR1cm4gcmVkdWNlcl81MDMucmVkdWNlQXJyb3dFeHByZXNzaW9uRSh0aGlzLCBzdGF0ZV81MDQpO1xuICB9XG4gIGV4dGVuZChhdHRyc181MDUpIHtcbiAgICByZXR1cm4gbmV3IEFycm93RXhwcmVzc2lvbkUoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzUwNSkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQXJyb3dFeHByZXNzaW9uRSA9IGZ1bmN0aW9uICh0ZXJtXzUwNiwgc3RhdGVfNTA3KSB7XG4gIHJldHVybiBuZXcgQXJyb3dFeHByZXNzaW9uRShzdGF0ZV81MDcpO1xufTtcbmV4cG9ydCB7QXJyb3dFeHByZXNzaW9uRSBhcyBBcnJvd0V4cHJlc3Npb25FfTtcbmNsYXNzIEFzc2lnbm1lbnRFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzUwOCwgdHlwZV81MDkpIHtcbiAgICBzdXBlcihhdHRyc181MDgsIHR5cGVfNTA5IHx8IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzUwOCwgXCJiaW5kaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJpbmRpbmdcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181MDgsIFwiZXhwcmVzc2lvblwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJleHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81MTAsIHN0YXRlXzUxMSA9IHt9KSB7XG4gICAgc3RhdGVfNTExLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBCaW5kaW5nSWRlbnRpZmllciA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl81MTApIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgQmluZGluZ1Byb3BlcnR5UHJvcGVydHkgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfNTEwKSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfNTEwKSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfNTEwKSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEFycmF5QmluZGluZyA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl81MTApIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgTWVtYmVyRXhwcmVzc2lvbiA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl81MTApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5iaW5kaW5nKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzUxMS5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl81MTApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTEwLCBzdGF0ZV81MTEpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtiaW5kaW5nOiB0aGlzLmJpbmRpbmcsIGV4cHJlc3Npb246IHRoaXMuZXhwcmVzc2lvbn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzUxMikge1xuICAgIGxldCBzdGF0ZV81MTMgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzUxMik7XG4gICAgcmV0dXJuIHJlZHVjZXJfNTEyLnJlZHVjZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzUxMyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzUxNCkge1xuICAgIHJldHVybiBuZXcgQXNzaWdubWVudEV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzUxNCkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV81MTUsIHN0YXRlXzUxNikge1xuICByZXR1cm4gbmV3IEFzc2lnbm1lbnRFeHByZXNzaW9uKHN0YXRlXzUxNik7XG59O1xuZXhwb3J0IHtBc3NpZ25tZW50RXhwcmVzc2lvbiBhcyBBc3NpZ25tZW50RXhwcmVzc2lvbn07XG5jbGFzcyBCaW5hcnlFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzUxNywgdHlwZV81MTgpIHtcbiAgICBzdXBlcihhdHRyc181MTcsIHR5cGVfNTE4IHx8IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTE3LCBcIm9wZXJhdG9yXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm9wZXJhdG9yXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTE3LCBcImxlZnRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibGVmdFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzUxNywgXCJyaWdodFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJyaWdodFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTE5LCBzdGF0ZV81MjAgPSB7fSkge1xuICAgIHN0YXRlXzUyMC5vcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgc3RhdGVfNTIwLmxlZnQgPSB0aGlzLmxlZnQgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5sZWZ0LnJlZHVjZShyZWR1Y2VyXzUxOSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmxlZnQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfNTIwLnJpZ2h0ID0gdGhpcy5yaWdodCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLnJpZ2h0LnJlZHVjZShyZWR1Y2VyXzUxOSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJpZ2h0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTE5LCBzdGF0ZV81MjApO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtvcGVyYXRvcjogdGhpcy5vcGVyYXRvciwgbGVmdDogdGhpcy5sZWZ0LCByaWdodDogdGhpcy5yaWdodH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzUyMSkge1xuICAgIGxldCBzdGF0ZV81MjIgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzUyMSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNTIxLnJlZHVjZUJpbmFyeUV4cHJlc3Npb24odGhpcywgc3RhdGVfNTIyKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNTIzKSB7XG4gICAgcmV0dXJuIG5ldyBCaW5hcnlFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181MjMpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV81MjQsIHN0YXRlXzUyNSkge1xuICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24oc3RhdGVfNTI1KTtcbn07XG5leHBvcnQge0JpbmFyeUV4cHJlc3Npb24gYXMgQmluYXJ5RXhwcmVzc2lvbn07XG5jbGFzcyBDYWxsRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc181MjYsIHR5cGVfNTI3KSB7XG4gICAgc3VwZXIoYXR0cnNfNTI2LCB0eXBlXzUyNyB8fCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181MjYsIFwiY2FsbGVlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImNhbGxlZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzUyNiwgXCJhcmd1bWVudHNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYXJndW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81MjgsIHN0YXRlXzUyOSA9IHt9KSB7XG4gICAgc3RhdGVfNTI5LmNhbGxlZSA9IHRoaXMuY2FsbGVlIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuY2FsbGVlLnJlZHVjZShyZWR1Y2VyXzUyOCkgOiB0aGlzLmNhbGxlZSBpbnN0YW5jZW9mIFN1cGVyID8gdGhpcy5jYWxsZWUucmVkdWNlKHJlZHVjZXJfNTI4KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuY2FsbGVlKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzUyOS5hcmd1bWVudHMgPSB0aGlzLmFyZ3VtZW50cy5tYXAoYV81MzAgPT4gYV81MzAgaW5zdGFuY2VvZiBTcHJlYWRFbGVtZW50ID8gYV81MzAucmVkdWNlKHJlZHVjZXJfNTI4KSA6IGFfNTMwIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IGFfNTMwLnJlZHVjZShyZWR1Y2VyXzUyOCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShhXzUzMCkpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl81MjgsIHN0YXRlXzUyOSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2NhbGxlZTogdGhpcy5jYWxsZWUsIGFyZ3VtZW50czogdGhpcy5hcmd1bWVudHN9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl81MzEpIHtcbiAgICBsZXQgc3RhdGVfNTMyID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl81MzEpO1xuICAgIHJldHVybiByZWR1Y2VyXzUzMS5yZWR1Y2VDYWxsRXhwcmVzc2lvbih0aGlzLCBzdGF0ZV81MzIpO1xuICB9XG4gIGV4dGVuZChhdHRyc181MzMpIHtcbiAgICByZXR1cm4gbmV3IENhbGxFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181MzMpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fNTM0LCBzdGF0ZV81MzUpIHtcbiAgcmV0dXJuIG5ldyBDYWxsRXhwcmVzc2lvbihzdGF0ZV81MzUpO1xufTtcbmV4cG9ydCB7Q2FsbEV4cHJlc3Npb24gYXMgQ2FsbEV4cHJlc3Npb259O1xuY2xhc3MgQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc181MzYsIHR5cGVfNTM3KSB7XG4gICAgc3VwZXIoYXR0cnNfNTM2LCB0eXBlXzUzNyB8fCBcIkNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzUzNiwgXCJiaW5kaW5nXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJpbmRpbmdcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181MzYsIFwib3BlcmF0b3JcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwib3BlcmF0b3JcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181MzYsIFwiZXhwcmVzc2lvblwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJleHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81MzgsIHN0YXRlXzUzOSA9IHt9KSB7XG4gICAgc3RhdGVfNTM5LmJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBCaW5kaW5nSWRlbnRpZmllciA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl81MzgpIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgTWVtYmVyRXhwcmVzc2lvbiA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl81MzgpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5iaW5kaW5nKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzUzOS5vcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgc3RhdGVfNTM5LmV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5leHByZXNzaW9uLnJlZHVjZShyZWR1Y2VyXzUzOCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4cHJlc3Npb24pKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl81MzgsIHN0YXRlXzUzOSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmRpbmc6IHRoaXMuYmluZGluZywgb3BlcmF0b3I6IHRoaXMub3BlcmF0b3IsIGV4cHJlc3Npb246IHRoaXMuZXhwcmVzc2lvbn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzU0MCkge1xuICAgIGxldCBzdGF0ZV81NDEgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU0MCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNTQwLnJlZHVjZUNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24odGhpcywgc3RhdGVfNTQxKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNTQyKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181NDIpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV81NDMsIHN0YXRlXzU0NCkge1xuICByZXR1cm4gbmV3IENvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24oc3RhdGVfNTQ0KTtcbn07XG5leHBvcnQge0NvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24gYXMgQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbn07XG5jbGFzcyBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gZXh0ZW5kcyBNZW1iZXJFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNTQ1LCB0eXBlXzU0Nikge1xuICAgIHN1cGVyKGF0dHJzXzU0NSwgdHlwZV81NDYgfHwgXCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU0NSwgXCJleHByZXNzaW9uXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU0Nywgc3RhdGVfNTQ4ID0ge30pIHtcbiAgICBzdGF0ZV81NDguZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLmV4cHJlc3Npb24ucmVkdWNlKHJlZHVjZXJfNTQ3KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwcmVzc2lvbikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU0Nywgc3RhdGVfNTQ4KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZXhwcmVzc2lvbjogdGhpcy5leHByZXNzaW9ufSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTQ5KSB7XG4gICAgbGV0IHN0YXRlXzU1MCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTQ5KTtcbiAgICByZXR1cm4gcmVkdWNlcl81NDkucmVkdWNlQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzU1MCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzU1MSkge1xuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181NTEpKTtcbiAgfVxufVxuTWVtYmVyRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzU1Miwgc3RhdGVfNTUzKSB7XG4gIHJldHVybiBuZXcgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKHN0YXRlXzU1Myk7XG59O1xuZXhwb3J0IHtDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gYXMgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9ufTtcbmNsYXNzIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc181NTQsIHR5cGVfNTU1KSB7XG4gICAgc3VwZXIoYXR0cnNfNTU0LCB0eXBlXzU1NSB8fCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTU0LCBcInRlc3RcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidGVzdFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU1NCwgXCJjb25zZXF1ZW50XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImNvbnNlcXVlbnRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181NTQsIFwiYWx0ZXJuYXRlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImFsdGVybmF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTU2LCBzdGF0ZV81NTcgPSB7fSkge1xuICAgIHN0YXRlXzU1Ny50ZXN0ID0gdGhpcy50ZXN0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMudGVzdC5yZWR1Y2UocmVkdWNlcl81NTYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXN0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzU1Ny5jb25zZXF1ZW50ID0gdGhpcy5jb25zZXF1ZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuY29uc2VxdWVudC5yZWR1Y2UocmVkdWNlcl81NTYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25zZXF1ZW50KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzU1Ny5hbHRlcm5hdGUgPSB0aGlzLmFsdGVybmF0ZSBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLmFsdGVybmF0ZS5yZWR1Y2UocmVkdWNlcl81NTYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5hbHRlcm5hdGUpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl81NTYsIHN0YXRlXzU1Nyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3Rlc3Q6IHRoaXMudGVzdCwgY29uc2VxdWVudDogdGhpcy5jb25zZXF1ZW50LCBhbHRlcm5hdGU6IHRoaXMuYWx0ZXJuYXRlfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTU4KSB7XG4gICAgbGV0IHN0YXRlXzU1OSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTU4KTtcbiAgICByZXR1cm4gcmVkdWNlcl81NTgucmVkdWNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzU1OSk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzU2MCkge1xuICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181NjApKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzU2MSwgc3RhdGVfNTYyKSB7XG4gIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uKHN0YXRlXzU2Mik7XG59O1xuZXhwb3J0IHtDb25kaXRpb25hbEV4cHJlc3Npb24gYXMgQ29uZGl0aW9uYWxFeHByZXNzaW9ufTtcbmNsYXNzIEZ1bmN0aW9uRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc181NjMsIHR5cGVfNTY0KSB7XG4gICAgc3VwZXIoYXR0cnNfNTYzLCB0eXBlXzU2NCB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTYzLCBcIm5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU2MywgXCJpc0dlbmVyYXRvclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJpc0dlbmVyYXRvclwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU2MywgXCJwYXJhbXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicGFyYW1zXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTYzLCBcImJvZHlcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYm9keVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTY1LCBzdGF0ZV81NjYgPSB7fSkge1xuICAgIHN0YXRlXzU2Ni5uYW1lID0gdGhpcy5uYW1lID09IG51bGwgPyBudWxsIDogdGhpcy5uYW1lIGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLm5hbWUucmVkdWNlKHJlZHVjZXJfNTY1KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMubmFtZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV81NjYuaXNHZW5lcmF0b3IgPSB0aGlzLmlzR2VuZXJhdG9yO1xuICAgIHN0YXRlXzU2Ni5wYXJhbXMgPSB0aGlzLnBhcmFtcyBpbnN0YW5jZW9mIEZvcm1hbFBhcmFtZXRlcnMgPyB0aGlzLnBhcmFtcy5yZWR1Y2UocmVkdWNlcl81NjUpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbXMpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfNTY2LmJvZHkgPSB0aGlzLmJvZHkgaW5zdGFuY2VvZiBGdW5jdGlvbkJvZHkgPyB0aGlzLmJvZHkucmVkdWNlKHJlZHVjZXJfNTY1KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU2NSwgc3RhdGVfNTY2KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lLCBpc0dlbmVyYXRvcjogdGhpcy5pc0dlbmVyYXRvciwgcGFyYW1zOiB0aGlzLnBhcmFtcywgYm9keTogdGhpcy5ib2R5fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTY3KSB7XG4gICAgbGV0IHN0YXRlXzU2OCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTY3KTtcbiAgICByZXR1cm4gcmVkdWNlcl81NjcucmVkdWNlRnVuY3Rpb25FeHByZXNzaW9uKHRoaXMsIHN0YXRlXzU2OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzU2OSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc181NjkpKTtcbiAgfVxufVxuRXhwcmVzc2lvbi5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzU3MCwgc3RhdGVfNTcxKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHN0YXRlXzU3MSk7XG59O1xuZXhwb3J0IHtGdW5jdGlvbkV4cHJlc3Npb24gYXMgRnVuY3Rpb25FeHByZXNzaW9ufTtcbmNsYXNzIEZ1bmN0aW9uRXhwcmVzc2lvbkUgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNTcyLCB0eXBlXzU3Mykge1xuICAgIHN1cGVyKGF0dHJzXzU3MiwgdHlwZV81NzMgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25FXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181NzIsIFwibmFtZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJuYW1lXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTcyLCBcImlzR2VuZXJhdG9yXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImlzR2VuZXJhdG9yXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNTcyLCBcInBhcmFtc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJwYXJhbXNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181NzIsIFwiYm9keVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJib2R5XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81NzQsIHN0YXRlXzU3NSA9IHt9KSB7XG4gICAgc3RhdGVfNTc1Lm5hbWUgPSB0aGlzLm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLm5hbWUgaW5zdGFuY2VvZiBCaW5kaW5nSWRlbnRpZmllciA/IHRoaXMubmFtZS5yZWR1Y2UocmVkdWNlcl81NzQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzU3NS5pc0dlbmVyYXRvciA9IHRoaXMuaXNHZW5lcmF0b3I7XG4gICAgc3RhdGVfNTc1LnBhcmFtcyA9IHRoaXMucGFyYW1zIGluc3RhbmNlb2YgRm9ybWFsUGFyYW1ldGVycyA/IHRoaXMucGFyYW1zLnJlZHVjZShyZWR1Y2VyXzU3NCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtcykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV81NzUuYm9keSA9IHRoaXMuYm9keS5tYXAoYV81NzYgPT4gYV81NzYgaW5zdGFuY2VvZiBUZXJtID8gYV81NzYucmVkdWNlKHJlZHVjZXJfNTc0KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfNTc2KSk7XG4gICAgfS5jYWxsKHRoaXMpKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU3NCwgc3RhdGVfNTc1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lLCBpc0dlbmVyYXRvcjogdGhpcy5pc0dlbmVyYXRvciwgcGFyYW1zOiB0aGlzLnBhcmFtcywgYm9keTogdGhpcy5ib2R5fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTc3KSB7XG4gICAgbGV0IHN0YXRlXzU3OCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTc3KTtcbiAgICByZXR1cm4gcmVkdWNlcl81NzcucmVkdWNlRnVuY3Rpb25FeHByZXNzaW9uRSh0aGlzLCBzdGF0ZV81NzgpO1xuICB9XG4gIGV4dGVuZChhdHRyc181NzkpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbkUoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzU3OSkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRnVuY3Rpb25FeHByZXNzaW9uRSA9IGZ1bmN0aW9uICh0ZXJtXzU4MCwgc3RhdGVfNTgxKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uRShzdGF0ZV81ODEpO1xufTtcbmV4cG9ydCB7RnVuY3Rpb25FeHByZXNzaW9uRSBhcyBGdW5jdGlvbkV4cHJlc3Npb25FfTtcbmNsYXNzIElkZW50aWZpZXJFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzU4MiwgdHlwZV81ODMpIHtcbiAgICBzdXBlcihhdHRyc181ODIsIHR5cGVfNTgzIHx8IFwiSWRlbnRpZmllckV4cHJlc3Npb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU4MiwgXCJuYW1lXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU4NCwgc3RhdGVfNTg1ID0ge30pIHtcbiAgICBzdGF0ZV81ODUubmFtZSA9IHRoaXMubmFtZTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzU4NCwgc3RhdGVfNTg1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bmFtZTogdGhpcy5uYW1lfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTg2KSB7XG4gICAgbGV0IHN0YXRlXzU4NyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTg2KTtcbiAgICByZXR1cm4gcmVkdWNlcl81ODYucmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24odGhpcywgc3RhdGVfNTg3KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNTg4KSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNTg4KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VJZGVudGlmaWVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzU4OSwgc3RhdGVfNTkwKSB7XG4gIHJldHVybiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24oc3RhdGVfNTkwKTtcbn07XG5leHBvcnQge0lkZW50aWZpZXJFeHByZXNzaW9uIGFzIElkZW50aWZpZXJFeHByZXNzaW9ufTtcbmNsYXNzIE5ld0V4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNTkxLCB0eXBlXzU5Mikge1xuICAgIHN1cGVyKGF0dHJzXzU5MSwgdHlwZV81OTIgfHwgXCJOZXdFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc181OTEsIFwiY2FsbGVlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImNhbGxlZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzU5MSwgXCJhcmd1bWVudHNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYXJndW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl81OTMsIHN0YXRlXzU5NCA9IHt9KSB7XG4gICAgc3RhdGVfNTk0LmNhbGxlZSA9IHRoaXMuY2FsbGVlIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuY2FsbGVlLnJlZHVjZShyZWR1Y2VyXzU5MykgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmNhbGxlZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV81OTQuYXJndW1lbnRzID0gdGhpcy5hcmd1bWVudHMubWFwKGFfNTk1ID0+IGFfNTk1IGluc3RhbmNlb2YgU3ByZWFkRWxlbWVudCA/IGFfNTk1LnJlZHVjZShyZWR1Y2VyXzU5MykgOiBhXzU5NSBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyBhXzU5NS5yZWR1Y2UocmVkdWNlcl81OTMpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV81OTUpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTkzLCBzdGF0ZV81OTQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtjYWxsZWU6IHRoaXMuY2FsbGVlLCBhcmd1bWVudHM6IHRoaXMuYXJndW1lbnRzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNTk2KSB7XG4gICAgbGV0IHN0YXRlXzU5NyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNTk2KTtcbiAgICByZXR1cm4gcmVkdWNlcl81OTYucmVkdWNlTmV3RXhwcmVzc2lvbih0aGlzLCBzdGF0ZV81OTcpO1xuICB9XG4gIGV4dGVuZChhdHRyc181OTgpIHtcbiAgICByZXR1cm4gbmV3IE5ld0V4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzU5OCkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzU5OSwgc3RhdGVfNjAwKSB7XG4gIHJldHVybiBuZXcgTmV3RXhwcmVzc2lvbihzdGF0ZV82MDApO1xufTtcbmV4cG9ydCB7TmV3RXhwcmVzc2lvbiBhcyBOZXdFeHByZXNzaW9ufTtcbmNsYXNzIE5ld1RhcmdldEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNjAxLCB0eXBlXzYwMikge1xuICAgIHN1cGVyKGF0dHJzXzYwMSwgdHlwZV82MDIgfHwgXCJOZXdUYXJnZXRFeHByZXNzaW9uXCIpO1xuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzYwMywgc3RhdGVfNjA0ID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzYwMywgc3RhdGVfNjA0KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNjA1KSB7XG4gICAgbGV0IHN0YXRlXzYwNiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjA1KTtcbiAgICByZXR1cm4gcmVkdWNlcl82MDUucmVkdWNlTmV3VGFyZ2V0RXhwcmVzc2lvbih0aGlzLCBzdGF0ZV82MDYpO1xuICB9XG4gIGV4dGVuZChhdHRyc182MDcpIHtcbiAgICByZXR1cm4gbmV3IE5ld1RhcmdldEV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzYwNykpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlTmV3VGFyZ2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzYwOCwgc3RhdGVfNjA5KSB7XG4gIHJldHVybiBuZXcgTmV3VGFyZ2V0RXhwcmVzc2lvbihzdGF0ZV82MDkpO1xufTtcbmV4cG9ydCB7TmV3VGFyZ2V0RXhwcmVzc2lvbiBhcyBOZXdUYXJnZXRFeHByZXNzaW9ufTtcbmNsYXNzIE9iamVjdEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNjEwLCB0eXBlXzYxMSkge1xuICAgIHN1cGVyKGF0dHJzXzYxMCwgdHlwZV82MTEgfHwgXCJPYmplY3RFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182MTAsIFwicHJvcGVydGllc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJwcm9wZXJ0aWVzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl82MTIsIHN0YXRlXzYxMyA9IHt9KSB7XG4gICAgc3RhdGVfNjEzLnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXMubWFwKGFfNjE0ID0+IGFfNjE0IGluc3RhbmNlb2YgT2JqZWN0UHJvcGVydHkgPyBhXzYxNC5yZWR1Y2UocmVkdWNlcl82MTIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV82MTQpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjEyLCBzdGF0ZV82MTMpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXN9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl82MTUpIHtcbiAgICBsZXQgc3RhdGVfNjE2ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl82MTUpO1xuICAgIHJldHVybiByZWR1Y2VyXzYxNS5yZWR1Y2VPYmplY3RFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzYxNik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzYxNykge1xuICAgIHJldHVybiBuZXcgT2JqZWN0RXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjE3KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VPYmplY3RFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fNjE4LCBzdGF0ZV82MTkpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RFeHByZXNzaW9uKHN0YXRlXzYxOSk7XG59O1xuZXhwb3J0IHtPYmplY3RFeHByZXNzaW9uIGFzIE9iamVjdEV4cHJlc3Npb259O1xuY2xhc3MgVW5hcnlFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzYyMCwgdHlwZV82MjEpIHtcbiAgICBzdXBlcihhdHRyc182MjAsIHR5cGVfNjIxIHx8IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182MjAsIFwib3BlcmF0b3JcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwib3BlcmF0b3JcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182MjAsIFwib3BlcmFuZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJvcGVyYW5kXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl82MjIsIHN0YXRlXzYyMyA9IHt9KSB7XG4gICAgc3RhdGVfNjIzLm9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICBzdGF0ZV82MjMub3BlcmFuZCA9IHRoaXMub3BlcmFuZCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLm9wZXJhbmQucmVkdWNlKHJlZHVjZXJfNjIyKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMub3BlcmFuZCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzYyMiwgc3RhdGVfNjIzKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7b3BlcmF0b3I6IHRoaXMub3BlcmF0b3IsIG9wZXJhbmQ6IHRoaXMub3BlcmFuZH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzYyNCkge1xuICAgIGxldCBzdGF0ZV82MjUgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzYyNCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNjI0LnJlZHVjZVVuYXJ5RXhwcmVzc2lvbih0aGlzLCBzdGF0ZV82MjUpO1xuICB9XG4gIGV4dGVuZChhdHRyc182MjYpIHtcbiAgICByZXR1cm4gbmV3IFVuYXJ5RXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjI2KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VVbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV82MjcsIHN0YXRlXzYyOCkge1xuICByZXR1cm4gbmV3IFVuYXJ5RXhwcmVzc2lvbihzdGF0ZV82MjgpO1xufTtcbmV4cG9ydCB7VW5hcnlFeHByZXNzaW9uIGFzIFVuYXJ5RXhwcmVzc2lvbn07XG5jbGFzcyBTdGF0aWNNZW1iZXJFeHByZXNzaW9uIGV4dGVuZHMgTWVtYmVyRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzYyOSwgdHlwZV82MzApIHtcbiAgICBzdXBlcihhdHRyc182MjksIHR5cGVfNjMwIHx8IFwiU3RhdGljTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNjI5LCBcInByb3BlcnR5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl82MzEsIHN0YXRlXzYzMiA9IHt9KSB7XG4gICAgc3RhdGVfNjMyLnByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzYzMSwgc3RhdGVfNjMyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7cHJvcGVydHk6IHRoaXMucHJvcGVydHl9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl82MzMpIHtcbiAgICBsZXQgc3RhdGVfNjM0ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl82MzMpO1xuICAgIHJldHVybiByZWR1Y2VyXzYzMy5yZWR1Y2VTdGF0aWNNZW1iZXJFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzYzNCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzYzNSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljTWVtYmVyRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjM1KSk7XG4gIH1cbn1cbk1lbWJlckV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fNjM2LCBzdGF0ZV82MzcpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNNZW1iZXJFeHByZXNzaW9uKHN0YXRlXzYzNyk7XG59O1xuZXhwb3J0IHtTdGF0aWNNZW1iZXJFeHByZXNzaW9uIGFzIFN0YXRpY01lbWJlckV4cHJlc3Npb259O1xuY2xhc3MgVGVtcGxhdGVFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzYzOCwgdHlwZV82MzkpIHtcbiAgICBzdXBlcihhdHRyc182MzgsIHR5cGVfNjM5IHx8IFwiVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182MzgsIFwidGFnXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInRhZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzYzOCwgXCJlbGVtZW50c1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJlbGVtZW50c1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjQwLCBzdGF0ZV82NDEgPSB7fSkge1xuICAgIHN0YXRlXzY0MS50YWcgPSB0aGlzLnRhZyA9PSBudWxsID8gbnVsbCA6IHRoaXMudGFnIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMudGFnLnJlZHVjZShyZWR1Y2VyXzY0MCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnRhZykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV82NDEuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcChhXzY0MiA9PiBhXzY0MiBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyBhXzY0Mi5yZWR1Y2UocmVkdWNlcl82NDApIDogYV82NDIgaW5zdGFuY2VvZiBUZW1wbGF0ZUVsZW1lbnQgPyBhXzY0Mi5yZWR1Y2UocmVkdWNlcl82NDApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV82NDIpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjQwLCBzdGF0ZV82NDEpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt0YWc6IHRoaXMudGFnLCBlbGVtZW50czogdGhpcy5lbGVtZW50c30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzY0Mykge1xuICAgIGxldCBzdGF0ZV82NDQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY0Myk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNjQzLnJlZHVjZVRlbXBsYXRlRXhwcmVzc2lvbih0aGlzLCBzdGF0ZV82NDQpO1xuICB9XG4gIGV4dGVuZChhdHRyc182NDUpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjQ1KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VUZW1wbGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV82NDYsIHN0YXRlXzY0Nykge1xuICByZXR1cm4gbmV3IFRlbXBsYXRlRXhwcmVzc2lvbihzdGF0ZV82NDcpO1xufTtcbmV4cG9ydCB7VGVtcGxhdGVFeHByZXNzaW9uIGFzIFRlbXBsYXRlRXhwcmVzc2lvbn07XG5jbGFzcyBUaGlzRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc182NDgsIHR5cGVfNjQ5KSB7XG4gICAgc3VwZXIoYXR0cnNfNjQ4LCB0eXBlXzY0OSB8fCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182NDgsIFwic3R4XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInN0eFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjUwLCBzdGF0ZV82NTEgPSB7fSkge1xuICAgIHN0YXRlXzY1MS5zdHggPSB0aGlzLnN0eDtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY1MCwgc3RhdGVfNjUxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7c3R4OiB0aGlzLnN0eH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzY1Mikge1xuICAgIGxldCBzdGF0ZV82NTMgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY1Mik7XG4gICAgcmV0dXJuIHJlZHVjZXJfNjUyLnJlZHVjZVRoaXNFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzY1Myk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzY1NCkge1xuICAgIHJldHVybiBuZXcgVGhpc0V4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzY1NCkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlVGhpc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV82NTUsIHN0YXRlXzY1Nikge1xuICByZXR1cm4gbmV3IFRoaXNFeHByZXNzaW9uKHN0YXRlXzY1Nik7XG59O1xuZXhwb3J0IHtUaGlzRXhwcmVzc2lvbiBhcyBUaGlzRXhwcmVzc2lvbn07XG5jbGFzcyBVcGRhdGVFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzY1NywgdHlwZV82NTgpIHtcbiAgICBzdXBlcihhdHRyc182NTcsIHR5cGVfNjU4IHx8IFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNjU3LCBcImlzUHJlZml4XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImlzUHJlZml4XCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNjU3LCBcIm9wZXJhdG9yXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm9wZXJhdG9yXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNjU3LCBcIm9wZXJhbmRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwib3BlcmFuZFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjU5LCBzdGF0ZV82NjAgPSB7fSkge1xuICAgIHN0YXRlXzY2MC5pc1ByZWZpeCA9IHRoaXMuaXNQcmVmaXg7XG4gICAgc3RhdGVfNjYwLm9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICBzdGF0ZV82NjAub3BlcmFuZCA9IHRoaXMub3BlcmFuZCBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5vcGVyYW5kLnJlZHVjZShyZWR1Y2VyXzY1OSkgOiB0aGlzLm9wZXJhbmQgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uID8gdGhpcy5vcGVyYW5kLnJlZHVjZShyZWR1Y2VyXzY1OSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm9wZXJhbmQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl82NTksIHN0YXRlXzY2MCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2lzUHJlZml4OiB0aGlzLmlzUHJlZml4LCBvcGVyYXRvcjogdGhpcy5vcGVyYXRvciwgb3BlcmFuZDogdGhpcy5vcGVyYW5kfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNjYxKSB7XG4gICAgbGV0IHN0YXRlXzY2MiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjYxKTtcbiAgICByZXR1cm4gcmVkdWNlcl82NjEucmVkdWNlVXBkYXRlRXhwcmVzc2lvbih0aGlzLCBzdGF0ZV82NjIpO1xuICB9XG4gIGV4dGVuZChhdHRyc182NjMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZUV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzY2MykpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXJtXzY2NCwgc3RhdGVfNjY1KSB7XG4gIHJldHVybiBuZXcgVXBkYXRlRXhwcmVzc2lvbihzdGF0ZV82NjUpO1xufTtcbmV4cG9ydCB7VXBkYXRlRXhwcmVzc2lvbiBhcyBVcGRhdGVFeHByZXNzaW9ufTtcbmNsYXNzIFlpZWxkRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc182NjYsIHR5cGVfNjY3KSB7XG4gICAgc3VwZXIoYXR0cnNfNjY2LCB0eXBlXzY2NyB8fCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNjY2LCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjY4LCBzdGF0ZV82NjkgPSB7fSkge1xuICAgIHN0YXRlXzY2OS5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uID09IG51bGwgPyBudWxsIDogdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl82NjgpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjY4LCBzdGF0ZV82NjkpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl82NzApIHtcbiAgICBsZXQgc3RhdGVfNjcxID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl82NzApO1xuICAgIHJldHVybiByZWR1Y2VyXzY3MC5yZWR1Y2VZaWVsZEV4cHJlc3Npb24odGhpcywgc3RhdGVfNjcxKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNjcyKSB7XG4gICAgcmV0dXJuIG5ldyBZaWVsZEV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzY3MikpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlWWllbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRlcm1fNjczLCBzdGF0ZV82NzQpIHtcbiAgcmV0dXJuIG5ldyBZaWVsZEV4cHJlc3Npb24oc3RhdGVfNjc0KTtcbn07XG5leHBvcnQge1lpZWxkRXhwcmVzc2lvbiBhcyBZaWVsZEV4cHJlc3Npb259O1xuY2xhc3MgWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzY3NSwgdHlwZV82NzYpIHtcbiAgICBzdXBlcihhdHRyc182NzUsIHR5cGVfNjc2IHx8IFwiWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182NzUsIFwiZXhwcmVzc2lvblwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJleHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl82NzcsIHN0YXRlXzY3OCA9IHt9KSB7XG4gICAgc3RhdGVfNjc4LmV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5leHByZXNzaW9uLnJlZHVjZShyZWR1Y2VyXzY3NykgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmV4cHJlc3Npb24pKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl82NzcsIHN0YXRlXzY3OCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2V4cHJlc3Npb246IHRoaXMuZXhwcmVzc2lvbn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzY3OSkge1xuICAgIGxldCBzdGF0ZV82ODAgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY3OSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNjc5LnJlZHVjZVlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbih0aGlzLCBzdGF0ZV82ODApO1xuICB9XG4gIGV4dGVuZChhdHRyc182ODEpIHtcbiAgICByZXR1cm4gbmV3IFlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjgxKSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV82ODIsIHN0YXRlXzY4Mykge1xuICByZXR1cm4gbmV3IFlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbihzdGF0ZV82ODMpO1xufTtcbmV4cG9ydCB7WWllbGRHZW5lcmF0b3JFeHByZXNzaW9uIGFzIFlpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbn07XG5jbGFzcyBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihhdHRyc182ODQsIHR5cGVfNjg1KSB7XG4gICAgc3VwZXIoYXR0cnNfNjg0LCB0eXBlXzY4NSB8fCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc182ODQsIFwiaW5uZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaW5uZXJcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY4Niwgc3RhdGVfNjg3ID0ge30pIHtcbiAgICBzdGF0ZV82ODcuaW5uZXIgPSB0aGlzLmlubmVyO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjg2LCBzdGF0ZV82ODcpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtpbm5lcjogdGhpcy5pbm5lcn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzY4OCkge1xuICAgIGxldCBzdGF0ZV82ODkgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzY4OCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNjg4LnJlZHVjZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHRoaXMsIHN0YXRlXzY4OSk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzY5MCkge1xuICAgIHJldHVybiBuZXcgUGFyZW50aGVzaXplZEV4cHJlc3Npb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzY5MCkpO1xuICB9XG59XG5FeHByZXNzaW9uLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodGVybV82OTEsIHN0YXRlXzY5Mikge1xuICByZXR1cm4gbmV3IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHN0YXRlXzY5Mik7XG59O1xuZXhwb3J0IHtQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBhcyBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbn07XG5jbGFzcyBCbG9ja1N0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzY5MywgdHlwZV82OTQpIHtcbiAgICBzdXBlcihhdHRyc182OTMsIHR5cGVfNjk0IHx8IFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzY5MywgXCJibG9ja1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJibG9ja1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjk1LCBzdGF0ZV82OTYgPSB7fSkge1xuICAgIHN0YXRlXzY5Ni5ibG9jayA9IHRoaXMuYmxvY2sgaW5zdGFuY2VvZiBCbG9jayA/IHRoaXMuYmxvY2sucmVkdWNlKHJlZHVjZXJfNjk1KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYmxvY2spKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl82OTUsIHN0YXRlXzY5Nik7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2Jsb2NrOiB0aGlzLmJsb2NrfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNjk3KSB7XG4gICAgbGV0IHN0YXRlXzY5OCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNjk3KTtcbiAgICByZXR1cm4gcmVkdWNlcl82OTcucmVkdWNlQmxvY2tTdGF0ZW1lbnQodGhpcywgc3RhdGVfNjk4KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNjk5KSB7XG4gICAgcmV0dXJuIG5ldyBCbG9ja1N0YXRlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNjk5KSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fNzAwLCBzdGF0ZV83MDEpIHtcbiAgcmV0dXJuIG5ldyBCbG9ja1N0YXRlbWVudChzdGF0ZV83MDEpO1xufTtcbmV4cG9ydCB7QmxvY2tTdGF0ZW1lbnQgYXMgQmxvY2tTdGF0ZW1lbnR9O1xuY2xhc3MgQnJlYWtTdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc183MDIsIHR5cGVfNzAzKSB7XG4gICAgc3VwZXIoYXR0cnNfNzAyLCB0eXBlXzcwMyB8fCBcIkJyZWFrU3RhdGVtZW50XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc183MDIsIFwibGFiZWxcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibGFiZWxcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzcwNCwgc3RhdGVfNzA1ID0ge30pIHtcbiAgICBzdGF0ZV83MDUubGFiZWwgPSB0aGlzLmxhYmVsID09IG51bGwgPyBudWxsIDogdGhpcy5sYWJlbDtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzcwNCwgc3RhdGVfNzA1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7bGFiZWw6IHRoaXMubGFiZWx9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83MDYpIHtcbiAgICBsZXQgc3RhdGVfNzA3ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83MDYpO1xuICAgIHJldHVybiByZWR1Y2VyXzcwNi5yZWR1Y2VCcmVha1N0YXRlbWVudCh0aGlzLCBzdGF0ZV83MDcpO1xuICB9XG4gIGV4dGVuZChhdHRyc183MDgpIHtcbiAgICByZXR1cm4gbmV3IEJyZWFrU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc183MDgpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83MDksIHN0YXRlXzcxMCkge1xuICByZXR1cm4gbmV3IEJyZWFrU3RhdGVtZW50KHN0YXRlXzcxMCk7XG59O1xuZXhwb3J0IHtCcmVha1N0YXRlbWVudCBhcyBCcmVha1N0YXRlbWVudH07XG5jbGFzcyBDb250aW51ZVN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzcxMSwgdHlwZV83MTIpIHtcbiAgICBzdXBlcihhdHRyc183MTEsIHR5cGVfNzEyIHx8IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzcxMSwgXCJsYWJlbFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJsYWJlbFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzEzLCBzdGF0ZV83MTQgPSB7fSkge1xuICAgIHN0YXRlXzcxNC5sYWJlbCA9IHRoaXMubGFiZWwgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmxhYmVsO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzEzLCBzdGF0ZV83MTQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtsYWJlbDogdGhpcy5sYWJlbH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzcxNSkge1xuICAgIGxldCBzdGF0ZV83MTYgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzcxNSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNzE1LnJlZHVjZUNvbnRpbnVlU3RhdGVtZW50KHRoaXMsIHN0YXRlXzcxNik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzcxNykge1xuICAgIHJldHVybiBuZXcgQ29udGludWVTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzcxNykpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzcxOCwgc3RhdGVfNzE5KSB7XG4gIHJldHVybiBuZXcgQ29udGludWVTdGF0ZW1lbnQoc3RhdGVfNzE5KTtcbn07XG5leHBvcnQge0NvbnRpbnVlU3RhdGVtZW50IGFzIENvbnRpbnVlU3RhdGVtZW50fTtcbmNsYXNzIERlYnVnZ2VyU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfNzIwLCB0eXBlXzcyMSkge1xuICAgIHN1cGVyKGF0dHJzXzcyMCwgdHlwZV83MjEgfHwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl83MjIsIHN0YXRlXzcyMyA9IHt9KSB7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl83MjIsIHN0YXRlXzcyMyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzcyNCkge1xuICAgIGxldCBzdGF0ZV83MjUgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzcyNCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNzI0LnJlZHVjZURlYnVnZ2VyU3RhdGVtZW50KHRoaXMsIHN0YXRlXzcyNSk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzcyNikge1xuICAgIHJldHVybiBuZXcgRGVidWdnZXJTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzcyNikpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzcyNywgc3RhdGVfNzI4KSB7XG4gIHJldHVybiBuZXcgRGVidWdnZXJTdGF0ZW1lbnQoc3RhdGVfNzI4KTtcbn07XG5leHBvcnQge0RlYnVnZ2VyU3RhdGVtZW50IGFzIERlYnVnZ2VyU3RhdGVtZW50fTtcbmNsYXNzIERvV2hpbGVTdGF0ZW1lbnQgZXh0ZW5kcyBJdGVyYXRpb25TdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc183MjksIHR5cGVfNzMwKSB7XG4gICAgc3VwZXIoYXR0cnNfNzI5LCB0eXBlXzczMCB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzcyOSwgXCJ0ZXN0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInRlc3RcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzczMSwgc3RhdGVfNzMyID0ge30pIHtcbiAgICBzdGF0ZV83MzIudGVzdCA9IHRoaXMudGVzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLnRlc3QucmVkdWNlKHJlZHVjZXJfNzMxKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMudGVzdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzczMSwgc3RhdGVfNzMyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7dGVzdDogdGhpcy50ZXN0fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNzMzKSB7XG4gICAgbGV0IHN0YXRlXzczNCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzMzKTtcbiAgICByZXR1cm4gcmVkdWNlcl83MzMucmVkdWNlRG9XaGlsZVN0YXRlbWVudCh0aGlzLCBzdGF0ZV83MzQpO1xuICB9XG4gIGV4dGVuZChhdHRyc183MzUpIHtcbiAgICByZXR1cm4gbmV3IERvV2hpbGVTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzczNSkpO1xuICB9XG59XG5JdGVyYXRpb25TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fNzM2LCBzdGF0ZV83MzcpIHtcbiAgcmV0dXJuIG5ldyBEb1doaWxlU3RhdGVtZW50KHN0YXRlXzczNyk7XG59O1xuZXhwb3J0IHtEb1doaWxlU3RhdGVtZW50IGFzIERvV2hpbGVTdGF0ZW1lbnR9O1xuY2xhc3MgRW1wdHlTdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc183MzgsIHR5cGVfNzM5KSB7XG4gICAgc3VwZXIoYXR0cnNfNzM4LCB0eXBlXzczOSB8fCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc0MCwgc3RhdGVfNzQxID0ge30pIHtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc0MCwgc3RhdGVfNzQxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfNzQyKSB7XG4gICAgbGV0IHN0YXRlXzc0MyA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzQyKTtcbiAgICByZXR1cm4gcmVkdWNlcl83NDIucmVkdWNlRW1wdHlTdGF0ZW1lbnQodGhpcywgc3RhdGVfNzQzKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNzQ0KSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eVN0YXRlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNzQ0KSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fNzQ1LCBzdGF0ZV83NDYpIHtcbiAgcmV0dXJuIG5ldyBFbXB0eVN0YXRlbWVudChzdGF0ZV83NDYpO1xufTtcbmV4cG9ydCB7RW1wdHlTdGF0ZW1lbnQgYXMgRW1wdHlTdGF0ZW1lbnR9O1xuY2xhc3MgRXhwcmVzc2lvblN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzc0NywgdHlwZV83NDgpIHtcbiAgICBzdXBlcihhdHRyc183NDcsIHR5cGVfNzQ4IHx8IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNzQ3LCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzQ5LCBzdGF0ZV83NTAgPSB7fSkge1xuICAgIHN0YXRlXzc1MC5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl83NDkpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzQ5LCBzdGF0ZV83NTApO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83NTEpIHtcbiAgICBsZXQgc3RhdGVfNzUyID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83NTEpO1xuICAgIHJldHVybiByZWR1Y2VyXzc1MS5yZWR1Y2VFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMsIHN0YXRlXzc1Mik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzc1Mykge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNzUzKSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83NTQsIHN0YXRlXzc1NSkge1xuICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RhdGVfNzU1KTtcbn07XG5leHBvcnQge0V4cHJlc3Npb25TdGF0ZW1lbnQgYXMgRXhwcmVzc2lvblN0YXRlbWVudH07XG5jbGFzcyBGb3JJblN0YXRlbWVudCBleHRlbmRzIEl0ZXJhdGlvblN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzc1NiwgdHlwZV83NTcpIHtcbiAgICBzdXBlcihhdHRyc183NTYsIHR5cGVfNzU3IHx8IFwiRm9ySW5TdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc1NiwgXCJsZWZ0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImxlZnRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc183NTYsIFwicmlnaHRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicmlnaHRcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc1OCwgc3RhdGVfNzU5ID0ge30pIHtcbiAgICBzdGF0ZV83NTkubGVmdCA9IHRoaXMubGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlRGVjbGFyYXRpb24gPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzU4KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzU4KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIEFycmF5QmluZGluZyA/IHRoaXMubGVmdC5yZWR1Y2UocmVkdWNlcl83NTgpIDogdGhpcy5sZWZ0IGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzU4KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzU4KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMubGVmdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV83NTkucmlnaHQgPSB0aGlzLnJpZ2h0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMucmlnaHQucmVkdWNlKHJlZHVjZXJfNzU4KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucmlnaHQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl83NTgsIHN0YXRlXzc1OSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2xlZnQ6IHRoaXMubGVmdCwgcmlnaHQ6IHRoaXMucmlnaHR9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83NjApIHtcbiAgICBsZXQgc3RhdGVfNzYxID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83NjApO1xuICAgIHJldHVybiByZWR1Y2VyXzc2MC5yZWR1Y2VGb3JJblN0YXRlbWVudCh0aGlzLCBzdGF0ZV83NjEpO1xuICB9XG4gIGV4dGVuZChhdHRyc183NjIpIHtcbiAgICByZXR1cm4gbmV3IEZvckluU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc183NjIpKTtcbiAgfVxufVxuSXRlcmF0aW9uU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRm9ySW5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83NjMsIHN0YXRlXzc2NCkge1xuICByZXR1cm4gbmV3IEZvckluU3RhdGVtZW50KHN0YXRlXzc2NCk7XG59O1xuZXhwb3J0IHtGb3JJblN0YXRlbWVudCBhcyBGb3JJblN0YXRlbWVudH07XG5jbGFzcyBGb3JPZlN0YXRlbWVudCBleHRlbmRzIEl0ZXJhdGlvblN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzc2NSwgdHlwZV83NjYpIHtcbiAgICBzdXBlcihhdHRyc183NjUsIHR5cGVfNzY2IHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc2NSwgXCJsZWZ0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImxlZnRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc183NjUsIFwicmlnaHRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicmlnaHRcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc2Nywgc3RhdGVfNzY4ID0ge30pIHtcbiAgICBzdGF0ZV83NjgubGVmdCA9IHRoaXMubGVmdCBpbnN0YW5jZW9mIFZhcmlhYmxlRGVjbGFyYXRpb24gPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzY3KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzY3KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIEFycmF5QmluZGluZyA/IHRoaXMubGVmdC5yZWR1Y2UocmVkdWNlcl83NjcpIDogdGhpcy5sZWZ0IGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzY3KSA6IHRoaXMubGVmdCBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gPyB0aGlzLmxlZnQucmVkdWNlKHJlZHVjZXJfNzY3KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMubGVmdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV83NjgucmlnaHQgPSB0aGlzLnJpZ2h0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMucmlnaHQucmVkdWNlKHJlZHVjZXJfNzY3KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucmlnaHQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl83NjcsIHN0YXRlXzc2OCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2xlZnQ6IHRoaXMubGVmdCwgcmlnaHQ6IHRoaXMucmlnaHR9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83NjkpIHtcbiAgICBsZXQgc3RhdGVfNzcwID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83NjkpO1xuICAgIHJldHVybiByZWR1Y2VyXzc2OS5yZWR1Y2VGb3JPZlN0YXRlbWVudCh0aGlzLCBzdGF0ZV83NzApO1xuICB9XG4gIGV4dGVuZChhdHRyc183NzEpIHtcbiAgICByZXR1cm4gbmV3IEZvck9mU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc183NzEpKTtcbiAgfVxufVxuSXRlcmF0aW9uU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRm9yT2ZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83NzIsIHN0YXRlXzc3Mykge1xuICByZXR1cm4gbmV3IEZvck9mU3RhdGVtZW50KHN0YXRlXzc3Myk7XG59O1xuZXhwb3J0IHtGb3JPZlN0YXRlbWVudCBhcyBGb3JPZlN0YXRlbWVudH07XG5jbGFzcyBGb3JTdGF0ZW1lbnQgZXh0ZW5kcyBJdGVyYXRpb25TdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc183NzQsIHR5cGVfNzc1KSB7XG4gICAgc3VwZXIoYXR0cnNfNzc0LCB0eXBlXzc3NSB8fCBcIkZvclN0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNzc0LCBcImluaXRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaW5pdFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc3NCwgXCJ0ZXN0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInRlc3RcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc183NzQsIFwidXBkYXRlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInVwZGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzc2LCBzdGF0ZV83NzcgPSB7fSkge1xuICAgIHN0YXRlXzc3Ny5pbml0ID0gdGhpcy5pbml0ID09IG51bGwgPyBudWxsIDogdGhpcy5pbml0IGluc3RhbmNlb2YgVmFyaWFibGVEZWNsYXJhdGlvbiA/IHRoaXMuaW5pdC5yZWR1Y2UocmVkdWNlcl83NzYpIDogdGhpcy5pbml0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuaW5pdC5yZWR1Y2UocmVkdWNlcl83NzYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzc3Ny50ZXN0ID0gdGhpcy50ZXN0ID09IG51bGwgPyBudWxsIDogdGhpcy50ZXN0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMudGVzdC5yZWR1Y2UocmVkdWNlcl83NzYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXN0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzc3Ny51cGRhdGUgPSB0aGlzLnVwZGF0ZSA9PSBudWxsID8gbnVsbCA6IHRoaXMudXBkYXRlIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMudXBkYXRlLnJlZHVjZShyZWR1Y2VyXzc3NikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnVwZGF0ZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc3Niwgc3RhdGVfNzc3KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7aW5pdDogdGhpcy5pbml0LCB0ZXN0OiB0aGlzLnRlc3QsIHVwZGF0ZTogdGhpcy51cGRhdGV9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83NzgpIHtcbiAgICBsZXQgc3RhdGVfNzc5ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83NzgpO1xuICAgIHJldHVybiByZWR1Y2VyXzc3OC5yZWR1Y2VGb3JTdGF0ZW1lbnQodGhpcywgc3RhdGVfNzc5KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfNzgwKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzc4MCkpO1xuICB9XG59XG5JdGVyYXRpb25TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83ODEsIHN0YXRlXzc4Mikge1xuICByZXR1cm4gbmV3IEZvclN0YXRlbWVudChzdGF0ZV83ODIpO1xufTtcbmV4cG9ydCB7Rm9yU3RhdGVtZW50IGFzIEZvclN0YXRlbWVudH07XG5jbGFzcyBJZlN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzc4MywgdHlwZV83ODQpIHtcbiAgICBzdXBlcihhdHRyc183ODMsIHR5cGVfNzg0IHx8IFwiSWZTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc4MywgXCJ0ZXN0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInRlc3RcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc183ODMsIFwiY29uc2VxdWVudFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJjb25zZXF1ZW50XCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfNzgzLCBcImFsdGVybmF0ZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJhbHRlcm5hdGVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc4NSwgc3RhdGVfNzg2ID0ge30pIHtcbiAgICBzdGF0ZV83ODYudGVzdCA9IHRoaXMudGVzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLnRlc3QucmVkdWNlKHJlZHVjZXJfNzg1KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMudGVzdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV83ODYuY29uc2VxdWVudCA9IHRoaXMuY29uc2VxdWVudCBpbnN0YW5jZW9mIFN0YXRlbWVudCA/IHRoaXMuY29uc2VxdWVudC5yZWR1Y2UocmVkdWNlcl83ODUpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25zZXF1ZW50KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzc4Ni5hbHRlcm5hdGUgPSB0aGlzLmFsdGVybmF0ZSA9PSBudWxsID8gbnVsbCA6IHRoaXMuYWx0ZXJuYXRlIGluc3RhbmNlb2YgU3RhdGVtZW50ID8gdGhpcy5hbHRlcm5hdGUucmVkdWNlKHJlZHVjZXJfNzg1KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYWx0ZXJuYXRlKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfNzg1LCBzdGF0ZV83ODYpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt0ZXN0OiB0aGlzLnRlc3QsIGNvbnNlcXVlbnQ6IHRoaXMuY29uc2VxdWVudCwgYWx0ZXJuYXRlOiB0aGlzLmFsdGVybmF0ZX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzc4Nykge1xuICAgIGxldCBzdGF0ZV83ODggPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc4Nyk7XG4gICAgcmV0dXJuIHJlZHVjZXJfNzg3LnJlZHVjZUlmU3RhdGVtZW50KHRoaXMsIHN0YXRlXzc4OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzc4OSkge1xuICAgIHJldHVybiBuZXcgSWZTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzc4OSkpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzc5MCwgc3RhdGVfNzkxKSB7XG4gIHJldHVybiBuZXcgSWZTdGF0ZW1lbnQoc3RhdGVfNzkxKTtcbn07XG5leHBvcnQge0lmU3RhdGVtZW50IGFzIElmU3RhdGVtZW50fTtcbmNsYXNzIExhYmVsZWRTdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc183OTIsIHR5cGVfNzkzKSB7XG4gICAgc3VwZXIoYXR0cnNfNzkyLCB0eXBlXzc5MyB8fCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc5MiwgXCJsYWJlbFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJsYWJlbFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzc5MiwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzc5NCwgc3RhdGVfNzk1ID0ge30pIHtcbiAgICBzdGF0ZV83OTUubGFiZWwgPSB0aGlzLmxhYmVsO1xuICAgIHN0YXRlXzc5NS5ib2R5ID0gdGhpcy5ib2R5IGluc3RhbmNlb2YgU3RhdGVtZW50ID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzc5NCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl83OTQsIHN0YXRlXzc5NSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2xhYmVsOiB0aGlzLmxhYmVsLCBib2R5OiB0aGlzLmJvZHl9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl83OTYpIHtcbiAgICBsZXQgc3RhdGVfNzk3ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl83OTYpO1xuICAgIHJldHVybiByZWR1Y2VyXzc5Ni5yZWR1Y2VMYWJlbGVkU3RhdGVtZW50KHRoaXMsIHN0YXRlXzc5Nyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzc5OCkge1xuICAgIHJldHVybiBuZXcgTGFiZWxlZFN0YXRlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfNzk4KSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV83OTksIHN0YXRlXzgwMCkge1xuICByZXR1cm4gbmV3IExhYmVsZWRTdGF0ZW1lbnQoc3RhdGVfODAwKTtcbn07XG5leHBvcnQge0xhYmVsZWRTdGF0ZW1lbnQgYXMgTGFiZWxlZFN0YXRlbWVudH07XG5jbGFzcyBSZXR1cm5TdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc184MDEsIHR5cGVfODAyKSB7XG4gICAgc3VwZXIoYXR0cnNfODAxLCB0eXBlXzgwMiB8fCBcIlJldHVyblN0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODAxLCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODAzLCBzdGF0ZV84MDQgPSB7fSkge1xuICAgIHN0YXRlXzgwNC5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uID09IG51bGwgPyBudWxsIDogdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl84MDMpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODAzLCBzdGF0ZV84MDQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl84MDUpIHtcbiAgICBsZXQgc3RhdGVfODA2ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84MDUpO1xuICAgIHJldHVybiByZWR1Y2VyXzgwNS5yZWR1Y2VSZXR1cm5TdGF0ZW1lbnQodGhpcywgc3RhdGVfODA2KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfODA3KSB7XG4gICAgcmV0dXJuIG5ldyBSZXR1cm5TdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzgwNykpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV84MDgsIHN0YXRlXzgwOSkge1xuICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudChzdGF0ZV84MDkpO1xufTtcbmV4cG9ydCB7UmV0dXJuU3RhdGVtZW50IGFzIFJldHVyblN0YXRlbWVudH07XG5jbGFzcyBTd2l0Y2hTdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc184MTAsIHR5cGVfODExKSB7XG4gICAgc3VwZXIoYXR0cnNfODEwLCB0eXBlXzgxMSB8fCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODEwLCBcImRpc2NyaW1pbmFudFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJkaXNjcmltaW5hbnRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184MTAsIFwiY2FzZXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiY2FzZXNcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzgxMiwgc3RhdGVfODEzID0ge30pIHtcbiAgICBzdGF0ZV84MTMuZGlzY3JpbWluYW50ID0gdGhpcy5kaXNjcmltaW5hbnQgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5kaXNjcmltaW5hbnQucmVkdWNlKHJlZHVjZXJfODEyKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGlzY3JpbWluYW50KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzgxMy5jYXNlcyA9IHRoaXMuY2FzZXMubWFwKGFfODE0ID0+IGFfODE0IGluc3RhbmNlb2YgU3dpdGNoQ2FzZSA/IGFfODE0LnJlZHVjZShyZWR1Y2VyXzgxMikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeShhXzgxNCkpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl84MTIsIHN0YXRlXzgxMyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2Rpc2NyaW1pbmFudDogdGhpcy5kaXNjcmltaW5hbnQsIGNhc2VzOiB0aGlzLmNhc2VzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfODE1KSB7XG4gICAgbGV0IHN0YXRlXzgxNiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODE1KTtcbiAgICByZXR1cm4gcmVkdWNlcl84MTUucmVkdWNlU3dpdGNoU3RhdGVtZW50KHRoaXMsIHN0YXRlXzgxNik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzgxNykge1xuICAgIHJldHVybiBuZXcgU3dpdGNoU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184MTcpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fODE4LCBzdGF0ZV84MTkpIHtcbiAgcmV0dXJuIG5ldyBTd2l0Y2hTdGF0ZW1lbnQoc3RhdGVfODE5KTtcbn07XG5leHBvcnQge1N3aXRjaFN0YXRlbWVudCBhcyBTd2l0Y2hTdGF0ZW1lbnR9O1xuY2xhc3MgU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc184MjAsIHR5cGVfODIxKSB7XG4gICAgc3VwZXIoYXR0cnNfODIwLCB0eXBlXzgyMSB8fCBcIlN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184MjAsIFwiZGlzY3JpbWluYW50XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImRpc2NyaW1pbmFudFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzgyMCwgXCJwcmVEZWZhdWx0Q2FzZXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicHJlRGVmYXVsdENhc2VzXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODIwLCBcImRlZmF1bHRDYXNlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImRlZmF1bHRDYXNlXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODIwLCBcInBvc3REZWZhdWx0Q2FzZXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwicG9zdERlZmF1bHRDYXNlc1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODIyLCBzdGF0ZV84MjMgPSB7fSkge1xuICAgIHN0YXRlXzgyMy5kaXNjcmltaW5hbnQgPSB0aGlzLmRpc2NyaW1pbmFudCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLmRpc2NyaW1pbmFudC5yZWR1Y2UocmVkdWNlcl84MjIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kaXNjcmltaW5hbnQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfODIzLnByZURlZmF1bHRDYXNlcyA9IHRoaXMucHJlRGVmYXVsdENhc2VzLm1hcChhXzgyNCA9PiBhXzgyNCBpbnN0YW5jZW9mIFN3aXRjaENhc2UgPyBhXzgyNC5yZWR1Y2UocmVkdWNlcl84MjIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV84MjQpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIHN0YXRlXzgyMy5kZWZhdWx0Q2FzZSA9IHRoaXMuZGVmYXVsdENhc2UgaW5zdGFuY2VvZiBTd2l0Y2hEZWZhdWx0ID8gdGhpcy5kZWZhdWx0Q2FzZS5yZWR1Y2UocmVkdWNlcl84MjIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZWZhdWx0Q2FzZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV84MjMucG9zdERlZmF1bHRDYXNlcyA9IHRoaXMucG9zdERlZmF1bHRDYXNlcy5tYXAoYV84MjUgPT4gYV84MjUgaW5zdGFuY2VvZiBTd2l0Y2hDYXNlID8gYV84MjUucmVkdWNlKHJlZHVjZXJfODIyKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfODI1KSk7XG4gICAgfS5jYWxsKHRoaXMpKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzgyMiwgc3RhdGVfODIzKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZGlzY3JpbWluYW50OiB0aGlzLmRpc2NyaW1pbmFudCwgcHJlRGVmYXVsdENhc2VzOiB0aGlzLnByZURlZmF1bHRDYXNlcywgZGVmYXVsdENhc2U6IHRoaXMuZGVmYXVsdENhc2UsIHBvc3REZWZhdWx0Q2FzZXM6IHRoaXMucG9zdERlZmF1bHRDYXNlc30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzgyNikge1xuICAgIGxldCBzdGF0ZV84MjcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzgyNik7XG4gICAgcmV0dXJuIHJlZHVjZXJfODI2LnJlZHVjZVN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0KHRoaXMsIHN0YXRlXzgyNyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzgyOCkge1xuICAgIHJldHVybiBuZXcgU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzgyOCkpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdCA9IGZ1bmN0aW9uICh0ZXJtXzgyOSwgc3RhdGVfODMwKSB7XG4gIHJldHVybiBuZXcgU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQoc3RhdGVfODMwKTtcbn07XG5leHBvcnQge1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0IGFzIFN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0fTtcbmNsYXNzIFRocm93U3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfODMxLCB0eXBlXzgzMikge1xuICAgIHN1cGVyKGF0dHJzXzgzMSwgdHlwZV84MzIgfHwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODMxLCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODMzLCBzdGF0ZV84MzQgPSB7fSkge1xuICAgIHN0YXRlXzgzNC5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl84MzMpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODMzLCBzdGF0ZV84MzQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl84MzUpIHtcbiAgICBsZXQgc3RhdGVfODM2ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84MzUpO1xuICAgIHJldHVybiByZWR1Y2VyXzgzNS5yZWR1Y2VUaHJvd1N0YXRlbWVudCh0aGlzLCBzdGF0ZV84MzYpO1xuICB9XG4gIGV4dGVuZChhdHRyc184MzcpIHtcbiAgICByZXR1cm4gbmV3IFRocm93U3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184MzcpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV84MzgsIHN0YXRlXzgzOSkge1xuICByZXR1cm4gbmV3IFRocm93U3RhdGVtZW50KHN0YXRlXzgzOSk7XG59O1xuZXhwb3J0IHtUaHJvd1N0YXRlbWVudCBhcyBUaHJvd1N0YXRlbWVudH07XG5jbGFzcyBUcnlDYXRjaFN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzg0MCwgdHlwZV84NDEpIHtcbiAgICBzdXBlcihhdHRyc184NDAsIHR5cGVfODQxIHx8IFwiVHJ5Q2F0Y2hTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg0MCwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184NDAsIFwiY2F0Y2hDbGF1c2VcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiY2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg0Miwgc3RhdGVfODQzID0ge30pIHtcbiAgICBzdGF0ZV84NDMuYm9keSA9IHRoaXMuYm9keSBpbnN0YW5jZW9mIEJsb2NrID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzg0MikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfODQzLmNhdGNoQ2xhdXNlID0gdGhpcy5jYXRjaENsYXVzZSBpbnN0YW5jZW9mIENhdGNoQ2xhdXNlID8gdGhpcy5jYXRjaENsYXVzZS5yZWR1Y2UocmVkdWNlcl84NDIpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jYXRjaENsYXVzZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg0Miwgc3RhdGVfODQzKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7Ym9keTogdGhpcy5ib2R5LCBjYXRjaENsYXVzZTogdGhpcy5jYXRjaENsYXVzZX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzg0NCkge1xuICAgIGxldCBzdGF0ZV84NDUgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg0NCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfODQ0LnJlZHVjZVRyeUNhdGNoU3RhdGVtZW50KHRoaXMsIHN0YXRlXzg0NSk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzg0Nikge1xuICAgIHJldHVybiBuZXcgVHJ5Q2F0Y2hTdGF0ZW1lbnQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzg0NikpO1xuICB9XG59XG5TdGF0ZW1lbnQuQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VUcnlDYXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzg0Nywgc3RhdGVfODQ4KSB7XG4gIHJldHVybiBuZXcgVHJ5Q2F0Y2hTdGF0ZW1lbnQoc3RhdGVfODQ4KTtcbn07XG5leHBvcnQge1RyeUNhdGNoU3RhdGVtZW50IGFzIFRyeUNhdGNoU3RhdGVtZW50fTtcbmNsYXNzIFRyeUZpbmFsbHlTdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc184NDksIHR5cGVfODUwKSB7XG4gICAgc3VwZXIoYXR0cnNfODQ5LCB0eXBlXzg1MCB8fCBcIlRyeUZpbmFsbHlTdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg0OSwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184NDksIFwiY2F0Y2hDbGF1c2VcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiY2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184NDksIFwiZmluYWxpemVyXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImZpbmFsaXplclwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODUxLCBzdGF0ZV84NTIgPSB7fSkge1xuICAgIHN0YXRlXzg1Mi5ib2R5ID0gdGhpcy5ib2R5IGluc3RhbmNlb2YgQmxvY2sgPyB0aGlzLmJvZHkucmVkdWNlKHJlZHVjZXJfODUxKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV84NTIuY2F0Y2hDbGF1c2UgPSB0aGlzLmNhdGNoQ2xhdXNlID09IG51bGwgPyBudWxsIDogdGhpcy5jYXRjaENsYXVzZSBpbnN0YW5jZW9mIENhdGNoQ2xhdXNlID8gdGhpcy5jYXRjaENsYXVzZS5yZWR1Y2UocmVkdWNlcl84NTEpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jYXRjaENsYXVzZSkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV84NTIuZmluYWxpemVyID0gdGhpcy5maW5hbGl6ZXIgaW5zdGFuY2VvZiBCbG9jayA/IHRoaXMuZmluYWxpemVyLnJlZHVjZShyZWR1Y2VyXzg1MSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmZpbmFsaXplcikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg1MSwgc3RhdGVfODUyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7Ym9keTogdGhpcy5ib2R5LCBjYXRjaENsYXVzZTogdGhpcy5jYXRjaENsYXVzZSwgZmluYWxpemVyOiB0aGlzLmZpbmFsaXplcn0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzg1Mykge1xuICAgIGxldCBzdGF0ZV84NTQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg1Myk7XG4gICAgcmV0dXJuIHJlZHVjZXJfODUzLnJlZHVjZVRyeUZpbmFsbHlTdGF0ZW1lbnQodGhpcywgc3RhdGVfODU0KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfODU1KSB7XG4gICAgcmV0dXJuIG5ldyBUcnlGaW5hbGx5U3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184NTUpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlVHJ5RmluYWxseVN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzg1Niwgc3RhdGVfODU3KSB7XG4gIHJldHVybiBuZXcgVHJ5RmluYWxseVN0YXRlbWVudChzdGF0ZV84NTcpO1xufTtcbmV4cG9ydCB7VHJ5RmluYWxseVN0YXRlbWVudCBhcyBUcnlGaW5hbGx5U3RhdGVtZW50fTtcbmNsYXNzIFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3RvcihhdHRyc184NTgsIHR5cGVfODU5KSB7XG4gICAgc3VwZXIoYXR0cnNfODU4LCB0eXBlXzg1OSB8fCBcIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg1OCwgXCJkZWNsYXJhdGlvblwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJkZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODYwLCBzdGF0ZV84NjEgPSB7fSkge1xuICAgIHN0YXRlXzg2MS5kZWNsYXJhdGlvbiA9IHRoaXMuZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBWYXJpYWJsZURlY2xhcmF0aW9uID8gdGhpcy5kZWNsYXJhdGlvbi5yZWR1Y2UocmVkdWNlcl84NjApIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZWNsYXJhdGlvbikpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg2MCwgc3RhdGVfODYxKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7ZGVjbGFyYXRpb246IHRoaXMuZGVjbGFyYXRpb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl84NjIpIHtcbiAgICBsZXQgc3RhdGVfODYzID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84NjIpO1xuICAgIHJldHVybiByZWR1Y2VyXzg2Mi5yZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRoaXMsIHN0YXRlXzg2Myk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzg2NCkge1xuICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfODY0KSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV84NjUsIHN0YXRlXzg2Nikge1xuICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQoc3RhdGVfODY2KTtcbn07XG5leHBvcnQge1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQgYXMgVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudH07XG5jbGFzcyBXaXRoU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfODY3LCB0eXBlXzg2OCkge1xuICAgIHN1cGVyKGF0dHJzXzg2NywgdHlwZV84NjggfHwgXCJXaXRoU3RhdGVtZW50XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184NjcsIFwib2JqZWN0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm9iamVjdFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg2NywgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg2OSwgc3RhdGVfODcwID0ge30pIHtcbiAgICBzdGF0ZV84NzAub2JqZWN0ID0gdGhpcy5vYmplY3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uID8gdGhpcy5vYmplY3QucmVkdWNlKHJlZHVjZXJfODY5KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMub2JqZWN0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzg3MC5ib2R5ID0gdGhpcy5ib2R5IGluc3RhbmNlb2YgU3RhdGVtZW50ID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzg2OSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl84NjksIHN0YXRlXzg3MCk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe29iamVjdDogdGhpcy5vYmplY3QsIGJvZHk6IHRoaXMuYm9keX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzg3MSkge1xuICAgIGxldCBzdGF0ZV84NzIgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg3MSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfODcxLnJlZHVjZVdpdGhTdGF0ZW1lbnQodGhpcywgc3RhdGVfODcyKTtcbiAgfVxuICBleHRlbmQoYXR0cnNfODczKSB7XG4gICAgcmV0dXJuIG5ldyBXaXRoU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184NzMpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uICh0ZXJtXzg3NCwgc3RhdGVfODc1KSB7XG4gIHJldHVybiBuZXcgV2l0aFN0YXRlbWVudChzdGF0ZV84NzUpO1xufTtcbmV4cG9ydCB7V2l0aFN0YXRlbWVudCBhcyBXaXRoU3RhdGVtZW50fTtcbmNsYXNzIFdoaWxlU3RhdGVtZW50IGV4dGVuZHMgSXRlcmF0aW9uU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfODc2LCB0eXBlXzg3Nykge1xuICAgIHN1cGVyKGF0dHJzXzg3NiwgdHlwZV84NzcgfHwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfODc2LCBcInRlc3RcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidGVzdFwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfODc4LCBzdGF0ZV84NzkgPSB7fSkge1xuICAgIHN0YXRlXzg3OS50ZXN0ID0gdGhpcy50ZXN0IGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMudGVzdC5yZWR1Y2UocmVkdWNlcl84NzgpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXN0KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODc4LCBzdGF0ZV84NzkpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt0ZXN0OiB0aGlzLnRlc3R9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl84ODApIHtcbiAgICBsZXQgc3RhdGVfODgxID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84ODApO1xuICAgIHJldHVybiByZWR1Y2VyXzg4MC5yZWR1Y2VXaGlsZVN0YXRlbWVudCh0aGlzLCBzdGF0ZV84ODEpO1xuICB9XG4gIGV4dGVuZChhdHRyc184ODIpIHtcbiAgICByZXR1cm4gbmV3IFdoaWxlU3RhdGVtZW50KE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184ODIpKTtcbiAgfVxufVxuSXRlcmF0aW9uU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodGVybV84ODMsIHN0YXRlXzg4NCkge1xuICByZXR1cm4gbmV3IFdoaWxlU3RhdGVtZW50KHN0YXRlXzg4NCk7XG59O1xuZXhwb3J0IHtXaGlsZVN0YXRlbWVudCBhcyBXaGlsZVN0YXRlbWVudH07XG5jbGFzcyBQcmFnbWEgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfODg1LCB0eXBlXzg4Nikge1xuICAgIHN1cGVyKGF0dHJzXzg4NSwgdHlwZV84ODYgfHwgXCJQcmFnbWFcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg4NSwgXCJraW5kXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImtpbmRcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc184ODUsIFwiaXRlbXNcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaXRlbXNcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg4Nywgc3RhdGVfODg4ID0ge30pIHtcbiAgICBzdGF0ZV84ODgua2luZCA9IHRoaXMua2luZDtcbiAgICBzdGF0ZV84ODguaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODg3LCBzdGF0ZV84ODgpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtraW5kOiB0aGlzLmtpbmQsIGl0ZW1zOiB0aGlzLml0ZW1zfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfODg5KSB7XG4gICAgbGV0IHN0YXRlXzg5MCA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODg5KTtcbiAgICByZXR1cm4gcmVkdWNlcl84ODkucmVkdWNlUHJhZ21hKHRoaXMsIHN0YXRlXzg5MCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzg5MSkge1xuICAgIHJldHVybiBuZXcgUHJhZ21hKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc184OTEpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVByYWdtYSA9IGZ1bmN0aW9uICh0ZXJtXzg5Miwgc3RhdGVfODkzKSB7XG4gIHJldHVybiBuZXcgUHJhZ21hKHN0YXRlXzg5Myk7XG59O1xuZXhwb3J0IHtQcmFnbWEgYXMgUHJhZ21hfTtcbmNsYXNzIEJsb2NrIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzg5NCwgdHlwZV84OTUpIHtcbiAgICBzdXBlcihhdHRyc184OTQsIHR5cGVfODk1IHx8IFwiQmxvY2tcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzg5NCwgXCJzdGF0ZW1lbnRzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInN0YXRlbWVudHNcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzg5Niwgc3RhdGVfODk3ID0ge30pIHtcbiAgICBzdGF0ZV84OTcuc3RhdGVtZW50cyA9IHRoaXMuc3RhdGVtZW50cy5tYXAoYV84OTggPT4gYV84OTggaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBhXzg5OC5yZWR1Y2UocmVkdWNlcl84OTYpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV84OTgpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfODk2LCBzdGF0ZV84OTcpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtzdGF0ZW1lbnRzOiB0aGlzLnN0YXRlbWVudHN9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl84OTkpIHtcbiAgICBsZXQgc3RhdGVfOTAwID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl84OTkpO1xuICAgIHJldHVybiByZWR1Y2VyXzg5OS5yZWR1Y2VCbG9jayh0aGlzLCBzdGF0ZV85MDApO1xuICB9XG4gIGV4dGVuZChhdHRyc185MDEpIHtcbiAgICByZXR1cm4gbmV3IEJsb2NrKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc185MDEpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUJsb2NrID0gZnVuY3Rpb24gKHRlcm1fOTAyLCBzdGF0ZV85MDMpIHtcbiAgcmV0dXJuIG5ldyBCbG9jayhzdGF0ZV85MDMpO1xufTtcbmV4cG9ydCB7QmxvY2sgYXMgQmxvY2t9O1xuY2xhc3MgQ2F0Y2hDbGF1c2UgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfOTA0LCB0eXBlXzkwNSkge1xuICAgIHN1cGVyKGF0dHJzXzkwNCwgdHlwZV85MDUgfHwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTA0LCBcImJpbmRpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYmluZGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzkwNCwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkwNiwgc3RhdGVfOTA3ID0ge30pIHtcbiAgICBzdGF0ZV85MDcuYmluZGluZyA9IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfOTA2KSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIEFycmF5QmluZGluZyA/IHRoaXMuYmluZGluZy5yZWR1Y2UocmVkdWNlcl85MDYpIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfOTA2KSA6IHRoaXMuYmluZGluZyBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfOTA2KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYmluZGluZykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV85MDcuYm9keSA9IHRoaXMuYm9keSBpbnN0YW5jZW9mIEJsb2NrID8gdGhpcy5ib2R5LnJlZHVjZShyZWR1Y2VyXzkwNikgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl85MDYsIHN0YXRlXzkwNyk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmRpbmc6IHRoaXMuYmluZGluZywgYm9keTogdGhpcy5ib2R5fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfOTA4KSB7XG4gICAgbGV0IHN0YXRlXzkwOSA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTA4KTtcbiAgICByZXR1cm4gcmVkdWNlcl85MDgucmVkdWNlQ2F0Y2hDbGF1c2UodGhpcywgc3RhdGVfOTA5KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfOTEwKSB7XG4gICAgcmV0dXJuIG5ldyBDYXRjaENsYXVzZShPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfOTEwKSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VDYXRjaENsYXVzZSA9IGZ1bmN0aW9uICh0ZXJtXzkxMSwgc3RhdGVfOTEyKSB7XG4gIHJldHVybiBuZXcgQ2F0Y2hDbGF1c2Uoc3RhdGVfOTEyKTtcbn07XG5leHBvcnQge0NhdGNoQ2xhdXNlIGFzIENhdGNoQ2xhdXNlfTtcbmNsYXNzIERpcmVjdGl2ZSBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc185MTMsIHR5cGVfOTE0KSB7XG4gICAgc3VwZXIoYXR0cnNfOTEzLCB0eXBlXzkxNCB8fCBcIkRpcmVjdGl2ZVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTEzLCBcInJhd1ZhbHVlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInJhd1ZhbHVlXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl85MTUsIHN0YXRlXzkxNiA9IHt9KSB7XG4gICAgc3RhdGVfOTE2LnJhd1ZhbHVlID0gdGhpcy5yYXdWYWx1ZTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkxNSwgc3RhdGVfOTE2KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7cmF3VmFsdWU6IHRoaXMucmF3VmFsdWV9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl85MTcpIHtcbiAgICBsZXQgc3RhdGVfOTE4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl85MTcpO1xuICAgIHJldHVybiByZWR1Y2VyXzkxNy5yZWR1Y2VEaXJlY3RpdmUodGhpcywgc3RhdGVfOTE4KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfOTE5KSB7XG4gICAgcmV0dXJuIG5ldyBEaXJlY3RpdmUoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzkxOSkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRGlyZWN0aXZlID0gZnVuY3Rpb24gKHRlcm1fOTIwLCBzdGF0ZV85MjEpIHtcbiAgcmV0dXJuIG5ldyBEaXJlY3RpdmUoc3RhdGVfOTIxKTtcbn07XG5leHBvcnQge0RpcmVjdGl2ZSBhcyBEaXJlY3RpdmV9O1xuY2xhc3MgRm9ybWFsUGFyYW1ldGVycyBleHRlbmRzIFRlcm0ge1xuICBjb25zdHJ1Y3RvcihhdHRyc185MjIsIHR5cGVfOTIzKSB7XG4gICAgc3VwZXIoYXR0cnNfOTIyLCB0eXBlXzkyMyB8fCBcIkZvcm1hbFBhcmFtZXRlcnNcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzkyMiwgXCJpdGVtc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzkyMiwgXCJyZXN0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInJlc3RcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkyNCwgc3RhdGVfOTI1ID0ge30pIHtcbiAgICBzdGF0ZV85MjUuaXRlbXMgPSB0aGlzLml0ZW1zLm1hcChhXzkyNiA9PiBhXzkyNiBpbnN0YW5jZW9mIE9iamVjdEJpbmRpbmcgPyBhXzkyNi5yZWR1Y2UocmVkdWNlcl85MjQpIDogYV85MjYgaW5zdGFuY2VvZiBBcnJheUJpbmRpbmcgPyBhXzkyNi5yZWR1Y2UocmVkdWNlcl85MjQpIDogYV85MjYgaW5zdGFuY2VvZiBCaW5kaW5nSWRlbnRpZmllciA/IGFfOTI2LnJlZHVjZShyZWR1Y2VyXzkyNCkgOiBhXzkyNiBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gPyBhXzkyNi5yZWR1Y2UocmVkdWNlcl85MjQpIDogYV85MjYgaW5zdGFuY2VvZiBCaW5kaW5nV2l0aERlZmF1bHQgPyBhXzkyNi5yZWR1Y2UocmVkdWNlcl85MjQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85MjYpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIHN0YXRlXzkyNS5yZXN0ID0gdGhpcy5yZXN0ID09IG51bGwgPyBudWxsIDogdGhpcy5yZXN0IGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLnJlc3QucmVkdWNlKHJlZHVjZXJfOTI0KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucmVzdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkyNCwgc3RhdGVfOTI1KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7aXRlbXM6IHRoaXMuaXRlbXMsIHJlc3Q6IHRoaXMucmVzdH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzkyNykge1xuICAgIGxldCBzdGF0ZV85MjggPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkyNyk7XG4gICAgcmV0dXJuIHJlZHVjZXJfOTI3LnJlZHVjZUZvcm1hbFBhcmFtZXRlcnModGhpcywgc3RhdGVfOTI4KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfOTI5KSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYWxQYXJhbWV0ZXJzKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc185MjkpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUZvcm1hbFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodGVybV85MzAsIHN0YXRlXzkzMSkge1xuICByZXR1cm4gbmV3IEZvcm1hbFBhcmFtZXRlcnMoc3RhdGVfOTMxKTtcbn07XG5leHBvcnQge0Zvcm1hbFBhcmFtZXRlcnMgYXMgRm9ybWFsUGFyYW1ldGVyc307XG5jbGFzcyBGdW5jdGlvbkJvZHkgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfOTMyLCB0eXBlXzkzMykge1xuICAgIHN1cGVyKGF0dHJzXzkzMiwgdHlwZV85MzMgfHwgXCJGdW5jdGlvbkJvZHlcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzkzMiwgXCJkaXJlY3RpdmVzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImRpcmVjdGl2ZXNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185MzIsIFwic3RhdGVtZW50c1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJzdGF0ZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl85MzQsIHN0YXRlXzkzNSA9IHt9KSB7XG4gICAgc3RhdGVfOTM1LmRpcmVjdGl2ZXMgPSB0aGlzLmRpcmVjdGl2ZXMubWFwKGFfOTM2ID0+IGFfOTM2KTtcbiAgICBzdGF0ZV85MzUuc3RhdGVtZW50cyA9IHRoaXMuc3RhdGVtZW50cy5tYXAoYV85MzcgPT4gYV85MzcgaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBhXzkzNy5yZWR1Y2UocmVkdWNlcl85MzQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85MzcpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTM0LCBzdGF0ZV85MzUpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsIHN0YXRlbWVudHM6IHRoaXMuc3RhdGVtZW50c30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzkzOCkge1xuICAgIGxldCBzdGF0ZV85MzkgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzkzOCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfOTM4LnJlZHVjZUZ1bmN0aW9uQm9keSh0aGlzLCBzdGF0ZV85MzkpO1xuICB9XG4gIGV4dGVuZChhdHRyc185NDApIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQm9keShPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfOTQwKSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbiAodGVybV85NDEsIHN0YXRlXzk0Mikge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uQm9keShzdGF0ZV85NDIpO1xufTtcbmV4cG9ydCB7RnVuY3Rpb25Cb2R5IGFzIEZ1bmN0aW9uQm9keX07XG5jbGFzcyBGdW5jdGlvbkRlY2xhcmF0aW9uIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXR0cnNfOTQzLCB0eXBlXzk0NCkge1xuICAgIHN1cGVyKGF0dHJzXzk0MywgdHlwZV85NDQgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185NDMsIFwibmFtZVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJuYW1lXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTQzLCBcImlzR2VuZXJhdG9yXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImlzR2VuZXJhdG9yXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTQzLCBcInBhcmFtc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJwYXJhbXNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185NDMsIFwiYm9keVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJib2R5XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl85NDUsIHN0YXRlXzk0NiA9IHt9KSB7XG4gICAgc3RhdGVfOTQ2Lm5hbWUgPSB0aGlzLm5hbWUgaW5zdGFuY2VvZiBCaW5kaW5nSWRlbnRpZmllciA/IHRoaXMubmFtZS5yZWR1Y2UocmVkdWNlcl85NDUpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzk0Ni5pc0dlbmVyYXRvciA9IHRoaXMuaXNHZW5lcmF0b3I7XG4gICAgc3RhdGVfOTQ2LnBhcmFtcyA9IHRoaXMucGFyYW1zIGluc3RhbmNlb2YgRm9ybWFsUGFyYW1ldGVycyA/IHRoaXMucGFyYW1zLnJlZHVjZShyZWR1Y2VyXzk0NSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtcykpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV85NDYuYm9keSA9IHRoaXMuYm9keSBpbnN0YW5jZW9mIEZ1bmN0aW9uQm9keSA/IHRoaXMuYm9keS5yZWR1Y2UocmVkdWNlcl85NDUpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTQ1LCBzdGF0ZV85NDYpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lOiB0aGlzLm5hbWUsIGlzR2VuZXJhdG9yOiB0aGlzLmlzR2VuZXJhdG9yLCBwYXJhbXM6IHRoaXMucGFyYW1zLCBib2R5OiB0aGlzLmJvZHl9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl85NDcpIHtcbiAgICBsZXQgc3RhdGVfOTQ4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl85NDcpO1xuICAgIHJldHVybiByZWR1Y2VyXzk0Ny5yZWR1Y2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRoaXMsIHN0YXRlXzk0OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzk0OSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbihPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfOTQ5KSk7XG4gIH1cbn1cblN0YXRlbWVudC5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAodGVybV85NTAsIHN0YXRlXzk1MSkge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uRGVjbGFyYXRpb24oc3RhdGVfOTUxKTtcbn07XG5leHBvcnQge0Z1bmN0aW9uRGVjbGFyYXRpb24gYXMgRnVuY3Rpb25EZWNsYXJhdGlvbn07XG5jbGFzcyBGdW5jdGlvbkRlY2xhcmF0aW9uRSBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzk1MiwgdHlwZV85NTMpIHtcbiAgICBzdXBlcihhdHRyc185NTIsIHR5cGVfOTUzIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvbkVcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzk1MiwgXCJuYW1lXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcIm5hbWVcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185NTIsIFwiaXNHZW5lcmF0b3JcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiaXNHZW5lcmF0b3JcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185NTIsIFwicGFyYW1zXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInBhcmFtc1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzk1MiwgXCJib2R5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImJvZHlcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk1NCwgc3RhdGVfOTU1ID0ge30pIHtcbiAgICBzdGF0ZV85NTUubmFtZSA9IHRoaXMubmFtZSBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyID8gdGhpcy5uYW1lLnJlZHVjZShyZWR1Y2VyXzk1NCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgc3RhdGVfOTU1LmlzR2VuZXJhdG9yID0gdGhpcy5pc0dlbmVyYXRvcjtcbiAgICBzdGF0ZV85NTUucGFyYW1zID0gdGhpcy5wYXJhbXMgaW5zdGFuY2VvZiBGb3JtYWxQYXJhbWV0ZXJzID8gdGhpcy5wYXJhbXMucmVkdWNlKHJlZHVjZXJfOTU0KSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1zKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzk1NS5ib2R5ID0gdGhpcy5ib2R5Lm1hcChhXzk1NiA9PiBhXzk1NiBpbnN0YW5jZW9mIFRlcm0gPyBhXzk1Ni5yZWR1Y2UocmVkdWNlcl85NTQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85NTYpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTU0LCBzdGF0ZV85NTUpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lOiB0aGlzLm5hbWUsIGlzR2VuZXJhdG9yOiB0aGlzLmlzR2VuZXJhdG9yLCBwYXJhbXM6IHRoaXMucGFyYW1zLCBib2R5OiB0aGlzLmJvZHl9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl85NTcpIHtcbiAgICBsZXQgc3RhdGVfOTU4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl85NTcpO1xuICAgIHJldHVybiByZWR1Y2VyXzk1Ny5yZWR1Y2VGdW5jdGlvbkRlY2xhcmF0aW9uRSh0aGlzLCBzdGF0ZV85NTgpO1xuICB9XG4gIGV4dGVuZChhdHRyc185NTkpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGVjbGFyYXRpb25FKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc185NTkpKTtcbiAgfVxufVxuU3RhdGVtZW50LkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlRnVuY3Rpb25EZWNsYXJhdGlvbkUgPSBmdW5jdGlvbiAodGVybV85NjAsIHN0YXRlXzk2MSkge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uRGVjbGFyYXRpb25FKHN0YXRlXzk2MSk7XG59O1xuZXhwb3J0IHtGdW5jdGlvbkRlY2xhcmF0aW9uRSBhcyBGdW5jdGlvbkRlY2xhcmF0aW9uRX07XG5jbGFzcyBTY3JpcHQgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfOTYyLCB0eXBlXzk2Mykge1xuICAgIHN1cGVyKGF0dHJzXzk2MiwgdHlwZV85NjMgfHwgXCJTY3JpcHRcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzk2MiwgXCJkaXJlY3RpdmVzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImRpcmVjdGl2ZXNcIik7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc185NjIsIFwic3RhdGVtZW50c1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJzdGF0ZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl85NjQsIHN0YXRlXzk2NSA9IHt9KSB7XG4gICAgc3RhdGVfOTY1LmRpcmVjdGl2ZXMgPSB0aGlzLmRpcmVjdGl2ZXMubWFwKGFfOTY2ID0+IGFfOTY2KTtcbiAgICBzdGF0ZV85NjUuc3RhdGVtZW50cyA9IHRoaXMuc3RhdGVtZW50cy5tYXAoYV85NjcgPT4gYV85NjcgaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBhXzk2Ny5yZWR1Y2UocmVkdWNlcl85NjQpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85NjcpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTY0LCBzdGF0ZV85NjUpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsIHN0YXRlbWVudHM6IHRoaXMuc3RhdGVtZW50c30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzk2OCkge1xuICAgIGxldCBzdGF0ZV85NjkgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk2OCk7XG4gICAgcmV0dXJuIHJlZHVjZXJfOTY4LnJlZHVjZVNjcmlwdCh0aGlzLCBzdGF0ZV85NjkpO1xuICB9XG4gIGV4dGVuZChhdHRyc185NzApIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfOTcwKSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTY3JpcHQgPSBmdW5jdGlvbiAodGVybV85NzEsIHN0YXRlXzk3Mikge1xuICByZXR1cm4gbmV3IFNjcmlwdChzdGF0ZV85NzIpO1xufTtcbmV4cG9ydCB7U2NyaXB0IGFzIFNjcmlwdH07XG5jbGFzcyBTcHJlYWRFbGVtZW50IGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzk3MywgdHlwZV85NzQpIHtcbiAgICBzdXBlcihhdHRyc185NzMsIHR5cGVfOTc0IHx8IFwiU3ByZWFkRWxlbWVudFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTczLCBcImV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiZXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTc1LCBzdGF0ZV85NzYgPSB7fSkge1xuICAgIHN0YXRlXzk3Ni5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgRXhwcmVzc2lvbiA/IHRoaXMuZXhwcmVzc2lvbi5yZWR1Y2UocmVkdWNlcl85NzUpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTc1LCBzdGF0ZV85NzYpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtleHByZXNzaW9uOiB0aGlzLmV4cHJlc3Npb259LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl85NzcpIHtcbiAgICBsZXQgc3RhdGVfOTc4ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl85NzcpO1xuICAgIHJldHVybiByZWR1Y2VyXzk3Ny5yZWR1Y2VTcHJlYWRFbGVtZW50KHRoaXMsIHN0YXRlXzk3OCk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzk3OSkge1xuICAgIHJldHVybiBuZXcgU3ByZWFkRWxlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfOTc5KSk7XG4gIH1cbn1cblRlcm0uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTcHJlYWRFbGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fOTgwLCBzdGF0ZV85ODEpIHtcbiAgcmV0dXJuIG5ldyBTcHJlYWRFbGVtZW50KHN0YXRlXzk4MSk7XG59O1xuZXhwb3J0IHtTcHJlYWRFbGVtZW50IGFzIFNwcmVhZEVsZW1lbnR9O1xuY2xhc3MgU3VwZXIgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfOTgyLCB0eXBlXzk4Mykge1xuICAgIHN1cGVyKGF0dHJzXzk4MiwgdHlwZV85ODMgfHwgXCJTdXBlclwiKTtcbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl85ODQsIHN0YXRlXzk4NSA9IHt9KSB7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl85ODQsIHN0YXRlXzk4NSk7XG4gIH1cbiAgX2Nsb25lQXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzk4Nikge1xuICAgIGxldCBzdGF0ZV85ODcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk4Nik7XG4gICAgcmV0dXJuIHJlZHVjZXJfOTg2LnJlZHVjZVN1cGVyKHRoaXMsIHN0YXRlXzk4Nyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzk4OCkge1xuICAgIHJldHVybiBuZXcgU3VwZXIoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzk4OCkpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU3VwZXIgPSBmdW5jdGlvbiAodGVybV85ODksIHN0YXRlXzk5MCkge1xuICByZXR1cm4gbmV3IFN1cGVyKHN0YXRlXzk5MCk7XG59O1xuZXhwb3J0IHtTdXBlciBhcyBTdXBlcn07XG5jbGFzcyBTd2l0Y2hDYXNlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzk5MSwgdHlwZV85OTIpIHtcbiAgICBzdXBlcihhdHRyc185OTEsIHR5cGVfOTkyIHx8IFwiU3dpdGNoQ2FzZVwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfOTkxLCBcInRlc3RcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidGVzdFwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzk5MSwgXCJjb25zZXF1ZW50XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImNvbnNlcXVlbnRcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk5Mywgc3RhdGVfOTk0ID0ge30pIHtcbiAgICBzdGF0ZV85OTQudGVzdCA9IHRoaXMudGVzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLnRlc3QucmVkdWNlKHJlZHVjZXJfOTkzKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMudGVzdCkpO1xuICAgIH0uY2FsbCh0aGlzKTtcbiAgICBzdGF0ZV85OTQuY29uc2VxdWVudCA9IHRoaXMuY29uc2VxdWVudC5tYXAoYV85OTUgPT4gYV85OTUgaW5zdGFuY2VvZiBTdGF0ZW1lbnQgPyBhXzk5NS5yZWR1Y2UocmVkdWNlcl85OTMpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV85OTUpKTtcbiAgICB9LmNhbGwodGhpcykpO1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXIuX3JlZHVjZVN0YXRlKHJlZHVjZXJfOTkzLCBzdGF0ZV85OTQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt0ZXN0OiB0aGlzLnRlc3QsIGNvbnNlcXVlbnQ6IHRoaXMuY29uc2VxdWVudH0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzk5Nikge1xuICAgIGxldCBzdGF0ZV85OTcgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzk5Nik7XG4gICAgcmV0dXJuIHJlZHVjZXJfOTk2LnJlZHVjZVN3aXRjaENhc2UodGhpcywgc3RhdGVfOTk3KTtcbiAgfVxuICBleHRlbmQoYXR0cnNfOTk4KSB7XG4gICAgcmV0dXJuIG5ldyBTd2l0Y2hDYXNlKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc185OTgpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVN3aXRjaENhc2UgPSBmdW5jdGlvbiAodGVybV85OTksIHN0YXRlXzEwMDApIHtcbiAgcmV0dXJuIG5ldyBTd2l0Y2hDYXNlKHN0YXRlXzEwMDApO1xufTtcbmV4cG9ydCB7U3dpdGNoQ2FzZSBhcyBTd2l0Y2hDYXNlfTtcbmNsYXNzIFN3aXRjaERlZmF1bHQgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTAwMSwgdHlwZV8xMDAyKSB7XG4gICAgc3VwZXIoYXR0cnNfMTAwMSwgdHlwZV8xMDAyIHx8IFwiU3dpdGNoRGVmYXVsdFwiKTtcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMTAwMSwgXCJjb25zZXF1ZW50XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcImNvbnNlcXVlbnRcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMDMsIHN0YXRlXzEwMDQgPSB7fSkge1xuICAgIHN0YXRlXzEwMDQuY29uc2VxdWVudCA9IHRoaXMuY29uc2VxdWVudC5tYXAoYV8xMDA1ID0+IGFfMTAwNSBpbnN0YW5jZW9mIFN0YXRlbWVudCA/IGFfMTAwNS5yZWR1Y2UocmVkdWNlcl8xMDAzKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfMTAwNSkpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDAzLCBzdGF0ZV8xMDA0KTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7Y29uc2VxdWVudDogdGhpcy5jb25zZXF1ZW50fSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTAwNikge1xuICAgIGxldCBzdGF0ZV8xMDA3ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDA2KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xMDA2LnJlZHVjZVN3aXRjaERlZmF1bHQodGhpcywgc3RhdGVfMTAwNyk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzEwMDgpIHtcbiAgICByZXR1cm4gbmV3IFN3aXRjaERlZmF1bHQoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzEwMDgpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVN3aXRjaERlZmF1bHQgPSBmdW5jdGlvbiAodGVybV8xMDA5LCBzdGF0ZV8xMDEwKSB7XG4gIHJldHVybiBuZXcgU3dpdGNoRGVmYXVsdChzdGF0ZV8xMDEwKTtcbn07XG5leHBvcnQge1N3aXRjaERlZmF1bHQgYXMgU3dpdGNoRGVmYXVsdH07XG5jbGFzcyBUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTAxMSwgdHlwZV8xMDEyKSB7XG4gICAgc3VwZXIoYXR0cnNfMTAxMSwgdHlwZV8xMDEyIHx8IFwiVGVtcGxhdGVFbGVtZW50XCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xMDExLCBcInJhd1ZhbHVlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZTogXCIgKyBcInJhd1ZhbHVlXCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8xMDEzLCBzdGF0ZV8xMDE0ID0ge30pIHtcbiAgICBzdGF0ZV8xMDE0LnJhd1ZhbHVlID0gdGhpcy5yYXdWYWx1ZTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMTMsIHN0YXRlXzEwMTQpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtyYXdWYWx1ZTogdGhpcy5yYXdWYWx1ZX0sIHN1cGVyLl9jbG9uZUF0dHJzKCkpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2VyXzEwMTUpIHtcbiAgICBsZXQgc3RhdGVfMTAxNiA9IHRoaXMuX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTAxNSk7XG4gICAgcmV0dXJuIHJlZHVjZXJfMTAxNS5yZWR1Y2VUZW1wbGF0ZUVsZW1lbnQodGhpcywgc3RhdGVfMTAxNik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzEwMTcpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlRWxlbWVudChPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMTAxNykpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRlcm1fMTAxOCwgc3RhdGVfMTAxOSkge1xuICByZXR1cm4gbmV3IFRlbXBsYXRlRWxlbWVudChzdGF0ZV8xMDE5KTtcbn07XG5leHBvcnQge1RlbXBsYXRlRWxlbWVudCBhcyBUZW1wbGF0ZUVsZW1lbnR9O1xuY2xhc3MgU3ludGF4VGVtcGxhdGUgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTAyMCwgdHlwZV8xMDIxKSB7XG4gICAgc3VwZXIoYXR0cnNfMTAyMCwgdHlwZV8xMDIxIHx8IFwiU3ludGF4VGVtcGxhdGVcIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzEwMjAsIFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidGVtcGxhdGVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMjIsIHN0YXRlXzEwMjMgPSB7fSkge1xuICAgIHN0YXRlXzEwMjMudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLm1hcChhXzEwMjQgPT4gYV8xMDI0IGluc3RhbmNlb2YgU3ludGF4VGVybSA/IGFfMTAyNC5yZWR1Y2UocmVkdWNlcl8xMDIyKSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGFfMTAyNCkpO1xuICAgIH0uY2FsbCh0aGlzKSk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDIyLCBzdGF0ZV8xMDIzKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7dGVtcGxhdGU6IHRoaXMudGVtcGxhdGV9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xMDI1KSB7XG4gICAgbGV0IHN0YXRlXzEwMjYgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMjUpO1xuICAgIHJldHVybiByZWR1Y2VyXzEwMjUucmVkdWNlU3ludGF4VGVtcGxhdGUodGhpcywgc3RhdGVfMTAyNik7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzEwMjcpIHtcbiAgICByZXR1cm4gbmV3IFN5bnRheFRlbXBsYXRlKE9iamVjdC5hc3NpZ24odGhpcy5fY2xvbmVBdHRycygpLCBhdHRyc18xMDI3KSk7XG4gIH1cbn1cbkV4cHJlc3Npb24uQ2xvbmVSZWR1Y2VyLnByb3RvdHlwZS5yZWR1Y2VTeW50YXhUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZXJtXzEwMjgsIHN0YXRlXzEwMjkpIHtcbiAgcmV0dXJuIG5ldyBTeW50YXhUZW1wbGF0ZShzdGF0ZV8xMDI5KTtcbn07XG5leHBvcnQge1N5bnRheFRlbXBsYXRlIGFzIFN5bnRheFRlbXBsYXRlfTtcbmNsYXNzIFN5bnRheFF1b3RlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzEwMzAsIHR5cGVfMTAzMSkge1xuICAgIHN1cGVyKGF0dHJzXzEwMzAsIHR5cGVfMTAzMSB8fCBcIlN5bnRheFF1b3RlXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xMDMwLCBcIm5hbWVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwibmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzEwMzAsIFwidGVtcGxhdGVcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwidGVtcGxhdGVcIik7XG4gICAgfVxuICB9XG4gIF9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMzIsIHN0YXRlXzEwMzMgPSB7fSkge1xuICAgIHN0YXRlXzEwMzMubmFtZSA9IHRoaXMubmFtZTtcbiAgICBzdGF0ZV8xMDMzLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwMzIsIHN0YXRlXzEwMzMpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtuYW1lOiB0aGlzLm5hbWUsIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTAzNCkge1xuICAgIGxldCBzdGF0ZV8xMDM1ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDM0KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xMDM0LnJlZHVjZVN5bnRheFF1b3RlKHRoaXMsIHN0YXRlXzEwMzUpO1xuICB9XG4gIGV4dGVuZChhdHRyc18xMDM2KSB7XG4gICAgcmV0dXJuIG5ldyBTeW50YXhRdW90ZShPYmplY3QuYXNzaWduKHRoaXMuX2Nsb25lQXR0cnMoKSwgYXR0cnNfMTAzNikpO1xuICB9XG59XG5UZXJtLkNsb25lUmVkdWNlci5wcm90b3R5cGUucmVkdWNlU3ludGF4UXVvdGUgPSBmdW5jdGlvbiAodGVybV8xMDM3LCBzdGF0ZV8xMDM4KSB7XG4gIHJldHVybiBuZXcgU3ludGF4UXVvdGUoc3RhdGVfMTAzOCk7XG59O1xuZXhwb3J0IHtTeW50YXhRdW90ZSBhcyBTeW50YXhRdW90ZX07XG5jbGFzcyBWYXJpYWJsZURlY2xhcmF0aW9uIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzXzEwMzksIHR5cGVfMTA0MCkge1xuICAgIHN1cGVyKGF0dHJzXzEwMzksIHR5cGVfMTA0MCB8fCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzEwMzksIFwia2luZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJraW5kXCIpO1xuICAgIH1cbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cnNfMTAzOSwgXCJkZWNsYXJhdG9yc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJkZWNsYXJhdG9yc1wiKTtcbiAgICB9XG4gIH1cbiAgX3JlZHVjZVN0YXRlKHJlZHVjZXJfMTA0MSwgc3RhdGVfMTA0MiA9IHt9KSB7XG4gICAgc3RhdGVfMTA0Mi5raW5kID0gdGhpcy5raW5kO1xuICAgIHN0YXRlXzEwNDIuZGVjbGFyYXRvcnMgPSB0aGlzLmRlY2xhcmF0b3JzLm1hcChhXzEwNDMgPT4gYV8xMDQzIGluc3RhbmNlb2YgVmFyaWFibGVEZWNsYXJhdG9yID8gYV8xMDQzLnJlZHVjZShyZWR1Y2VyXzEwNDEpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoYV8xMDQzKSk7XG4gICAgfS5jYWxsKHRoaXMpKTtcbiAgICA7XG4gICAgcmV0dXJuIHN1cGVyLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwNDEsIHN0YXRlXzEwNDIpO1xuICB9XG4gIF9jbG9uZUF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtraW5kOiB0aGlzLmtpbmQsIGRlY2xhcmF0b3JzOiB0aGlzLmRlY2xhcmF0b3JzfSwgc3VwZXIuX2Nsb25lQXR0cnMoKSk7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZXJfMTA0NCkge1xuICAgIGxldCBzdGF0ZV8xMDQ1ID0gdGhpcy5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDQ0KTtcbiAgICByZXR1cm4gcmVkdWNlcl8xMDQ0LnJlZHVjZVZhcmlhYmxlRGVjbGFyYXRpb24odGhpcywgc3RhdGVfMTA0NSk7XG4gIH1cbiAgZXh0ZW5kKGF0dHJzXzEwNDYpIHtcbiAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24oT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzEwNDYpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAodGVybV8xMDQ3LCBzdGF0ZV8xMDQ4KSB7XG4gIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZV8xMDQ4KTtcbn07XG5leHBvcnQge1ZhcmlhYmxlRGVjbGFyYXRpb24gYXMgVmFyaWFibGVEZWNsYXJhdGlvbn07XG5jbGFzcyBWYXJpYWJsZURlY2xhcmF0b3IgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoYXR0cnNfMTA0OSwgdHlwZV8xMDUwKSB7XG4gICAgc3VwZXIoYXR0cnNfMTA0OSwgdHlwZV8xMDUwIHx8IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpO1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChhdHRyc18xMDQ5LCBcImJpbmRpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlOiBcIiArIFwiYmluZGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzXzEwNDksIFwiaW5pdFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGU6IFwiICsgXCJpbml0XCIpO1xuICAgIH1cbiAgfVxuICBfcmVkdWNlU3RhdGUocmVkdWNlcl8xMDUxLCBzdGF0ZV8xMDUyID0ge30pIHtcbiAgICBzdGF0ZV8xMDUyLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBPYmplY3RCaW5kaW5nID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzEwNTEpIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgQXJyYXlCaW5kaW5nID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzEwNTEpIDogdGhpcy5iaW5kaW5nIGluc3RhbmNlb2YgQmluZGluZ0lkZW50aWZpZXIgPyB0aGlzLmJpbmRpbmcucmVkdWNlKHJlZHVjZXJfMTA1MSkgOiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uID8gdGhpcy5iaW5kaW5nLnJlZHVjZShyZWR1Y2VyXzEwNTEpIDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5iaW5kaW5nKSk7XG4gICAgfS5jYWxsKHRoaXMpO1xuICAgIHN0YXRlXzEwNTIuaW5pdCA9IHRoaXMuaW5pdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuaW5pdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24gPyB0aGlzLmluaXQucmVkdWNlKHJlZHVjZXJfMTA1MSkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXQpKTtcbiAgICB9LmNhbGwodGhpcyk7XG4gICAgO1xuICAgIHJldHVybiBzdXBlci5fcmVkdWNlU3RhdGUocmVkdWNlcl8xMDUxLCBzdGF0ZV8xMDUyKTtcbiAgfVxuICBfY2xvbmVBdHRycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7YmluZGluZzogdGhpcy5iaW5kaW5nLCBpbml0OiB0aGlzLmluaXR9LCBzdXBlci5fY2xvbmVBdHRycygpKTtcbiAgfVxuICByZWR1Y2UocmVkdWNlcl8xMDUzKSB7XG4gICAgbGV0IHN0YXRlXzEwNTQgPSB0aGlzLl9yZWR1Y2VTdGF0ZShyZWR1Y2VyXzEwNTMpO1xuICAgIHJldHVybiByZWR1Y2VyXzEwNTMucmVkdWNlVmFyaWFibGVEZWNsYXJhdG9yKHRoaXMsIHN0YXRlXzEwNTQpO1xuICB9XG4gIGV4dGVuZChhdHRyc18xMDU1KSB7XG4gICAgcmV0dXJuIG5ldyBWYXJpYWJsZURlY2xhcmF0b3IoT2JqZWN0LmFzc2lnbih0aGlzLl9jbG9uZUF0dHJzKCksIGF0dHJzXzEwNTUpKTtcbiAgfVxufVxuVGVybS5DbG9uZVJlZHVjZXIucHJvdG90eXBlLnJlZHVjZVZhcmlhYmxlRGVjbGFyYXRvciA9IGZ1bmN0aW9uICh0ZXJtXzEwNTYsIHN0YXRlXzEwNTcpIHtcbiAgcmV0dXJuIG5ldyBWYXJpYWJsZURlY2xhcmF0b3Ioc3RhdGVfMTA1Nyk7XG59O1xuZXhwb3J0IHtWYXJpYWJsZURlY2xhcmF0b3IgYXMgVmFyaWFibGVEZWNsYXJhdG9yfTtcbiJdfQ==

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.freshScope = freshScope;
	exports.Scope = Scope;

	var _symbol = __webpack_require__(43);

	let scopeIndex = 0;
	function freshScope(name = 'scope') {
	  scopeIndex++;
	  return (0, _symbol.Symbol)(name + '_' + scopeIndex);
	}

	function Scope(name) {
	  return (0, _symbol.Symbol)(name);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY29wZS5qcyJdLCJuYW1lcyI6WyJmcmVzaFNjb3BlIiwiU2NvcGUiLCJzY29wZUluZGV4IiwibmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFLZ0JBLFUsR0FBQUEsVTtRQUtBQyxLLEdBQUFBLEs7O0FBVGhCOztBQUVBLElBQUlDLGFBQWEsQ0FBakI7QUFFTyxTQUFTRixVQUFULENBQW9CRyxPQUFlLE9BQW5DLEVBQTRDO0FBQ2pERDtBQUNBLFNBQU8sb0JBQU9DLE9BQU8sR0FBUCxHQUFhRCxVQUFwQixDQUFQO0FBQ0Q7O0FBRU0sU0FBU0QsS0FBVCxDQUFlRSxJQUFmLEVBQTZCO0FBQ2xDLFNBQU8sb0JBQU9BLElBQVAsQ0FBUDtBQUNEIiwiZmlsZSI6InNjb3BlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB7IFN5bWJvbCB9IGZyb20gJy4vc3ltYm9sJztcblxubGV0IHNjb3BlSW5kZXggPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZnJlc2hTY29wZShuYW1lOiBzdHJpbmcgPSAnc2NvcGUnKSB7XG4gIHNjb3BlSW5kZXgrKztcbiAgcmV0dXJuIFN5bWJvbChuYW1lICsgJ18nICsgc2NvcGVJbmRleCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTY29wZShuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFN5bWJvbChuYW1lKTtcbn1cbiJdfQ==

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.gensym = gensym;
	let internedMap = new Map();

	let counter = 0;

	function gensym(name) {
	  let prefix = name == null ? 's_' : name + '_';
	  let sym = new Symbol(prefix + counter);
	  counter++;
	  return sym;
	}

	class Symbol {

	  constructor(name) {
	    this.name = name;
	  }
	  toString() {
	    return this.name;
	  }
	}

	function makeSymbol(name) {
	  let s = internedMap.get(name);
	  if (s) {
	    return s;
	  } else {
	    let sym = new Symbol(name);
	    internedMap.set(name, sym);
	    return sym;
	  }
	}

	exports.Symbol = makeSymbol;
	exports.SymbolClass = Symbol;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zeW1ib2wuanMiXSwibmFtZXMiOlsiZ2Vuc3ltIiwiaW50ZXJuZWRNYXAiLCJNYXAiLCJjb3VudGVyIiwibmFtZSIsInByZWZpeCIsInN5bSIsIlN5bWJvbCIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJtYWtlU3ltYm9sIiwicyIsImdldCIsInNldCIsIlN5bWJvbENsYXNzIl0sIm1hcHBpbmdzIjoiOzs7OztRQUtnQkEsTSxHQUFBQSxNO0FBSmhCLElBQUlDLGNBQW1DLElBQUlDLEdBQUosRUFBdkM7O0FBRUEsSUFBSUMsVUFBVSxDQUFkOztBQUVPLFNBQVNILE1BQVQsQ0FBZ0JJLElBQWhCLEVBQThCO0FBQ25DLE1BQUlDLFNBQVNELFFBQVEsSUFBUixHQUFlLElBQWYsR0FBc0JBLE9BQU8sR0FBMUM7QUFDQSxNQUFJRSxNQUFNLElBQUlDLE1BQUosQ0FBV0YsU0FBU0YsT0FBcEIsQ0FBVjtBQUNBQTtBQUNBLFNBQU9HLEdBQVA7QUFDRDs7QUFFRCxNQUFNQyxNQUFOLENBQWE7O0FBR1hDLGNBQVlKLElBQVosRUFBMEI7QUFDeEIsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7QUFDREssYUFBVztBQUNULFdBQU8sS0FBS0wsSUFBWjtBQUNEO0FBUlU7O0FBV2IsU0FBU00sVUFBVCxDQUFvQk4sSUFBcEIsRUFBMEM7QUFDeEMsTUFBSU8sSUFBSVYsWUFBWVcsR0FBWixDQUFnQlIsSUFBaEIsQ0FBUjtBQUNBLE1BQUlPLENBQUosRUFBTztBQUNMLFdBQU9BLENBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJTCxNQUFNLElBQUlDLE1BQUosQ0FBV0gsSUFBWCxDQUFWO0FBQ0FILGdCQUFZWSxHQUFaLENBQWdCVCxJQUFoQixFQUFzQkUsR0FBdEI7QUFDQSxXQUFPQSxHQUFQO0FBQ0Q7QUFDRjs7UUFHZUMsTSxHQUFkRyxVO1FBQ1VJLFcsR0FBVlAsTSIsImZpbGUiOiJzeW1ib2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xubGV0IGludGVybmVkTWFwOiBNYXA8c3RyaW5nLCBTeW1ib2w+ID0gbmV3IE1hcCgpO1xuXG5sZXQgY291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5zeW0obmFtZTogc3RyaW5nKSB7XG4gIGxldCBwcmVmaXggPSBuYW1lID09IG51bGwgPyAnc18nIDogbmFtZSArICdfJztcbiAgbGV0IHN5bSA9IG5ldyBTeW1ib2wocHJlZml4ICsgY291bnRlcik7XG4gIGNvdW50ZXIrKztcbiAgcmV0dXJuIHN5bTtcbn1cblxuY2xhc3MgU3ltYm9sIHtcbiAgbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlU3ltYm9sKG5hbWU6IHN0cmluZyk6IFN5bWJvbCB7XG4gIGxldCBzID0gaW50ZXJuZWRNYXAuZ2V0KG5hbWUpO1xuICBpZiAocykge1xuICAgIHJldHVybiBzO1xuICB9IGVsc2Uge1xuICAgIGxldCBzeW0gPSBuZXcgU3ltYm9sKG5hbWUpO1xuICAgIGludGVybmVkTWFwLnNldChuYW1lLCBzeW0pO1xuICAgIHJldHVybiBzeW07XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgbWFrZVN5bWJvbCBhcyBTeW1ib2wsXG4gIFN5bWJvbCBhcyBTeW1ib2xDbGFzc1xufTtcbiJdfQ==

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _transforms = __webpack_require__(45);

	class Env {
	  constructor() {
	    this.map = new Map();
	    this.map.set('function', _transforms.FunctionDeclTransform);
	    this.map.set('var', _transforms.VariableDeclTransform);
	    this.map.set('let', _transforms.LetDeclTransform);
	    this.map.set('const', _transforms.ConstDeclTransform);
	    this.map.set('syntaxrec', _transforms.SyntaxrecDeclTransform);
	    this.map.set('syntax', _transforms.SyntaxDeclTransform);
	    this.map.set('return', _transforms.ReturnStatementTransform);
	    this.map.set('while', _transforms.WhileTransform);
	    this.map.set('if', _transforms.IfTransform);
	    this.map.set('for', _transforms.ForTransform);
	    this.map.set('switch', _transforms.SwitchTransform);
	    this.map.set('break', _transforms.BreakTransform);
	    this.map.set('continue', _transforms.ContinueTransform);
	    this.map.set('do', _transforms.DoTransform);
	    this.map.set('debugger', _transforms.DebuggerTransform);
	    this.map.set('with', _transforms.WithTransform);
	    this.map.set('try', _transforms.TryTransform);
	    this.map.set('throw', _transforms.ThrowTransform);
	    this.map.set('new', _transforms.NewTransform);
	  }

	  has(key) {
	    return this.map.has(key);
	  }

	  get(key) {
	    return this.map.get(key);
	  }

	  set(key, val) {
	    return this.map.set(key, val);
	  }
	}
	exports.default = Env;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbnYuanMiXSwibmFtZXMiOlsiRW52IiwiY29uc3RydWN0b3IiLCJtYXAiLCJNYXAiLCJzZXQiLCJoYXMiLCJrZXkiLCJnZXQiLCJ2YWwiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQXNCZSxNQUFNQSxHQUFOLENBQVU7QUFDdkJDLGdCQUFjO0FBQ1osU0FBS0MsR0FBTCxHQUFXLElBQUlDLEdBQUosRUFBWDtBQUNBLFNBQUtELEdBQUwsQ0FBU0UsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsS0FBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLE9BQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxXQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsUUFBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLFFBQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxPQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsSUFBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLEtBQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxRQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsT0FBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLFVBQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxJQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsVUFBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLE1BQWI7QUFDQSxTQUFLRixHQUFMLENBQVNFLEdBQVQsQ0FBYSxLQUFiO0FBQ0EsU0FBS0YsR0FBTCxDQUFTRSxHQUFULENBQWEsT0FBYjtBQUNBLFNBQUtGLEdBQUwsQ0FBU0UsR0FBVCxDQUFhLEtBQWI7QUFDRDs7QUFFREMsTUFBSUMsR0FBSixFQUFTO0FBQ1AsV0FBTyxLQUFLSixHQUFMLENBQVNHLEdBQVQsQ0FBYUMsR0FBYixDQUFQO0FBQ0Q7O0FBRURDLE1BQUlELEdBQUosRUFBUztBQUNQLFdBQU8sS0FBS0osR0FBTCxDQUFTSyxHQUFULENBQWFELEdBQWIsQ0FBUDtBQUNEOztBQUVERixNQUFJRSxHQUFKLEVBQVNFLEdBQVQsRUFBYztBQUNaLFdBQU8sS0FBS04sR0FBTCxDQUFTRSxHQUFULENBQWFFLEdBQWIsRUFBa0JFLEdBQWxCLENBQVA7QUFDRDtBQWxDc0I7a0JBQUpSLEciLCJmaWxlIjoiZW52LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRnVuY3Rpb25EZWNsVHJhbnNmb3JtLFxuICBWYXJpYWJsZURlY2xUcmFuc2Zvcm0sXG4gIExldERlY2xUcmFuc2Zvcm0sXG4gIENvbnN0RGVjbFRyYW5zZm9ybSxcbiAgU3ludGF4RGVjbFRyYW5zZm9ybSxcbiAgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSxcbiAgUmV0dXJuU3RhdGVtZW50VHJhbnNmb3JtLFxuICBJZlRyYW5zZm9ybSxcbiAgRm9yVHJhbnNmb3JtLFxuICBTd2l0Y2hUcmFuc2Zvcm0sXG4gIEJyZWFrVHJhbnNmb3JtLFxuICBDb250aW51ZVRyYW5zZm9ybSxcbiAgRG9UcmFuc2Zvcm0sXG4gIERlYnVnZ2VyVHJhbnNmb3JtLFxuICBXaXRoVHJhbnNmb3JtLFxuICBUcnlUcmFuc2Zvcm0sXG4gIFRocm93VHJhbnNmb3JtLFxuICBOZXdUcmFuc2Zvcm0sXG4gIFdoaWxlVHJhbnNmb3JtXG59IGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWFwLnNldCgnZnVuY3Rpb24nLCBGdW5jdGlvbkRlY2xUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldCgndmFyJywgVmFyaWFibGVEZWNsVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ2xldCcsIExldERlY2xUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldCgnY29uc3QnLCBDb25zdERlY2xUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldCgnc3ludGF4cmVjJywgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KCdzeW50YXgnLCBTeW50YXhEZWNsVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ3JldHVybicsIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KCd3aGlsZScsIFdoaWxlVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ2lmJywgSWZUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldCgnZm9yJywgRm9yVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ3N3aXRjaCcsIFN3aXRjaFRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KCdicmVhaycsIEJyZWFrVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ2NvbnRpbnVlJywgQ29udGludWVUcmFuc2Zvcm0pO1xuICAgIHRoaXMubWFwLnNldCgnZG8nLCBEb1RyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KCdkZWJ1Z2dlcicsIERlYnVnZ2VyVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ3dpdGgnLCBXaXRoVHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ3RyeScsIFRyeVRyYW5zZm9ybSk7XG4gICAgdGhpcy5tYXAuc2V0KCd0aHJvdycsIFRocm93VHJhbnNmb3JtKTtcbiAgICB0aGlzLm1hcC5zZXQoJ25ldycsIE5ld1RyYW5zZm9ybSk7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgfVxuXG4gIHNldChrZXksIHZhbCkge1xuICAgIHJldHVybiB0aGlzLm1hcC5zZXQoa2V5LCB2YWwpO1xuICB9XG59XG4iXX0=

/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class FunctionDeclTransform {}
	exports.FunctionDeclTransform = FunctionDeclTransform;
	class VariableDeclTransform {}
	exports.VariableDeclTransform = VariableDeclTransform;
	class NewTransform {}
	exports.NewTransform = NewTransform;
	class ThrowTransform {}
	exports.ThrowTransform = ThrowTransform;
	class LetDeclTransform {}
	exports.LetDeclTransform = LetDeclTransform;
	class ConstDeclTransform {}
	exports.ConstDeclTransform = ConstDeclTransform;
	class TryTransform {}
	exports.TryTransform = TryTransform;
	class WhileTransform {}
	exports.WhileTransform = WhileTransform;
	class IfTransform {}
	exports.IfTransform = IfTransform;
	class ForTransform {}
	exports.ForTransform = ForTransform;
	class SwitchTransform {}
	exports.SwitchTransform = SwitchTransform;
	class BreakTransform {}
	exports.BreakTransform = BreakTransform;
	class ContinueTransform {}
	exports.ContinueTransform = ContinueTransform;
	class DoTransform {}
	exports.DoTransform = DoTransform;
	class WithTransform {}
	exports.WithTransform = WithTransform;
	class DebuggerTransform {}
	exports.DebuggerTransform = DebuggerTransform;
	class SyntaxrecDeclTransform {}
	exports.SyntaxrecDeclTransform = SyntaxrecDeclTransform;
	class SyntaxDeclTransform {}
	exports.SyntaxDeclTransform = SyntaxDeclTransform;
	class ReturnStatementTransform {}
	exports.ReturnStatementTransform = ReturnStatementTransform;
	class VarBindingTransform {
	  constructor(id) {
	    this.id = id;
	  }
	}
	exports.VarBindingTransform = VarBindingTransform;
	class CompiletimeTransform {
	  constructor(value) {
	    this.value = value;
	  }
	}
	exports.CompiletimeTransform = CompiletimeTransform;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2Zvcm1zLmpzIl0sIm5hbWVzIjpbIkZ1bmN0aW9uRGVjbFRyYW5zZm9ybSIsIlZhcmlhYmxlRGVjbFRyYW5zZm9ybSIsIk5ld1RyYW5zZm9ybSIsIlRocm93VHJhbnNmb3JtIiwiTGV0RGVjbFRyYW5zZm9ybSIsIkNvbnN0RGVjbFRyYW5zZm9ybSIsIlRyeVRyYW5zZm9ybSIsIldoaWxlVHJhbnNmb3JtIiwiSWZUcmFuc2Zvcm0iLCJGb3JUcmFuc2Zvcm0iLCJTd2l0Y2hUcmFuc2Zvcm0iLCJCcmVha1RyYW5zZm9ybSIsIkNvbnRpbnVlVHJhbnNmb3JtIiwiRG9UcmFuc2Zvcm0iLCJXaXRoVHJhbnNmb3JtIiwiRGVidWdnZXJUcmFuc2Zvcm0iLCJTeW50YXhyZWNEZWNsVHJhbnNmb3JtIiwiU3ludGF4RGVjbFRyYW5zZm9ybSIsIlJldHVyblN0YXRlbWVudFRyYW5zZm9ybSIsIlZhckJpbmRpbmdUcmFuc2Zvcm0iLCJjb25zdHJ1Y3RvciIsImlkIiwiQ29tcGlsZXRpbWVUcmFuc2Zvcm0iLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxxQkFBTixDQUE0QjtRQUF0QkEscUIsR0FBQUEscUI7QUFDTixNQUFNQyxxQkFBTixDQUE0QjtRQUF0QkEscUIsR0FBQUEscUI7QUFDTixNQUFNQyxZQUFOLENBQW1CO1FBQWJBLFksR0FBQUEsWTtBQUNOLE1BQU1DLGNBQU4sQ0FBcUI7UUFBZkEsYyxHQUFBQSxjO0FBQ04sTUFBTUMsZ0JBQU4sQ0FBdUI7UUFBakJBLGdCLEdBQUFBLGdCO0FBQ04sTUFBTUMsa0JBQU4sQ0FBeUI7UUFBbkJBLGtCLEdBQUFBLGtCO0FBQ04sTUFBTUMsWUFBTixDQUFtQjtRQUFiQSxZLEdBQUFBLFk7QUFDTixNQUFNQyxjQUFOLENBQXFCO1FBQWZBLGMsR0FBQUEsYztBQUNOLE1BQU1DLFdBQU4sQ0FBa0I7UUFBWkEsVyxHQUFBQSxXO0FBQ04sTUFBTUMsWUFBTixDQUFtQjtRQUFiQSxZLEdBQUFBLFk7QUFDTixNQUFNQyxlQUFOLENBQXNCO1FBQWhCQSxlLEdBQUFBLGU7QUFDTixNQUFNQyxjQUFOLENBQXFCO1FBQWZBLGMsR0FBQUEsYztBQUNOLE1BQU1DLGlCQUFOLENBQXdCO1FBQWxCQSxpQixHQUFBQSxpQjtBQUNOLE1BQU1DLFdBQU4sQ0FBa0I7UUFBWkEsVyxHQUFBQSxXO0FBQ04sTUFBTUMsYUFBTixDQUFvQjtRQUFkQSxhLEdBQUFBLGE7QUFDTixNQUFNQyxpQkFBTixDQUF3QjtRQUFsQkEsaUIsR0FBQUEsaUI7QUFDTixNQUFNQyxzQkFBTixDQUE2QjtRQUF2QkEsc0IsR0FBQUEsc0I7QUFDTixNQUFNQyxtQkFBTixDQUEwQjtRQUFwQkEsbUIsR0FBQUEsbUI7QUFDTixNQUFNQyx3QkFBTixDQUErQjtRQUF6QkEsd0IsR0FBQUEsd0I7QUFDTixNQUFNQyxtQkFBTixDQUEwQjtBQUMvQkMsY0FBWUMsRUFBWixFQUFnQjtBQUNkLFNBQUtBLEVBQUwsR0FBVUEsRUFBVjtBQUNEO0FBSDhCO1FBQXBCRixtQixHQUFBQSxtQjtBQUtOLE1BQU1HLG9CQUFOLENBQTJCO0FBQ2hDRixjQUFZRyxLQUFaLEVBQW1CO0FBQ2pCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNEO0FBSCtCO1FBQXJCRCxvQixHQUFBQSxvQiIsImZpbGUiOiJ0cmFuc2Zvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZURlY2xUcmFuc2Zvcm0geyB9XG5leHBvcnQgY2xhc3MgTmV3VHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIFRocm93VHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIExldERlY2xUcmFuc2Zvcm0geyB9XG5leHBvcnQgY2xhc3MgQ29uc3REZWNsVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIFRyeVRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBXaGlsZVRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBJZlRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBGb3JUcmFuc2Zvcm0geyB9XG5leHBvcnQgY2xhc3MgU3dpdGNoVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIEJyZWFrVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIENvbnRpbnVlVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIERvVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIFdpdGhUcmFuc2Zvcm0geyB9XG5leHBvcnQgY2xhc3MgRGVidWdnZXJUcmFuc2Zvcm0geyB9XG5leHBvcnQgY2xhc3MgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBTeW50YXhEZWNsVHJhbnNmb3JtIHsgfVxuZXhwb3J0IGNsYXNzIFJldHVyblN0YXRlbWVudFRyYW5zZm9ybSB7IH1cbmV4cG9ydCBjbGFzcyBWYXJCaW5kaW5nVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBDb21waWxldGltZVRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG4iXX0=

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _termExpander = __webpack_require__(47);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _tokenExpander = __webpack_require__(67);

	var _tokenExpander2 = _interopRequireDefault(_tokenExpander);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class Compiler {
	  constructor(phase, env, store, context) {
	    this.phase = phase;
	    this.env = env;
	    this.store = store;
	    this.context = context;
	  }

	  compile(stxl) {
	    let tokenExpander = new _tokenExpander2.default(_.merge(this.context, {
	      phase: this.phase,
	      env: this.env,
	      store: this.store
	    }));
	    let termExpander = new _termExpander2.default(_.merge(this.context, {
	      phase: this.phase,
	      env: this.env,
	      store: this.store
	    }));

	    return tokenExpander.expand(stxl).map(t => termExpander.expand(t));
	  }
	}
	exports.default = Compiler;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21waWxlci5qcyJdLCJuYW1lcyI6WyJfIiwiQ29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsInBoYXNlIiwiZW52Iiwic3RvcmUiLCJjb250ZXh0IiwiY29tcGlsZSIsInN0eGwiLCJ0b2tlbkV4cGFuZGVyIiwibWVyZ2UiLCJ0ZXJtRXhwYW5kZXIiLCJleHBhbmQiLCJtYXAiLCJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlBLEM7Ozs7OztBQUdHLE1BQU1DLFFBQU4sQ0FBZTtBQUM1QkMsY0FBWUMsS0FBWixFQUFtQkMsR0FBbkIsRUFBd0JDLEtBQXhCLEVBQStCQyxPQUEvQixFQUF3QztBQUN0QyxTQUFLSCxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLQyxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDRDs7QUFFREMsVUFBUUMsSUFBUixFQUFjO0FBQ1osUUFBSUMsZ0JBQWdCLDRCQUFrQlQsRUFBRVUsS0FBRixDQUFRLEtBQUtKLE9BQWIsRUFBc0I7QUFDMURILGFBQU8sS0FBS0EsS0FEOEM7QUFFMURDLFdBQUssS0FBS0EsR0FGZ0Q7QUFHMURDLGFBQU8sS0FBS0E7QUFIOEMsS0FBdEIsQ0FBbEIsQ0FBcEI7QUFLQSxRQUFJTSxlQUFlLDJCQUFpQlgsRUFBRVUsS0FBRixDQUFRLEtBQUtKLE9BQWIsRUFBc0I7QUFDeERILGFBQU8sS0FBS0EsS0FENEM7QUFFeERDLFdBQUssS0FBS0EsR0FGOEM7QUFHeERDLGFBQU8sS0FBS0E7QUFINEMsS0FBdEIsQ0FBakIsQ0FBbkI7O0FBTUEsV0FBT0ksY0FBY0csTUFBZCxDQUFxQkosSUFBckIsRUFBMkJLLEdBQTNCLENBQStCQyxLQUFLSCxhQUFhQyxNQUFiLENBQW9CRSxDQUFwQixDQUFwQyxDQUFQO0FBQ0Q7QUFyQjJCO2tCQUFUYixRIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRlcm1FeHBhbmRlciBmcm9tICcuL3Rlcm0tZXhwYW5kZXIuanMnO1xuaW1wb3J0IFRva2VuRXhwYW5kZXIgZnJvbSAnLi90b2tlbi1leHBhbmRlcic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3JhbWRhJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlciB7XG4gIGNvbnN0cnVjdG9yKHBoYXNlLCBlbnYsIHN0b3JlLCBjb250ZXh0KSB7XG4gICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgY29tcGlsZShzdHhsKSB7XG4gICAgbGV0IHRva2VuRXhwYW5kZXIgPSBuZXcgVG9rZW5FeHBhbmRlcihfLm1lcmdlKHRoaXMuY29udGV4dCwge1xuICAgICAgcGhhc2U6IHRoaXMucGhhc2UsXG4gICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmVcbiAgICB9KSk7XG4gICAgbGV0IHRlcm1FeHBhbmRlciA9IG5ldyBUZXJtRXhwYW5kZXIoXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtcbiAgICAgIHBoYXNlOiB0aGlzLnBoYXNlLFxuICAgICAgZW52OiB0aGlzLmVudixcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRva2VuRXhwYW5kZXIuZXhwYW5kKHN0eGwpLm1hcCh0ID0+IHRlcm1FeHBhbmRlci5leHBhbmQodCkpO1xuICB9XG59XG4iXX0=

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _immutable = __webpack_require__(10);

	var _terms = __webpack_require__(48);

	var _sweetSpec = __webpack_require__(41);

	var T = _interopRequireWildcard(_sweetSpec);

	var _scope = __webpack_require__(42);

	var _compiler = __webpack_require__(46);

	var _compiler2 = _interopRequireDefault(_compiler);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _enforester = __webpack_require__(49);

	var _templateProcessor = __webpack_require__(65);

	var _astDispatcher = __webpack_require__(66);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	var _scopeReducer = __webpack_require__(50);

	var _scopeReducer2 = _interopRequireDefault(_scopeReducer);

	var _symbol = __webpack_require__(43);

	var _transforms = __webpack_require__(45);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	class TermExpander extends _astDispatcher2.default {
	  constructor(context) {
	    super('expand', true);
	    this.context = context;
	  }

	  expand(term) {
	    return this.dispatch(term);
	  }

	  expandRawSyntax(term) {
	    return term;
	  }

	  expandRawDelimiter(term) {
	    return term;
	  }

	  expandTemplateExpression(term) {
	    return new T.TemplateExpression({
	      tag: term.tag == null ? null : this.expand(term.tag),
	      elements: term.elements.toArray()
	    });
	  }

	  expandBreakStatement(term) {
	    return new T.BreakStatement({
	      label: term.label ? term.label.val() : null
	    });
	  }

	  expandDoWhileStatement(term) {
	    return new T.DoWhileStatement({
	      body: this.expand(term.body),
	      test: this.expand(term.test)
	    });
	  }

	  expandWithStatement(term) {
	    return new T.WithStatement({
	      body: this.expand(term.body),
	      object: this.expand(term.object)
	    });
	  }

	  expandDebuggerStatement(term) {
	    return term;
	  }

	  expandContinueStatement(term) {
	    return new T.ContinueStatement({
	      label: term.label ? term.label.val() : null
	    });
	  }

	  expandSwitchStatementWithDefault(term) {
	    return new T.SwitchStatementWithDefault({
	      discriminant: this.expand(term.discriminant),
	      preDefaultCases: term.preDefaultCases.map(c => this.expand(c)).toArray(),
	      defaultCase: this.expand(term.defaultCase),
	      postDefaultCases: term.postDefaultCases.map(c => this.expand(c)).toArray()
	    });
	  }

	  expandComputedMemberExpression(term) {
	    return new T.ComputedMemberExpression({
	      object: this.expand(term.object),
	      expression: this.expand(term.expression)
	    });
	  }

	  expandSwitchStatement(term) {
	    return new T.SwitchStatement({
	      discriminant: this.expand(term.discriminant),
	      cases: term.cases.map(c => this.expand(c)).toArray()
	    });
	  }

	  expandFormalParameters(term) {
	    let rest = term.rest == null ? null : this.expand(term.rest);
	    return new T.FormalParameters({
	      items: term.items.map(i => this.expand(i)),
	      rest
	    });
	  }

	  expandArrowExpressionE(term) {
	    return this.doFunctionExpansion(term, 'ArrowExpression');
	  }

	  expandArrowExpression(term) {
	    return this.doFunctionExpansion(term, 'ArrowExpression');
	  }

	  expandSwitchDefault(term) {
	    return new T.SwitchDefault({
	      consequent: term.consequent.map(c => this.expand(c)).toArray()
	    });
	  }

	  expandSwitchCase(term) {
	    return new T.SwitchCase({
	      test: this.expand(term.test),
	      consequent: term.consequent.map(c => this.expand(c)).toArray()
	    });
	  }

	  expandForInStatement(term) {
	    return new T.ForInStatement({
	      left: this.expand(term.left),
	      right: this.expand(term.right),
	      body: this.expand(term.body)
	    });
	  }

	  expandTryCatchStatement(term) {
	    return new T.TryCatchStatement({
	      body: this.expand(term.body),
	      catchClause: this.expand(term.catchClause)
	    });
	  }

	  expandTryFinallyStatement(term) {
	    let catchClause = term.catchClause == null ? null : this.expand(term.catchClause);
	    return new T.TryFinallyStatement({
	      body: this.expand(term.body),
	      catchClause,
	      finalizer: this.expand(term.finalizer)
	    });
	  }

	  expandCatchClause(term) {
	    return new T.CatchClause({
	      binding: this.expand(term.binding),
	      body: this.expand(term.body)
	    });
	  }

	  expandThrowStatement(term) {
	    return new T.ThrowStatement({
	      expression: this.expand(term.expression)
	    });
	  }

	  expandForOfStatement(term) {
	    return new T.ForOfStatement({
	      left: this.expand(term.left),
	      right: this.expand(term.right),
	      body: this.expand(term.body)
	    });
	  }

	  expandBindingIdentifier(term) {
	    return term;
	  }

	  expandBindingPropertyIdentifier(term) {
	    return term;
	  }
	  expandBindingPropertyProperty(term) {
	    return new T.BindingPropertyProperty({
	      name: this.expand(term.name),
	      binding: this.expand(term.binding)
	    });
	  }

	  expandComputedPropertyName(term) {
	    return new T.ComputedPropertyName({
	      expression: this.expand(term.expression)
	    });
	  }

	  expandObjectBinding(term) {
	    return new T.ObjectBinding({
	      properties: term.properties.map(t => this.expand(t)).toArray()
	    });
	  }

	  expandArrayBinding(term) {
	    let restElement = term.restElement == null ? null : this.expand(term.restElement);
	    return new T.ArrayBinding({
	      elements: term.elements.map(t => t == null ? null : this.expand(t)).toArray(),
	      restElement
	    });
	  }

	  expandBindingWithDefault(term) {
	    return new T.BindingWithDefault({
	      binding: this.expand(term.binding),
	      init: this.expand(term.init)
	    });
	  }

	  expandShorthandProperty(term) {
	    // because hygiene, shorthand properties must turn into DataProperties
	    return new T.DataProperty({
	      name: new T.StaticPropertyName({
	        value: term.name
	      }),
	      expression: new T.IdentifierExpression({
	        name: term.name
	      })
	    });
	  }

	  expandForStatement(term) {
	    let init = term.init == null ? null : this.expand(term.init);
	    let test = term.test == null ? null : this.expand(term.test);
	    let update = term.update == null ? null : this.expand(term.update);
	    let body = this.expand(term.body);
	    return new T.ForStatement({ init, test, update, body });
	  }

	  expandYieldExpression(term) {
	    let expr = term.expression == null ? null : this.expand(term.expression);
	    return new T.YieldExpression({
	      expression: expr
	    });
	  }

	  expandYieldGeneratorExpression(term) {
	    let expr = term.expression == null ? null : this.expand(term.expression);
	    return new T.YieldGeneratorExpression({
	      expression: expr
	    });
	  }

	  expandWhileStatement(term) {
	    return new T.WhileStatement({
	      test: this.expand(term.test),
	      body: this.expand(term.body)
	    });
	  }

	  expandIfStatement(term) {
	    let consequent = term.consequent == null ? null : this.expand(term.consequent);
	    let alternate = term.alternate == null ? null : this.expand(term.alternate);
	    return new T.IfStatement({
	      test: this.expand(term.test),
	      consequent: consequent,
	      alternate: alternate
	    });
	  }

	  expandBlockStatement(term) {
	    return new T.BlockStatement({
	      block: this.expand(term.block)
	    });
	  }

	  expandBlock(term) {
	    let scope = (0, _scope.freshScope)('block');
	    this.context.currentScope.push(scope);
	    let compiler = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);

	    let markedBody, bodyTerm;
	    markedBody = term.statements.map(b => b.reduce(new _scopeReducer2.default([{ scope, phase: _syntax.ALL_PHASES, flip: false }], this.context.bindings)));
	    bodyTerm = new T.Block({
	      statements: compiler.compile(markedBody)
	    });
	    this.context.currentScope.pop();
	    return bodyTerm;
	  }

	  expandVariableDeclarationStatement(term) {
	    return new T.VariableDeclarationStatement({
	      declaration: this.expand(term.declaration)
	    });
	  }
	  expandReturnStatement(term) {
	    if (term.expression == null) {
	      return term;
	    }
	    return new T.ReturnStatement({
	      expression: this.expand(term.expression)
	    });
	  }

	  expandClassDeclaration(term) {
	    return new T.ClassDeclaration({
	      name: term.name == null ? null : this.expand(term.name),
	      super: term.super == null ? null : this.expand(term.super),
	      elements: term.elements.map(el => this.expand(el)).toArray()
	    });
	  }

	  expandClassExpression(term) {
	    return new T.ClassExpression({
	      name: term.name == null ? null : this.expand(term.name),
	      super: term.super == null ? null : this.expand(term.super),
	      elements: term.elements.map(el => this.expand(el)).toArray()
	    });
	  }

	  expandClassElement(term) {
	    return new T.ClassElement({
	      isStatic: term.isStatic,
	      method: this.expand(term.method)
	    });
	  }

	  expandThisExpression(term) {
	    return term;
	  }

	  expandSyntaxTemplate(term) {
	    let r = (0, _templateProcessor.processTemplate)(term.template.slice(1, term.template.size - 1));
	    let ident = this.context.getTemplateIdentifier();
	    this.context.templateMap.set(ident, r.template);
	    let name = _syntax2.default.fromIdentifier('syntaxTemplate', term.template.first().value);
	    let callee = new T.IdentifierExpression({
	      name: name
	    });

	    let expandedInterps = r.interp.map(i => {
	      let enf = new _enforester.Enforester(i, (0, _immutable.List)(), this.context);
	      return this.expand(enf.enforest('expression'));
	    });

	    let args = _immutable.List.of(new T.LiteralNumericExpression({ value: ident })).concat(expandedInterps);

	    return new T.CallExpression({
	      callee, arguments: args
	    });
	  }

	  expandStaticMemberExpression(term) {
	    return new T.StaticMemberExpression({
	      object: this.expand(term.object),
	      property: term.property
	    });
	  }

	  expandArrayExpression(term) {
	    return new T.ArrayExpression({
	      elements: term.elements.map(t => t == null ? t : this.expand(t))
	    });
	  }

	  expandImport(term) {
	    return term;
	  }

	  expandImportNamespace(term) {
	    return term;
	  }

	  expandExport(term) {
	    return new T.Export({
	      declaration: this.expand(term.declaration)
	    });
	  }

	  expandExportDefault(term) {
	    return new T.ExportDefault({
	      body: this.expand(term.body)
	    });
	  }

	  expandExportFrom(term) {
	    return term;
	  }

	  expandExportAllFrom(term) {
	    return term;
	  }

	  expandExportSpecifier(term) {
	    return term;
	  }

	  expandStaticPropertyName(term) {
	    return term;
	  }

	  expandDataProperty(term) {
	    return new T.DataProperty({
	      name: this.expand(term.name),
	      expression: this.expand(term.expression)
	    });
	  }

	  expandObjectExpression(term) {
	    return new T.ObjectExpression({
	      properties: term.properties.map(t => this.expand(t))
	    });
	  }

	  expandVariableDeclarator(term) {
	    let init = term.init == null ? null : this.expand(term.init);
	    return new T.VariableDeclarator({
	      binding: this.expand(term.binding),
	      init: init
	    });
	  }

	  expandVariableDeclaration(term) {
	    if (term.kind === 'syntax' || term.kind === 'syntaxrec') {
	      return term;
	    }
	    return new T.VariableDeclaration({
	      kind: term.kind,
	      declarators: term.declarators.map(d => this.expand(d))
	    });
	  }

	  expandParenthesizedExpression(term) {
	    if (term.inner.size === 0) {
	      throw new Error('unexpected end of input');
	    }
	    let enf = new _enforester.Enforester(term.inner, (0, _immutable.List)(), this.context);
	    let lookahead = enf.peek();
	    let t = enf.enforestExpression();
	    if (t == null || enf.rest.size > 0) {
	      throw enf.createError(lookahead, 'unexpected syntax');
	    }
	    return this.expand(t);
	  }

	  expandUnaryExpression(term) {
	    return new T.UnaryExpression({
	      operator: term.operator,
	      operand: this.expand(term.operand)
	    });
	  }

	  expandUpdateExpression(term) {
	    return new T.UpdateExpression({
	      isPrefix: term.isPrefix,
	      operator: term.operator,
	      operand: this.expand(term.operand)
	    });
	  }

	  expandBinaryExpression(term) {
	    let left = this.expand(term.left);
	    let right = this.expand(term.right);
	    return new T.BinaryExpression({
	      left: left,
	      operator: term.operator,
	      right: right
	    });
	  }

	  expandConditionalExpression(term) {
	    return new T.ConditionalExpression({
	      test: this.expand(term.test),
	      consequent: this.expand(term.consequent),
	      alternate: this.expand(term.alternate)
	    });
	  }

	  expandNewTargetExpression(term) {
	    return term;
	  }

	  expandNewExpression(term) {
	    let callee = this.expand(term.callee);
	    let enf = new _enforester.Enforester(term.arguments, (0, _immutable.List)(), this.context);
	    let args = enf.enforestArgumentList().map(arg => this.expand(arg));
	    return new T.NewExpression({
	      callee,
	      arguments: args.toArray()
	    });
	  }

	  expandSuper(term) {
	    return term;
	  }

	  expandCallExpression(term) {
	    let callee = this.expand(term.callee);
	    let enf = new _enforester.Enforester(term.arguments, (0, _immutable.List)(), this.context);
	    let args = enf.enforestArgumentList().map(arg => this.expand(arg));
	    return new T.CallExpression({
	      callee: callee,
	      arguments: args
	    });
	  }

	  expandSpreadElement(term) {
	    return new T.SpreadElement({
	      expression: this.expand(term.expression)
	    });
	  }

	  expandExpressionStatement(term) {
	    let child = this.expand(term.expression);
	    return new T.ExpressionStatement({
	      expression: child
	    });
	  }

	  expandLabeledStatement(term) {
	    return new T.LabeledStatement({
	      label: term.label.val(),
	      body: this.expand(term.body)
	    });
	  }

	  doFunctionExpansion(term, type) {
	    let scope = (0, _scope.freshScope)('fun');
	    let params;
	    let self = this;
	    if (type !== 'Getter' && type !== 'Setter') {
	      // TODO: need to register the parameter bindings again
	      params = term.params.reduce(new class extends T.default.CloneReducer {
	        reduceBindingIdentifier(term) {
	          let name = term.name.addScope(scope, self.context.bindings, _syntax.ALL_PHASES);
	          let newBinding = (0, _symbol.gensym)(name.val());

	          self.context.env.set(newBinding.toString(), new _transforms.VarBindingTransform(name));
	          self.context.bindings.add(name, {
	            binding: newBinding,
	            phase: self.context.phase,
	            skipDup: true
	          });
	          return new T.BindingIdentifier({ name });
	        }
	      }());
	      params = this.expand(params);
	    }
	    this.context.currentScope.push(scope);
	    let compiler = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);

	    let bodyTerm;
	    let scopeReducer = new _scopeReducer2.default([{ scope, phase: _syntax.ALL_PHASES, flip: false }], this.context.bindings);
	    if (term.body instanceof T.default) {
	      // Arrow functions have a single term as their body
	      bodyTerm = this.expand(term.body.reduce(scopeReducer));
	    } else {
	      let compiledBody = compiler.compile(term.body.map(b => b.reduce(scopeReducer)));
	      const directives = compiledBody.takeWhile(s => (0, _terms.isExpressionStatement)(s) && (0, _terms.isLiteralStringExpression)(s.expression)).map(s => new T.Directive({ rawValue: s.expression.value }));
	      bodyTerm = new T.FunctionBody({
	        directives: directives,
	        statements: compiledBody.slice(directives.size)
	      });
	    }
	    this.context.currentScope.pop();

	    switch (type) {
	      case 'Getter':
	        return new T.Getter({
	          name: this.expand(term.name),
	          body: bodyTerm
	        });
	      case 'Setter':
	        return new T.Setter({
	          name: this.expand(term.name),
	          param: term.param,
	          body: bodyTerm
	        });
	      case 'Method':
	        return new T.Method({
	          name: term.name,
	          isGenerator: term.isGenerator,
	          params: params,
	          body: bodyTerm
	        });
	      case 'ArrowExpression':
	        return new T.ArrowExpression({
	          params: params,
	          body: bodyTerm
	        });
	      case 'FunctionExpression':
	        return new T.FunctionExpression({
	          name: term.name,
	          isGenerator: term.isGenerator,
	          params: params,
	          body: bodyTerm
	        });
	      case 'FunctionDeclaration':
	        return new T.FunctionDeclaration({
	          name: term.name,
	          isGenerator: term.isGenerator,
	          params: params,
	          body: bodyTerm
	        });
	      default:
	        throw new Error(`Unknown function type: ${ type }`);
	    }
	  }

	  expandMethod(term) {
	    return this.doFunctionExpansion(term, 'Method');
	  }

	  expandSetter(term) {
	    return this.doFunctionExpansion(term, 'Setter');
	  }

	  expandGetter(term) {
	    return this.doFunctionExpansion(term, 'Getter');
	  }

	  expandFunctionDeclarationE(term) {
	    return this.doFunctionExpansion(term, 'FunctionDeclaration');
	  }

	  expandFunctionExpressionE(term) {
	    return this.doFunctionExpansion(term, 'FunctionExpression');
	  }

	  expandCompoundAssignmentExpression(term) {
	    return new T.CompoundAssignmentExpression({
	      binding: this.expand(term.binding),
	      operator: term.operator,
	      expression: this.expand(term.expression)
	    });
	  }

	  expandAssignmentExpression(term) {
	    return new T.AssignmentExpression({
	      binding: this.expand(term.binding),
	      expression: this.expand(term.expression)
	    });
	  }

	  expandEmptyStatement(term) {
	    return term;
	  }

	  expandLiteralBooleanExpression(term) {
	    return term;
	  }

	  expandLiteralNumericExpression(term) {
	    return term;
	  }
	  expandLiteralInfinityExpression(term) {
	    return term;
	  }

	  expandIdentifierExpression(term) {
	    let trans = this.context.env.get(term.name.resolve(this.context.phase));
	    if (trans) {
	      return new T.IdentifierExpression({
	        name: trans.id
	      });
	    }
	    return term;
	  }

	  expandLiteralNullExpression(term) {
	    return term;
	  }

	  expandLiteralStringExpression(term) {
	    return term;
	  }

	  expandLiteralRegExpExpression(term) {
	    return term;
	  }
	}
	exports.default = TermExpander;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXJtLWV4cGFuZGVyLmpzIl0sIm5hbWVzIjpbIlQiLCJUZXJtRXhwYW5kZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJleHBhbmQiLCJ0ZXJtIiwiZGlzcGF0Y2giLCJleHBhbmRSYXdTeW50YXgiLCJleHBhbmRSYXdEZWxpbWl0ZXIiLCJleHBhbmRUZW1wbGF0ZUV4cHJlc3Npb24iLCJUZW1wbGF0ZUV4cHJlc3Npb24iLCJ0YWciLCJlbGVtZW50cyIsInRvQXJyYXkiLCJleHBhbmRCcmVha1N0YXRlbWVudCIsIkJyZWFrU3RhdGVtZW50IiwibGFiZWwiLCJ2YWwiLCJleHBhbmREb1doaWxlU3RhdGVtZW50IiwiRG9XaGlsZVN0YXRlbWVudCIsImJvZHkiLCJ0ZXN0IiwiZXhwYW5kV2l0aFN0YXRlbWVudCIsIldpdGhTdGF0ZW1lbnQiLCJvYmplY3QiLCJleHBhbmREZWJ1Z2dlclN0YXRlbWVudCIsImV4cGFuZENvbnRpbnVlU3RhdGVtZW50IiwiQ29udGludWVTdGF0ZW1lbnQiLCJleHBhbmRTd2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdCIsIlN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0IiwiZGlzY3JpbWluYW50IiwicHJlRGVmYXVsdENhc2VzIiwibWFwIiwiYyIsImRlZmF1bHRDYXNlIiwicG9zdERlZmF1bHRDYXNlcyIsImV4cGFuZENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiIsIkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiIsImV4cHJlc3Npb24iLCJleHBhbmRTd2l0Y2hTdGF0ZW1lbnQiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJjYXNlcyIsImV4cGFuZEZvcm1hbFBhcmFtZXRlcnMiLCJyZXN0IiwiRm9ybWFsUGFyYW1ldGVycyIsIml0ZW1zIiwiaSIsImV4cGFuZEFycm93RXhwcmVzc2lvbkUiLCJkb0Z1bmN0aW9uRXhwYW5zaW9uIiwiZXhwYW5kQXJyb3dFeHByZXNzaW9uIiwiZXhwYW5kU3dpdGNoRGVmYXVsdCIsIlN3aXRjaERlZmF1bHQiLCJjb25zZXF1ZW50IiwiZXhwYW5kU3dpdGNoQ2FzZSIsIlN3aXRjaENhc2UiLCJleHBhbmRGb3JJblN0YXRlbWVudCIsIkZvckluU3RhdGVtZW50IiwibGVmdCIsInJpZ2h0IiwiZXhwYW5kVHJ5Q2F0Y2hTdGF0ZW1lbnQiLCJUcnlDYXRjaFN0YXRlbWVudCIsImNhdGNoQ2xhdXNlIiwiZXhwYW5kVHJ5RmluYWxseVN0YXRlbWVudCIsIlRyeUZpbmFsbHlTdGF0ZW1lbnQiLCJmaW5hbGl6ZXIiLCJleHBhbmRDYXRjaENsYXVzZSIsIkNhdGNoQ2xhdXNlIiwiYmluZGluZyIsImV4cGFuZFRocm93U3RhdGVtZW50IiwiVGhyb3dTdGF0ZW1lbnQiLCJleHBhbmRGb3JPZlN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiZXhwYW5kQmluZGluZ0lkZW50aWZpZXIiLCJleHBhbmRCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyIiwiZXhwYW5kQmluZGluZ1Byb3BlcnR5UHJvcGVydHkiLCJCaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSIsIm5hbWUiLCJleHBhbmRDb21wdXRlZFByb3BlcnR5TmFtZSIsIkNvbXB1dGVkUHJvcGVydHlOYW1lIiwiZXhwYW5kT2JqZWN0QmluZGluZyIsIk9iamVjdEJpbmRpbmciLCJwcm9wZXJ0aWVzIiwidCIsImV4cGFuZEFycmF5QmluZGluZyIsInJlc3RFbGVtZW50IiwiQXJyYXlCaW5kaW5nIiwiZXhwYW5kQmluZGluZ1dpdGhEZWZhdWx0IiwiQmluZGluZ1dpdGhEZWZhdWx0IiwiaW5pdCIsImV4cGFuZFNob3J0aGFuZFByb3BlcnR5IiwiRGF0YVByb3BlcnR5IiwiU3RhdGljUHJvcGVydHlOYW1lIiwidmFsdWUiLCJJZGVudGlmaWVyRXhwcmVzc2lvbiIsImV4cGFuZEZvclN0YXRlbWVudCIsInVwZGF0ZSIsIkZvclN0YXRlbWVudCIsImV4cGFuZFlpZWxkRXhwcmVzc2lvbiIsImV4cHIiLCJZaWVsZEV4cHJlc3Npb24iLCJleHBhbmRZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24iLCJZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24iLCJleHBhbmRXaGlsZVN0YXRlbWVudCIsIldoaWxlU3RhdGVtZW50IiwiZXhwYW5kSWZTdGF0ZW1lbnQiLCJhbHRlcm5hdGUiLCJJZlN0YXRlbWVudCIsImV4cGFuZEJsb2NrU3RhdGVtZW50IiwiQmxvY2tTdGF0ZW1lbnQiLCJibG9jayIsImV4cGFuZEJsb2NrIiwic2NvcGUiLCJjdXJyZW50U2NvcGUiLCJwdXNoIiwiY29tcGlsZXIiLCJwaGFzZSIsImVudiIsInN0b3JlIiwibWFya2VkQm9keSIsImJvZHlUZXJtIiwic3RhdGVtZW50cyIsImIiLCJyZWR1Y2UiLCJmbGlwIiwiYmluZGluZ3MiLCJCbG9jayIsImNvbXBpbGUiLCJwb3AiLCJleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50IiwiVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCIsImRlY2xhcmF0aW9uIiwiZXhwYW5kUmV0dXJuU3RhdGVtZW50IiwiUmV0dXJuU3RhdGVtZW50IiwiZXhwYW5kQ2xhc3NEZWNsYXJhdGlvbiIsIkNsYXNzRGVjbGFyYXRpb24iLCJzdXBlciIsImVsIiwiZXhwYW5kQ2xhc3NFeHByZXNzaW9uIiwiQ2xhc3NFeHByZXNzaW9uIiwiZXhwYW5kQ2xhc3NFbGVtZW50IiwiQ2xhc3NFbGVtZW50IiwiaXNTdGF0aWMiLCJtZXRob2QiLCJleHBhbmRUaGlzRXhwcmVzc2lvbiIsImV4cGFuZFN5bnRheFRlbXBsYXRlIiwiciIsInRlbXBsYXRlIiwic2xpY2UiLCJzaXplIiwiaWRlbnQiLCJnZXRUZW1wbGF0ZUlkZW50aWZpZXIiLCJ0ZW1wbGF0ZU1hcCIsInNldCIsImZyb21JZGVudGlmaWVyIiwiZmlyc3QiLCJjYWxsZWUiLCJleHBhbmRlZEludGVycHMiLCJpbnRlcnAiLCJlbmYiLCJlbmZvcmVzdCIsImFyZ3MiLCJvZiIsIkxpdGVyYWxOdW1lcmljRXhwcmVzc2lvbiIsImNvbmNhdCIsIkNhbGxFeHByZXNzaW9uIiwiYXJndW1lbnRzIiwiZXhwYW5kU3RhdGljTWVtYmVyRXhwcmVzc2lvbiIsIlN0YXRpY01lbWJlckV4cHJlc3Npb24iLCJwcm9wZXJ0eSIsImV4cGFuZEFycmF5RXhwcmVzc2lvbiIsIkFycmF5RXhwcmVzc2lvbiIsImV4cGFuZEltcG9ydCIsImV4cGFuZEltcG9ydE5hbWVzcGFjZSIsImV4cGFuZEV4cG9ydCIsIkV4cG9ydCIsImV4cGFuZEV4cG9ydERlZmF1bHQiLCJFeHBvcnREZWZhdWx0IiwiZXhwYW5kRXhwb3J0RnJvbSIsImV4cGFuZEV4cG9ydEFsbEZyb20iLCJleHBhbmRFeHBvcnRTcGVjaWZpZXIiLCJleHBhbmRTdGF0aWNQcm9wZXJ0eU5hbWUiLCJleHBhbmREYXRhUHJvcGVydHkiLCJleHBhbmRPYmplY3RFeHByZXNzaW9uIiwiT2JqZWN0RXhwcmVzc2lvbiIsImV4cGFuZFZhcmlhYmxlRGVjbGFyYXRvciIsIlZhcmlhYmxlRGVjbGFyYXRvciIsImV4cGFuZFZhcmlhYmxlRGVjbGFyYXRpb24iLCJraW5kIiwiVmFyaWFibGVEZWNsYXJhdGlvbiIsImRlY2xhcmF0b3JzIiwiZCIsImV4cGFuZFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwiaW5uZXIiLCJFcnJvciIsImxvb2thaGVhZCIsInBlZWsiLCJlbmZvcmVzdEV4cHJlc3Npb24iLCJjcmVhdGVFcnJvciIsImV4cGFuZFVuYXJ5RXhwcmVzc2lvbiIsIlVuYXJ5RXhwcmVzc2lvbiIsIm9wZXJhdG9yIiwib3BlcmFuZCIsImV4cGFuZFVwZGF0ZUV4cHJlc3Npb24iLCJVcGRhdGVFeHByZXNzaW9uIiwiaXNQcmVmaXgiLCJleHBhbmRCaW5hcnlFeHByZXNzaW9uIiwiQmluYXJ5RXhwcmVzc2lvbiIsImV4cGFuZENvbmRpdGlvbmFsRXhwcmVzc2lvbiIsIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImV4cGFuZE5ld1RhcmdldEV4cHJlc3Npb24iLCJleHBhbmROZXdFeHByZXNzaW9uIiwiZW5mb3Jlc3RBcmd1bWVudExpc3QiLCJhcmciLCJOZXdFeHByZXNzaW9uIiwiZXhwYW5kU3VwZXIiLCJleHBhbmRDYWxsRXhwcmVzc2lvbiIsImV4cGFuZFNwcmVhZEVsZW1lbnQiLCJTcHJlYWRFbGVtZW50IiwiZXhwYW5kRXhwcmVzc2lvblN0YXRlbWVudCIsImNoaWxkIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsImV4cGFuZExhYmVsZWRTdGF0ZW1lbnQiLCJMYWJlbGVkU3RhdGVtZW50IiwidHlwZSIsInBhcmFtcyIsInNlbGYiLCJDbG9uZVJlZHVjZXIiLCJyZWR1Y2VCaW5kaW5nSWRlbnRpZmllciIsImFkZFNjb3BlIiwibmV3QmluZGluZyIsInRvU3RyaW5nIiwiYWRkIiwic2tpcER1cCIsIkJpbmRpbmdJZGVudGlmaWVyIiwic2NvcGVSZWR1Y2VyIiwiY29tcGlsZWRCb2R5IiwiZGlyZWN0aXZlcyIsInRha2VXaGlsZSIsInMiLCJEaXJlY3RpdmUiLCJyYXdWYWx1ZSIsIkZ1bmN0aW9uQm9keSIsIkdldHRlciIsIlNldHRlciIsInBhcmFtIiwiTWV0aG9kIiwiaXNHZW5lcmF0b3IiLCJBcnJvd0V4cHJlc3Npb24iLCJGdW5jdGlvbkV4cHJlc3Npb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiZXhwYW5kTWV0aG9kIiwiZXhwYW5kU2V0dGVyIiwiZXhwYW5kR2V0dGVyIiwiZXhwYW5kRnVuY3Rpb25EZWNsYXJhdGlvbkUiLCJleHBhbmRGdW5jdGlvbkV4cHJlc3Npb25FIiwiZXhwYW5kQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbiIsIkNvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24iLCJleHBhbmRBc3NpZ25tZW50RXhwcmVzc2lvbiIsIkFzc2lnbm1lbnRFeHByZXNzaW9uIiwiZXhwYW5kRW1wdHlTdGF0ZW1lbnQiLCJleHBhbmRMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24iLCJleHBhbmRMaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24iLCJleHBhbmRMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uIiwiZXhwYW5kSWRlbnRpZmllckV4cHJlc3Npb24iLCJ0cmFucyIsImdldCIsInJlc29sdmUiLCJpZCIsImV4cGFuZExpdGVyYWxOdWxsRXhwcmVzc2lvbiIsImV4cGFuZExpdGVyYWxTdHJpbmdFeHByZXNzaW9uIiwiZXhwYW5kTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOztBQUNBOztJQUFrQkEsQzs7QUFDbEI7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O0FBR2UsTUFBTUMsWUFBTixpQ0FBeUM7QUFDdERDLGNBQVlDLE9BQVosRUFBcUI7QUFDbkIsVUFBTSxRQUFOLEVBQWdCLElBQWhCO0FBQ0EsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRURDLFNBQU9DLElBQVAsRUFBYTtBQUNYLFdBQU8sS0FBS0MsUUFBTCxDQUFjRCxJQUFkLENBQVA7QUFDRDs7QUFFREUsa0JBQWdCRixJQUFoQixFQUFzQjtBQUNwQixXQUFPQSxJQUFQO0FBQ0Q7O0FBRURHLHFCQUFtQkgsSUFBbkIsRUFBeUI7QUFDdkIsV0FBT0EsSUFBUDtBQUNEOztBQUVESSwyQkFBeUJKLElBQXpCLEVBQStCO0FBQzdCLFdBQU8sSUFBSUwsRUFBRVUsa0JBQU4sQ0FBeUI7QUFDOUJDLFdBQUtOLEtBQUtNLEdBQUwsSUFBWSxJQUFaLEdBQW1CLElBQW5CLEdBQTBCLEtBQUtQLE1BQUwsQ0FBWUMsS0FBS00sR0FBakIsQ0FERDtBQUU5QkMsZ0JBQVVQLEtBQUtPLFFBQUwsQ0FBY0MsT0FBZDtBQUZvQixLQUF6QixDQUFQO0FBSUQ7O0FBRURDLHVCQUFxQlQsSUFBckIsRUFBMkI7QUFDekIsV0FBTyxJQUFJTCxFQUFFZSxjQUFOLENBQXFCO0FBQzFCQyxhQUFPWCxLQUFLVyxLQUFMLEdBQWFYLEtBQUtXLEtBQUwsQ0FBV0MsR0FBWCxFQUFiLEdBQWdDO0FBRGIsS0FBckIsQ0FBUDtBQUdEOztBQUVEQyx5QkFBdUJiLElBQXZCLEVBQTZCO0FBQzNCLFdBQU8s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S3JRLE9BQUwsQ0FBYWlILEdBQWIsQ0FBaUJxSixHQUFqQixDQUFxQnBRLEtBQUt1RSxJQUFMLENBQVU4TCxPQUFWLENBQWtCLEtBQUt2USxPQUFMLENBQWFnSCxLQUEvQixDQUFyQixDQUFaO0FBQ0EsUUFBSXFKLEtBQUosRUFBVztBQUNULGFBQU8sSUFBSXhRLEVBQUU2RixvQkFBTixDQUEyQjtBQUNoQ2pCLGNBQU00TCxNQUFNRztBQURvQixPQUEzQixDQUFQO0FBR0Q7QUFDRCxXQUFPdFEsSUFBUDtBQUNEOztBQUVEdVEsOEJBQTRCdlEsSUFBNUIsRUFBa0M7QUFDaEMsV0FBT0EsSUFBUDtBQUNEOztBQUVEd1EsZ0NBQThCeFEsSUFBOUIsRUFBb0M7QUFDbEMsV0FBT0EsSUFBUDtBQUNEOztBQUVEeVEsZ0NBQThCelEsSUFBOUIsRUFBb0M7QUFDbEMsV0FBT0EsSUFBUDtBQUNEO0FBL29CcUQ7a0JBQW5DSixZIiwiZmlsZSI6InRlcm0tZXhwYW5kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB7IGlzRXhwcmVzc2lvblN0YXRlbWVudCwgaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbiB9IGZyb20gJy4vdGVybXMnO1xuaW1wb3J0IFRlcm0sICogYXMgVCBmcm9tICdzd2VldC1zcGVjJztcbmltcG9ydCB7IGZyZXNoU2NvcGUgfSBmcm9tICcuL3Njb3BlJztcbmltcG9ydCBDb21waWxlciBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7IEFMTF9QSEFTRVMgfSBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgeyBFbmZvcmVzdGVyIH0gZnJvbSAnLi9lbmZvcmVzdGVyJztcbmltcG9ydCB7IHByb2Nlc3NUZW1wbGF0ZSB9IGZyb20gJy4vdGVtcGxhdGUtcHJvY2Vzc29yJztcbmltcG9ydCBBU1REaXNwYXRjaGVyIGZyb20gJy4vYXN0LWRpc3BhdGNoZXInO1xuaW1wb3J0IFNjb3BlUmVkdWNlciBmcm9tICcuL3Njb3BlLXJlZHVjZXInO1xuaW1wb3J0IHsgZ2Vuc3ltIH0gZnJvbSAnLi9zeW1ib2wnO1xuaW1wb3J0IHsgVmFyQmluZGluZ1RyYW5zZm9ybSB9IGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5pbXBvcnQgU3ludGF4IGZyb20gJy4vc3ludGF4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybUV4cGFuZGVyIGV4dGVuZHMgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICBzdXBlcignZXhwYW5kJywgdHJ1ZSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGV4cGFuZCh0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2godGVybSk7XG4gIH1cblxuICBleHBhbmRSYXdTeW50YXgodGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kUmF3RGVsaW1pdGVyKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGV4cGFuZFRlbXBsYXRlRXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULlRlbXBsYXRlRXhwcmVzc2lvbih7XG4gICAgICB0YWc6IHRlcm0udGFnID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS50YWcpLFxuICAgICAgZWxlbWVudHM6IHRlcm0uZWxlbWVudHMudG9BcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRCcmVha1N0YXRlbWVudCh0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkJyZWFrU3RhdGVtZW50KHtcbiAgICAgIGxhYmVsOiB0ZXJtLmxhYmVsID8gdGVybS5sYWJlbC52YWwoKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZERvV2hpbGVTdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Eb1doaWxlU3RhdGVtZW50KHtcbiAgICAgIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm0uYm9keSksXG4gICAgICB0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtLnRlc3QpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRXaXRoU3RhdGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuV2l0aFN0YXRlbWVudCh7XG4gICAgICBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtLmJvZHkpLFxuICAgICAgb2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtLm9iamVjdClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZERlYnVnZ2VyU3RhdGVtZW50KHRlcm0pIHsgcmV0dXJuIHRlcm07fVxuXG4gIGV4cGFuZENvbnRpbnVlU3RhdGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuQ29udGludWVTdGF0ZW1lbnQoe1xuICAgICAgbGFiZWw6IHRlcm0ubGFiZWwgPyB0ZXJtLmxhYmVsLnZhbCgpIDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Td2l0Y2hTdGF0ZW1lbnRXaXRoRGVmYXVsdCh7XG4gICAgICBkaXNjcmltaW5hbnQ6IHRoaXMuZXhwYW5kKHRlcm0uZGlzY3JpbWluYW50KSxcbiAgICAgIHByZURlZmF1bHRDYXNlczogdGVybS5wcmVEZWZhdWx0Q2FzZXMubWFwKGMgPT4gdGhpcy5leHBhbmQoYykpLnRvQXJyYXkoKSxcbiAgICAgIGRlZmF1bHRDYXNlOiB0aGlzLmV4cGFuZCh0ZXJtLmRlZmF1bHRDYXNlKSxcbiAgICAgIHBvc3REZWZhdWx0Q2FzZXM6IHRlcm0ucG9zdERlZmF1bHRDYXNlcy5tYXAoYyA9PiB0aGlzLmV4cGFuZChjKSkudG9BcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRDb21wdXRlZE1lbWJlckV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oe1xuICAgICAgb2JqZWN0OiB0aGlzLmV4cGFuZCh0ZXJtLm9iamVjdCksXG4gICAgICBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtLmV4cHJlc3Npb24pXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRTd2l0Y2hTdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Td2l0Y2hTdGF0ZW1lbnQoe1xuICAgICAgZGlzY3JpbWluYW50OiB0aGlzLmV4cGFuZCh0ZXJtLmRpc2NyaW1pbmFudCksXG4gICAgICBjYXNlczogdGVybS5jYXNlcy5tYXAoYyA9PiB0aGlzLmV4cGFuZChjKSkudG9BcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRGb3JtYWxQYXJhbWV0ZXJzKHRlcm0pIHtcbiAgICBsZXQgcmVzdCA9IHRlcm0ucmVzdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm0ucmVzdCk7XG4gICAgcmV0dXJuIG5ldyBULkZvcm1hbFBhcmFtZXRlcnMoe1xuICAgICAgaXRlbXM6IHRlcm0uaXRlbXMubWFwKGkgPT4gdGhpcy5leHBhbmQoaSkpLFxuICAgICAgcmVzdFxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQXJyb3dFeHByZXNzaW9uRSh0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtLCAnQXJyb3dFeHByZXNzaW9uJyk7XG4gIH1cblxuICBleHBhbmRBcnJvd0V4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiB0aGlzLmRvRnVuY3Rpb25FeHBhbnNpb24odGVybSwgJ0Fycm93RXhwcmVzc2lvbicpO1xuICB9XG5cbiAgZXhwYW5kU3dpdGNoRGVmYXVsdCh0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULlN3aXRjaERlZmF1bHQoe1xuICAgICAgY29uc2VxdWVudDogdGVybS5jb25zZXF1ZW50Lm1hcChjID0+IHRoaXMuZXhwYW5kKGMpKS50b0FycmF5KClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFN3aXRjaENhc2UodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Td2l0Y2hDYXNlKHtcbiAgICAgIHRlc3Q6IHRoaXMuZXhwYW5kKHRlcm0udGVzdCksXG4gICAgICBjb25zZXF1ZW50OiB0ZXJtLmNvbnNlcXVlbnQubWFwKGMgPT4gdGhpcy5leHBhbmQoYykpLnRvQXJyYXkoKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kRm9ySW5TdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Gb3JJblN0YXRlbWVudCh7XG4gICAgICBsZWZ0OiB0aGlzLmV4cGFuZCh0ZXJtLmxlZnQpLFxuICAgICAgcmlnaHQ6IHRoaXMuZXhwYW5kKHRlcm0ucmlnaHQpLFxuICAgICAgYm9keTogdGhpcy5leHBhbmQodGVybS5ib2R5KVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kVHJ5Q2F0Y2hTdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5UcnlDYXRjaFN0YXRlbWVudCh7XG4gICAgICBib2R5OiB0aGlzLmV4cGFuZCh0ZXJtLmJvZHkpLFxuICAgICAgY2F0Y2hDbGF1c2U6IHRoaXMuZXhwYW5kKHRlcm0uY2F0Y2hDbGF1c2UpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRUcnlGaW5hbGx5U3RhdGVtZW50KHRlcm0pIHtcbiAgICBsZXQgY2F0Y2hDbGF1c2UgPSB0ZXJtLmNhdGNoQ2xhdXNlID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5jYXRjaENsYXVzZSk7XG4gICAgcmV0dXJuIG5ldyBULlRyeUZpbmFsbHlTdGF0ZW1lbnQoe1xuICAgICAgYm9keTogdGhpcy5leHBhbmQodGVybS5ib2R5KSxcbiAgICAgIGNhdGNoQ2xhdXNlLFxuICAgICAgZmluYWxpemVyOiB0aGlzLmV4cGFuZCh0ZXJtLmZpbmFsaXplcilcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZENhdGNoQ2xhdXNlKHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuQ2F0Y2hDbGF1c2Uoe1xuICAgICAgYmluZGluZzogdGhpcy5leHBhbmQodGVybS5iaW5kaW5nKSxcbiAgICAgIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm0uYm9keSlcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFRocm93U3RhdGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuVGhyb3dTdGF0ZW1lbnQoe1xuICAgICAgZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybS5leHByZXNzaW9uKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kRm9yT2ZTdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Gb3JPZlN0YXRlbWVudCh7XG4gICAgICBsZWZ0OiB0aGlzLmV4cGFuZCh0ZXJtLmxlZnQpLFxuICAgICAgcmlnaHQ6IHRoaXMuZXhwYW5kKHRlcm0ucmlnaHQpLFxuICAgICAgYm9keTogdGhpcy5leHBhbmQodGVybS5ib2R5KVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQmluZGluZ0lkZW50aWZpZXIodGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcih0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cbiAgZXhwYW5kQmluZGluZ1Byb3BlcnR5UHJvcGVydHkodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5CaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiB0aGlzLmV4cGFuZCh0ZXJtLm5hbWUpLFxuICAgICAgYmluZGluZzogdGhpcy5leHBhbmQodGVybS5iaW5kaW5nKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQ29tcHV0ZWRQcm9wZXJ0eU5hbWUodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Db21wdXRlZFByb3BlcnR5TmFtZSh7XG4gICAgICBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtLmV4cHJlc3Npb24pXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRPYmplY3RCaW5kaW5nKHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuT2JqZWN0QmluZGluZyh7XG4gICAgICBwcm9wZXJ0aWVzOiB0ZXJtLnByb3BlcnRpZXMubWFwKHQgPT4gdGhpcy5leHBhbmQodCkpLnRvQXJyYXkoKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQXJyYXlCaW5kaW5nKHRlcm0pIHtcbiAgICBsZXQgcmVzdEVsZW1lbnQgPSB0ZXJtLnJlc3RFbGVtZW50ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5yZXN0RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ldyBULkFycmF5QmluZGluZyh7XG4gICAgICBlbGVtZW50czogdGVybS5lbGVtZW50cy5tYXAodCA9PiB0ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodCkpLnRvQXJyYXkoKSxcbiAgICAgIHJlc3RFbGVtZW50XG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRCaW5kaW5nV2l0aERlZmF1bHQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5CaW5kaW5nV2l0aERlZmF1bHQoe1xuICAgICAgYmluZGluZzogdGhpcy5leHBhbmQodGVybS5iaW5kaW5nKSxcbiAgICAgIGluaXQ6IHRoaXMuZXhwYW5kKHRlcm0uaW5pdClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFNob3J0aGFuZFByb3BlcnR5KHRlcm0pIHtcbiAgICAvLyBiZWNhdXNlIGh5Z2llbmUsIHNob3J0aGFuZCBwcm9wZXJ0aWVzIG11c3QgdHVybiBpbnRvIERhdGFQcm9wZXJ0aWVzXG4gICAgcmV0dXJuIG5ldyBULkRhdGFQcm9wZXJ0eSh7XG4gICAgICBuYW1lOiBuZXcgVC5TdGF0aWNQcm9wZXJ0eU5hbWUoe1xuICAgICAgICB2YWx1ZTogdGVybS5uYW1lXG4gICAgICB9KSxcbiAgICAgIGV4cHJlc3Npb246IG5ldyBULklkZW50aWZpZXJFeHByZXNzaW9uKHtcbiAgICAgICAgbmFtZTogdGVybS5uYW1lXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cblxuICBleHBhbmRGb3JTdGF0ZW1lbnQodGVybSkge1xuICAgIGxldCBpbml0ID0gdGVybS5pbml0ID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5pbml0KTtcbiAgICBsZXQgdGVzdCA9IHRlcm0udGVzdCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm0udGVzdCk7XG4gICAgbGV0IHVwZGF0ZSA9IHRlcm0udXBkYXRlID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS51cGRhdGUpO1xuICAgIGxldCBib2R5ID0gdGhpcy5leHBhbmQodGVybS5ib2R5KTtcbiAgICByZXR1cm4gbmV3IFQuRm9yU3RhdGVtZW50KHsgaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5IH0pO1xuICB9XG5cbiAgZXhwYW5kWWllbGRFeHByZXNzaW9uKHRlcm0pIHtcbiAgICBsZXQgZXhwciA9IHRlcm0uZXhwcmVzc2lvbiA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm0uZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5ldyBULllpZWxkRXhwcmVzc2lvbih7XG4gICAgICBleHByZXNzaW9uOiBleHByXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24odGVybSkge1xuICAgIGxldCBleHByID0gdGVybS5leHByZXNzaW9uID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gbmV3IFQuWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uKHtcbiAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFdoaWxlU3RhdGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuV2hpbGVTdGF0ZW1lbnQoe1xuICAgICAgdGVzdDogdGhpcy5leHBhbmQodGVybS50ZXN0KSxcbiAgICAgIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm0uYm9keSlcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZElmU3RhdGVtZW50KHRlcm0pIHtcbiAgICBsZXQgY29uc2VxdWVudCA9IHRlcm0uY29uc2VxdWVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMuZXhwYW5kKHRlcm0uY29uc2VxdWVudCk7XG4gICAgbGV0IGFsdGVybmF0ZSA9IHRlcm0uYWx0ZXJuYXRlID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5hbHRlcm5hdGUpO1xuICAgIHJldHVybiBuZXcgVC5JZlN0YXRlbWVudCh7XG4gICAgICB0ZXN0OiB0aGlzLmV4cGFuZCh0ZXJtLnRlc3QpLFxuICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcbiAgICAgIGFsdGVybmF0ZTogYWx0ZXJuYXRlXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRCbG9ja1N0YXRlbWVudCh0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkJsb2NrU3RhdGVtZW50KHtcbiAgICAgIGJsb2NrOiB0aGlzLmV4cGFuZCh0ZXJtLmJsb2NrKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQmxvY2sodGVybSkge1xuICAgIGxldCBzY29wZSA9IGZyZXNoU2NvcGUoJ2Jsb2NrJyk7XG4gICAgdGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZS5wdXNoKHNjb3BlKTtcbiAgICBsZXQgY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIodGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuZW52LCB0aGlzLmNvbnRleHQuc3RvcmUsIHRoaXMuY29udGV4dCk7XG5cbiAgICBsZXQgbWFya2VkQm9keSwgYm9keVRlcm07XG4gICAgbWFya2VkQm9keSA9IHRlcm0uc3RhdGVtZW50cy5tYXAoYiA9PiBiLnJlZHVjZShuZXcgU2NvcGVSZWR1Y2VyKFt7c2NvcGUsIHBoYXNlOiBBTExfUEhBU0VTLCBmbGlwOiBmYWxzZX1dLCB0aGlzLmNvbnRleHQuYmluZGluZ3MpKSk7XG4gICAgYm9keVRlcm0gPSBuZXcgVC5CbG9jayh7XG4gICAgICBzdGF0ZW1lbnRzOiBjb21waWxlci5jb21waWxlKG1hcmtlZEJvZHkpXG4gICAgfSk7XG4gICAgdGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZS5wb3AoKTtcbiAgICByZXR1cm4gYm9keVRlcm07XG4gIH1cblxuICBleHBhbmRWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCh7XG4gICAgICBkZWNsYXJhdGlvbjogdGhpcy5leHBhbmQodGVybS5kZWNsYXJhdGlvbilcbiAgICB9KTtcbiAgfVxuICBleHBhbmRSZXR1cm5TdGF0ZW1lbnQodGVybSkge1xuICAgIGlmICh0ZXJtLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRlcm07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVC5SZXR1cm5TdGF0ZW1lbnQoe1xuICAgICAgZXhwcmVzc2lvbjogdGhpcy5leHBhbmQodGVybS5leHByZXNzaW9uKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQ2xhc3NEZWNsYXJhdGlvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkNsYXNzRGVjbGFyYXRpb24oe1xuICAgICAgbmFtZTogdGVybS5uYW1lID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5uYW1lKSxcbiAgICAgIHN1cGVyOiB0ZXJtLnN1cGVyID09IG51bGwgPyBudWxsIDogdGhpcy5leHBhbmQodGVybS5zdXBlciksXG4gICAgICBlbGVtZW50czogdGVybS5lbGVtZW50cy5tYXAoZWwgPT4gdGhpcy5leHBhbmQoZWwpKS50b0FycmF5KClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZENsYXNzRXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkNsYXNzRXhwcmVzc2lvbih7XG4gICAgICBuYW1lOiB0ZXJtLm5hbWUgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtLm5hbWUpLFxuICAgICAgc3VwZXI6IHRlcm0uc3VwZXIgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtLnN1cGVyKSxcbiAgICAgIGVsZW1lbnRzOiB0ZXJtLmVsZW1lbnRzLm1hcChlbCA9PiB0aGlzLmV4cGFuZChlbCkpLnRvQXJyYXkoKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kQ2xhc3NFbGVtZW50KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuQ2xhc3NFbGVtZW50KHtcbiAgICAgIGlzU3RhdGljOiB0ZXJtLmlzU3RhdGljLFxuICAgICAgbWV0aG9kOiB0aGlzLmV4cGFuZCh0ZXJtLm1ldGhvZClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFRoaXNFeHByZXNzaW9uKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGV4cGFuZFN5bnRheFRlbXBsYXRlKHRlcm0pIHtcbiAgICBsZXQgciA9IHByb2Nlc3NUZW1wbGF0ZSh0ZXJtLnRlbXBsYXRlLnNsaWNlKDEsIHRlcm0udGVtcGxhdGUuc2l6ZSAtIDEpKTtcbiAgICBsZXQgaWRlbnQgPSB0aGlzLmNvbnRleHQuZ2V0VGVtcGxhdGVJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jb250ZXh0LnRlbXBsYXRlTWFwLnNldChpZGVudCwgci50ZW1wbGF0ZSk7XG4gICAgbGV0IG5hbWUgPSBTeW50YXguZnJvbUlkZW50aWZpZXIoJ3N5bnRheFRlbXBsYXRlJywgdGVybS50ZW1wbGF0ZS5maXJzdCgpLnZhbHVlKTtcbiAgICBsZXQgY2FsbGVlID0gbmV3IFQuSWRlbnRpZmllckV4cHJlc3Npb24oe1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuXG4gICAgbGV0IGV4cGFuZGVkSW50ZXJwcyA9IHIuaW50ZXJwLm1hcChpID0+IHtcbiAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3RlcihpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmQoZW5mLmVuZm9yZXN0KCdleHByZXNzaW9uJykpO1xuICAgIH0pO1xuXG4gICAgbGV0IGFyZ3MgPSBMaXN0Lm9mKG5ldyBULkxpdGVyYWxOdW1lcmljRXhwcmVzc2lvbih7IHZhbHVlOiBpZGVudCB9KSlcbiAgICAgICAgICAgICAgICAgICAuY29uY2F0KGV4cGFuZGVkSW50ZXJwcyk7XG5cbiAgICByZXR1cm4gbmV3IFQuQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgY2FsbGVlLCBhcmd1bWVudHM6IGFyZ3NcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFN0YXRpY01lbWJlckV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiBuZXcgVC5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKHtcbiAgICAgIG9iamVjdDogdGhpcy5leHBhbmQodGVybS5vYmplY3QpLFxuICAgICAgcHJvcGVydHk6IHRlcm0ucHJvcGVydHlcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZEFycmF5RXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkFycmF5RXhwcmVzc2lvbih7XG4gICAgICBlbGVtZW50czogdGVybS5lbGVtZW50cy5tYXAodCA9PiB0ID09IG51bGwgPyB0IDogdGhpcy5leHBhbmQodCkpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRJbXBvcnQodGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kSW1wb3J0TmFtZXNwYWNlKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGV4cGFuZEV4cG9ydCh0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkV4cG9ydCh7XG4gICAgICBkZWNsYXJhdGlvbjogdGhpcy5leHBhbmQodGVybS5kZWNsYXJhdGlvbilcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZEV4cG9ydERlZmF1bHQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5FeHBvcnREZWZhdWx0KHtcbiAgICAgIGJvZHk6IHRoaXMuZXhwYW5kKHRlcm0uYm9keSlcbiAgICB9KTtcbiAgfVxuXG5cbiAgZXhwYW5kRXhwb3J0RnJvbSh0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBleHBhbmRFeHBvcnRBbGxGcm9tKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGV4cGFuZEV4cG9ydFNwZWNpZmllcih0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBleHBhbmRTdGF0aWNQcm9wZXJ0eU5hbWUodGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kRGF0YVByb3BlcnR5KHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuRGF0YVByb3BlcnR5KHtcbiAgICAgIG5hbWU6IHRoaXMuZXhwYW5kKHRlcm0ubmFtZSksXG4gICAgICBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtLmV4cHJlc3Npb24pXG4gICAgfSk7XG4gIH1cblxuXG4gIGV4cGFuZE9iamVjdEV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiBuZXcgVC5PYmplY3RFeHByZXNzaW9uKHtcbiAgICAgIHByb3BlcnRpZXM6IHRlcm0ucHJvcGVydGllcy5tYXAodCA9PiB0aGlzLmV4cGFuZCh0KSlcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFZhcmlhYmxlRGVjbGFyYXRvcih0ZXJtKSB7XG4gICAgbGV0IGluaXQgPSB0ZXJtLmluaXQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmV4cGFuZCh0ZXJtLmluaXQpO1xuICAgIHJldHVybiBuZXcgVC5WYXJpYWJsZURlY2xhcmF0b3Ioe1xuICAgICAgYmluZGluZzogdGhpcy5leHBhbmQodGVybS5iaW5kaW5nKSxcbiAgICAgIGluaXQ6IGluaXRcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFZhcmlhYmxlRGVjbGFyYXRpb24odGVybSkge1xuICAgIGlmICh0ZXJtLmtpbmQgPT09ICdzeW50YXgnIHx8IHRlcm0ua2luZCA9PT0gJ3N5bnRheHJlYycpIHtcbiAgICAgIHJldHVybiB0ZXJtO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQuVmFyaWFibGVEZWNsYXJhdGlvbih7XG4gICAgICBraW5kOiB0ZXJtLmtpbmQsXG4gICAgICBkZWNsYXJhdG9yczogdGVybS5kZWNsYXJhdG9ycy5tYXAoZCA9PiB0aGlzLmV4cGFuZChkKSlcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHRlcm0pIHtcbiAgICBpZiAodGVybS5pbm5lci5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gICAgfVxuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcih0ZXJtLmlubmVyLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGxvb2thaGVhZCA9IGVuZi5wZWVrKCk7XG4gICAgbGV0IHQgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHQgPT0gbnVsbCB8fCBlbmYucmVzdC5zaXplID4gMCkge1xuICAgICAgdGhyb3cgZW5mLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ3VuZXhwZWN0ZWQgc3ludGF4Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGFuZCh0KTtcbiAgfVxuXG4gIGV4cGFuZFVuYXJ5RXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULlVuYXJ5RXhwcmVzc2lvbih7XG4gICAgICBvcGVyYXRvcjogdGVybS5vcGVyYXRvcixcbiAgICAgIG9wZXJhbmQ6IHRoaXMuZXhwYW5kKHRlcm0ub3BlcmFuZClcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFVwZGF0ZUV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiBuZXcgVC5VcGRhdGVFeHByZXNzaW9uKHtcbiAgICAgIGlzUHJlZml4OiB0ZXJtLmlzUHJlZml4LFxuICAgICAgb3BlcmF0b3I6IHRlcm0ub3BlcmF0b3IsXG4gICAgICBvcGVyYW5kOiB0aGlzLmV4cGFuZCh0ZXJtLm9wZXJhbmQpXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRCaW5hcnlFeHByZXNzaW9uKHRlcm0pIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMuZXhwYW5kKHRlcm0ubGVmdCk7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5leHBhbmQodGVybS5yaWdodCk7XG4gICAgcmV0dXJuIG5ldyBULkJpbmFyeUV4cHJlc3Npb24oe1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIG9wZXJhdG9yOiB0ZXJtLm9wZXJhdG9yLFxuICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRDb25kaXRpb25hbEV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiBuZXcgVC5Db25kaXRpb25hbEV4cHJlc3Npb24oe1xuICAgICAgdGVzdDogdGhpcy5leHBhbmQodGVybS50ZXN0KSxcbiAgICAgIGNvbnNlcXVlbnQ6IHRoaXMuZXhwYW5kKHRlcm0uY29uc2VxdWVudCksXG4gICAgICBhbHRlcm5hdGU6IHRoaXMuZXhwYW5kKHRlcm0uYWx0ZXJuYXRlKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kTmV3VGFyZ2V0RXhwcmVzc2lvbih0ZXJtKSB7IHJldHVybiB0ZXJtOyB9XG5cbiAgZXhwYW5kTmV3RXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgbGV0IGNhbGxlZSA9IHRoaXMuZXhwYW5kKHRlcm0uY2FsbGVlKTtcbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIodGVybS5hcmd1bWVudHMsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgYXJncyA9IGVuZi5lbmZvcmVzdEFyZ3VtZW50TGlzdCgpLm1hcChhcmcgPT4gdGhpcy5leHBhbmQoYXJnKSk7XG4gICAgcmV0dXJuIG5ldyBULk5ld0V4cHJlc3Npb24oe1xuICAgICAgY2FsbGVlLFxuICAgICAgYXJndW1lbnRzOiBhcmdzLnRvQXJyYXkoKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kU3VwZXIodGVybSkgeyByZXR1cm4gdGVybTsgfVxuXG4gIGV4cGFuZENhbGxFeHByZXNzaW9uKHRlcm0pIHtcbiAgICBsZXQgY2FsbGVlID0gdGhpcy5leHBhbmQodGVybS5jYWxsZWUpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcih0ZXJtLmFyZ3VtZW50cywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhcmdzID0gZW5mLmVuZm9yZXN0QXJndW1lbnRMaXN0KCkubWFwKGFyZyA9PiB0aGlzLmV4cGFuZChhcmcpKTtcbiAgICByZXR1cm4gbmV3IFQuQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgY2FsbGVlOiBjYWxsZWUsXG4gICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZFNwcmVhZEVsZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5TcHJlYWRFbGVtZW50KHtcbiAgICAgIGV4cHJlc3Npb246IHRoaXMuZXhwYW5kKHRlcm0uZXhwcmVzc2lvbilcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZEV4cHJlc3Npb25TdGF0ZW1lbnQodGVybSkge1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZXhwYW5kKHRlcm0uZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5ldyBULkV4cHJlc3Npb25TdGF0ZW1lbnQoe1xuICAgICAgZXhwcmVzc2lvbjogY2hpbGRcbiAgICB9KTtcbiAgfVxuXG4gIGV4cGFuZExhYmVsZWRTdGF0ZW1lbnQodGVybSkge1xuICAgIHJldHVybiBuZXcgVC5MYWJlbGVkU3RhdGVtZW50KHtcbiAgICAgIGxhYmVsOiB0ZXJtLmxhYmVsLnZhbCgpLFxuICAgICAgYm9keTogdGhpcy5leHBhbmQodGVybS5ib2R5KVxuICAgIH0pO1xuICB9XG5cbiAgZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtLCB0eXBlKSB7XG4gICAgbGV0IHNjb3BlID0gZnJlc2hTY29wZSgnZnVuJyk7XG4gICAgbGV0IHBhcmFtcztcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGUgIT09ICdHZXR0ZXInICYmIHR5cGUgIT09ICdTZXR0ZXInKSB7XG4gICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBwYXJhbWV0ZXIgYmluZGluZ3MgYWdhaW5cbiAgICAgIHBhcmFtcyA9IHRlcm0ucGFyYW1zLnJlZHVjZShuZXcgY2xhc3MgZXh0ZW5kcyBUZXJtLkNsb25lUmVkdWNlciB7XG4gICAgICAgIHJlZHVjZUJpbmRpbmdJZGVudGlmaWVyKHRlcm0pIHtcbiAgICAgICAgICBsZXQgbmFtZSA9IHRlcm0ubmFtZS5hZGRTY29wZShzY29wZSwgc2VsZi5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKTtcbiAgICAgICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuYW1lLnZhbCgpKTtcblxuICAgICAgICAgIHNlbGYuY29udGV4dC5lbnYuc2V0KG5ld0JpbmRpbmcudG9TdHJpbmcoKSwgbmV3IFZhckJpbmRpbmdUcmFuc2Zvcm0obmFtZSkpXG4gICAgICAgICAgc2VsZi5jb250ZXh0LmJpbmRpbmdzLmFkZChuYW1lLCB7XG4gICAgICAgICAgICBiaW5kaW5nOiBuZXdCaW5kaW5nLFxuICAgICAgICAgICAgcGhhc2U6IHNlbGYuY29udGV4dC5waGFzZSxcbiAgICAgICAgICAgIHNraXBEdXA6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IFQuQmluZGluZ0lkZW50aWZpZXIoeyBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhcmFtcyA9IHRoaXMuZXhwYW5kKHBhcmFtcyk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5jdXJyZW50U2NvcGUucHVzaChzY29wZSk7XG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHRoaXMuY29udGV4dC5waGFzZSwgdGhpcy5jb250ZXh0LmVudiwgdGhpcy5jb250ZXh0LnN0b3JlLCB0aGlzLmNvbnRleHQpO1xuXG4gICAgbGV0IGJvZHlUZXJtO1xuICAgIGxldCBzY29wZVJlZHVjZXIgPSBuZXcgU2NvcGVSZWR1Y2VyKFt7IHNjb3BlLCBwaGFzZTogQUxMX1BIQVNFUywgZmxpcDogZmFsc2UgfV0sIHRoaXMuY29udGV4dC5iaW5kaW5ncyk7XG4gICAgaWYgKHRlcm0uYm9keSBpbnN0YW5jZW9mIFRlcm0pIHtcbiAgICAgIC8vIEFycm93IGZ1bmN0aW9ucyBoYXZlIGEgc2luZ2xlIHRlcm0gYXMgdGhlaXIgYm9keVxuICAgICAgYm9keVRlcm0gPSB0aGlzLmV4cGFuZCh0ZXJtLmJvZHkucmVkdWNlKHNjb3BlUmVkdWNlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29tcGlsZWRCb2R5ID0gY29tcGlsZXIuY29tcGlsZShcbiAgICAgICAgdGVybS5ib2R5Lm1hcChiID0+IGIucmVkdWNlKHNjb3BlUmVkdWNlcikpXG4gICAgICApO1xuICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IGNvbXBpbGVkQm9keVxuICAgICAgICAgICAgLnRha2VXaGlsZShzID0+IGlzRXhwcmVzc2lvblN0YXRlbWVudChzKSAmJiBpc0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uKHMuZXhwcmVzc2lvbikpXG4gICAgICAgICAgICAubWFwKHMgPT4gbmV3IFQuRGlyZWN0aXZlKHsgcmF3VmFsdWU6IHMuZXhwcmVzc2lvbi52YWx1ZSB9KSk7XG4gICAgICBib2R5VGVybSA9IG5ldyBULkZ1bmN0aW9uQm9keSh7XG4gICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICAgIHN0YXRlbWVudHM6IGNvbXBpbGVkQm9keS5zbGljZShkaXJlY3RpdmVzLnNpemUpXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZS5wb3AoKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnR2V0dGVyJzpcbiAgICAgICAgcmV0dXJuIG5ldyBULkdldHRlcih7XG4gICAgICAgICAgbmFtZTogdGhpcy5leHBhbmQodGVybS5uYW1lKSxcbiAgICAgICAgICBib2R5OiBib2R5VGVybVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ1NldHRlcic6XG4gICAgICAgIHJldHVybiBuZXcgVC5TZXR0ZXIoe1xuICAgICAgICAgIG5hbWU6IHRoaXMuZXhwYW5kKHRlcm0ubmFtZSksXG4gICAgICAgICAgcGFyYW06IHRlcm0ucGFyYW0sXG4gICAgICAgICAgYm9keTogYm9keVRlcm1cbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdNZXRob2QnOlxuICAgICAgICByZXR1cm4gbmV3IFQuTWV0aG9kKHtcbiAgICAgICAgICBuYW1lOiB0ZXJtLm5hbWUsXG4gICAgICAgICAgaXNHZW5lcmF0b3I6IHRlcm0uaXNHZW5lcmF0b3IsXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgYm9keTogYm9keVRlcm1cbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdBcnJvd0V4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gbmV3IFQuQXJyb3dFeHByZXNzaW9uKHtcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICBib2R5OiBib2R5VGVybVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBuZXcgVC5GdW5jdGlvbkV4cHJlc3Npb24oe1xuICAgICAgICAgIG5hbWU6IHRlcm0ubmFtZSxcbiAgICAgICAgICBpc0dlbmVyYXRvcjogdGVybS5pc0dlbmVyYXRvcixcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICBib2R5OiBib2R5VGVybVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICByZXR1cm4gbmV3IFQuRnVuY3Rpb25EZWNsYXJhdGlvbih7XG4gICAgICAgICAgbmFtZTogdGVybS5uYW1lLFxuICAgICAgICAgIGlzR2VuZXJhdG9yOiB0ZXJtLmlzR2VuZXJhdG9yLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIGJvZHk6IGJvZHlUZXJtXG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1bmN0aW9uIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBleHBhbmRNZXRob2QodGVybSkge1xuICAgIHJldHVybiB0aGlzLmRvRnVuY3Rpb25FeHBhbnNpb24odGVybSwgJ01ldGhvZCcpO1xuICB9XG5cbiAgZXhwYW5kU2V0dGVyKHRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5kb0Z1bmN0aW9uRXhwYW5zaW9uKHRlcm0sICdTZXR0ZXInKTtcbiAgfVxuXG4gIGV4cGFuZEdldHRlcih0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtLCAnR2V0dGVyJyk7XG4gIH1cblxuICBleHBhbmRGdW5jdGlvbkRlY2xhcmF0aW9uRSh0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtLCAnRnVuY3Rpb25EZWNsYXJhdGlvbicpO1xuICB9XG5cbiAgZXhwYW5kRnVuY3Rpb25FeHByZXNzaW9uRSh0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9GdW5jdGlvbkV4cGFuc2lvbih0ZXJtLCAnRnVuY3Rpb25FeHByZXNzaW9uJyk7XG4gIH1cblxuICBleHBhbmRDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uKHRlcm0pIHtcbiAgICByZXR1cm4gbmV3IFQuQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbih7XG4gICAgICBiaW5kaW5nOiB0aGlzLmV4cGFuZCh0ZXJtLmJpbmRpbmcpLFxuICAgICAgb3BlcmF0b3I6IHRlcm0ub3BlcmF0b3IsXG4gICAgICBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtLmV4cHJlc3Npb24pXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRBc3NpZ25tZW50RXhwcmVzc2lvbih0ZXJtKSB7XG4gICAgcmV0dXJuIG5ldyBULkFzc2lnbm1lbnRFeHByZXNzaW9uKHtcbiAgICAgIGJpbmRpbmc6IHRoaXMuZXhwYW5kKHRlcm0uYmluZGluZyksXG4gICAgICBleHByZXNzaW9uOiB0aGlzLmV4cGFuZCh0ZXJtLmV4cHJlc3Npb24pXG4gICAgfSk7XG4gIH1cblxuICBleHBhbmRFbXB0eVN0YXRlbWVudCh0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBleHBhbmRMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuICBleHBhbmRMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uKHRlcm0pIHtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGV4cGFuZElkZW50aWZpZXJFeHByZXNzaW9uKHRlcm0pIHtcbiAgICBsZXQgdHJhbnMgPSB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtLm5hbWUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKTtcbiAgICBpZiAodHJhbnMpIHtcbiAgICAgIHJldHVybiBuZXcgVC5JZGVudGlmaWVyRXhwcmVzc2lvbih7XG4gICAgICAgIG5hbWU6IHRyYW5zLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBleHBhbmRMaXRlcmFsTnVsbEV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXhwYW5kTGl0ZXJhbFJlZ0V4cEV4cHJlc3Npb24odGVybSkge1xuICAgIHJldHVybiB0ZXJtO1xuICB9XG59XG4iXX0=

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isExportDeclaration = exports.isImportDeclaration = exports.isCompiletimeStatement = exports.isCompiletimeDeclaration = exports.isSyntaxDeclarationStatement = exports.isExportSyntax = exports.isParenthesizedExpression = exports.isFunctionWithName = exports.isFunctionTerm = exports.isSyntaxrecDeclaration = exports.isSyntaxDeclaration = exports.isEOF = exports.isVariableDeclarator = exports.isVariableDeclaration = exports.isSyntaxTemplate = exports.isTemplateElement = exports.isSwitchDefault = exports.isSwitchCase = exports.isSuper = exports.isSpreadElement = exports.isScript = exports.isFunctionDeclaration = exports.isFunctionBody = exports.isFormalParameters = exports.isDirective = exports.isCatchClause = exports.isBlock = exports.isWithStatement = exports.isWhileStatement = exports.isVariableDeclarationStatement = exports.isTryFinallyStatement = exports.isTryCatchStatement = exports.isThrowStatement = exports.isSwitchStatementWithDefault = exports.isSwitchStatement = exports.isReturnStatement = exports.isLabeledStatement = exports.isIfStatement = exports.isForStatement = exports.isForOfStatement = exports.isForInStatement = exports.isExpressionStatement = exports.isEmptyStatement = exports.isDoWhileStatement = exports.isDebuggerStatement = exports.isCompoundAssignmentExpression = exports.isContinueStatement = exports.isBreakStatement = exports.isBlockStatement = exports.isYieldGeneratorExpression = exports.isYieldExpression = exports.isUpdateExpression = exports.isThisExpression = exports.isTemplateExpression = exports.isStaticMemberExpression = exports.isUnaryExpression = exports.isObjectExpression = exports.isNewTargetExpression = exports.isNewExpression = exports.isIdentifierExpression = exports.isFunctionExpression = exports.isConditionalExpression = exports.isComputedMemberExpression = exports.isComputedAssignmentExpression = exports.isCallExpression = exports.isBinaryExpression = exports.isAssignmentExpression = exports.isArrowExpression = exports.isArrayExpression = exports.isLiteralStringExpression = exports.isLiteralRegExpExpression = exports.isLiteralNumericExpression = exports.isLiteralNullExpression = exports.isLiteralInfinityExpression = exports.isLiteralBooleanExpression = exports.isStaticPropertyName = exports.isComputedPropertyName = exports.isShorthandProperty = exports.isDataProperty = exports.isSetter = exports.isGetter = exports.isMethod = exports.isExportSpecifier = exports.isExportDefault = exports.isExport = exports.isExportFrom = exports.isExportAllFrom = exports.isImportSpecifier = exports.isImportNamespace = exports.isImport = exports.isModule = exports.isClassElement = exports.isClassDeclaration = exports.isClassExpression = exports.isBindingPropertyProperty = exports.isBindingPropertyIdentifier = exports.isObjectBinding = exports.isArrayBinding = exports.isBindingIdentifier = exports.isBindingWithDefault = undefined;

	var _ramda = __webpack_require__(18);

	var R = _interopRequireWildcard(_ramda);

	var _sweetSpec = __webpack_require__(41);

	var _sweetSpec2 = _interopRequireDefault(_sweetSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// bindings
	const isBindingWithDefault = exports.isBindingWithDefault = R.whereEq({ type: 'BindingWithDefault' });
	const isBindingIdentifier = exports.isBindingIdentifier = R.whereEq({ type: 'BindingIdentifier' });
	const isArrayBinding = exports.isArrayBinding = R.whereEq({ type: 'ArrayBinding' });
	const isObjectBinding = exports.isObjectBinding = R.whereEq({ type: 'ObjectBinding' });
	const isBindingPropertyIdentifier = exports.isBindingPropertyIdentifier = R.whereEq({ type: 'BindingPropertyIdentifier' });
	const isBindingPropertyProperty = exports.isBindingPropertyProperty = R.whereEq({ type: 'BindingPropertyIdentifier' });

	// class
	const isClassExpression = exports.isClassExpression = R.whereEq({ type: 'ClassExpression' });
	const isClassDeclaration = exports.isClassDeclaration = R.whereEq({ type: 'ClassDeclaration' });
	const isClassElement = exports.isClassElement = R.whereEq({ type: 'ClassElement' });

	// modules
	const isModule = exports.isModule = R.whereEq({ type: 'Module' });
	const isImport = exports.isImport = R.whereEq({ type: 'Import' });
	const isImportNamespace = exports.isImportNamespace = R.whereEq({ type: 'ImportNamespace' });
	const isImportSpecifier = exports.isImportSpecifier = R.whereEq({ type: 'ImportSpecifier' });
	const isExportAllFrom = exports.isExportAllFrom = R.whereEq({ type: 'ExportAllFrom' });
	const isExportFrom = exports.isExportFrom = R.whereEq({ type: 'ExportFrom' });
	const isExport = exports.isExport = R.whereEq({ type: 'Export' });
	const isExportDefault = exports.isExportDefault = R.whereEq({ type: 'ExportDefault' });
	const isExportSpecifier = exports.isExportSpecifier = R.whereEq({ type: 'ExportSpecifier' });

	// property definition
	const isMethod = exports.isMethod = R.whereEq({ type: 'Method' });
	const isGetter = exports.isGetter = R.whereEq({ type: 'Getter' });
	const isSetter = exports.isSetter = R.whereEq({ type: 'Setter' });
	const isDataProperty = exports.isDataProperty = R.whereEq({ type: 'DataProperty' });
	const isShorthandProperty = exports.isShorthandProperty = R.whereEq({ type: 'ShorthandProperty' });
	const isComputedPropertyName = exports.isComputedPropertyName = R.whereEq({ type: 'ComputedPropertyName' });
	const isStaticPropertyName = exports.isStaticPropertyName = R.whereEq({ type: 'StaticPropertyName' });

	// literals
	const isLiteralBooleanExpression = exports.isLiteralBooleanExpression = R.whereEq({ type: 'LiteralBooleanExpression' });
	const isLiteralInfinityExpression = exports.isLiteralInfinityExpression = R.whereEq({ type: 'LiteralInfinityExpression' });
	const isLiteralNullExpression = exports.isLiteralNullExpression = R.whereEq({ type: 'LiteralNullExpression' });
	const isLiteralNumericExpression = exports.isLiteralNumericExpression = R.whereEq({ type: 'LiteralNumericExpression' });
	const isLiteralRegExpExpression = exports.isLiteralRegExpExpression = R.whereEq({ type: 'LiteralRegExpExpression' });
	const isLiteralStringExpression = exports.isLiteralStringExpression = R.whereEq({ type: 'LiteralStringExpression' });

	// expressions
	const isArrayExpression = exports.isArrayExpression = R.whereEq({ type: 'ArrayExpression' });
	const isArrowExpression = exports.isArrowExpression = R.whereEq({ type: 'ArrowExpression' });
	const isAssignmentExpression = exports.isAssignmentExpression = R.whereEq({ type: 'AssignmentExpression' });
	const isBinaryExpression = exports.isBinaryExpression = R.whereEq({ type: 'BinaryExpression' });
	const isCallExpression = exports.isCallExpression = R.whereEq({ type: 'CallExpression' });
	const isComputedAssignmentExpression = exports.isComputedAssignmentExpression = R.whereEq({ type: 'ComputedAssignmentExpression' });
	const isComputedMemberExpression = exports.isComputedMemberExpression = R.whereEq({ type: 'ComputedMemberExpression' });
	const isConditionalExpression = exports.isConditionalExpression = R.whereEq({ type: 'ConditionalExpression' });
	const isFunctionExpression = exports.isFunctionExpression = R.whereEq({ type: 'FunctionExpression' });
	const isIdentifierExpression = exports.isIdentifierExpression = R.whereEq({ type: 'IdentifierExpression' });
	const isNewExpression = exports.isNewExpression = R.whereEq({ type: 'NewExpression' });
	const isNewTargetExpression = exports.isNewTargetExpression = R.whereEq({ type: 'NewTargetExpression' });
	const isObjectExpression = exports.isObjectExpression = R.whereEq({ type: 'ObjectExpression' });
	const isUnaryExpression = exports.isUnaryExpression = R.whereEq({ type: 'UnaryExpression' });
	const isStaticMemberExpression = exports.isStaticMemberExpression = R.whereEq({ type: 'StaticMemberExpression' });
	const isTemplateExpression = exports.isTemplateExpression = R.whereEq({ type: 'TemplateExpression' });
	const isThisExpression = exports.isThisExpression = R.whereEq({ type: 'ThisExpression' });
	const isUpdateExpression = exports.isUpdateExpression = R.whereEq({ type: 'UpdateExpression' });
	const isYieldExpression = exports.isYieldExpression = R.whereEq({ type: 'YieldExpression' });
	const isYieldGeneratorExpression = exports.isYieldGeneratorExpression = R.whereEq({ type: 'YieldGeneratorExpression' });

	// statements
	const isBlockStatement = exports.isBlockStatement = R.whereEq({ type: 'BlockStatement' });
	const isBreakStatement = exports.isBreakStatement = R.whereEq({ type: 'BreakStatement' });
	const isContinueStatement = exports.isContinueStatement = R.whereEq({ type: 'ContinueStatement' });
	const isCompoundAssignmentExpression = exports.isCompoundAssignmentExpression = R.whereEq({ type: 'CompoundAssignmentExpression' });
	const isDebuggerStatement = exports.isDebuggerStatement = R.whereEq({ type: 'DebuggerStatement' });
	const isDoWhileStatement = exports.isDoWhileStatement = R.whereEq({ type: 'DoWhileStatement' });
	const isEmptyStatement = exports.isEmptyStatement = R.whereEq({ type: 'EmptyStatement' });
	const isExpressionStatement = exports.isExpressionStatement = R.whereEq({ type: 'ExpressionStatement' });
	const isForInStatement = exports.isForInStatement = R.whereEq({ type: 'ForInStatement' });
	const isForOfStatement = exports.isForOfStatement = R.whereEq({ type: 'ForOfStatement' });
	const isForStatement = exports.isForStatement = R.whereEq({ type: 'ForStatement' });
	const isIfStatement = exports.isIfStatement = R.whereEq({ type: 'IfStatement' });
	const isLabeledStatement = exports.isLabeledStatement = R.whereEq({ type: 'LabeledStatement' });
	const isReturnStatement = exports.isReturnStatement = R.whereEq({ type: 'ReturnStatement' });
	const isSwitchStatement = exports.isSwitchStatement = R.whereEq({ type: 'SwitchStatement' });
	const isSwitchStatementWithDefault = exports.isSwitchStatementWithDefault = R.whereEq({ type: 'SwitchStatementWithDefault' });
	const isThrowStatement = exports.isThrowStatement = R.whereEq({ type: 'ThrowStatement' });
	const isTryCatchStatement = exports.isTryCatchStatement = R.whereEq({ type: 'TryCatchStatement' });
	const isTryFinallyStatement = exports.isTryFinallyStatement = R.whereEq({ type: 'TryFinallyStatement' });
	const isVariableDeclarationStatement = exports.isVariableDeclarationStatement = R.whereEq({ type: 'VariableDeclarationStatement' });
	const isWhileStatement = exports.isWhileStatement = R.whereEq({ type: 'WhileStatement' });
	const isWithStatement = exports.isWithStatement = R.whereEq({ type: 'WithStatement' });

	// other
	const isBlock = exports.isBlock = R.whereEq({ type: 'Block' });
	const isCatchClause = exports.isCatchClause = R.whereEq({ type: 'CatchClause' });
	const isDirective = exports.isDirective = R.whereEq({ type: 'Directive' });
	const isFormalParameters = exports.isFormalParameters = R.whereEq({ type: 'FormalParameters' });
	const isFunctionBody = exports.isFunctionBody = R.whereEq({ type: 'FunctionBody' });
	const isFunctionDeclaration = exports.isFunctionDeclaration = R.whereEq({ type: 'FunctionDeclaration' });
	const isScript = exports.isScript = R.whereEq({ type: 'Script' });
	const isSpreadElement = exports.isSpreadElement = R.whereEq({ type: 'SpreadElement' });
	const isSuper = exports.isSuper = R.whereEq({ type: 'Super' });
	const isSwitchCase = exports.isSwitchCase = R.whereEq({ type: 'SwitchCase' });
	const isSwitchDefault = exports.isSwitchDefault = R.whereEq({ type: 'SwitchDefault' });
	const isTemplateElement = exports.isTemplateElement = R.whereEq({ type: 'TemplateElement' });
	const isSyntaxTemplate = exports.isSyntaxTemplate = R.whereEq({ type: 'SyntaxTemplate' });
	const isVariableDeclaration = exports.isVariableDeclaration = R.whereEq({ type: 'VariableDeclaration' });
	const isVariableDeclarator = exports.isVariableDeclarator = R.whereEq({ type: 'VariableDeclarator' });
	const isEOF = exports.isEOF = R.whereEq({ type: 'EOF' });
	const isSyntaxDeclaration = exports.isSyntaxDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntax' }));
	const isSyntaxrecDeclaration = exports.isSyntaxrecDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntaxrec' }));
	const isFunctionTerm = exports.isFunctionTerm = R.either(isFunctionDeclaration, isFunctionExpression);
	const isFunctionWithName = exports.isFunctionWithName = R.and(isFunctionTerm, R.complement(R.where({ name: R.isNil })));
	const isParenthesizedExpression = exports.isParenthesizedExpression = R.whereEq({ type: 'ParenthesizedExpression' });
	const isExportSyntax = exports.isExportSyntax = R.both(isExport, exp => R.or(isSyntaxDeclaration(exp.declaration), isSyntaxrecDeclaration(exp.declaration)));
	const isSyntaxDeclarationStatement = exports.isSyntaxDeclarationStatement = R.both(isVariableDeclarationStatement, decl => isCompiletimeDeclaration(decl.declaration));

	const isCompiletimeDeclaration = exports.isCompiletimeDeclaration = R.either(isSyntaxDeclaration, isSyntaxrecDeclaration);
	const isCompiletimeStatement = exports.isCompiletimeStatement = term => {
	  return term instanceof _sweetSpec2.default && isVariableDeclarationStatement(term) && isCompiletimeDeclaration(term.declaration);
	};
	const isImportDeclaration = exports.isImportDeclaration = R.either(isImport, isImportNamespace);
	const isExportDeclaration = exports.isExportDeclaration = R.either(isExport, isExportDefault, isExportFrom, isExportAllFrom);
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXJtcy5qcyJdLCJuYW1lcyI6WyJSIiwiaXNCaW5kaW5nV2l0aERlZmF1bHQiLCJ3aGVyZUVxIiwidHlwZSIsImlzQmluZGluZ0lkZW50aWZpZXIiLCJpc0FycmF5QmluZGluZyIsImlzT2JqZWN0QmluZGluZyIsImlzQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllciIsImlzQmluZGluZ1Byb3BlcnR5UHJvcGVydHkiLCJpc0NsYXNzRXhwcmVzc2lvbiIsImlzQ2xhc3NEZWNsYXJhdGlvbiIsImlzQ2xhc3NFbGVtZW50IiwiaXNNb2R1bGUiLCJpc0ltcG9ydCIsImlzSW1wb3J0TmFtZXNwYWNlIiwiaXNJbXBvcnRTcGVjaWZpZXIiLCJpc0V4cG9ydEFsbEZyb20iLCJpc0V4cG9ydEZyb20iLCJpc0V4cG9ydCIsImlzRXhwb3J0RGVmYXVsdCIsImlzRXhwb3J0U3BlY2lmaWVyIiwiaXNNZXRob2QiLCJpc0dldHRlciIsImlzU2V0dGVyIiwiaXNEYXRhUHJvcGVydHkiLCJpc1Nob3J0aGFuZFByb3BlcnR5IiwiaXNDb21wdXRlZFByb3BlcnR5TmFtZSIsImlzU3RhdGljUHJvcGVydHlOYW1lIiwiaXNMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24iLCJpc0xpdGVyYWxJbmZpbml0eUV4cHJlc3Npb24iLCJpc0xpdGVyYWxOdWxsRXhwcmVzc2lvbiIsImlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uIiwiaXNMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbiIsImlzTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24iLCJpc0FycmF5RXhwcmVzc2lvbiIsImlzQXJyb3dFeHByZXNzaW9uIiwiaXNBc3NpZ25tZW50RXhwcmVzc2lvbiIsImlzQmluYXJ5RXhwcmVzc2lvbiIsImlzQ2FsbEV4cHJlc3Npb24iLCJpc0NvbXB1dGVkQXNzaWdubWVudEV4cHJlc3Npb24iLCJpc0NvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiIsImlzQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0lkZW50aWZpZXJFeHByZXNzaW9uIiwiaXNOZXdFeHByZXNzaW9uIiwiaXNOZXdUYXJnZXRFeHByZXNzaW9uIiwiaXNPYmplY3RFeHByZXNzaW9uIiwiaXNVbmFyeUV4cHJlc3Npb24iLCJpc1N0YXRpY01lbWJlckV4cHJlc3Npb24iLCJpc1RlbXBsYXRlRXhwcmVzc2lvbiIsImlzVGhpc0V4cHJlc3Npb24iLCJpc1VwZGF0ZUV4cHJlc3Npb24iLCJpc1lpZWxkRXhwcmVzc2lvbiIsImlzWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uIiwiaXNCbG9ja1N0YXRlbWVudCIsImlzQnJlYWtTdGF0ZW1lbnQiLCJpc0NvbnRpbnVlU3RhdGVtZW50IiwiaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uIiwiaXNEZWJ1Z2dlclN0YXRlbWVudCIsImlzRG9XaGlsZVN0YXRlbWVudCIsImlzRW1wdHlTdGF0ZW1lbnQiLCJpc0V4cHJlc3Npb25TdGF0ZW1lbnQiLCJpc0ZvckluU3RhdGVtZW50IiwiaXNGb3JPZlN0YXRlbWVudCIsImlzRm9yU3RhdGVtZW50IiwiaXNJZlN0YXRlbWVudCIsImlzTGFiZWxlZFN0YXRlbWVudCIsImlzUmV0dXJuU3RhdGVtZW50IiwiaXNTd2l0Y2hTdGF0ZW1lbnQiLCJpc1N3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0IiwiaXNUaHJvd1N0YXRlbWVudCIsImlzVHJ5Q2F0Y2hTdGF0ZW1lbnQiLCJpc1RyeUZpbmFsbHlTdGF0ZW1lbnQiLCJpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQiLCJpc1doaWxlU3RhdGVtZW50IiwiaXNXaXRoU3RhdGVtZW50IiwiaXNCbG9jayIsImlzQ2F0Y2hDbGF1c2UiLCJpc0RpcmVjdGl2ZSIsImlzRm9ybWFsUGFyYW1ldGVycyIsImlzRnVuY3Rpb25Cb2R5IiwiaXNGdW5jdGlvbkRlY2xhcmF0aW9uIiwiaXNTY3JpcHQiLCJpc1NwcmVhZEVsZW1lbnQiLCJpc1N1cGVyIiwiaXNTd2l0Y2hDYXNlIiwiaXNTd2l0Y2hEZWZhdWx0IiwiaXNUZW1wbGF0ZUVsZW1lbnQiLCJpc1N5bnRheFRlbXBsYXRlIiwiaXNWYXJpYWJsZURlY2xhcmF0aW9uIiwiaXNWYXJpYWJsZURlY2xhcmF0b3IiLCJpc0VPRiIsImlzU3ludGF4RGVjbGFyYXRpb24iLCJib3RoIiwia2luZCIsImlzU3ludGF4cmVjRGVjbGFyYXRpb24iLCJpc0Z1bmN0aW9uVGVybSIsImVpdGhlciIsImlzRnVuY3Rpb25XaXRoTmFtZSIsImFuZCIsImNvbXBsZW1lbnQiLCJ3aGVyZSIsIm5hbWUiLCJpc05pbCIsImlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24iLCJpc0V4cG9ydFN5bnRheCIsImV4cCIsIm9yIiwiZGVjbGFyYXRpb24iLCJpc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50IiwiZGVjbCIsImlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbiIsImlzQ29tcGlsZXRpbWVTdGF0ZW1lbnQiLCJ0ZXJtIiwiaXNJbXBvcnREZWNsYXJhdGlvbiIsImlzRXhwb3J0RGVjbGFyYXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7SUFBWUEsQzs7QUFDWjs7Ozs7Ozs7QUFFQTtBQUNPLE1BQU1DLHNEQUF1QkQsRUFBRUUsT0FBRixDQUFVLEVBQUVDLE1BQU0sb0JBQVIsRUFBVixDQUE3QjtBQUNBLE1BQU1DLG9EQUFzQkosRUFBRUUsT0FBRixDQUFVLEVBQUVDLE1BQU0sbUJBQVIsRUFBVixDQUE1QjtBQUNBLE1BQU1FLDBDQUFpQkwsRUFBRUUsT0FBRixDQUFVLEVBQUVDLE1BQU0sY0FBUixFQUFWLENBQXZCO0FBQ0EsTUFBTUcsNENBQWtCTixFQUFFRSxPQUFGLENBQVUsRUFBRUMsTUFBTSxlQUFSLEVBQVYsQ0FBeEI7QUFDQSxNQUFNSSxvRUFBOEJQLEVBQUVFLE9BQUYsQ0FBVSxFQUFFQyxNQUFNLDJCQUFSLEVBQVYsQ0FBcEM7QUFDQSxNQUFNSyxnRUFBNEJSLEVBQUVFLE9BQUYsQ0FBVSxFQUFFQyxNQUFNLDJCQUFSLEVBQVYsQ0FB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TUFBRixDQUFTcEYsUUFBVCxFQUFtQkMsaUJBQW5CLENBQTVCO0FBQ0EsTUFBTXFHLG9EQUFzQm5ILEVBQUVpRyxNQUFGLENBQVMvRSxRQUFULEVBQW1CQyxlQUFuQixFQUFvQ0YsWUFBcEMsRUFBa0RELGVBQWxELENBQTVCIiwiZmlsZSI6InRlcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUiBmcm9tICdyYW1kYSc7XG5pbXBvcnQgVGVybSBmcm9tICdzd2VldC1zcGVjJztcblxuLy8gYmluZGluZ3NcbmV4cG9ydCBjb25zdCBpc0JpbmRpbmdXaXRoRGVmYXVsdCA9IFIud2hlcmVFcSh7IHR5cGU6ICdCaW5kaW5nV2l0aERlZmF1bHQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzQmluZGluZ0lkZW50aWZpZXIgPSBSLndoZXJlRXEoeyB0eXBlOiAnQmluZGluZ0lkZW50aWZpZXInIH0pO1xuZXhwb3J0IGNvbnN0IGlzQXJyYXlCaW5kaW5nID0gUi53aGVyZUVxKHsgdHlwZTogJ0FycmF5QmluZGluZycgfSk7XG5leHBvcnQgY29uc3QgaXNPYmplY3RCaW5kaW5nID0gUi53aGVyZUVxKHsgdHlwZTogJ09iamVjdEJpbmRpbmcnIH0pO1xuZXhwb3J0IGNvbnN0IGlzQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllciA9IFIud2hlcmVFcSh7IHR5cGU6ICdCaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyJyB9KTtcbmV4cG9ydCBjb25zdCBpc0JpbmRpbmdQcm9wZXJ0eVByb3BlcnR5ID0gUi53aGVyZUVxKHsgdHlwZTogJ0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXInIH0pO1xuXG4vLyBjbGFzc1xuZXhwb3J0IGNvbnN0IGlzQ2xhc3NFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0NsYXNzRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNDbGFzc0RlY2xhcmF0aW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0NsYXNzRGVjbGFyYXRpb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzQ2xhc3NFbGVtZW50ID0gUi53aGVyZUVxKHsgdHlwZTogJ0NsYXNzRWxlbWVudCcgfSk7XG5cbi8vIG1vZHVsZXNcbmV4cG9ydCBjb25zdCBpc01vZHVsZSA9IFIud2hlcmVFcSh7IHR5cGU6ICdNb2R1bGUnIH0pO1xuZXhwb3J0IGNvbnN0IGlzSW1wb3J0ID0gUi53aGVyZUVxKHsgdHlwZTogJ0ltcG9ydCcgfSk7XG5leHBvcnQgY29uc3QgaXNJbXBvcnROYW1lc3BhY2UgPSBSLndoZXJlRXEoeyB0eXBlOiAnSW1wb3J0TmFtZXNwYWNlJyB9KTtcbmV4cG9ydCBjb25zdCBpc0ltcG9ydFNwZWNpZmllciA9IFIud2hlcmVFcSh7IHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInIH0pO1xuZXhwb3J0IGNvbnN0IGlzRXhwb3J0QWxsRnJvbSA9IFIud2hlcmVFcSh7IHR5cGU6ICdFeHBvcnRBbGxGcm9tJyB9KTtcbmV4cG9ydCBjb25zdCBpc0V4cG9ydEZyb20gPSBSLndoZXJlRXEoeyB0eXBlOiAnRXhwb3J0RnJvbScgfSk7XG5leHBvcnQgY29uc3QgaXNFeHBvcnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnRXhwb3J0JyB9KTtcbmV4cG9ydCBjb25zdCBpc0V4cG9ydERlZmF1bHQgPSBSLndoZXJlRXEoeyB0eXBlOiAnRXhwb3J0RGVmYXVsdCcgfSk7XG5leHBvcnQgY29uc3QgaXNFeHBvcnRTcGVjaWZpZXIgPSBSLndoZXJlRXEoeyB0eXBlOiAnRXhwb3J0U3BlY2lmaWVyJyB9KTtcblxuLy8gcHJvcGVydHkgZGVmaW5pdGlvblxuZXhwb3J0IGNvbnN0IGlzTWV0aG9kID0gUi53aGVyZUVxKHsgdHlwZTogJ01ldGhvZCcgfSk7XG5leHBvcnQgY29uc3QgaXNHZXR0ZXIgPSBSLndoZXJlRXEoeyB0eXBlOiAnR2V0dGVyJyB9KTtcbmV4cG9ydCBjb25zdCBpc1NldHRlciA9IFIud2hlcmVFcSh7IHR5cGU6ICdTZXR0ZXInIH0pO1xuZXhwb3J0IGNvbnN0IGlzRGF0YVByb3BlcnR5ID0gUi53aGVyZUVxKHsgdHlwZTogJ0RhdGFQcm9wZXJ0eScgfSk7XG5leHBvcnQgY29uc3QgaXNTaG9ydGhhbmRQcm9wZXJ0eSA9IFIud2hlcmVFcSh7IHR5cGU6ICdTaG9ydGhhbmRQcm9wZXJ0eScgfSk7XG5leHBvcnQgY29uc3QgaXNDb21wdXRlZFByb3BlcnR5TmFtZSA9IFIud2hlcmVFcSh7IHR5cGU6ICdDb21wdXRlZFByb3BlcnR5TmFtZScgfSk7XG5leHBvcnQgY29uc3QgaXNTdGF0aWNQcm9wZXJ0eU5hbWUgPSBSLndoZXJlRXEoeyB0eXBlOiAnU3RhdGljUHJvcGVydHlOYW1lJyB9KTtcblxuLy8gbGl0ZXJhbHNcbmV4cG9ydCBjb25zdCBpc0xpdGVyYWxCb29sZWFuRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc0xpdGVyYWxOdWxsRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdMaXRlcmFsTnVsbEV4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdMaXRlcmFsU3RyaW5nRXhwcmVzc2lvbicgfSk7XG5cbi8vIGV4cHJlc3Npb25zXG5leHBvcnQgY29uc3QgaXNBcnJheUV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnQXJyYXlFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc0Fycm93RXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdBcnJvd0V4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzQXNzaWdubWVudEV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnQXNzaWdubWVudEV4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzQmluYXJ5RXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdCaW5hcnlFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc0NhbGxFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0NhbGxFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc0NvbXB1dGVkQXNzaWdubWVudEV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnQ29tcHV0ZWRBc3NpZ25tZW50RXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc0NvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdDb25kaXRpb25hbEV4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0Z1bmN0aW9uRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNJZGVudGlmaWVyRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdJZGVudGlmaWVyRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNOZXdFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ05ld0V4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzTmV3VGFyZ2V0RXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdOZXdUYXJnZXRFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc09iamVjdEV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNVbmFyeUV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnVW5hcnlFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc1N0YXRpY01lbWJlckV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnU3RhdGljTWVtYmVyRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZUV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnVGVtcGxhdGVFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc1RoaXNFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ1RoaXNFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc1VwZGF0ZUV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnVXBkYXRlRXhwcmVzc2lvbicgfSk7XG5leHBvcnQgY29uc3QgaXNZaWVsZEV4cHJlc3Npb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnWWllbGRFeHByZXNzaW9uJyB9KTtcbmV4cG9ydCBjb25zdCBpc1lpZWxkR2VuZXJhdG9yRXhwcmVzc2lvbiA9IFIud2hlcmVFcSh7IHR5cGU6ICdZaWVsZEdlbmVyYXRvckV4cHJlc3Npb24nIH0pO1xuXG4vLyBzdGF0ZW1lbnRzXG5leHBvcnQgY29uc3QgaXNCbG9ja1N0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdCbG9ja1N0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNCcmVha1N0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdCcmVha1N0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNDb250aW51ZVN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdDb250aW51ZVN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0NvbXBvdW5kQXNzaWdubWVudEV4cHJlc3Npb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzRGVidWdnZXJTdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnRGVidWdnZXJTdGF0ZW1lbnQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzRG9XaGlsZVN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdEb1doaWxlU3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc0VtcHR5U3RhdGVtZW50ID0gUi53aGVyZUVxKHsgdHlwZTogJ0VtcHR5U3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc0V4cHJlc3Npb25TdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnRXhwcmVzc2lvblN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNGb3JJblN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdGb3JJblN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNGb3JPZlN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdGb3JPZlN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNGb3JTdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnRm9yU3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc0lmU3RhdGVtZW50ID0gUi53aGVyZUVxKHsgdHlwZTogJ0lmU3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc0xhYmVsZWRTdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnTGFiZWxlZFN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNSZXR1cm5TdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnUmV0dXJuU3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc1N3aXRjaFN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdTd2l0Y2hTdGF0ZW1lbnQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQgPSBSLndoZXJlRXEoeyB0eXBlOiAnU3dpdGNoU3RhdGVtZW50V2l0aERlZmF1bHQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzVGhyb3dTdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnVGhyb3dTdGF0ZW1lbnQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzVHJ5Q2F0Y2hTdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnVHJ5Q2F0Y2hTdGF0ZW1lbnQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzVHJ5RmluYWxseVN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdUcnlGaW5hbGx5U3RhdGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNXaGlsZVN0YXRlbWVudCA9IFIud2hlcmVFcSh7IHR5cGU6ICdXaGlsZVN0YXRlbWVudCcgfSk7XG5leHBvcnQgY29uc3QgaXNXaXRoU3RhdGVtZW50ID0gUi53aGVyZUVxKHsgdHlwZTogJ1dpdGhTdGF0ZW1lbnQnIH0pO1xuXG4vLyBvdGhlclxuZXhwb3J0IGNvbnN0IGlzQmxvY2sgPSBSLndoZXJlRXEoeyB0eXBlOiAnQmxvY2snIH0pO1xuZXhwb3J0IGNvbnN0IGlzQ2F0Y2hDbGF1c2UgPSBSLndoZXJlRXEoeyB0eXBlOiAnQ2F0Y2hDbGF1c2UnIH0pO1xuZXhwb3J0IGNvbnN0IGlzRGlyZWN0aXZlID0gUi53aGVyZUVxKHsgdHlwZTogJ0RpcmVjdGl2ZScgfSk7XG5leHBvcnQgY29uc3QgaXNGb3JtYWxQYXJhbWV0ZXJzID0gUi53aGVyZUVxKHsgdHlwZTogJ0Zvcm1hbFBhcmFtZXRlcnMnIH0pO1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25Cb2R5ID0gUi53aGVyZUVxKHsgdHlwZTogJ0Z1bmN0aW9uQm9keScgfSk7XG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbkRlY2xhcmF0aW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIH0pO1xuZXhwb3J0IGNvbnN0IGlzU2NyaXB0ID0gUi53aGVyZUVxKHsgdHlwZTogJ1NjcmlwdCcgfSk7XG5leHBvcnQgY29uc3QgaXNTcHJlYWRFbGVtZW50ID0gUi53aGVyZUVxKHsgdHlwZTogJ1NwcmVhZEVsZW1lbnQnIH0pO1xuZXhwb3J0IGNvbnN0IGlzU3VwZXIgPSBSLndoZXJlRXEoeyB0eXBlOiAnU3VwZXInIH0pO1xuZXhwb3J0IGNvbnN0IGlzU3dpdGNoQ2FzZSA9IFIud2hlcmVFcSh7IHR5cGU6ICdTd2l0Y2hDYXNlJyB9KTtcbmV4cG9ydCBjb25zdCBpc1N3aXRjaERlZmF1bHQgPSBSLndoZXJlRXEoeyB0eXBlOiAnU3dpdGNoRGVmYXVsdCcgfSk7XG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZUVsZW1lbnQgPSBSLndoZXJlRXEoeyB0eXBlOiAnVGVtcGxhdGVFbGVtZW50JyB9KTtcbmV4cG9ydCBjb25zdCBpc1N5bnRheFRlbXBsYXRlID0gUi53aGVyZUVxKHsgdHlwZTogJ1N5bnRheFRlbXBsYXRlJyB9KTtcbmV4cG9ydCBjb25zdCBpc1ZhcmlhYmxlRGVjbGFyYXRpb24gPSBSLndoZXJlRXEoeyB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdGlvbicgfSk7XG5leHBvcnQgY29uc3QgaXNWYXJpYWJsZURlY2xhcmF0b3IgPSBSLndoZXJlRXEoeyB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdG9yJyB9KTtcbmV4cG9ydCBjb25zdCBpc0VPRiA9IFIud2hlcmVFcSh7IHR5cGU6ICdFT0YnIH0pO1xuZXhwb3J0IGNvbnN0IGlzU3ludGF4RGVjbGFyYXRpb24gPSBSLmJvdGgoaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBSLndoZXJlRXEoeyBraW5kOiAnc3ludGF4JyB9KSk7XG5leHBvcnQgY29uc3QgaXNTeW50YXhyZWNEZWNsYXJhdGlvbiA9IFIuYm90aChpc1ZhcmlhYmxlRGVjbGFyYXRpb24sIFIud2hlcmVFcSh7IGtpbmQ6ICdzeW50YXhyZWMnIH0pKTtcbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uVGVybSA9IFIuZWl0aGVyKGlzRnVuY3Rpb25EZWNsYXJhdGlvbiwgaXNGdW5jdGlvbkV4cHJlc3Npb24pO1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25XaXRoTmFtZSA9IFIuYW5kKGlzRnVuY3Rpb25UZXJtLCBSLmNvbXBsZW1lbnQoUi53aGVyZSh7IG5hbWU6IFIuaXNOaWwgfSkpKTtcbmV4cG9ydCBjb25zdCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gUi53aGVyZUVxKHsgdHlwZTogJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJ30pO1xuZXhwb3J0IGNvbnN0IGlzRXhwb3J0U3ludGF4ID0gUi5ib3RoKGlzRXhwb3J0LCBleHAgPT4gUi5vcihpc1N5bnRheERlY2xhcmF0aW9uKGV4cC5kZWNsYXJhdGlvbiksIGlzU3ludGF4cmVjRGVjbGFyYXRpb24oZXhwLmRlY2xhcmF0aW9uKSkpO1xuZXhwb3J0IGNvbnN0IGlzU3ludGF4RGVjbGFyYXRpb25TdGF0ZW1lbnQgPSBSLmJvdGgoaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50LCBkZWNsID0+IGlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbihkZWNsLmRlY2xhcmF0aW9uKSk7XG5cblxuZXhwb3J0IGNvbnN0IGlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbiA9IFIuZWl0aGVyKGlzU3ludGF4RGVjbGFyYXRpb24sIGlzU3ludGF4cmVjRGVjbGFyYXRpb24pO1xuZXhwb3J0IGNvbnN0IGlzQ29tcGlsZXRpbWVTdGF0ZW1lbnQgPSB0ZXJtID0+IHtcbiAgcmV0dXJuICh0ZXJtIGluc3RhbmNlb2YgVGVybSkgJiYgaXNWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm0pICYmIGlzQ29tcGlsZXRpbWVEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uKTtcbn07XG5leHBvcnQgY29uc3QgaXNJbXBvcnREZWNsYXJhdGlvbiA9IFIuZWl0aGVyKGlzSW1wb3J0LCBpc0ltcG9ydE5hbWVzcGFjZSk7XG5leHBvcnQgY29uc3QgaXNFeHBvcnREZWNsYXJhdGlvbiA9IFIuZWl0aGVyKGlzRXhwb3J0LCBpc0V4cG9ydERlZmF1bHQsIGlzRXhwb3J0RnJvbSwgaXNFeHBvcnRBbGxGcm9tKTtcbiJdfQ==

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Enforester = undefined;

	var _terms = __webpack_require__(48);

	var _sweetSpec = __webpack_require__(41);

	var T = _interopRequireWildcard(_sweetSpec);

	var _ramdaFantasy = __webpack_require__(19);

	var _scopeReducer = __webpack_require__(50);

	var _scopeReducer2 = _interopRequireDefault(_scopeReducer);

	var _transforms = __webpack_require__(45);

	var _immutable = __webpack_require__(10);

	var _errors = __webpack_require__(39);

	var _operators = __webpack_require__(51);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _scope = __webpack_require__(42);

	var _loadSyntax = __webpack_require__(52);

	var _macroContext = __webpack_require__(64);

	var _macroContext2 = _interopRequireDefault(_macroContext);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	const Just = _ramdaFantasy.Maybe.Just;
	const Nothing = _ramdaFantasy.Maybe.Nothing;

	const EXPR_LOOP_OPERATOR = {};
	const EXPR_LOOP_NO_CHANGE = {};
	const EXPR_LOOP_EXPANSION = {};

	function getLineNumber(x) {
	  let stx;
	  if (x instanceof _syntax2.default) {
	    stx = x;
	  } else if (x instanceof T.RawSyntax) {
	    stx = x.value;
	  } else if (x instanceof T.RawDelimiter) {
	    return getLineNumber(x.inner.first());
	  } else {
	    throw new Error(`Not implemented yet ${ x }`);
	  }
	  return stx.lineNumber();
	}

	class Enforester {

	  constructor(stxl, prev, context) {
	    this.done = false;
	    (0, _errors.assert)(_immutable.List.isList(stxl), 'expecting a list of terms to enforest');
	    (0, _errors.assert)(_immutable.List.isList(prev), 'expecting a list of terms to enforest');
	    (0, _errors.assert)(context, 'expecting a context to enforest');
	    this.term = null;

	    this.rest = stxl;
	    this.prev = prev;

	    this.context = context;
	  }

	  peek(n = 0) {
	    return this.rest.get(n);
	  }

	  advance() {
	    let ret = this.rest.first();
	    this.rest = this.rest.rest();
	    return ret;
	  }

	  /*
	   enforest works over:
	   prev - a list of the previously enforest Terms
	   term - the current term being enforested (initially null)
	   rest - remaining Terms to enforest
	   */
	  enforest(type = 'Module') {
	    // initialize the term
	    this.term = null;

	    if (this.rest.size === 0) {
	      this.done = true;
	      return this.term;
	    }

	    if (this.isEOF(this.peek())) {
	      this.term = new T.EOF({});
	      this.advance();
	      return this.term;
	    }

	    let result;
	    if (type === 'expression') {
	      result = this.enforestExpressionLoop();
	    } else {
	      result = this.enforestModule();
	    }

	    if (this.rest.size === 0) {
	      this.done = true;
	    }
	    return result;
	  }

	  enforestModule() {
	    return this.enforestBody();
	  }

	  enforestBody() {
	    return this.enforestModuleItem();
	  }

	  enforestModuleItem() {
	    let lookahead = this.peek();
	    if (this.isKeyword(lookahead, 'import')) {
	      this.advance();
	      return this.enforestImportDeclaration();
	    } else if (this.isKeyword(lookahead, 'export')) {
	      this.advance();
	      return this.enforestExportDeclaration();
	    }
	    return this.enforestStatement();
	  }

	  enforestExportDeclaration() {
	    let lookahead = this.peek();
	    if (this.isPunctuator(lookahead, '*')) {
	      this.advance();
	      let moduleSpecifier = this.enforestFromClause();
	      return new T.ExportAllFrom({ moduleSpecifier });
	    } else if (this.isBraces(lookahead)) {
	      let namedExports = this.enforestExportClause();
	      let moduleSpecifier = null;
	      if (this.isIdentifier(this.peek(), 'from')) {
	        moduleSpecifier = this.enforestFromClause();
	      }
	      return new T.ExportFrom({ namedExports, moduleSpecifier });
	    } else if (this.isKeyword(lookahead, 'class')) {
	      return new T.Export({
	        declaration: this.enforestClass({ isExpr: false })
	      });
	    } else if (this.isFnDeclTransform(lookahead)) {
	      return new T.Export({
	        declaration: this.enforestFunction({ isExpr: false })
	      });
	    } else if (this.isKeyword(lookahead, 'default')) {
	      this.advance();
	      if (this.isFnDeclTransform(this.peek())) {
	        return new T.ExportDefault({
	          body: this.enforestFunction({ isExpr: false, inDefault: true })
	        });
	      } else if (this.isKeyword(this.peek(), 'class')) {
	        return new T.ExportDefault({
	          body: this.enforestClass({ isExpr: false, inDefault: true })
	        });
	      } else {
	        let body = this.enforestExpressionLoop();
	        this.consumeSemicolon();
	        return new T.ExportDefault({ body });
	      }
	    } else if (this.isVarDeclTransform(lookahead) || this.isLetDeclTransform(lookahead) || this.isConstDeclTransform(lookahead) || this.isSyntaxrecDeclTransform(lookahead) || this.isSyntaxDeclTransform(lookahead)) {
	      return new T.Export({
	        declaration: this.enforestVariableDeclaration()
	      });
	    }
	    throw this.createError(lookahead, 'unexpected syntax');
	  }

	  enforestExportClause() {
	    let enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let result = [];
	    while (enf.rest.size !== 0) {
	      result.push(enf.enforestExportSpecifier());
	      enf.consumeComma();
	    }
	    return (0, _immutable.List)(result);
	  }

	  enforestExportSpecifier() {
	    let name = this.enforestIdentifier();
	    if (this.isIdentifier(this.peek(), 'as')) {
	      this.advance();
	      let exportedName = this.enforestIdentifier();
	      return new T.ExportSpecifier({ name, exportedName });
	    }
	    return new T.ExportSpecifier({
	      name: null,
	      exportedName: name
	    });
	  }

	  enforestImportDeclaration() {
	    let lookahead = this.peek();
	    let defaultBinding = null;
	    let namedImports = (0, _immutable.List)();
	    let forSyntax = false;

	    if (this.isStringLiteral(lookahead)) {
	      let moduleSpecifier = this.advance();
	      this.consumeSemicolon();
	      return new T.Import({
	        defaultBinding,
	        namedImports,
	        moduleSpecifier,
	        forSyntax
	      });
	    }

	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	      defaultBinding = this.enforestBindingIdentifier();
	      if (!this.isPunctuator(this.peek(), ',')) {
	        let moduleSpecifier = this.enforestFromClause();
	        if (this.isKeyword(this.peek(), 'for') && this.isIdentifier(this.peek(1), 'syntax')) {
	          this.advance();
	          this.advance();
	          forSyntax = true;
	        }

	        return new T.Import({
	          defaultBinding, moduleSpecifier,
	          namedImports: (0, _immutable.List)(),
	          forSyntax
	        });
	      }
	    }
	    this.consumeComma();
	    lookahead = this.peek();
	    if (this.isBraces(lookahead)) {
	      let imports = this.enforestNamedImports();
	      let fromClause = this.enforestFromClause();
	      if (this.isKeyword(this.peek(), 'for') && this.isIdentifier(this.peek(1), 'syntax')) {
	        this.advance();
	        this.advance();
	        forSyntax = true;
	      }

	      return new T.Import({
	        defaultBinding,
	        forSyntax,
	        namedImports: imports,
	        moduleSpecifier: fromClause

	      });
	    } else if (this.isPunctuator(lookahead, '*')) {
	      let namespaceBinding = this.enforestNamespaceBinding();
	      let moduleSpecifier = this.enforestFromClause();
	      if (this.isKeyword(this.peek(), 'for') && this.isIdentifier(this.peek(1), 'syntax')) {
	        this.advance();
	        this.advance();
	        forSyntax = true;
	      }
	      return new T.ImportNamespace({
	        defaultBinding, forSyntax, namespaceBinding, moduleSpecifier
	      });
	    }
	    throw this.createError(lookahead, 'unexpected syntax');
	  }

	  enforestNamespaceBinding() {
	    this.matchPunctuator('*');
	    this.matchIdentifier('as');
	    return this.enforestBindingIdentifier();
	  }

	  enforestNamedImports() {
	    let enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let result = [];
	    while (enf.rest.size !== 0) {
	      result.push(enf.enforestImportSpecifiers());
	      enf.consumeComma();
	    }
	    return (0, _immutable.List)(result);
	  }

	  enforestImportSpecifiers() {
	    let lookahead = this.peek();
	    let name;
	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	      name = this.matchRawSyntax();
	      if (!this.isIdentifier(this.peek(), 'as')) {
	        return new T.ImportSpecifier({
	          name: null,
	          binding: new T.BindingIdentifier({
	            name: name
	          })
	        });
	      } else {
	        this.matchIdentifier('as');
	      }
	    } else {
	      throw this.createError(lookahead, 'unexpected token in import specifier');
	    }
	    return new T.ImportSpecifier({
	      name, binding: this.enforestBindingIdentifier()
	    });
	  }

	  enforestFromClause() {
	    this.matchIdentifier('from');
	    let lookahead = this.matchStringLiteral();
	    this.consumeSemicolon();
	    return lookahead;
	  }

	  enforestStatementListItem() {
	    let lookahead = this.peek();

	    if (this.isFnDeclTransform(lookahead)) {
	      return this.enforestFunction({ isExpr: false });
	    } else if (this.isKeyword(lookahead, 'class')) {
	      return this.enforestClass({ isExpr: false });
	    } else {
	      return this.enforestStatement();
	    }
	  }

	  enforestStatement() {
	    let lookahead = this.peek();

	    if (this.term === null && this.isCompiletimeTransform(lookahead)) {
	      this.expandMacro();
	      lookahead = this.peek();
	    }

	    if (this.term === null && this.isTerm(lookahead) && lookahead instanceof T.Statement) {
	      // TODO: check that this is actually an statement
	      return this.advance();
	    }

	    if (this.term === null && this.isBraces(lookahead)) {
	      return this.enforestBlockStatement();
	    }

	    if (this.term === null && this.isWhileTransform(lookahead)) {
	      return this.enforestWhileStatement();
	    }

	    if (this.term === null && this.isIfTransform(lookahead)) {
	      return this.enforestIfStatement();
	    }
	    if (this.term === null && this.isForTransform(lookahead)) {
	      return this.enforestForStatement();
	    }
	    if (this.term === null && this.isSwitchTransform(lookahead)) {
	      return this.enforestSwitchStatement();
	    }
	    if (this.term === null && this.isBreakTransform(lookahead)) {
	      return this.enforestBreakStatement();
	    }
	    if (this.term === null && this.isContinueTransform(lookahead)) {
	      return this.enforestContinueStatement();
	    }
	    if (this.term === null && this.isDoTransform(lookahead)) {
	      return this.enforestDoStatement();
	    }
	    if (this.term === null && this.isDebuggerTransform(lookahead)) {
	      return this.enforestDebuggerStatement();
	    }
	    if (this.term === null && this.isWithTransform(lookahead)) {
	      return this.enforestWithStatement();
	    }
	    if (this.term === null && this.isTryTransform(lookahead)) {
	      return this.enforestTryStatement();
	    }
	    if (this.term === null && this.isThrowTransform(lookahead)) {
	      return this.enforestThrowStatement();
	    }

	    // TODO: put somewhere else
	    if (this.term === null && this.isKeyword(lookahead, 'class')) {
	      return this.enforestClass({ isExpr: false });
	    }

	    if (this.term === null && this.isFnDeclTransform(lookahead)) {
	      return this.enforestFunction({ isExpr: false });
	    }

	    if (this.term === null && this.isIdentifier(lookahead) && this.isPunctuator(this.peek(1), ':')) {
	      return this.enforestLabeledStatement();
	    }

	    if (this.term === null && (this.isVarDeclTransform(lookahead) || this.isLetDeclTransform(lookahead) || this.isConstDeclTransform(lookahead) || this.isSyntaxrecDeclTransform(lookahead) || this.isSyntaxDeclTransform(lookahead))) {
	      let stmt = new T.VariableDeclarationStatement({
	        declaration: this.enforestVariableDeclaration()
	      });
	      this.consumeSemicolon();
	      return stmt;
	    }

	    if (this.term === null && this.isReturnStmtTransform(lookahead)) {
	      return this.enforestReturnStatement();
	    }

	    if (this.term === null && this.isPunctuator(lookahead, ';')) {
	      this.advance();
	      return new T.EmptyStatement({});
	    }

	    return this.enforestExpressionStatement();
	  }

	  enforestLabeledStatement() {
	    let label = this.matchIdentifier();
	    this.matchPunctuator(':');
	    let stmt = this.enforestStatement();

	    return new T.LabeledStatement({
	      label: label,
	      body: stmt
	    });
	  }

	  enforestBreakStatement() {
	    this.matchKeyword('break');
	    let lookahead = this.peek();
	    let label = null;
	    if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {
	      this.consumeSemicolon();
	      return new T.BreakStatement({ label });
	    }
	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'yield') || this.isKeyword(lookahead, 'let')) {
	      label = this.enforestIdentifier();
	    }
	    this.consumeSemicolon();

	    return new T.BreakStatement({ label });
	  }

	  enforestTryStatement() {
	    this.matchKeyword('try');
	    let body = this.enforestBlock();
	    if (this.isKeyword(this.peek(), 'catch')) {
	      let catchClause = this.enforestCatchClause();
	      if (this.isKeyword(this.peek(), 'finally')) {
	        this.advance();
	        let finalizer = this.enforestBlock();
	        return new T.TryFinallyStatement({
	          body, catchClause, finalizer
	        });
	      }
	      return new T.TryCatchStatement({ body, catchClause });
	    }
	    if (this.isKeyword(this.peek(), 'finally')) {
	      this.advance();
	      let finalizer = this.enforestBlock();
	      return new T.TryFinallyStatement({ body, catchClause: null, finalizer });
	    }
	    throw this.createError(this.peek(), 'try with no catch or finally');
	  }

	  enforestCatchClause() {
	    this.matchKeyword('catch');
	    let bindingParens = this.matchParens();
	    let enf = new Enforester(bindingParens, (0, _immutable.List)(), this.context);
	    let binding = enf.enforestBindingTarget();
	    let body = this.enforestBlock();
	    return new T.CatchClause({ binding, body });
	  }

	  enforestThrowStatement() {
	    this.matchKeyword('throw');
	    let expression = this.enforestExpression();
	    this.consumeSemicolon();
	    return new T.ThrowStatement({ expression });
	  }

	  enforestWithStatement() {
	    this.matchKeyword('with');
	    let objParens = this.matchParens();
	    let enf = new Enforester(objParens, (0, _immutable.List)(), this.context);
	    let object = enf.enforestExpression();
	    let body = this.enforestStatement();
	    return new T.WithStatement({ object, body });
	  }

	  enforestDebuggerStatement() {
	    this.matchKeyword('debugger');

	    return new T.DebuggerStatement({});
	  }

	  enforestDoStatement() {
	    this.matchKeyword('do');
	    let body = this.enforestStatement();
	    this.matchKeyword('while');
	    let testBody = this.matchParens();
	    let enf = new Enforester(testBody, (0, _immutable.List)(), this.context);
	    let test = enf.enforestExpression();
	    this.consumeSemicolon();
	    return new T.DoWhileStatement({ body, test });
	  }

	  enforestContinueStatement() {
	    let kwd = this.matchKeyword('continue');
	    let lookahead = this.peek();
	    let label = null;
	    if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {
	      this.consumeSemicolon();
	      return new T.ContinueStatement({ label });
	    }
	    if (lookahead instanceof T.RawSyntax && this.lineNumberEq(kwd, lookahead) && (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'yield') || this.isKeyword(lookahead, 'let'))) {
	      label = this.enforestIdentifier();
	    }
	    this.consumeSemicolon();

	    return new T.ContinueStatement({ label });
	  }

	  enforestSwitchStatement() {
	    this.matchKeyword('switch');
	    let cond = this.matchParens();
	    let enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	    let discriminant = enf.enforestExpression();
	    let body = this.matchCurlies();

	    if (body.size === 0) {
	      return new T.SwitchStatement({
	        discriminant: discriminant,
	        cases: (0, _immutable.List)()
	      });
	    }
	    enf = new Enforester(body, (0, _immutable.List)(), this.context);
	    let cases = enf.enforestSwitchCases();
	    let lookahead = enf.peek();
	    if (enf.isKeyword(lookahead, 'default')) {
	      let defaultCase = enf.enforestSwitchDefault();
	      let postDefaultCases = enf.enforestSwitchCases();
	      return new T.SwitchStatementWithDefault({
	        discriminant,
	        preDefaultCases: cases,
	        defaultCase,
	        postDefaultCases
	      });
	    }
	    return new T.SwitchStatement({ discriminant, cases });
	  }

	  enforestSwitchCases() {
	    let cases = [];
	    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), 'default'))) {
	      cases.push(this.enforestSwitchCase());
	    }
	    return (0, _immutable.List)(cases);
	  }

	  enforestSwitchCase() {
	    this.matchKeyword('case');
	    return new T.SwitchCase({
	      test: this.enforestExpression(),
	      consequent: this.enforestSwitchCaseBody()
	    });
	  }

	  enforestSwitchCaseBody() {
	    this.matchPunctuator(':');
	    return this.enforestStatementListInSwitchCaseBody();
	  }

	  enforestStatementListInSwitchCaseBody() {
	    let result = [];
	    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), 'default') || this.isKeyword(this.peek(), 'case'))) {
	      result.push(this.enforestStatementListItem());
	    }
	    return (0, _immutable.List)(result);
	  }

	  enforestSwitchDefault() {
	    this.matchKeyword('default');
	    return new T.SwitchDefault({
	      consequent: this.enforestSwitchCaseBody()
	    });
	  }

	  enforestForStatement() {
	    this.matchKeyword('for');
	    let cond = this.matchParens();
	    let enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	    let lookahead, test, init, right, left, update, cnst;

	    // case where init is null
	    if (enf.isPunctuator(enf.peek(), ';')) {
	      enf.advance();
	      if (!enf.isPunctuator(enf.peek(), ';')) {
	        test = enf.enforestExpression();
	      }
	      enf.matchPunctuator(';');
	      if (enf.rest.size !== 0) {
	        right = enf.enforestExpression();
	      }
	      return new T.ForStatement({
	        init: null,
	        test: test,
	        update: right,
	        body: this.enforestStatement()
	      });
	      // case where init is not null
	    } else {
	      // testing
	      lookahead = enf.peek();
	      if (enf.isVarDeclTransform(lookahead) || enf.isLetDeclTransform(lookahead) || enf.isConstDeclTransform(lookahead)) {
	        init = enf.enforestVariableDeclaration();
	        lookahead = enf.peek();
	        if (this.isKeyword(lookahead, 'in') || this.isIdentifier(lookahead, 'of')) {
	          if (this.isKeyword(lookahead, 'in')) {
	            enf.advance();
	            right = enf.enforestExpression();
	            cnst = T.ForInStatement;
	          } else {
	            (0, _errors.assert)(this.isIdentifier(lookahead, 'of'), 'expecting `of` keyword');
	            enf.advance();
	            right = enf.enforestExpression();
	            cnst = T.ForOfStatement;
	          }
	          return new cnst({
	            left: init, right, body: this.enforestStatement()
	          });
	        }
	        enf.matchPunctuator(';');
	        if (enf.isPunctuator(enf.peek(), ';')) {
	          enf.advance();
	          test = null;
	        } else {
	          test = enf.enforestExpression();
	          enf.matchPunctuator(';');
	        }
	        update = enf.enforestExpression();
	      } else {
	        if (this.isKeyword(enf.peek(1), 'in') || this.isIdentifier(enf.peek(1), 'of')) {
	          left = enf.enforestBindingIdentifier();
	          let kind = enf.advance();
	          if (this.isKeyword(kind, 'in')) {
	            cnst = T.ForInStatement;
	          } else {
	            cnst = T.ForOfStatement;
	          }
	          right = enf.enforestExpression();
	          return new cnst({
	            left: left, right, body: this.enforestStatement()
	          });
	        }
	        init = enf.enforestExpression();
	        enf.matchPunctuator(';');
	        if (enf.isPunctuator(enf.peek(), ';')) {
	          enf.advance();
	          test = null;
	        } else {
	          test = enf.enforestExpression();
	          enf.matchPunctuator(';');
	        }
	        update = enf.enforestExpression();
	      }
	      return new T.ForStatement({ init, test, update, body: this.enforestStatement() });
	    }
	  }

	  enforestIfStatement() {
	    this.matchKeyword('if');
	    let cond = this.matchParens();
	    let enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	    let lookahead = enf.peek();
	    let test = enf.enforestExpression();
	    if (test === null) {
	      throw enf.createError(lookahead, 'expecting an expression');
	    }
	    let consequent = this.enforestStatement();
	    let alternate = null;
	    if (this.isKeyword(this.peek(), 'else')) {
	      this.advance();
	      alternate = this.enforestStatement();
	    }
	    return new T.IfStatement({ test, consequent, alternate });
	  }

	  enforestWhileStatement() {
	    this.matchKeyword('while');
	    let cond = this.matchParens();
	    let enf = new Enforester(cond, (0, _immutable.List)(), this.context);
	    let lookahead = enf.peek();
	    let test = enf.enforestExpression();
	    if (test === null) {
	      throw enf.createError(lookahead, 'expecting an expression');
	    }
	    let body = this.enforestStatement();

	    return new T.WhileStatement({ test, body });
	  }

	  enforestBlockStatement() {
	    return new T.BlockStatement({
	      block: this.enforestBlock()
	    });
	  }

	  enforestBlock() {
	    return new T.Block({
	      statements: this.matchCurlies()
	    });
	  }

	  enforestClass({ isExpr = false, inDefault = false }) {
	    let kw = this.matchRawSyntax();
	    let name = null,
	        supr = null;

	    if (this.isIdentifier(this.peek())) {
	      name = this.enforestBindingIdentifier();
	    } else if (!isExpr) {
	      if (inDefault) {
	        name = new T.BindingIdentifier({
	          name: _syntax2.default.fromIdentifier('_default', kw)
	        });
	      } else {
	        throw this.createError(this.peek(), 'unexpected syntax');
	      }
	    }

	    if (this.isKeyword(this.peek(), 'extends')) {
	      this.advance();
	      supr = this.enforestExpressionLoop();
	    }

	    let elements = [];
	    let enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    while (enf.rest.size !== 0) {
	      if (enf.isPunctuator(enf.peek(), ';')) {
	        enf.advance();
	        continue;
	      }

	      let isStatic = false;
	      let { methodOrKey, kind } = enf.enforestMethodDefinition();
	      if (kind === 'identifier' && methodOrKey.value.val() === 'static') {
	        isStatic = true;
	        ({ methodOrKey, kind } = enf.enforestMethodDefinition());
	      }
	      if (kind === 'method') {
	        elements.push(new T.ClassElement({ isStatic, method: methodOrKey }));
	      } else {
	        throw this.createError(enf.peek(), 'Only methods are allowed in classes');
	      }
	    }
	    return new (isExpr ? T.ClassExpression : T.ClassDeclaration)({
	      name, super: supr,
	      elements: (0, _immutable.List)(elements)
	    });
	  }

	  enforestBindingTarget({ allowPunctuator = false } = {}) {
	    let lookahead = this.peek();
	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead) || allowPunctuator && this.isPunctuator(lookahead)) {
	      return this.enforestBindingIdentifier({ allowPunctuator });
	    } else if (this.isBrackets(lookahead)) {
	      return this.enforestArrayBinding();
	    } else if (this.isBraces(lookahead)) {
	      return this.enforestObjectBinding();
	    }
	    (0, _errors.assert)(false, 'not implemented yet');
	  }

	  enforestObjectBinding() {
	    let enf = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);
	    let properties = [];
	    while (enf.rest.size !== 0) {
	      properties.push(enf.enforestBindingProperty());
	      enf.consumeComma();
	    }

	    return new T.ObjectBinding({
	      properties: (0, _immutable.List)(properties)
	    });
	  }

	  enforestBindingProperty() {
	    let lookahead = this.peek();
	    let { name, binding } = this.enforestPropertyName();
	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'let') || this.isKeyword(lookahead, 'yield')) {
	      if (!this.isPunctuator(this.peek(), ':')) {
	        let defaultValue = null;
	        if (this.isAssign(this.peek())) {
	          this.advance();
	          let expr = this.enforestExpressionLoop();
	          defaultValue = expr;
	        }
	        return new T.BindingPropertyIdentifier({
	          binding, init: defaultValue
	        });
	      }
	    }
	    this.matchPunctuator(':');
	    binding = this.enforestBindingElement();
	    return new T.BindingPropertyProperty({
	      name, binding
	    });
	  }

	  enforestArrayBinding() {
	    let bracket = this.matchSquares();
	    let enf = new Enforester(bracket, (0, _immutable.List)(), this.context);
	    let elements = [],
	        restElement = null;
	    while (enf.rest.size !== 0) {
	      let el;
	      if (enf.isPunctuator(enf.peek(), ',')) {
	        enf.consumeComma();
	        el = null;
	      } else {
	        if (enf.isPunctuator(enf.peek(), '...')) {
	          enf.advance();
	          restElement = enf.enforestBindingTarget();
	          break;
	        } else {
	          el = enf.enforestBindingElement();
	        }
	        enf.consumeComma();
	      }
	      elements.push(el);
	    }
	    return new T.ArrayBinding({
	      elements: (0, _immutable.List)(elements),
	      restElement
	    });
	  }

	  enforestBindingElement() {
	    let binding = this.enforestBindingTarget();

	    if (this.isAssign(this.peek())) {
	      this.advance();
	      let init = this.enforestExpressionLoop();
	      binding = new T.BindingWithDefault({ binding, init });
	    }
	    return binding;
	  }

	  enforestBindingIdentifier({ allowPunctuator } = {}) {
	    let name;
	    if (allowPunctuator && this.isPunctuator(this.peek())) {
	      name = this.enforestPunctuator();
	    } else {
	      name = this.enforestIdentifier();
	    }
	    return new T.BindingIdentifier({ name });
	  }

	  enforestPunctuator() {
	    let lookahead = this.peek();
	    if (this.isPunctuator(lookahead)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting a punctuator');
	  }

	  enforestIdentifier() {
	    let lookahead = this.peek();
	    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting an identifier');
	  }

	  enforestReturnStatement() {
	    let kw = this.matchRawSyntax();
	    let lookahead = this.peek();

	    // short circuit for the empty expression case
	    if (this.rest.size === 0 || lookahead && !this.lineNumberEq(kw, lookahead)) {
	      return new T.ReturnStatement({
	        expression: null
	      });
	    }

	    let term = null;
	    if (!this.isPunctuator(lookahead, ';')) {
	      term = this.enforestExpression();
	      (0, _errors.expect)(term != null, 'Expecting an expression to follow return keyword', lookahead, this.rest);
	    }

	    this.consumeSemicolon();
	    return new T.ReturnStatement({
	      expression: term
	    });
	  }

	  enforestVariableDeclaration() {
	    let kind;
	    let lookahead = this.matchRawSyntax();
	    let kindSyn = lookahead;
	    let phase = this.context.phase;

	    if (kindSyn && this.context.env.get(kindSyn.resolve(phase)) === _transforms.VariableDeclTransform) {
	      kind = 'var';
	    } else if (kindSyn && this.context.env.get(kindSyn.resolve(phase)) === _transforms.LetDeclTransform) {
	      kind = 'let';
	    } else if (kindSyn && this.context.env.get(kindSyn.resolve(phase)) === _transforms.ConstDeclTransform) {
	      kind = 'const';
	    } else if (kindSyn && this.context.env.get(kindSyn.resolve(phase)) === _transforms.SyntaxDeclTransform) {
	      kind = 'syntax';
	    } else if (kindSyn && this.context.env.get(kindSyn.resolve(phase)) === _transforms.SyntaxrecDeclTransform) {
	      kind = 'syntaxrec';
	    }

	    let decls = (0, _immutable.List)();

	    while (true) {
	      let term = this.enforestVariableDeclarator({ isSyntax: kind === 'syntax' || kind === 'syntaxrec' });
	      let lookahead = this.peek();
	      decls = decls.concat(term);

	      if (this.isPunctuator(lookahead, ',')) {
	        this.advance();
	      } else {
	        break;
	      }
	    }

	    return new T.VariableDeclaration({
	      kind: kind,
	      declarators: decls
	    });
	  }

	  enforestVariableDeclarator({ isSyntax }) {
	    let id = this.enforestBindingTarget({ allowPunctuator: isSyntax });
	    let lookahead = this.peek();

	    let init;
	    if (this.isPunctuator(lookahead, '=')) {
	      this.advance();
	      let enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	      init = enf.enforest('expression');
	      this.rest = enf.rest;
	    } else {
	      init = null;
	    }
	    return new T.VariableDeclarator({
	      binding: id,
	      init: init
	    });
	  }

	  enforestExpressionStatement() {
	    let start = this.rest.get(0);
	    let expr = this.enforestExpression();
	    if (expr === null) {
	      throw this.createError(start, 'not a valid expression');
	    }
	    this.consumeSemicolon();

	    return new T.ExpressionStatement({
	      expression: expr
	    });
	  }

	  enforestExpression() {
	    let left = this.enforestExpressionLoop();
	    let lookahead = this.peek();
	    if (this.isPunctuator(lookahead, ',')) {
	      while (this.rest.size !== 0) {
	        if (!this.isPunctuator(this.peek(), ',')) {
	          break;
	        }
	        let operator = this.matchRawSyntax();
	        let right = this.enforestExpressionLoop();
	        left = new T.BinaryExpression({ left, operator: operator.val(), right });
	      }
	    }
	    this.term = null;
	    return left;
	  }

	  enforestExpressionLoop() {
	    this.term = null;
	    this.opCtx = {
	      prec: 0,
	      combine: x => x,
	      stack: (0, _immutable.List)()
	    };

	    do {
	      let term = this.enforestAssignmentExpression();
	      // no change means we've done as much enforesting as possible
	      // if nothing changed, maybe we just need to pop the expr stack
	      if (term === EXPR_LOOP_NO_CHANGE && this.opCtx.stack.size > 0) {
	        this.term = this.opCtx.combine(this.term);
	        let { prec, combine } = this.opCtx.stack.last();
	        this.opCtx.prec = prec;
	        this.opCtx.combine = combine;
	        this.opCtx.stack = this.opCtx.stack.pop();
	      } else if (term === EXPR_LOOP_NO_CHANGE) {
	        break;
	      } else if (term === EXPR_LOOP_OPERATOR || term === EXPR_LOOP_EXPANSION) {
	        // operator means an opCtx was pushed on the stack
	        this.term = null;
	      } else {
	        this.term = term;
	      }
	    } while (true); // get a fixpoint
	    return this.term;
	  }

	  enforestAssignmentExpression() {
	    let lookahead = this.peek();

	    if (this.term === null && this.isCompiletimeTransform(lookahead)) {
	      this.expandMacro();
	      lookahead = this.peek();
	    }

	    if (this.term === null && this.isTerm(lookahead) && lookahead instanceof T.Expression) {
	      // TODO: check that this is actually an expression
	      return this.advance();
	    }

	    if (this.term === null && this.isKeyword(lookahead, 'yield')) {
	      return this.enforestYieldExpression();
	    }

	    if (this.term === null && this.isKeyword(lookahead, 'class')) {
	      return this.enforestClass({ isExpr: true });
	    }

	    if (this.term === null && lookahead && (this.isIdentifier(lookahead) || this.isParens(lookahead)) && this.isPunctuator(this.peek(1), '=>') && this.lineNumberEq(lookahead, this.peek(1))) {
	      return this.enforestArrowExpression();
	    }

	    if (this.term === null && this.isSyntaxTemplate(lookahead)) {
	      return this.enforestSyntaxTemplate();
	    }

	    // ($x:expr)
	    if (this.term === null && this.isParens(lookahead)) {
	      return new T.ParenthesizedExpression({
	        inner: this.matchParens()
	      });
	    }

	    if (this.term === null && (this.isKeyword(lookahead, 'this') || this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'let') || this.isKeyword(lookahead, 'yield') || this.isNumericLiteral(lookahead) || this.isStringLiteral(lookahead) || this.isTemplate(lookahead) || this.isBooleanLiteral(lookahead) || this.isNullLiteral(lookahead) || this.isRegularExpression(lookahead) || this.isFnDeclTransform(lookahead) || this.isBraces(lookahead) || this.isBrackets(lookahead))) {
	      return this.enforestPrimaryExpression();
	    }

	    // prefix unary
	    if (this.term === null && this.isOperator(lookahead)) {
	      return this.enforestUnaryExpression();
	    }

	    if (this.term === null && this.isVarBindingTransform(lookahead) && lookahead instanceof T.RawSyntax) {
	      let lookstx = lookahead.value;
	      // $FlowFixMe
	      let id = this.getFromCompiletimeEnvironment(lookstx).id;
	      if (id !== lookstx) {
	        this.advance();
	        this.rest = _immutable.List.of(id).concat(this.rest);
	        return EXPR_LOOP_EXPANSION;
	      }
	    }

	    if (this.term === null && (this.isNewTransform(lookahead) || this.isKeyword(lookahead, 'super')) ||
	    // and then check the cases where the term part of p is something...
	    this.term && (
	    // $x:expr . $prop:ident
	    this.isPunctuator(lookahead, '.') && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1))) ||
	    // $x:expr [ $b:expr ]
	    this.isBrackets(lookahead) ||
	    // $x:expr (...)
	    this.isParens(lookahead))) {
	      return this.enforestLeftHandSideExpression({ allowCall: true });
	    }

	    // $x:id `...`
	    if (this.term && this.isTemplate(lookahead)) {
	      return this.enforestTemplateLiteral();
	    }

	    // postfix unary
	    if (this.term && this.isUpdateOperator(lookahead)) {
	      return this.enforestUpdateExpression();
	    }

	    // $l:expr $op:binaryOperator $r:expr
	    if (this.term && this.isOperator(lookahead)) {
	      return this.enforestBinaryExpression();
	    }

	    // $x:expr = $init:expr
	    if (this.term && this.isAssign(lookahead)) {
	      let binding = this.transformDestructuring(this.term);
	      let op = this.matchRawSyntax();

	      let enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	      let init = enf.enforest('expression');
	      this.rest = enf.rest;

	      if (op.val() === '=') {
	        return new T.AssignmentExpression({
	          binding,
	          expression: init
	        });
	      } else {
	        return new T.CompoundAssignmentExpression({
	          binding,
	          operator: op.val(),
	          expression: init
	        });
	      }
	    }

	    if (this.term && this.isPunctuator(lookahead, '?')) {
	      return this.enforestConditionalExpression();
	    }

	    return EXPR_LOOP_NO_CHANGE;
	  }

	  enforestPrimaryExpression() {
	    let lookahead = this.peek();
	    // $x:ThisExpression
	    if (this.term === null && this.isKeyword(lookahead, 'this')) {
	      return this.enforestThisExpression();
	    }
	    // $x:ident
	    if (this.term === null && (this.isIdentifier(lookahead) || this.isKeyword(lookahead, 'let') || this.isKeyword(lookahead, 'yield'))) {
	      return this.enforestIdentifierExpression();
	    }
	    if (this.term === null && this.isNumericLiteral(lookahead)) {
	      return this.enforestNumericLiteral();
	    }
	    if (this.term === null && this.isStringLiteral(lookahead)) {
	      return this.enforestStringLiteral();
	    }
	    if (this.term === null && this.isTemplate(lookahead)) {
	      return this.enforestTemplateLiteral();
	    }
	    if (this.term === null && this.isBooleanLiteral(lookahead)) {
	      return this.enforestBooleanLiteral();
	    }
	    if (this.term === null && this.isNullLiteral(lookahead)) {
	      return this.enforestNullLiteral();
	    }
	    if (this.term === null && this.isRegularExpression(lookahead)) {
	      return this.enforestRegularExpressionLiteral();
	    }
	    // $x:FunctionExpression
	    if (this.term === null && this.isFnDeclTransform(lookahead)) {
	      return this.enforestFunction({ isExpr: true });
	    }
	    // { $p:prop (,) ... }
	    if (this.term === null && this.isBraces(lookahead)) {
	      return this.enforestObjectExpression();
	    }
	    // [$x:expr (,) ...]
	    if (this.term === null && this.isBrackets(lookahead)) {
	      return this.enforestArrayExpression();
	    }
	    (0, _errors.assert)(false, 'Not a primary expression');
	  }

	  enforestLeftHandSideExpression({ allowCall }) {
	    let lookahead = this.peek();

	    if (this.isKeyword(lookahead, 'super')) {
	      this.advance();
	      this.term = new T.Super({});
	    } else if (this.isNewTransform(lookahead)) {
	      this.term = this.enforestNewExpression();
	    } else if (this.isKeyword(lookahead, 'this')) {
	      this.term = this.enforestThisExpression();
	    }

	    while (true) {
	      lookahead = this.peek();
	      if (this.isParens(lookahead)) {
	        if (!allowCall) {
	          // we're dealing with a new expression
	          if (this.term && ((0, _terms.isIdentifierExpression)(this.term) || (0, _terms.isStaticMemberExpression)(this.term) || (0, _terms.isComputedMemberExpression)(this.term))) {
	            return this.term;
	          }
	          this.term = this.enforestExpressionLoop();
	        } else {
	          this.term = this.enforestCallExpression();
	        }
	      } else if (this.isBrackets(lookahead)) {
	        this.term = this.term ? this.enforestComputedMemberExpression() : this.enforestPrimaryExpression();
	      } else if (this.isPunctuator(lookahead, '.') && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) {
	        this.term = this.enforestStaticMemberExpression();
	      } else if (this.isTemplate(lookahead)) {
	        this.term = this.enforestTemplateLiteral();
	      } else if (this.isBraces(lookahead)) {
	        this.term = this.enforestPrimaryExpression();
	      } else if (this.isIdentifier(lookahead)) {
	        this.term = new T.IdentifierExpression({ name: this.enforestIdentifier() });
	      } else {
	        break;
	      }
	    }
	    return this.term;
	  }

	  enforestBooleanLiteral() {
	    return new T.LiteralBooleanExpression({
	      value: this.matchRawSyntax().val() === 'true'
	    });
	  }

	  enforestTemplateLiteral() {
	    return new T.TemplateExpression({
	      tag: this.term,
	      elements: this.enforestTemplateElements()
	    });
	  }

	  enforestStringLiteral() {
	    return new T.LiteralStringExpression({
	      value: this.matchRawSyntax().val()
	    });
	  }

	  enforestNumericLiteral() {
	    let num = this.matchRawSyntax();
	    if (num.val() === 1 / 0) {
	      return new T.LiteralInfinityExpression({});
	    }
	    return new T.LiteralNumericExpression({
	      value: num.val()
	    });
	  }

	  enforestIdentifierExpression() {
	    return new T.IdentifierExpression({
	      name: this.matchRawSyntax()
	    });
	  }

	  enforestRegularExpressionLiteral() {
	    let reStx = this.matchRawSyntax();

	    let lastSlash = reStx.token.value.lastIndexOf('/');
	    let pattern = reStx.token.value.slice(1, lastSlash);
	    let flags = reStx.token.value.slice(lastSlash + 1);
	    return new T.LiteralRegExpExpression({
	      pattern, flags
	    });
	  }

	  enforestNullLiteral() {
	    this.advance();
	    return new T.LiteralNullExpression({});
	  }

	  enforestThisExpression() {
	    return new T.ThisExpression({
	      stx: this.matchRawSyntax()
	    });
	  }

	  enforestArgumentList() {
	    let result = [];
	    while (this.rest.size > 0) {
	      let arg;
	      if (this.isPunctuator(this.peek(), '...')) {
	        this.advance();
	        arg = new T.SpreadElement({
	          expression: this.enforestExpressionLoop()
	        });
	      } else {
	        arg = this.enforestExpressionLoop();
	      }
	      if (this.rest.size > 0) {
	        this.matchPunctuator(',');
	      }
	      result.push(arg);
	    }
	    return (0, _immutable.List)(result);
	  }

	  enforestNewExpression() {
	    this.matchKeyword('new');
	    if (this.isPunctuator(this.peek(), '.') && this.isIdentifier(this.peek(1), 'target')) {
	      this.advance();
	      this.advance();
	      return new T.NewTargetExpression({});
	    }

	    let callee = this.enforestLeftHandSideExpression({ allowCall: false });
	    let args;
	    if (this.isParens(this.peek())) {
	      args = this.matchParens();
	    } else {
	      args = (0, _immutable.List)();
	    }
	    return new T.NewExpression({
	      callee,
	      arguments: args
	    });
	  }

	  enforestComputedMemberExpression() {
	    let enf = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context);
	    return new T.ComputedMemberExpression({
	      object: this.term,
	      expression: enf.enforestExpression()
	    });
	  }

	  transformDestructuring(term) {
	    switch (term.type) {
	      case 'IdentifierExpression':
	        return new T.BindingIdentifier({ name: term.name });

	      case 'ParenthesizedExpression':
	        if (term.inner.size === 1 && this.isIdentifier(term.inner.get(0))) {
	          return new T.BindingIdentifier({ name: term.inner.get(0).value });
	        }
	        return term;
	      case 'DataProperty':
	        return new T.BindingPropertyProperty({
	          name: term.name,
	          binding: this.transformDestructuringWithDefault(term.expression)
	        });
	      case 'ShorthandProperty':
	        return new T.BindingPropertyIdentifier({
	          binding: new T.BindingIdentifier({ name: term.name }),
	          init: null
	        });
	      case 'ObjectExpression':
	        return new T.ObjectBinding({
	          properties: term.properties.map(t => this.transformDestructuring(t))
	        });
	      case 'ArrayExpression':
	        {
	          let last = term.elements.last();
	          if (last != null && last.type === 'SpreadElement') {
	            return new T.ArrayBinding({
	              elements: term.elements.slice(0, -1).map(t => t && this.transformDestructuringWithDefault(t)),
	              restElement: this.transformDestructuringWithDefault(last.expression)
	            });
	          } else {
	            return new T.ArrayBinding({
	              elements: term.elements.map(t => t && this.transformDestructuringWithDefault(t)),
	              restElement: null
	            });
	          }
	        }
	      case 'StaticPropertyName':
	        return new T.BindingIdentifier({
	          name: term.value
	        });
	      case 'ComputedMemberExpression':
	      case 'StaticMemberExpression':
	      case 'ArrayBinding':
	      case 'BindingIdentifier':
	      case 'BindingPropertyIdentifier':
	      case 'BindingPropertyProperty':
	      case 'BindingWithDefault':
	      case 'ObjectBinding':
	        return term;
	    }
	    (0, _errors.assert)(false, 'not implemented yet for ' + term.type);
	  }

	  transformDestructuringWithDefault(term) {
	    switch (term.type) {
	      case 'AssignmentExpression':
	        return new T.BindingWithDefault({
	          binding: this.transformDestructuring(term.binding),
	          init: term.expression
	        });
	    }
	    return this.transformDestructuring(term);
	  }

	  enforestCallExpression() {
	    let paren = this.matchParens();
	    return new T.CallExpression({
	      callee: this.term,
	      arguments: paren
	    });
	  }

	  enforestArrowExpression() {
	    let enf;
	    if (this.isIdentifier(this.peek())) {
	      enf = new Enforester(_immutable.List.of(this.advance()), (0, _immutable.List)(), this.context);
	    } else {
	      let p = this.matchParens();
	      enf = new Enforester(p, (0, _immutable.List)(), this.context);
	    }
	    let params = enf.enforestFormalParameters();
	    this.matchPunctuator('=>');

	    let body;
	    if (this.isBraces(this.peek())) {
	      body = this.matchCurlies();
	      return new T.ArrowExpressionE({ params, body });
	    } else {
	      enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	      body = enf.enforestExpressionLoop();
	      this.rest = enf.rest;
	      return new T.ArrowExpression({ params, body });
	    }
	  }

	  enforestYieldExpression() {
	    let kwd = this.matchKeyword('yield');
	    let lookahead = this.peek();

	    if (this.rest.size === 0 || lookahead && !this.lineNumberEq(kwd, lookahead)) {
	      return new T.YieldExpression({
	        expression: null
	      });
	    } else {
	      let isGenerator = false;
	      if (this.isPunctuator(this.peek(), '*')) {
	        isGenerator = true;
	        this.advance();
	      }
	      let expr = this.enforestExpression();
	      return new (isGenerator ? T.YieldGeneratorExpression : T.YieldExpression)({
	        expression: expr
	      });
	    }
	  }

	  enforestSyntaxTemplate() {
	    return new T.SyntaxTemplate({
	      template: this.matchRawDelimiter()
	    });
	  }

	  enforestStaticMemberExpression() {
	    let object = this.term;
	    this.advance();
	    let property = this.matchRawSyntax();

	    return new T.StaticMemberExpression({
	      object: object,
	      property: property
	    });
	  }

	  enforestArrayExpression() {
	    let arr = this.matchSquares();

	    let elements = [];

	    let enf = new Enforester(arr, (0, _immutable.List)(), this.context);

	    while (enf.rest.size > 0) {
	      let lookahead = enf.peek();
	      if (enf.isPunctuator(lookahead, ',')) {
	        enf.advance();
	        elements.push(null);
	      } else if (enf.isPunctuator(lookahead, '...')) {
	        enf.advance();
	        let expression = enf.enforestExpressionLoop();
	        if (expression == null) {
	          throw enf.createError(lookahead, 'expecting expression');
	        }
	        elements.push(new T.SpreadElement({ expression }));
	      } else {
	        let term = enf.enforestExpressionLoop();
	        if (term == null) {
	          throw enf.createError(lookahead, 'expected expression');
	        }
	        elements.push(term);
	        enf.consumeComma();
	      }
	    }

	    return new T.ArrayExpression({
	      elements: (0, _immutable.List)(elements)
	    });
	  }

	  enforestObjectExpression() {
	    let obj = this.matchCurlies();

	    let properties = (0, _immutable.List)();

	    let enf = new Enforester(obj, (0, _immutable.List)(), this.context);

	    let lastProp = null;
	    while (enf.rest.size > 0) {
	      let prop = enf.enforestPropertyDefinition();
	      enf.consumeComma();
	      properties = properties.concat(prop);

	      if (lastProp === prop) {
	        throw enf.createError(prop, 'invalid syntax in object');
	      }
	      lastProp = prop;
	    }

	    return new T.ObjectExpression({
	      properties: properties
	    });
	  }

	  enforestPropertyDefinition() {

	    let { methodOrKey, kind } = this.enforestMethodDefinition();

	    switch (kind) {
	      case 'method':
	        return methodOrKey;
	      case 'identifier':
	        if (this.isAssign(this.peek())) {
	          this.advance();
	          let init = this.enforestExpressionLoop();
	          return new T.BindingPropertyIdentifier({
	            init, binding: this.transformDestructuring(methodOrKey)
	          });
	        } else if (!this.isPunctuator(this.peek(), ':')) {
	          return new T.ShorthandProperty({
	            name: methodOrKey.value
	          });
	        }
	    }

	    this.matchPunctuator(':');
	    let expr = this.enforestExpressionLoop();

	    return new T.DataProperty({
	      name: methodOrKey,
	      expression: expr
	    });
	  }

	  enforestMethodDefinition() {
	    let lookahead = this.peek();
	    let isGenerator = false;
	    if (this.isPunctuator(lookahead, '*')) {
	      isGenerator = true;
	      this.advance();
	    }

	    if (this.isIdentifier(lookahead, 'get') && this.isPropertyName(this.peek(1))) {
	      this.advance();
	      let { name } = this.enforestPropertyName();
	      this.matchParens();
	      let body = this.matchCurlies();
	      return {
	        methodOrKey: new T.Getter({ name, body }),
	        kind: 'method'
	      };
	    } else if (this.isIdentifier(lookahead, 'set') && this.isPropertyName(this.peek(1))) {
	      this.advance();
	      let { name } = this.enforestPropertyName();
	      let enf = new Enforester(this.matchParens(), (0, _immutable.List)(), this.context);
	      let param = enf.enforestBindingElement();
	      let body = this.matchCurlies();
	      return {
	        methodOrKey: new T.Setter({ name, param, body }),
	        kind: 'method'
	      };
	    }
	    let { name } = this.enforestPropertyName();
	    if (this.isParens(this.peek())) {
	      let params = this.matchParens();
	      let enf = new Enforester(params, (0, _immutable.List)(), this.context);
	      let formalParams = enf.enforestFormalParameters();

	      let body = this.matchCurlies();
	      return {
	        methodOrKey: new T.Method({
	          isGenerator,
	          name, params: formalParams, body
	        }),
	        kind: 'method'
	      };
	    }
	    return {
	      methodOrKey: name,
	      kind: this.isIdentifier(lookahead) || this.isKeyword(lookahead) ? 'identifier' : 'property'
	    };
	  }

	  enforestPropertyName() {
	    let lookahead = this.peek();

	    if (this.isStringLiteral(lookahead) || this.isNumericLiteral(lookahead)) {
	      return {
	        name: new T.StaticPropertyName({
	          value: this.matchRawSyntax()
	        }),
	        binding: null
	      };
	    } else if (this.isBrackets(lookahead)) {
	      let enf = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context);
	      let expr = enf.enforestExpressionLoop();
	      return {
	        name: new T.ComputedPropertyName({
	          expression: expr
	        }),
	        binding: null
	      };
	    }
	    let name = this.matchRawSyntax();
	    return {
	      name: new T.StaticPropertyName({ value: name }),
	      binding: new T.BindingIdentifier({ name })
	    };
	  }

	  enforestFunction({ isExpr, inDefault }) {
	    let name = null,
	        params,
	        body;
	    let isGenerator = false;
	    // eat the function keyword
	    let fnKeyword = this.matchRawSyntax();
	    let lookahead = this.peek();

	    if (this.isPunctuator(lookahead, '*')) {
	      isGenerator = true;
	      this.advance();
	      lookahead = this.peek();
	    }

	    if (!this.isParens(lookahead)) {
	      name = this.enforestBindingIdentifier();
	    } else if (inDefault) {
	      name = new T.BindingIdentifier({
	        name: _syntax2.default.fromIdentifier('*default*', fnKeyword)
	      });
	    }

	    params = this.matchParens();

	    body = this.matchCurlies();

	    let enf = new Enforester(params, (0, _immutable.List)(), this.context);
	    let formalParams = enf.enforestFormalParameters();

	    return new (isExpr ? T.FunctionExpressionE : T.FunctionDeclarationE)({
	      name: name,
	      isGenerator: isGenerator,
	      params: formalParams,
	      body: body
	    });
	  }

	  enforestFormalParameters() {
	    let items = [];
	    let rest = null;
	    while (this.rest.size !== 0) {
	      let lookahead = this.peek();
	      if (this.isPunctuator(lookahead, '...')) {
	        this.matchPunctuator('...');
	        rest = this.enforestBindingIdentifier();
	        break;
	      }
	      items.push(this.enforestParam());
	      this.consumeComma();
	    }
	    return new T.FormalParameters({
	      items: (0, _immutable.List)(items), rest
	    });
	  }

	  enforestParam() {
	    return this.enforestBindingElement();
	  }

	  enforestUpdateExpression() {
	    let operator = this.matchUnaryOperator();

	    return new T.UpdateExpression({
	      isPrefix: false,
	      operator: operator.val(),
	      operand: this.transformDestructuring(this.term)
	    });
	  }

	  enforestUnaryExpression() {
	    let operator = this.matchUnaryOperator();
	    this.opCtx.stack = this.opCtx.stack.push({
	      prec: this.opCtx.prec,
	      combine: this.opCtx.combine
	    });
	    // TODO: all builtins are 14, custom operators will change this
	    this.opCtx.prec = 14;
	    this.opCtx.combine = rightTerm => {
	      if (operator.val() === '++' || operator.val() === '--') {
	        return new T.UpdateExpression({
	          operator: operator.val(),
	          operand: this.transformDestructuring(rightTerm),
	          isPrefix: true
	        });
	      } else {
	        return new T.UnaryExpression({
	          operator: operator.val(),
	          operand: rightTerm
	        });
	      }
	    };
	    return EXPR_LOOP_OPERATOR;
	  }

	  enforestConditionalExpression() {
	    // first, pop the operator stack
	    let test = this.opCtx.combine(this.term);
	    if (this.opCtx.stack.size > 0) {
	      let { prec, combine } = this.opCtx.stack.last();
	      this.opCtx.stack = this.opCtx.stack.pop();
	      this.opCtx.prec = prec;
	      this.opCtx.combine = combine;
	    }

	    this.matchPunctuator('?');
	    let enf = new Enforester(this.rest, (0, _immutable.List)(), this.context);
	    let consequent = enf.enforestExpressionLoop();
	    enf.matchPunctuator(':');
	    enf = new Enforester(enf.rest, (0, _immutable.List)(), this.context);
	    let alternate = enf.enforestExpressionLoop();
	    this.rest = enf.rest;
	    return new T.ConditionalExpression({
	      test, consequent, alternate
	    });
	  }

	  enforestBinaryExpression() {

	    let leftTerm = this.term;
	    let opStx = this.peek();

	    if (opStx instanceof T.RawSyntax && (0, _operators.operatorLt)(this.opCtx.prec, (0, _operators.getOperatorPrec)(opStx.value.val()), (0, _operators.getOperatorAssoc)(opStx.value.val()))) {
	      let op = opStx.value;
	      this.opCtx.stack = this.opCtx.stack.push({
	        prec: this.opCtx.prec,
	        combine: this.opCtx.combine
	      });
	      this.opCtx.prec = (0, _operators.getOperatorPrec)(op.val());
	      this.opCtx.combine = rightTerm => {
	        return new T.BinaryExpression({
	          left: leftTerm,
	          operator: op.val(),
	          right: rightTerm
	        });
	      };
	      this.advance();
	      return EXPR_LOOP_OPERATOR;
	    } else {
	      let term = this.opCtx.combine(leftTerm);
	      // this.rest does not change
	      let { prec, combine } = this.opCtx.stack.last();
	      this.opCtx.stack = this.opCtx.stack.pop();
	      this.opCtx.prec = prec;
	      this.opCtx.combine = combine;
	      return term;
	    }
	  }

	  enforestTemplateElements() {
	    let lookahead = this.matchTemplate();
	    let elements = lookahead.token.items.map(it => {
	      if (this.isDelimiter(it)) {
	        let enf = new Enforester(it.inner.slice(1, it.inner.size - 1), (0, _immutable.List)(), this.context);
	        return enf.enforest('expression');
	      }
	      return new T.TemplateElement({
	        rawValue: it.slice.text
	      });
	    });
	    return elements;
	  }

	  expandMacro() {
	    let lookahead = this.peek();
	    while (this.isCompiletimeTransform(lookahead)) {
	      let name = this.matchRawSyntax();

	      let syntaxTransform = this.getFromCompiletimeEnvironment(name);
	      if (syntaxTransform == null) {
	        throw this.createError(name, `The macro ${ name.resolve(this.context.phase) } does not have a bound value`);
	      } else if (typeof syntaxTransform.value !== 'function') {
	        throw this.createError(name, `The macro ${ name.resolve(this.context.phase) } was not bound to a callable value: ${ syntaxTransform.value }`);
	      }
	      let useSiteScope = (0, _scope.freshScope)('u');
	      let introducedScope = (0, _scope.freshScope)('i');
	      // TODO: needs to be a list of scopes I think
	      this.context.useScope = useSiteScope;

	      let ctx = new _macroContext2.default(this, name, this.context, useSiteScope, introducedScope);

	      let result = (0, _loadSyntax.sanitizeReplacementValues)(syntaxTransform.value.call(null, ctx));
	      if (!_immutable.List.isList(result)) {
	        throw this.createError(name, 'macro must return a list but got: ' + result);
	      }
	      let scopeReducer = new _scopeReducer2.default([{ scope: introducedScope, phase: _syntax.ALL_PHASES, flip: true }], this.context.bindings, true);
	      result = result.map(terms => {
	        if (terms instanceof _syntax2.default) {
	          return new T.RawSyntax({
	            value: terms
	          }).reduce(scopeReducer);
	        } else if (!(terms instanceof T.default)) {
	          throw this.createError(name, 'macro must return syntax objects or terms but got: ' + terms);
	        }
	        return terms.reduce(scopeReducer);
	      });

	      this.rest = result.concat(ctx._rest(this));
	      lookahead = this.peek();
	    }
	  }

	  consumeSemicolon() {
	    let lookahead = this.peek();

	    if (lookahead && this.isPunctuator(lookahead, ';')) {
	      this.advance();
	    }
	  }

	  consumeComma() {
	    let lookahead = this.peek();

	    if (lookahead && this.isPunctuator(lookahead, ',')) {
	      this.advance();
	    }
	  }

	  safeCheck(obj, type, val = null) {
	    if (obj instanceof T.default) {
	      if (obj instanceof T.RawSyntax) {
	        return obj.value && (typeof obj.value.match === 'function' ? obj.value.match(type, val) : false);
	      } else if (obj instanceof T.RawDelimiter) {
	        return type === 'delimiter' || obj.kind === type;
	      }
	    }
	    return obj && (typeof obj.match === 'function' ? obj.match(type, val) : false);
	  }

	  isTerm(term) {
	    return term && term instanceof T.default;
	  }

	  isEOF(obj) {
	    return this.safeCheck(obj, 'eof');
	  }

	  isIdentifier(obj, val = null) {
	    return this.safeCheck(obj, 'identifier', val);
	  }

	  isPropertyName(obj) {
	    return this.isIdentifier(obj) || this.isKeyword(obj) || this.isNumericLiteral(obj) || this.isStringLiteral(obj) || this.isBrackets(obj);
	  }

	  isNumericLiteral(obj, val = null) {
	    return this.safeCheck(obj, 'number', val);
	  }

	  isStringLiteral(obj, val = null) {
	    return this.safeCheck(obj, 'string', val);
	  }

	  isTemplate(obj, val = null) {
	    return this.safeCheck(obj, 'template', val);
	  }

	  isSyntaxTemplate(obj) {
	    return this.safeCheck(obj, 'syntaxTemplate');
	  }

	  isBooleanLiteral(obj, val = null) {
	    return this.safeCheck(obj, 'boolean', val);
	  }

	  isNullLiteral(obj, val = null) {
	    return this.safeCheck(obj, 'null', val);
	  }

	  isRegularExpression(obj, val = null) {
	    return this.safeCheck(obj, 'regularExpression', val);
	  }

	  isDelimiter(obj) {
	    return this.safeCheck(obj, 'delimiter');
	  }

	  isParens(obj) {
	    return this.safeCheck(obj, 'parens');
	  }

	  isBraces(obj) {
	    return this.safeCheck(obj, 'braces');
	  }

	  isBrackets(obj) {
	    return this.safeCheck(obj, 'brackets');
	  }

	  isAssign(obj, val = null) {
	    return this.safeCheck(obj, 'assign', val);
	  }

	  isKeyword(obj, val = null) {
	    return this.safeCheck(obj, 'keyword', val);
	  }

	  isPunctuator(obj, val = null) {
	    return this.safeCheck(obj, 'punctuator', val);
	  }

	  isOperator(obj) {
	    return (this.safeCheck(obj, 'punctuator') || this.safeCheck(obj, 'identifier') || this.safeCheck(obj, 'keyword')) && (obj instanceof T.RawSyntax && (0, _operators.isOperator)(obj.value) || obj instanceof _syntax2.default && (0, _operators.isOperator)(obj));
	  }

	  isUpdateOperator(obj) {
	    return this.safeCheck(obj, 'punctuator', '++') || this.safeCheck(obj, 'punctuator', '--');
	  }

	  safeResolve(obj, phase) {
	    if (obj instanceof T.RawSyntax) {
	      return typeof obj.value.resolve === 'function' ? Just(obj.value.resolve(phase)) : Nothing();
	    } else if (obj instanceof _syntax2.default) {
	      return typeof obj.resolve === 'function' ? Just(obj.resolve(phase)) : Nothing();
	    }
	    return Nothing();
	  }

	  isTransform(obj, trans) {
	    return this.safeResolve(obj, this.context.phase).map(name => this.context.env.get(name) === trans || this.context.store.get(name) === trans).getOrElse(false);
	  }

	  isTransformInstance(obj, trans) {
	    return this.safeResolve(obj, this.context.phase).map(name => this.context.env.get(name) instanceof trans || this.context.store.get(name) instanceof trans).getOrElse(false);
	  }

	  isFnDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.FunctionDeclTransform);
	  }

	  isVarDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.VariableDeclTransform);
	  }

	  isLetDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.LetDeclTransform);
	  }

	  isConstDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.ConstDeclTransform);
	  }

	  isSyntaxDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.SyntaxDeclTransform);
	  }

	  isSyntaxrecDeclTransform(obj) {
	    return this.isTransform(obj, _transforms.SyntaxrecDeclTransform);
	  }

	  isReturnStmtTransform(obj) {
	    return this.isTransform(obj, _transforms.ReturnStatementTransform);
	  }

	  isWhileTransform(obj) {
	    return this.isTransform(obj, _transforms.WhileTransform);
	  }

	  isForTransform(obj) {
	    return this.isTransform(obj, _transforms.ForTransform);
	  }

	  isSwitchTransform(obj) {
	    return this.isTransform(obj, _transforms.SwitchTransform);
	  }

	  isBreakTransform(obj) {
	    return this.isTransform(obj, _transforms.BreakTransform);
	  }

	  isContinueTransform(obj) {
	    return this.isTransform(obj, _transforms.ContinueTransform);
	  }

	  isDoTransform(obj) {
	    return this.isTransform(obj, _transforms.DoTransform);
	  }

	  isDebuggerTransform(obj) {
	    return this.isTransform(obj, _transforms.DebuggerTransform);
	  }

	  isWithTransform(obj) {
	    return this.isTransform(obj, _transforms.WithTransform);
	  }

	  isTryTransform(obj) {
	    return this.isTransform(obj, _transforms.TryTransform);
	  }

	  isThrowTransform(obj) {
	    return this.isTransform(obj, _transforms.ThrowTransform);
	  }

	  isIfTransform(obj) {
	    return this.isTransform(obj, _transforms.IfTransform);
	  }

	  isNewTransform(obj) {
	    return this.isTransform(obj, _transforms.NewTransform);
	  }

	  isCompiletimeTransform(obj) {
	    return this.isTransformInstance(obj, _transforms.CompiletimeTransform);
	  }

	  isVarBindingTransform(obj) {
	    return this.isTransformInstance(obj, _transforms.VarBindingTransform);
	  }

	  getFromCompiletimeEnvironment(term) {
	    if (this.context.env.has(term.resolve(this.context.phase))) {
	      return this.context.env.get(term.resolve(this.context.phase));
	    }
	    return this.context.store.get(term.resolve(this.context.phase));
	  }

	  lineNumberEq(a, b) {
	    if (!(a && b)) {
	      return false;
	    }
	    return getLineNumber(a) === getLineNumber(b);
	  }

	  matchRawDelimiter() {
	    let lookahead = this.advance();
	    if (lookahead instanceof T.RawDelimiter) {
	      return lookahead.inner;
	    }
	    throw this.createError(lookahead, 'expecting a RawDelimiter');
	  }

	  matchRawSyntax() {
	    let lookahead = this.advance();
	    if (lookahead instanceof T.RawSyntax) {
	      return lookahead.value;
	    }
	    throw this.createError(lookahead, 'expecting a RawSyntax');
	  }

	  matchIdentifier(val) {
	    let lookahead = this.peek();
	    if (this.isIdentifier(lookahead, val)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting an identifier');
	  }

	  matchKeyword(val) {
	    let lookahead = this.peek();
	    if (this.isKeyword(lookahead, val)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting ' + val);
	  }

	  matchLiteral() {
	    let lookahead = this.peek();
	    if (this.isNumericLiteral(lookahead) || this.isStringLiteral(lookahead) || this.isBooleanLiteral(lookahead) || this.isNullLiteral(lookahead) || this.isTemplate(lookahead) || this.isRegularExpression(lookahead)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting a literal');
	  }

	  matchStringLiteral() {
	    let lookahead = this.peek();
	    if (this.isStringLiteral(lookahead)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting a string literal');
	  }

	  matchTemplate() {
	    let lookahead = this.peek();
	    if (this.isTemplate(lookahead)) {
	      return this.matchRawSyntax();
	    }
	    throw this.createError(lookahead, 'expecting a template literal');
	  }

	  matchParens() {
	    let lookahead = this.peek();
	    if (this.isParens(lookahead)) {
	      let inner = this.matchRawDelimiter();
	      return inner.slice(1, inner.size - 1);
	    }
	    throw this.createError(lookahead, 'expecting parens');
	  }

	  matchCurlies() {
	    let lookahead = this.peek();
	    if (this.isBraces(lookahead)) {
	      let inner = this.matchRawDelimiter();
	      return inner.slice(1, inner.size - 1);
	    }
	    throw this.createError(lookahead, 'expecting curly braces');
	  }

	  matchSquares() {
	    let lookahead = this.peek();
	    if (this.isBrackets(lookahead)) {
	      let inner = this.matchRawDelimiter();
	      return inner.slice(1, inner.size - 1);
	    }
	    throw this.createError(lookahead, 'expecting square braces');
	  }

	  matchUnaryOperator() {
	    let lookahead = this.matchRawSyntax();
	    if ((0, _operators.isUnaryOperator)(lookahead)) {
	      return lookahead;
	    }
	    throw this.createError(lookahead, 'expecting a unary operator');
	  }

	  matchPunctuator(val) {
	    let lookahead = this.matchRawSyntax();
	    if (this.isPunctuator(lookahead)) {
	      if (typeof val !== 'undefined') {
	        if (lookahead.val() === val) {
	          return lookahead;
	        } else {
	          throw this.createError(lookahead, 'expecting a ' + val + ' punctuator');
	        }
	      }
	      return lookahead;
	    }
	    throw this.createError(lookahead, 'expecting a punctuator');
	  }

	  createError(stx, message) {
	    let ctx = '';
	    let offending = stx;
	    if (this.rest.size > 0) {
	      ctx = this.rest.slice(0, 20).map(term => {
	        if (term instanceof T.RawDelimiter) {
	          return term.inner;
	        }
	        return _immutable.List.of(term);
	      }).flatten().map(s => {
	        let sval = s instanceof T.RawSyntax ? s.value.val() : s.toString();
	        if (s === offending) {
	          return '__' + sval + '__';
	        }
	        return sval;
	      }).join(' ');
	    } else {
	      ctx = offending.toString();
	    }
	    return new Error(message + '\n' + ctx);
	  }
	}
	exports.Enforester = Enforester;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbmZvcmVzdGVyLmpzIl0sIm5hbWVzIjpbIlQiLCJKdXN0IiwiTm90aGluZyIsIkVYUFJfTE9PUF9PUEVSQVRPUiIsIkVYUFJfTE9PUF9OT19DSEFOR0UiLCJFWFBSX0xPT1BfRVhQQU5TSU9OIiwiZ2V0TGluZU51bWJlciIsIngiLCJzdHgiLCJSYXdTeW50YXgiLCJ2YWx1ZSIsIlJhd0RlbGltaXRlciIsImlubmVyIiwiZmlyc3QiLCJFcnJvciIsImxpbmVOdW1iZXIiLCJFbmZvcmVzdGVyIiwiY29uc3RydWN0b3IiLCJzdHhsIiwicHJldiIsImNvbnRleHQiLCJkb25lIiwiaXNMaXN0IiwidGVybSIsInJlc3QiLCJwZWVrIiwibiIsImdldCIsImFkdmFuY2UiLCJyZXQiLCJlbmZvcmVzdCIsInR5cGUiLCJzaXplIiwiaXNFT0YiLCJFT0YiLCJyZXN1bHQiLCJlbmZvcmVzdEV4cHJlc3Npb25Mb29wIiwiZW5mb3Jlc3RNb2R1bGUiLCJlbmZvcmVzdEJvZHkiLCJlbmZvcmVzdE1vZHVsZUl0ZW0iLCJsb29rYWhlYWQiLCJpc0tleXdvcmQiLCJlbmZvcmVzdEltcG9ydERlY2xhcmF0aW9uIiwiZW5mb3Jlc3RFeHBvcnREZWNsYXJhdGlvbiIsImVuZm9yZXN0U3RhdGVtZW50IiwiaXNQdW5jdHVhdG9yIiwibW9kdWxlU3BlY2lmaWVyIiwiZW5mb3Jlc3RGcm9tQ2xhdXNlIiwiRXhwb3J0QWxsRnJvbSIsImlzQnJhY2VzIiwibmFtZWRFeHBvcnRzIiwiZW5mb3Jlc3RFeHBvcnRDbGF1c2UiLCJpc0lkZW50aWZpZXIiLCJFeHBvcnRGcm9tIiwiRXhwb3J0IiwiZGVjbGFyYXRpb24iLCJlbmZvcmVzdENsYXNzIiwiaXNFeHByIiwiaXNGbkRlY2xUcmFuc2Zvcm0iLCJlbmZvcmVzdEZ1bmN0aW9uIiwiRXhwb3J0RGVmYXVsdCIsImJvZHkiLCJpbkRlZmF1bHQiLCJjb25zdW1lU2VtaWNvbG9uIiwiaXNWYXJEZWNsVHJhbnNmb3JtIiwiaXNMZXREZWNsVHJhbnNmb3JtIiwiaXNDb25zdERlY2xUcmFuc2Zvcm0iLCJpc1N5bnRheHJlY0RlY2xUcmFuc2Zvcm0iLCJpc1N5bnRheERlY2xUcmFuc2Zvcm0iLCJlbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRpb24iLCJjcmVhdGVFcnJvciIsImVuZiIsIm1hdGNoQ3VybGllcyIsInB1c2giLCJlbmZvcmVzdEV4cG9ydFNwZWNpZmllciIsImNvbnN1bWVDb21tYSIsIm5hbWUiLCJlbmZvcmVzdElkZW50aWZpZXIiLCJleHBvcnRlZE5hbWUiLCJFeHBvcnRTcGVjaWZpZXIiLCJkZWZhdWx0QmluZGluZyIsIm5hbWVkSW1wb3J0cyIsImZvclN5bnRheCIsImlzU3RyaW5nTGl0ZXJhbCIsIkltcG9ydCIsImVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIiLCJpbXBvcnRzIiwiZW5mb3Jlc3ROYW1lZEltcG9ydHMiLCJmcm9tQ2xhdXNlIiwibmFtZXNwYWNlQmluZGluZyIsImVuZm9yZXN0TmFtZXNwYWNlQmluZGluZyIsIkltcG9ydE5hbWVzcGFjZSIsIm1hdGNoUHVuY3R1YXRvciIsIm1hdGNoSWRlbnRpZmllciIsImVuZm9yZXN0SW1wb3J0U3BlY2lmaWVycyIsIm1hdGNoUmF3U3ludGF4IiwiSW1wb3J0U3BlY2lmaWVyIiwiYmluZGluZyIsIkJpbmRpbmdJZGVudGlmaWVyIiwibWF0Y2hTdHJpbmdMaXRlcmFsIiwiZW5mb3Jlc3RTdGF0ZW1lbnRMaXN0SXRlbSIsImlzQ29tcGlsZXRpbWVUcmFuc2Zvcm0iLCJleHBhbmRNYWNybyIsImlzVGVybSIsIlN0YXRlbWVudCIsImVuZm9yZXN0QmxvY2tTdGF0ZW1lbnQiLCJpc1doaWxlVHJhbnNmb3JtIiwiZW5mb3Jlc3RXaGlsZVN0YXRlbWVudCIsImlzSWZUcmFuc2Zvcm0iLCJlbmZvcmVzdElmU3RhdGVtZW50IiwiaXNGb3JUcmFuc2Zvcm0iLCJlbmZvcmVzdEZvclN0YXRlbWVudCIsImlzU3dpdGNoVHJhbnNmb3JtIiwiZW5mb3Jlc3RTd2l0Y2hTdGF0ZW1lbnQiLCJpc0JyZWFrVHJhbnNmb3JtIiwiZW5mb3Jlc3RCcmVha1N0YXRlbWVudCIsImlzQ29udGludWVUcmFuc2Zvcm0iLCJlbmZvcmVzdENvbnRpbnVlU3RhdGVtZW50IiwiaXNEb1RyYW5zZm9ybSIsImVuZm9yZXN0RG9TdGF0ZW1lbnQiLCJpc0RlYnVnZ2VyVHJhbnNmb3JtIiwiZW5mb3Jlc3REZWJ1Z2dlclN0YXRlbWVudCIsImlzV2l0aFRyYW5zZm9ybSIsImVuZm9yZXN0V2l0aFN0YXRlbWVudCIsImlzVHJ5VHJhbnNmb3JtIiwiZW5mb3Jlc3RUcnlTdGF0ZW1lbnQiLCJpc1Rocm93VHJhbnNmb3JtIiwiZW5mb3Jlc3RUaHJvd1N0YXRlbWVudCIsImVuZm9yZXN0TGFiZWxlZFN0YXRlbWVudCIsInN0bXQiLCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50IiwiaXNSZXR1cm5TdG10VHJhbnNmb3JtIiwiZW5mb3Jlc3RSZXR1cm5TdGF0ZW1lbnQiLCJFbXB0eVN0YXRlbWVudCIsImVuZm9yZXN0RXhwcmVzc2lvblN0YXRlbWVudCIsImxhYmVsIiwiTGFiZWxlZFN0YXRlbWVudCIsIm1hdGNoS2V5d29yZCIsIkJyZWFrU3RhdGVtZW50IiwiZW5mb3Jlc3RCbG9jayIsImNhdGNoQ2xhdXNlIiwiZW5mb3Jlc3RDYXRjaENsYXVzZSIsImZpbmFsaXplciIsIlRyeUZpbmFsbHlTdGF0ZW1lbnQiLCJUcnlDYXRjaFN0YXRlbWVudCIsImJpbmRpbmdQYXJlbnMiLCJtYXRjaFBhcmVucyIsImVuZm9yZXN0QmluZGluZ1RhcmdldCIsIkNhdGNoQ2xhdXNlIiwiZXhwcmVzc2lvbiIsImVuZm9yZXN0RXhwcmVzc2lvbiIsIlRocm93U3RhdGVtZW50Iiwib2JqUGFyZW5zIiwib2JqZWN0IiwiV2l0aFN0YXRlbWVudCIsIkRlYnVnZ2VyU3RhdGVtZW50IiwidGVzdEJvZHkiLCJ0ZXN0IiwiRG9XaGlsZVN0YXRlbWVudCIsImt3ZCIsIkNvbnRpbnVlU3RhdGVtZW50IiwibGluZU51bWJlckVxIiwiY29uZCIsImRpc2NyaW1pbmFudCIsIlN3aXRjaFN0YXRlbWVudCIsImNhc2VzIiwiZW5mb3Jlc3RTd2l0Y2hDYXNlcyIsImRlZmF1bHRDYXNlIiwiZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0IiwicG9zdERlZmF1bHRDYXNlcyIsIlN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0IiwicHJlRGVmYXVsdENhc2VzIiwiZW5mb3Jlc3RTd2l0Y2hDYXNlIiwiU3dpdGNoQ2FzZSIsImNvbnNlcXVlbnQiLCJlbmZvcmVzdFN3aXRjaENhc2VCb2R5IiwiZW5mb3Jlc3RTdGF0ZW1lbnRMaXN0SW5Td2l0Y2hDYXNlQm9keSIsIlN3aXRjaERlZmF1bHQiLCJpbml0IiwicmlnaHQiLCJsZWZ0IiwidXBkYXRlIiwiY25zdCIsIkZvclN0YXRlbWVudCIsIkZvckluU3RhdGVtZW50IiwiRm9yT2ZTdGF0ZW1lbnQiLCJraW5kIiwiYWx0ZXJuYXRlIiwiSWZTdGF0ZW1lbnQiLCJXaGlsZVN0YXRlbWVudCIsIkJsb2NrU3RhdGVtZW50IiwiYmxvY2siLCJCbG9jayIsInN0YXRlbWVudHMiLCJrdyIsInN1cHIiLCJmcm9tSWRlbnRpZmllciIsImVsZW1lbnRzIiwiaXNTdGF0aWMiLCJtZXRob2RPcktleSIsImVuZm9yZXN0TWV0aG9kRGVmaW5pdGlvbiIsInZhbCIsIkNsYXNzRWxlbWVudCIsIm1ldGhvZCIsIkNsYXNzRXhwcmVzc2lvbiIsIkNsYXNzRGVjbGFyYXRpb24iLCJzdXBlciIsImFsbG93UHVuY3R1YXRvciIsImlzQnJhY2tldHMiLCJlbmZvcmVzdEFycmF5QmluZGluZyIsImVuZm9yZXN0T2JqZWN0QmluZGluZyIsInByb3BlcnRpZXMiLCJlbmZvcmVzdEJpbmRpbmdQcm9wZXJ0eSIsIk9iamVjdEJpbmRpbmciLCJlbmZvcmVzdFByb3BlcnR5TmFtZSIsImRlZmF1bHRWYWx1ZSIsImlzQXNzaWduIiwiZXhwciIsIkJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIiLCJlbmZvcmVzdEJpbmRpbmdFbGVtZW50IiwiQmluZGluZ1Byb3BlcnR5UHJvcGVydHkiLCJicmFja2V0IiwibWF0Y2hTcXVhcmVzIiwicmVzdEVsZW1lbnQiLCJlbCIsIkFycmF5QmluZGluZyIsIkJpbmRpbmdXaXRoRGVmYXVsdCIsImVuZm9yZXN0UHVuY3R1YXRvciIsIlJldHVyblN0YXRlbWVudCIsImtpbmRTeW4iLCJwaGFzZSIsImVudiIsInJlc29sdmUiLCJkZWNscyIsImVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdG9yIiwiaXNTeW50YXgiLCJjb25jYXQiLCJWYXJpYWJsZURlY2xhcmF0aW9uIiwiZGVjbGFyYXRvcnMiLCJpZCIsIlZhcmlhYmxlRGVjbGFyYXRvciIsInN0YXJ0IiwiRXhwcmVzc2lvblN0YXRlbWVudCIsIm9wZXJhdG9yIiwiQmluYXJ5RXhwcmVzc2lvbiIsIm9wQ3R4IiwicHJlYyIsImNvbWJpbmUiLCJzdGFjayIsImVuZm9yZXN0QXNzaWdubWVudEV4cHJlc3Npb24iLCJsYXN0IiwicG9wIiwiRXhwcmVzc2lvbiIsImVuZm9yZXN0WWllbGRFeHByZXNzaW9uIiwiaXNQYXJlbnMiLCJlbmZvcmVzdEFycm93RXhwcmVzc2lvbiIsImlzU3ludGF4VGVtcGxhdGUiLCJlbmZvcmVzdFN5bnRheFRlbXBsYXRlIiwiUGFyZW50aGVzaXplZEV4cHJlc3Npb24iLCJpc051bWVyaWNMaXRlcmFsIiwiaXNUZW1wbGF0ZSIsImlzQm9vbGVhbkxpdGVyYWwiLCJpc051bGxMaXRlcmFsIiwiaXNSZWd1bGFyRXhwcmVzc2lvbiIsImVuZm9yZXN0UHJpbWFyeUV4cHJlc3Npb24iLCJpc09wZXJhdG9yIiwiZW5mb3Jlc3RVbmFyeUV4cHJlc3Npb24iLCJpc1ZhckJpbmRpbmdUcmFuc2Zvcm0iLCJsb29rc3R4IiwiZ2V0RnJvbUNvbXBpbGV0aW1lRW52aXJvbm1lbnQiLCJvZiIsImlzTmV3VHJhbnNmb3JtIiwiZW5mb3Jlc3RMZWZ0SGFuZFNpZGVFeHByZXNzaW9uIiwiYWxsb3dDYWxsIiwiZW5mb3Jlc3RUZW1wbGF0ZUxpdGVyYWwiLCJpc1VwZGF0ZU9wZXJhdG9yIiwiZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uIiwiZW5mb3Jlc3RCaW5hcnlFeHByZXNzaW9uIiwidHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyIsIm9wIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJDb21wb3VuZEFzc2lnbm1lbnRFeHByZXNzaW9uIiwiZW5mb3Jlc3RDb25kaXRpb25hbEV4cHJlc3Npb24iLCJlbmZvcmVzdFRoaXNFeHByZXNzaW9uIiwiZW5mb3Jlc3RJZGVudGlmaWVyRXhwcmVzc2lvbiIsImVuZm9yZXN0TnVtZXJpY0xpdGVyYWwiLCJlbmZvcmVzdFN0cmluZ0xpdGVyYWwiLCJlbmZvcmVzdEJvb2xlYW5MaXRlcmFsIiwiZW5mb3Jlc3ROdWxsTGl0ZXJhbCIsImVuZm9yZXN0UmVndWxhckV4cHJlc3Npb25MaXRlcmFsIiwiZW5mb3Jlc3RPYmplY3RFeHByZXNzaW9uIiwiZW5mb3Jlc3RBcnJheUV4cHJlc3Npb24iLCJTdXBlciIsImVuZm9yZXN0TmV3RXhwcmVzc2lvbiIsImVuZm9yZXN0Q2FsbEV4cHJlc3Npb24iLCJlbmZvcmVzdENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiIsImVuZm9yZXN0U3RhdGljTWVtYmVyRXhwcmVzc2lvbiIsIklkZW50aWZpZXJFeHByZXNzaW9uIiwiTGl0ZXJhbEJvb2xlYW5FeHByZXNzaW9uIiwiVGVtcGxhdGVFeHByZXNzaW9uIiwidGFnIiwiZW5mb3Jlc3RUZW1wbGF0ZUVsZW1lbnRzIiwiTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24iLCJudW0iLCJMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uIiwiTGl0ZXJhbE51bWVyaWNFeHByZXNzaW9uIiwicmVTdHgiLCJsYXN0U2xhc2giLCJ0b2tlbiIsImxhc3RJbmRleE9mIiwicGF0dGVybiIsInNsaWNlIiwiZmxhZ3MiLCJMaXRlcmFsUmVnRXhwRXhwcmVzc2lvbiIsIkxpdGVyYWxOdWxsRXhwcmVzc2lvbiIsIlRoaXNFeHByZXNzaW9uIiwiZW5mb3Jlc3RBcmd1bWVudExpc3QiLCJhcmciLCJTcHJlYWRFbGVtZW50IiwiTmV3VGFyZ2V0RXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZ3MiLCJOZXdFeHByZXNzaW9uIiwiYXJndW1lbnRzIiwiQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uIiwidHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0IiwibWFwIiwidCIsInBhcmVuIiwiQ2FsbEV4cHJlc3Npb24iLCJwIiwicGFyYW1zIiwiZW5mb3Jlc3RGb3JtYWxQYXJhbWV0ZXJzIiwiQXJyb3dFeHByZXNzaW9uRSIsIkFycm93RXhwcmVzc2lvbiIsIllpZWxkRXhwcmVzc2lvbiIsImlzR2VuZXJhdG9yIiwiWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uIiwiU3ludGF4VGVtcGxhdGUiLCJ0ZW1wbGF0ZSIsIm1hdGNoUmF3RGVsaW1pdGVyIiwicHJvcGVydHkiLCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uIiwiYXJyIiwiQXJyYXlFeHByZXNzaW9uIiwib2JqIiwibGFzdFByb3AiLCJwcm9wIiwiZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24iLCJPYmplY3RFeHByZXNzaW9uIiwiU2hvcnRoYW5kUHJvcGVydHkiLCJEYXRhUHJvcGVydHkiLCJpc1Byb3BlcnR5TmFtZSIsIkdldHRlciIsInBhcmFtIiwiU2V0dGVyIiwiZm9ybWFsUGFyYW1zIiwiTWV0aG9kIiwiU3RhdGljUHJvcGVydHlOYW1lIiwiQ29tcHV0ZWRQcm9wZXJ0eU5hbWUiLCJmbktleXdvcmQiLCJGdW5jdGlvbkV4cHJlc3Npb25FIiwiRnVuY3Rpb25EZWNsYXJhdGlvbkUiLCJpdGVtcyIsImVuZm9yZXN0UGFyYW0iLCJGb3JtYWxQYXJhbWV0ZXJzIiwibWF0Y2hVbmFyeU9wZXJhdG9yIiwiVXBkYXRlRXhwcmVzc2lvbiIsImlzUHJlZml4Iiwib3BlcmFuZCIsInJpZ2h0VGVybSIsIlVuYXJ5RXhwcmVzc2lvbiIsIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImxlZnRUZXJtIiwib3BTdHgiLCJtYXRjaFRlbXBsYXRlIiwiaXQiLCJpc0RlbGltaXRlciIsIlRlbXBsYXRlRWxlbWVudCIsInJhd1ZhbHVlIiwidGV4dCIsInN5bnRheFRyYW5zZm9ybSIsInVzZVNpdGVTY29wZSIsImludHJvZHVjZWRTY29wZSIsInVzZVNjb3BlIiwiY3R4IiwiY2FsbCIsInNjb3BlUmVkdWNlciIsInNjb3BlIiwiZmxpcCIsImJpbmRpbmdzIiwidGVybXMiLCJyZWR1Y2UiLCJfcmVzdCIsInNhZmVDaGVjayIsIm1hdGNoIiwic2FmZVJlc29sdmUiLCJpc1RyYW5zZm9ybSIsInRyYW5zIiwic3RvcmUiLCJnZXRPckVsc2UiLCJpc1RyYW5zZm9ybUluc3RhbmNlIiwiaGFzIiwiYSIsImIiLCJtYXRjaExpdGVyYWwiLCJtZXNzYWdlIiwib2ZmZW5kaW5nIiwiZmxhdHRlbiIsInMiLCJzdmFsIiwidG9TdHJpbmciLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0lBQWtCQSxDOztBQUNsQjs7QUFDQTs7OztBQUlBOztBQXVCQTs7QUFDQTs7QUFDQTs7QUFPQTs7OztBQUdBOztBQUNBOztBQUVBOzs7Ozs7OztBQXpDQSxNQUFNQyxPQUFPLG9CQUFNQSxJQUFuQjtBQUNBLE1BQU1DLFVBQVUsb0JBQU1BLE9BQXRCOztBQTBDQSxNQUFNQyxxQkFBcUIsRUFBM0I7QUFDQSxNQUFNQyxzQkFBc0IsRUFBNUI7QUFDQSxNQUFNQyxzQkFBc0IsRUFBNUI7O0FBRUEsU0FBU0MsYUFBVCxDQUF1QkMsQ0FBdkIsRUFBMkM7QUFDekMsTUFBSUMsR0FBSjtBQUNBLE1BQUlELDZCQUFKLEVBQXlCO0FBQ3ZCQyxVQUFNRCxDQUFOO0FBQ0QsR0FGRCxNQUVPLElBQUlBLGFBQWFQLEVBQUVTLFNBQW5CLEVBQThCO0FBQ25DRCxVQUFNRCxFQUFFRyxLQUFSO0FBQ0QsR0FGTSxNQUVBLElBQUlILGFBQWFQLEVBQUVXLFlBQW5CLEVBQWlDO0FBQ3RDLFdBQU9MLGNBQWNDLEVBQUVLLEtBQUYsQ0FBUUMsS0FBUixFQUFkLENBQVA7QUFDRCxHQUZNLE1BRUE7QUFDTCxVQUFNLElBQUlD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O0FBQ3BCLFlBQUlDLE9BQU9ELGFBQWF6WixFQUFFUyxTQUFmLEdBQTJCZ1osRUFBRS9ZLEtBQUYsQ0FBUStMLEdBQVIsRUFBM0IsR0FBMkNnTixFQUFFRSxRQUFGLEVBQXREO0FBQ0EsWUFBSUYsTUFBTUYsU0FBVixFQUFxQjtBQUNuQixpQkFBTyxPQUFPRyxJQUFQLEdBQWMsSUFBckI7QUFDRDtBQUNELGVBQU9BLElBQVA7QUFDRCxPQVhLLEVBV0hFLElBWEcsQ0FXRSxHQVhGLENBQU47QUFZRCxLQWJELE1BYU87QUFDTDNCLFlBQU1zQixVQUFVSSxRQUFWLEVBQU47QUFDRDtBQUNELFdBQU8sSUFBSTdZLEtBQUosQ0FBVXdZLFVBQVUsSUFBVixHQUFpQnJCLEdBQTNCLENBQVA7QUFFRDtBQWxwRXFCO1FBQVhqWCxVLEdBQUFBLFUiLCJmaWxlIjoiZW5mb3Jlc3Rlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBpc0lkZW50aWZpZXJFeHByZXNzaW9uLCBpc1N0YXRpY01lbWJlckV4cHJlc3Npb24sIGlzQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uIH0gZnJvbSAnLi90ZXJtcyc7XG5pbXBvcnQgVGVybSwgKiBhcyBUIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0IHsgTWF5YmUgfSBmcm9tICdyYW1kYS1mYW50YXN5JztcbmltcG9ydCBTY29wZVJlZHVjZXIgZnJvbSAnLi9zY29wZS1yZWR1Y2VyJztcbmNvbnN0IEp1c3QgPSBNYXliZS5KdXN0O1xuY29uc3QgTm90aGluZyA9IE1heWJlLk5vdGhpbmc7XG5cbmltcG9ydCB7XG4gIEZ1bmN0aW9uRGVjbFRyYW5zZm9ybSxcbiAgVmFyaWFibGVEZWNsVHJhbnNmb3JtLFxuICBOZXdUcmFuc2Zvcm0sXG4gIExldERlY2xUcmFuc2Zvcm0sXG4gIENvbnN0RGVjbFRyYW5zZm9ybSxcbiAgU3ludGF4RGVjbFRyYW5zZm9ybSxcbiAgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSxcbiAgUmV0dXJuU3RhdGVtZW50VHJhbnNmb3JtLFxuICBXaGlsZVRyYW5zZm9ybSxcbiAgSWZUcmFuc2Zvcm0sXG4gIEZvclRyYW5zZm9ybSxcbiAgU3dpdGNoVHJhbnNmb3JtLFxuICBCcmVha1RyYW5zZm9ybSxcbiAgQ29udGludWVUcmFuc2Zvcm0sXG4gIERvVHJhbnNmb3JtLFxuICBEZWJ1Z2dlclRyYW5zZm9ybSxcbiAgV2l0aFRyYW5zZm9ybSxcbiAgVHJ5VHJhbnNmb3JtLFxuICBUaHJvd1RyYW5zZm9ybSxcbiAgQ29tcGlsZXRpbWVUcmFuc2Zvcm0sXG4gIFZhckJpbmRpbmdUcmFuc2Zvcm1cbn0gZnJvbSAnLi90cmFuc2Zvcm1zJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgZXhwZWN0LCBhc3NlcnQgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge1xuICBpc09wZXJhdG9yLFxuICBpc1VuYXJ5T3BlcmF0b3IsXG4gIGdldE9wZXJhdG9yQXNzb2MsXG4gIGdldE9wZXJhdG9yUHJlYyxcbiAgb3BlcmF0b3JMdFxufSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQgU3ludGF4LCB7IEFMTF9QSEFTRVMgfSBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgdHlwZSB7IFN5bWJvbENsYXNzIH0gZnJvbSAnLi9zeW1ib2wnO1xuXG5pbXBvcnQgeyBmcmVzaFNjb3BlIH0gZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgeyBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzIH0gZnJvbSAnLi9sb2FkLXN5bnRheCc7XG5cbmltcG9ydCBNYWNyb0NvbnRleHQgZnJvbSAnLi9tYWNyby1jb250ZXh0JztcblxuY29uc3QgRVhQUl9MT09QX09QRVJBVE9SID0ge307XG5jb25zdCBFWFBSX0xPT1BfTk9fQ0hBTkdFID0ge307XG5jb25zdCBFWFBSX0xPT1BfRVhQQU5TSU9OID0ge307XG5cbmZ1bmN0aW9uIGdldExpbmVOdW1iZXIoeDogU3ludGF4IHwgVC5UZXJtKSB7XG4gIGxldCBzdHg7XG4gIGlmICh4IGluc3RhbmNlb2YgU3ludGF4KSB7XG4gICAgc3R4ID0geDtcbiAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgVC5SYXdTeW50YXgpIHtcbiAgICBzdHggPSB4LnZhbHVlO1xuICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBULlJhd0RlbGltaXRlcikge1xuICAgIHJldHVybiBnZXRMaW5lTnVtYmVyKHguaW5uZXIuZmlyc3QoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgeWV0ICR7eH1gKTtcbiAgfVxuICByZXR1cm4gc3R4LmxpbmVOdW1iZXIoKTtcbn1cblxuZXhwb3J0IGNsYXNzIEVuZm9yZXN0ZXIge1xuICBkb25lOiBib29sZWFuO1xuICB0ZXJtOiA/VGVybTtcbiAgcmVzdDogTGlzdDxUZXJtPjtcbiAgcHJldjogTGlzdDxUZXJtPjtcbiAgY29udGV4dDoge1xuICAgIGVudjogTWFwPHN0cmluZywgYW55PjtcbiAgICBzdG9yZTogTWFwPHN0cmluZywgYW55PjtcbiAgICBwaGFzZTogbnVtYmVyIHwge307XG4gICAgdXNlU2NvcGU6IFN5bWJvbENsYXNzO1xuICAgIGJpbmRpbmdzOiBhbnk7XG4gIH07XG4gIG9wQ3R4OiB7XG4gICAgcHJlYzogbnVtYmVyLFxuICAgIGNvbWJpbmU6ICh4OiBhbnkpID0+IGFueSxcbiAgICBzdGFjazogTGlzdDwqPlxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHN0eGw6IExpc3Q8VGVybT4sIHByZXY6IExpc3Q8VGVybT4sIGNvbnRleHQ6IGFueSkge1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIGFzc2VydChMaXN0LmlzTGlzdChzdHhsKSwgJ2V4cGVjdGluZyBhIGxpc3Qgb2YgdGVybXMgdG8gZW5mb3Jlc3QnKTtcbiAgICBhc3NlcnQoTGlzdC5pc0xpc3QocHJldiksICdleHBlY3RpbmcgYSBsaXN0IG9mIHRlcm1zIHRvIGVuZm9yZXN0Jyk7XG4gICAgYXNzZXJ0KGNvbnRleHQsICdleHBlY3RpbmcgYSBjb250ZXh0IHRvIGVuZm9yZXN0Jyk7XG4gICAgdGhpcy50ZXJtID0gbnVsbDtcblxuICAgIHRoaXMucmVzdCA9IHN0eGw7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBwZWVrKG46IG51bWJlciA9IDApOiA/VGVybSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdC5nZXQobik7XG4gIH1cblxuICBhZHZhbmNlKCkge1xuICAgIGxldCByZXQ6ID9UZXJtID0gdGhpcy5yZXN0LmZpcnN0KCk7XG4gICAgdGhpcy5yZXN0ID0gdGhpcy5yZXN0LnJlc3QoKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLypcbiAgIGVuZm9yZXN0IHdvcmtzIG92ZXI6XG4gICBwcmV2IC0gYSBsaXN0IG9mIHRoZSBwcmV2aW91c2x5IGVuZm9yZXN0IFRlcm1zXG4gICB0ZXJtIC0gdGhlIGN1cnJlbnQgdGVybSBiZWluZyBlbmZvcmVzdGVkIChpbml0aWFsbHkgbnVsbClcbiAgIHJlc3QgLSByZW1haW5pbmcgVGVybXMgdG8gZW5mb3Jlc3RcbiAgICovXG4gIGVuZm9yZXN0KHR5cGU/OiAnZXhwcmVzc2lvbicgfCAnTW9kdWxlJyA9ICdNb2R1bGUnKSB7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgdGVybVxuICAgIHRoaXMudGVybSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5yZXN0LnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy50ZXJtO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRU9GKHRoaXMucGVlaygpKSkge1xuICAgICAgdGhpcy50ZXJtID0gbmV3IFQuRU9GKHt9KTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudGVybTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlID09PSAnZXhwcmVzc2lvbicpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmVuZm9yZXN0TW9kdWxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVzdC5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZW5mb3Jlc3RNb2R1bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCb2R5KCk7XG4gIH1cblxuICBlbmZvcmVzdEJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RNb2R1bGVJdGVtKCk7XG4gIH1cblxuICBlbmZvcmVzdE1vZHVsZUl0ZW0oKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWQsICdpbXBvcnQnKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChsb29rYWhlYWQsICdleHBvcnQnKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEV4cG9ydERlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gIH1cblxuICBlbmZvcmVzdEV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnKicpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBtb2R1bGVTcGVjaWZpZXIgPSB0aGlzLmVuZm9yZXN0RnJvbUNsYXVzZSgpO1xuICAgICAgcmV0dXJuIG5ldyBULkV4cG9ydEFsbEZyb20oeyBtb2R1bGVTcGVjaWZpZXIgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZCkpIHtcbiAgICAgIGxldCBuYW1lZEV4cG9ydHMgPSB0aGlzLmVuZm9yZXN0RXhwb3J0Q2xhdXNlKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgJ2Zyb20nKSkge1xuICAgICAgICBtb2R1bGVTcGVjaWZpZXIgPSB0aGlzLmVuZm9yZXN0RnJvbUNsYXVzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBULkV4cG9ydEZyb20oeyBuYW1lZEV4cG9ydHMsIG1vZHVsZVNwZWNpZmllciB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBuZXcgVC5FeHBvcnQoe1xuICAgICAgICBkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdENsYXNzKHsgaXNFeHByOiBmYWxzZSB9KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiBuZXcgVC5FeHBvcnQoe1xuICAgICAgICBkZWNsYXJhdGlvbjogdGhpcy5lbmZvcmVzdEZ1bmN0aW9uKHtpc0V4cHI6IGZhbHNlfSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnZGVmYXVsdCcpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKHRoaXMucGVlaygpKSkge1xuICAgICAgICByZXR1cm4gbmV3IFQuRXhwb3J0RGVmYXVsdCh7XG4gICAgICAgICAgYm9keTogdGhpcy5lbmZvcmVzdEZ1bmN0aW9uKHtpc0V4cHI6IGZhbHNlLCBpbkRlZmF1bHQ6IHRydWV9KVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksICdjbGFzcycpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVC5FeHBvcnREZWZhdWx0KHtcbiAgICAgICAgICBib2R5OiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogZmFsc2UsIGluRGVmYXVsdDogdHJ1ZX0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJvZHkgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBuZXcgVC5FeHBvcnREZWZhdWx0KHsgYm9keSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWYXJEZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc0xldERlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSB8fFxuICAgICAgICB0aGlzLmlzQ29uc3REZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc1N5bnRheHJlY0RlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSB8fFxuICAgICAgICB0aGlzLmlzU3ludGF4RGVjbFRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gbmV3IFQuRXhwb3J0KHtcbiAgICAgICAgZGVjbGFyYXRpb246IHRoaXMuZW5mb3Jlc3RWYXJpYWJsZURlY2xhcmF0aW9uKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ3VuZXhwZWN0ZWQgc3ludGF4Jyk7XG4gIH1cblxuICBlbmZvcmVzdEV4cG9ydENsYXVzZSgpIHtcbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoZW5mLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goZW5mLmVuZm9yZXN0RXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgZW5mLmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHQpO1xuICB9XG5cbiAgZW5mb3Jlc3RFeHBvcnRTcGVjaWZpZXIoKSB7XG4gICAgbGV0IG5hbWUgPSB0aGlzLmVuZm9yZXN0SWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSwgJ2FzJykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IGV4cG9ydGVkTmFtZSA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gbmV3IFQuRXhwb3J0U3BlY2lmaWVyKHsgbmFtZSwgZXhwb3J0ZWROYW1lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQuRXhwb3J0U3BlY2lmaWVyKHtcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBleHBvcnRlZE5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0SW1wb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIGxldCBkZWZhdWx0QmluZGluZyA9IG51bGw7XG4gICAgbGV0IG5hbWVkSW1wb3J0cyA9IExpc3QoKTtcbiAgICBsZXQgZm9yU3ludGF4ID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc1N0cmluZ0xpdGVyYWwobG9va2FoZWFkKSkge1xuICAgICAgbGV0IG1vZHVsZVNwZWNpZmllciA9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbmV3IFQuSW1wb3J0KHtcbiAgICAgICAgZGVmYXVsdEJpbmRpbmcsXG4gICAgICAgIG5hbWVkSW1wb3J0cyxcbiAgICAgICAgbW9kdWxlU3BlY2lmaWVyLFxuICAgICAgICBmb3JTeW50YXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCkpIHtcbiAgICAgIGRlZmF1bHRCaW5kaW5nID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgICBpZiAoIXRoaXMuaXNQdW5jdHVhdG9yKHRoaXMucGVlaygpLCAnLCcpKSB7XG4gICAgICAgIGxldCBtb2R1bGVTcGVjaWZpZXIgPSB0aGlzLmVuZm9yZXN0RnJvbUNsYXVzZSgpO1xuICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksICdmb3InKSAmJiB0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoMSksICdzeW50YXgnKSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIGZvclN5bnRheCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFQuSW1wb3J0KHtcbiAgICAgICAgICBkZWZhdWx0QmluZGluZywgbW9kdWxlU3BlY2lmaWVyLFxuICAgICAgICAgIG5hbWVkSW1wb3J0czogTGlzdCgpLFxuICAgICAgICAgIGZvclN5bnRheFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdW1lQ29tbWEoKTtcbiAgICBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNlcyhsb29rYWhlYWQpKSB7XG4gICAgICBsZXQgaW1wb3J0cyA9IHRoaXMuZW5mb3Jlc3ROYW1lZEltcG9ydHMoKTtcbiAgICAgIGxldCBmcm9tQ2xhdXNlID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgJ2ZvcicpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgJ3N5bnRheCcpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgZm9yU3ludGF4ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBULkltcG9ydCh7XG4gICAgICAgIGRlZmF1bHRCaW5kaW5nLFxuICAgICAgICBmb3JTeW50YXgsXG4gICAgICAgIG5hbWVkSW1wb3J0czogaW1wb3J0cyxcbiAgICAgICAgbW9kdWxlU3BlY2lmaWVyOiBmcm9tQ2xhdXNlXG5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnKicpKSB7XG4gICAgICBsZXQgbmFtZXNwYWNlQmluZGluZyA9IHRoaXMuZW5mb3Jlc3ROYW1lc3BhY2VCaW5kaW5nKCk7XG4gICAgICBsZXQgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5lbmZvcmVzdEZyb21DbGF1c2UoKTtcbiAgICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgJ2ZvcicpICYmIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSwgJ3N5bnRheCcpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgZm9yU3ludGF4ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVC5JbXBvcnROYW1lc3BhY2Uoe1xuICAgICAgICBkZWZhdWx0QmluZGluZywgZm9yU3ludGF4LCBuYW1lc3BhY2VCaW5kaW5nLCBtb2R1bGVTcGVjaWZpZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ3VuZXhwZWN0ZWQgc3ludGF4Jyk7XG4gIH1cblxuICBlbmZvcmVzdE5hbWVzcGFjZUJpbmRpbmcoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoJyonKTtcbiAgICB0aGlzLm1hdGNoSWRlbnRpZmllcignYXMnKTtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gIH1cblxuICBlbmZvcmVzdE5hbWVkSW1wb3J0cygpIHtcbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIodGhpcy5tYXRjaEN1cmxpZXMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoZW5mLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goZW5mLmVuZm9yZXN0SW1wb3J0U3BlY2lmaWVycygpKTtcbiAgICAgIGVuZi5jb25zdW1lQ29tbWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIExpc3QocmVzdWx0KTtcbiAgfVxuXG4gIGVuZm9yZXN0SW1wb3J0U3BlY2lmaWVycygpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZCkgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkKSkge1xuICAgICAgbmFtZSA9IHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcbiAgICAgIGlmICghdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCksICdhcycpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVC5JbXBvcnRTcGVjaWZpZXIoe1xuICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgYmluZGluZzogbmV3IFQuQmluZGluZ0lkZW50aWZpZXIoe1xuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRjaElkZW50aWZpZXIoJ2FzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAndW5leHBlY3RlZCB0b2tlbiBpbiBpbXBvcnQgc3BlY2lmaWVyJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVC5JbXBvcnRTcGVjaWZpZXIoe1xuICAgICAgbmFtZSwgYmluZGluZzogdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0RnJvbUNsYXVzZSgpIHtcbiAgICB0aGlzLm1hdGNoSWRlbnRpZmllcignZnJvbScpO1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLm1hdGNoU3RyaW5nTGl0ZXJhbCgpO1xuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBsb29rYWhlYWQ7XG4gIH1cblxuICBlbmZvcmVzdFN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcblxuICAgIGlmICh0aGlzLmlzRm5EZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RnVuY3Rpb24oeyBpc0V4cHI6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDbGFzcyh7IGlzRXhwcjogZmFsc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgfVxuICB9XG5cbiAgZW5mb3Jlc3RTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQ29tcGlsZXRpbWVUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgdGhpcy5leHBhbmRNYWNybygpO1xuICAgICAgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVGVybShsb29rYWhlYWQpICYmIGxvb2thaGVhZCBpbnN0YW5jZW9mIFQuU3RhdGVtZW50KSB7XG4gICAgICAvLyBUT0RPOiBjaGVjayB0aGF0IHRoaXMgaXMgYWN0dWFsbHkgYW4gc3RhdGVtZW50XG4gICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQnJhY2VzKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QmxvY2tTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNXaGlsZVRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFdoaWxlU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzSWZUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RJZlN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNGb3JUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RGb3JTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3dpdGNoVHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0U3dpdGNoU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyZWFrVHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QnJlYWtTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQ29udGludWVUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb250aW51ZVN0YXRlbWVudCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNEb1RyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdERvU3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0RlYnVnZ2VyVHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0RGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzV2l0aFRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFdpdGhTdGF0ZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVHJ5VHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VHJ5U3RhdGVtZW50KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1Rocm93VHJhbnNmb3JtKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VGhyb3dTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBwdXQgc29tZXdoZXJlIGVsc2VcbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2NsYXNzJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogZmFsc2V9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNGbkRlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RGdW5jdGlvbih7aXNFeHByOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkKSAmJlxuICAgICAgICB0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoMSksICc6JykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TGFiZWxlZFN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiZcbiAgICAgICAgKHRoaXMuaXNWYXJEZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgIHRoaXMuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgIHRoaXMuaXNDb25zdERlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSB8fFxuICAgICAgICAgdGhpcy5pc1N5bnRheHJlY0RlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSB8fFxuICAgICAgICAgdGhpcy5pc1N5bnRheERlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSkpIHtcbiAgICAgIGxldCBzdG10ID0gbmV3IFQuVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCh7XG4gICAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzUmV0dXJuU3RtdFRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFJldHVyblN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnOycpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiBuZXcgVC5FbXB0eVN0YXRlbWVudCh7fSk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcbiAgfVxuXG4gIGVuZm9yZXN0TGFiZWxlZFN0YXRlbWVudCgpIHtcbiAgICBsZXQgbGFiZWwgPSB0aGlzLm1hdGNoSWRlbnRpZmllcigpO1xuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKCc6Jyk7XG4gICAgbGV0IHN0bXQgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG5cbiAgICByZXR1cm4gbmV3IFQuTGFiZWxlZFN0YXRlbWVudCh7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBib2R5OiBzdG10XG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdEJyZWFrU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdicmVhaycpO1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgbGFiZWwgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICc7JykpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5ldyBULkJyZWFrU3RhdGVtZW50KHsgbGFiZWwgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3lpZWxkJykgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnbGV0JykpIHtcbiAgICAgIGxhYmVsID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICByZXR1cm4gbmV3IFQuQnJlYWtTdGF0ZW1lbnQoeyBsYWJlbCB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0VHJ5U3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCd0cnknKTtcbiAgICBsZXQgYm9keSA9IHRoaXMuZW5mb3Jlc3RCbG9jaygpO1xuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgJ2NhdGNoJykpIHtcbiAgICAgIGxldCBjYXRjaENsYXVzZSA9IHRoaXMuZW5mb3Jlc3RDYXRjaENsYXVzZSgpO1xuICAgICAgaWYgKHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCAnZmluYWxseScpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBsZXQgZmluYWxpemVyID0gdGhpcy5lbmZvcmVzdEJsb2NrKCk7XG4gICAgICAgIHJldHVybiBuZXcgVC5UcnlGaW5hbGx5U3RhdGVtZW50KHtcbiAgICAgICAgICBib2R5LCBjYXRjaENsYXVzZSwgZmluYWxpemVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBULlRyeUNhdGNoU3RhdGVtZW50KHsgYm9keSwgY2F0Y2hDbGF1c2UgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgJ2ZpbmFsbHknKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgZmluYWxpemVyID0gdGhpcy5lbmZvcmVzdEJsb2NrKCk7XG4gICAgICByZXR1cm4gbmV3IFQuVHJ5RmluYWxseVN0YXRlbWVudCh7IGJvZHksIGNhdGNoQ2xhdXNlOiBudWxsLCBmaW5hbGl6ZXIgfSk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IodGhpcy5wZWVrKCksICd0cnkgd2l0aCBubyBjYXRjaCBvciBmaW5hbGx5Jyk7XG4gIH1cblxuICBlbmZvcmVzdENhdGNoQ2xhdXNlKCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdjYXRjaCcpO1xuICAgIGxldCBiaW5kaW5nUGFyZW5zID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3RlcihiaW5kaW5nUGFyZW5zLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGJpbmRpbmcgPSBlbmYuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgbGV0IGJvZHkgPSB0aGlzLmVuZm9yZXN0QmxvY2soKTtcbiAgICByZXR1cm4gbmV3IFQuQ2F0Y2hDbGF1c2UoeyBiaW5kaW5nLCBib2R5IH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RUaHJvd1N0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZCgndGhyb3cnKTtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIG5ldyBULlRocm93U3RhdGVtZW50KHsgZXhwcmVzc2lvbiB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0V2l0aFN0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZCgnd2l0aCcpO1xuICAgIGxldCBvYmpQYXJlbnMgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKG9ialBhcmVucywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBvYmplY3QgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgbGV0IGJvZHkgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIG5ldyBULldpdGhTdGF0ZW1lbnQoeyBvYmplY3QsIGJvZHkgfSk7XG4gIH1cblxuICBlbmZvcmVzdERlYnVnZ2VyU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWJ1Z2dlcicpO1xuXG4gICAgcmV0dXJuIG5ldyBULkRlYnVnZ2VyU3RhdGVtZW50KHt9KTtcbiAgfVxuXG4gIGVuZm9yZXN0RG9TdGF0ZW1lbnQoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoJ2RvJyk7XG4gICAgbGV0IGJvZHkgPSB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KCk7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoJ3doaWxlJyk7XG4gICAgbGV0IHRlc3RCb2R5ID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcih0ZXN0Qm9keSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCB0ZXN0ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVC5Eb1doaWxlU3RhdGVtZW50KHsgYm9keSwgdGVzdCB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0Q29udGludWVTdGF0ZW1lbnQoKSB7XG4gICAgbGV0IGt3ZCA9IHRoaXMubWF0Y2hLZXl3b3JkKCdjb250aW51ZScpO1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQgbGFiZWwgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3Quc2l6ZSA9PT0gMCB8fCB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICc7JykpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5ldyBULkNvbnRpbnVlU3RhdGVtZW50KHsgbGFiZWwgfSk7XG4gICAgfVxuICAgIGlmICgobG9va2FoZWFkIGluc3RhbmNlb2YgVC5SYXdTeW50YXggJiYgdGhpcy5saW5lTnVtYmVyRXEoa3dkLCBsb29rYWhlYWQpKSAmJlxuICAgICAgICAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkKSB8fFxuICAgICAgICAgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAneWllbGQnKSB8fFxuICAgICAgICAgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnbGV0JykpKSB7XG4gICAgICBsYWJlbCA9IHRoaXMuZW5mb3Jlc3RJZGVudGlmaWVyKCk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgcmV0dXJuIG5ldyBULkNvbnRpbnVlU3RhdGVtZW50KHsgbGFiZWwgfSk7XG4gIH1cblxuICBlbmZvcmVzdFN3aXRjaFN0YXRlbWVudCgpIHtcbiAgICB0aGlzLm1hdGNoS2V5d29yZCgnc3dpdGNoJyk7XG4gICAgbGV0IGNvbmQgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKGNvbmQsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgZGlzY3JpbWluYW50ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgIGxldCBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcblxuICAgIGlmIChib2R5LnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVC5Td2l0Y2hTdGF0ZW1lbnQoe1xuICAgICAgICBkaXNjcmltaW5hbnQ6IGRpc2NyaW1pbmFudCxcbiAgICAgICAgY2FzZXM6IExpc3QoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVuZiA9IG5ldyBFbmZvcmVzdGVyKGJvZHksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgY2FzZXMgPSBlbmYuZW5mb3Jlc3RTd2l0Y2hDYXNlcygpO1xuICAgIGxldCBsb29rYWhlYWQgPSBlbmYucGVlaygpO1xuICAgIGlmIChlbmYuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2RlZmF1bHQnKSkge1xuICAgICAgbGV0IGRlZmF1bHRDYXNlID0gZW5mLmVuZm9yZXN0U3dpdGNoRGVmYXVsdCgpO1xuICAgICAgbGV0IHBvc3REZWZhdWx0Q2FzZXMgPSBlbmYuZW5mb3Jlc3RTd2l0Y2hDYXNlcygpO1xuICAgICAgcmV0dXJuIG5ldyBULlN3aXRjaFN0YXRlbWVudFdpdGhEZWZhdWx0KHtcbiAgICAgICAgZGlzY3JpbWluYW50LFxuICAgICAgICBwcmVEZWZhdWx0Q2FzZXM6IGNhc2VzLFxuICAgICAgICBkZWZhdWx0Q2FzZSxcbiAgICAgICAgcG9zdERlZmF1bHRDYXNlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVC5Td2l0Y2hTdGF0ZW1lbnQoeyAgZGlzY3JpbWluYW50LCBjYXNlcyB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0U3dpdGNoQ2FzZXMoKSB7XG4gICAgbGV0IGNhc2VzID0gW107XG4gICAgd2hpbGUgKCEodGhpcy5yZXN0LnNpemUgPT09IDAgfHwgdGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksICdkZWZhdWx0JykpKSB7XG4gICAgICBjYXNlcy5wdXNoKHRoaXMuZW5mb3Jlc3RTd2l0Y2hDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChjYXNlcyk7XG4gIH1cblxuICBlbmZvcmVzdFN3aXRjaENhc2UoKSB7XG4gICAgdGhpcy5tYXRjaEtleXdvcmQoJ2Nhc2UnKTtcbiAgICByZXR1cm4gbmV3IFQuU3dpdGNoQ2FzZSh7XG4gICAgICB0ZXN0OiB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbigpLFxuICAgICAgY29uc2VxdWVudDogdGhpcy5lbmZvcmVzdFN3aXRjaENhc2VCb2R5KClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0U3dpdGNoQ2FzZUJvZHkoKSB7XG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoJzonKTtcbiAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFN0YXRlbWVudExpc3RJblN3aXRjaENhc2VCb2R5KCk7XG4gIH1cblxuICBlbmZvcmVzdFN0YXRlbWVudExpc3RJblN3aXRjaENhc2VCb2R5KCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSghKHRoaXMucmVzdC5zaXplID09PSAwIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCAnZGVmYXVsdCcpIHx8IHRoaXMuaXNLZXl3b3JkKHRoaXMucGVlaygpLCAnY2FzZScpKSkge1xuICAgICAgcmVzdWx0LnB1c2godGhpcy5lbmZvcmVzdFN0YXRlbWVudExpc3RJdGVtKCkpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHQpO1xuICB9XG5cbiAgZW5mb3Jlc3RTd2l0Y2hEZWZhdWx0KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XG4gICAgcmV0dXJuIG5ldyBULlN3aXRjaERlZmF1bHQoe1xuICAgICAgY29uc2VxdWVudDogdGhpcy5lbmZvcmVzdFN3aXRjaENhc2VCb2R5KClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0Rm9yU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdmb3InKTtcbiAgICBsZXQgY29uZCA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIoY29uZCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBsb29rYWhlYWQsIHRlc3QsIGluaXQsIHJpZ2h0LCBsZWZ0LCB1cGRhdGUsIGNuc3Q7XG5cbiAgICAvLyBjYXNlIHdoZXJlIGluaXQgaXMgbnVsbFxuICAgIGlmIChlbmYuaXNQdW5jdHVhdG9yKGVuZi5wZWVrKCksICc7JykpIHtcbiAgICAgIGVuZi5hZHZhbmNlKCk7XG4gICAgICBpZiAoIWVuZi5pc1B1bmN0dWF0b3IoZW5mLnBlZWsoKSwgJzsnKSkge1xuICAgICAgICB0ZXN0ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgICAgZW5mLm1hdGNoUHVuY3R1YXRvcignOycpO1xuICAgICAgaWYgKGVuZi5yZXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgcmlnaHQgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFQuRm9yU3RhdGVtZW50KHtcbiAgICAgICAgaW5pdDogbnVsbCxcbiAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgdXBkYXRlOiByaWdodCxcbiAgICAgICAgYm9keTogdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpXG4gICAgICB9KTtcbiAgICAvLyBjYXNlIHdoZXJlIGluaXQgaXMgbm90IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVzdGluZ1xuICAgICAgbG9va2FoZWFkID0gZW5mLnBlZWsoKTtcbiAgICAgIGlmIChlbmYuaXNWYXJEZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgICBlbmYuaXNMZXREZWNsVHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgICBlbmYuaXNDb25zdERlY2xUcmFuc2Zvcm0obG9va2FoZWFkKSkge1xuICAgICAgICBpbml0ID0gZW5mLmVuZm9yZXN0VmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICBsb29rYWhlYWQgPSBlbmYucGVlaygpO1xuICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnaW4nKSB8fCB0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQsICdvZicpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2luJykpIHtcbiAgICAgICAgICAgIGVuZi5hZHZhbmNlKCk7XG4gICAgICAgICAgICByaWdodCA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIGNuc3QgPSBULkZvckluU3RhdGVtZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkLCAnb2YnKSwgJ2V4cGVjdGluZyBgb2ZgIGtleXdvcmQnKVxuICAgICAgICAgICAgZW5mLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgY25zdCA9IFQuRm9yT2ZTdGF0ZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgY25zdCh7XG4gICAgICAgICAgICBsZWZ0OiBpbml0LCByaWdodCwgYm9keTogdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5mLm1hdGNoUHVuY3R1YXRvcignOycpO1xuICAgICAgICBpZiAoZW5mLmlzUHVuY3R1YXRvcihlbmYucGVlaygpLCAnOycpKSB7XG4gICAgICAgICAgZW5mLmFkdmFuY2UoKTtcbiAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXN0ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICAgIGVuZi5tYXRjaFB1bmN0dWF0b3IoJzsnKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQoZW5mLnBlZWsoMSksICdpbicpIHx8IHRoaXMuaXNJZGVudGlmaWVyKGVuZi5wZWVrKDEpLCAnb2YnKSkge1xuICAgICAgICAgIGxlZnQgPSBlbmYuZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcigpO1xuICAgICAgICAgIGxldCBraW5kID0gZW5mLmFkdmFuY2UoKTtcbiAgICAgICAgICBpZiAodGhpcy5pc0tleXdvcmQoa2luZCwgJ2luJykpIHtcbiAgICAgICAgICAgIGNuc3QgPSBULkZvckluU3RhdGVtZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbnN0ID0gVC5Gb3JPZlN0YXRlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHQgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBjbnN0KHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsIHJpZ2h0LCBib2R5OiB0aGlzLmVuZm9yZXN0U3RhdGVtZW50KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbml0ID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICBlbmYubWF0Y2hQdW5jdHVhdG9yKCc7Jyk7XG4gICAgICAgIGlmIChlbmYuaXNQdW5jdHVhdG9yKGVuZi5wZWVrKCksICc7JykpIHtcbiAgICAgICAgICBlbmYuYWR2YW5jZSgpO1xuICAgICAgICAgIHRlc3QgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlc3QgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZW5mLm1hdGNoUHVuY3R1YXRvcignOycpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVC5Gb3JTdGF0ZW1lbnQoeyBpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHk6IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKSB9KTtcbiAgICB9XG4gIH1cblxuICBlbmZvcmVzdElmU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdpZicpO1xuICAgIGxldCBjb25kID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcihjb25kLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGxvb2thaGVhZCA9IGVuZi5wZWVrKCk7XG4gICAgbGV0IHRlc3QgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVuZi5jcmVhdGVFcnJvcihsb29rYWhlYWQsICdleHBlY3RpbmcgYW4gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBsZXQgY29uc2VxdWVudCA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKCksICdlbHNlJykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgYWx0ZXJuYXRlID0gdGhpcy5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQuSWZTdGF0ZW1lbnQoeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUgfSk7XG4gIH1cblxuICBlbmZvcmVzdFdoaWxlU3RhdGVtZW50KCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCd3aGlsZScpO1xuICAgIGxldCBjb25kID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcihjb25kLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGxvb2thaGVhZCA9IGVuZi5wZWVrKCk7XG4gICAgbGV0IHRlc3QgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVuZi5jcmVhdGVFcnJvcihsb29rYWhlYWQsICdleHBlY3RpbmcgYW4gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBsZXQgYm9keSA9IHRoaXMuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcblxuICAgIHJldHVybiBuZXcgVC5XaGlsZVN0YXRlbWVudCh7IHRlc3QsIGJvZHkgfSk7XG4gIH1cblxuICBlbmZvcmVzdEJsb2NrU3RhdGVtZW50KCkge1xuICAgIHJldHVybiBuZXcgVC5CbG9ja1N0YXRlbWVudCh7XG4gICAgICBibG9jazogdGhpcy5lbmZvcmVzdEJsb2NrKClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0QmxvY2soKSB7XG4gICAgcmV0dXJuIG5ldyBULkJsb2NrKHtcbiAgICAgIHN0YXRlbWVudHM6IHRoaXMubWF0Y2hDdXJsaWVzKClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0Q2xhc3MoeyBpc0V4cHIgPSBmYWxzZSwgaW5EZWZhdWx0ID0gZmFsc2UgfToge2lzRXhwcj86IGJvb2xlYW4sIGluRGVmYXVsdD86IGJvb2xlYW59KSB7XG4gICAgbGV0IGt3ID0gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIGxldCBuYW1lID0gbnVsbCwgc3VwciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKCkpKSB7XG4gICAgICBuYW1lID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICghaXNFeHByKSB7XG4gICAgICBpZiAoaW5EZWZhdWx0KSB7XG4gICAgICAgIG5hbWUgPSBuZXcgVC5CaW5kaW5nSWRlbnRpZmllcih7XG4gICAgICAgICAgbmFtZTogU3ludGF4LmZyb21JZGVudGlmaWVyKCdfZGVmYXVsdCcsIGt3KVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IodGhpcy5wZWVrKCksICd1bmV4cGVjdGVkIHN5bnRheCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoKSwgJ2V4dGVuZHMnKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBzdXByID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgfVxuXG4gICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMubWF0Y2hDdXJsaWVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICB3aGlsZSAoZW5mLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgaWYgKGVuZi5pc1B1bmN0dWF0b3IoZW5mLnBlZWsoKSwgJzsnKSkge1xuICAgICAgICBlbmYuYWR2YW5jZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGlzU3RhdGljID0gZmFsc2U7XG4gICAgICBsZXQge21ldGhvZE9yS2V5LCBraW5kfSA9IGVuZi5lbmZvcmVzdE1ldGhvZERlZmluaXRpb24oKTtcbiAgICAgIGlmIChraW5kID09PSAnaWRlbnRpZmllcicgJiYgbWV0aG9kT3JLZXkudmFsdWUudmFsKCkgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgKHttZXRob2RPcktleSwga2luZH0gPSBlbmYuZW5mb3Jlc3RNZXRob2REZWZpbml0aW9uKCkpO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09ICdtZXRob2QnKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IFQuQ2xhc3NFbGVtZW50KHtpc1N0YXRpYywgbWV0aG9kOiBtZXRob2RPcktleX0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoZW5mLnBlZWsoKSwgJ09ubHkgbWV0aG9kcyBhcmUgYWxsb3dlZCBpbiBjbGFzc2VzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgKGlzRXhwciA/IFQuQ2xhc3NFeHByZXNzaW9uIDogVC5DbGFzc0RlY2xhcmF0aW9uKSh7XG4gICAgICBuYW1lLCBzdXBlcjogc3VwcixcbiAgICAgIGVsZW1lbnRzOiBMaXN0KGVsZW1lbnRzKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KHsgYWxsb3dQdW5jdHVhdG9yID0gZmFsc2UgfToge2FsbG93UHVuY3R1YXRvcj86IGJvb2xlYW59ID0ge30pIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZCkgfHwgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkKSB8fCAoYWxsb3dQdW5jdHVhdG9yICYmIHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKHsgYWxsb3dQdW5jdHVhdG9yIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QXJyYXlCaW5kaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0T2JqZWN0QmluZGluZygpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsICdub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gIH1cblxuICBlbmZvcmVzdE9iamVjdEJpbmRpbmcoKSB7XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMubWF0Y2hDdXJsaWVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICBsZXQgcHJvcGVydGllcyA9IFtdO1xuICAgIHdoaWxlIChlbmYucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goZW5mLmVuZm9yZXN0QmluZGluZ1Byb3BlcnR5KCkpO1xuICAgICAgZW5mLmNvbnN1bWVDb21tYSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVC5PYmplY3RCaW5kaW5nKHtcbiAgICAgIHByb3BlcnRpZXM6IExpc3QocHJvcGVydGllcylcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0QmluZGluZ1Byb3BlcnR5KCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBsZXQge25hbWUsIGJpbmRpbmd9ID0gdGhpcy5lbmZvcmVzdFByb3BlcnR5TmFtZSgpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2xldCcpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3lpZWxkJykpIHtcbiAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksICc6JykpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzQXNzaWduKHRoaXMucGVlaygpKSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIGxldCBleHByID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gZXhwcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFQuQmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcih7XG4gICAgICAgICAgYmluZGluZywgaW5pdDogZGVmYXVsdFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hdGNoUHVuY3R1YXRvcignOicpO1xuICAgIGJpbmRpbmcgPSB0aGlzLmVuZm9yZXN0QmluZGluZ0VsZW1lbnQoKTtcbiAgICByZXR1cm4gbmV3IFQuQmluZGluZ1Byb3BlcnR5UHJvcGVydHkoe1xuICAgICAgbmFtZSwgYmluZGluZ1xuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RBcnJheUJpbmRpbmcoKSB7XG4gICAgbGV0IGJyYWNrZXQgPSB0aGlzLm1hdGNoU3F1YXJlcygpO1xuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3RlcihicmFja2V0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGVsZW1lbnRzID0gW10sIHJlc3RFbGVtZW50ID0gbnVsbDtcbiAgICB3aGlsZSAoZW5mLnJlc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgbGV0IGVsO1xuICAgICAgaWYgKGVuZi5pc1B1bmN0dWF0b3IoZW5mLnBlZWsoKSwgJywnKSkge1xuICAgICAgICBlbmYuY29uc3VtZUNvbW1hKCk7XG4gICAgICAgIGVsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbmYuaXNQdW5jdHVhdG9yKGVuZi5wZWVrKCksICcuLi4nKSkge1xuICAgICAgICAgIGVuZi5hZHZhbmNlKCk7XG4gICAgICAgICAgcmVzdEVsZW1lbnQgPSBlbmYuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwgPSBlbmYuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVuZi5jb25zdW1lQ29tbWEoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQuQXJyYXlCaW5kaW5nKHtcbiAgICAgIGVsZW1lbnRzOiBMaXN0KGVsZW1lbnRzKSxcbiAgICAgIHJlc3RFbGVtZW50XG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdEJpbmRpbmdFbGVtZW50KCkge1xuICAgIGxldCBiaW5kaW5nID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdUYXJnZXQoKTtcblxuICAgIGlmICh0aGlzLmlzQXNzaWduKHRoaXMucGVlaygpKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQgaW5pdCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgYmluZGluZyA9IG5ldyBULkJpbmRpbmdXaXRoRGVmYXVsdCh7IGJpbmRpbmcsIGluaXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5nO1xuICB9XG5cbiAgZW5mb3Jlc3RCaW5kaW5nSWRlbnRpZmllcih7IGFsbG93UHVuY3R1YXRvciB9OiB7IGFsbG93UHVuY3R1YXRvcj86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKGFsbG93UHVuY3R1YXRvciAmJiB0aGlzLmlzUHVuY3R1YXRvcih0aGlzLnBlZWsoKSkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLmVuZm9yZXN0UHVuY3R1YXRvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gdGhpcy5lbmZvcmVzdElkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBULkJpbmRpbmdJZGVudGlmaWVyKHsgbmFtZSB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0UHVuY3R1YXRvcigpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIGEgcHVuY3R1YXRvcicpO1xuICB9XG5cbiAgZW5mb3Jlc3RJZGVudGlmaWVyKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkKSB8fCB0aGlzLmlzS2V5d29yZChsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyBhbiBpZGVudGlmaWVyJyk7XG4gIH1cblxuXG4gIGVuZm9yZXN0UmV0dXJuU3RhdGVtZW50KCkge1xuICAgIGxldCBrdyA9IHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG5cbiAgICAvLyBzaG9ydCBjaXJjdWl0IGZvciB0aGUgZW1wdHkgZXhwcmVzc2lvbiBjYXNlXG4gICAgaWYgKHRoaXMucmVzdC5zaXplID09PSAwIHx8XG4gICAgICAgIChsb29rYWhlYWQgJiYgIXRoaXMubGluZU51bWJlckVxKGt3LCBsb29rYWhlYWQpKSkge1xuICAgICAgcmV0dXJuIG5ldyBULlJldHVyblN0YXRlbWVudCh7XG4gICAgICAgIGV4cHJlc3Npb246IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCB0ZXJtID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgJzsnKSkge1xuICAgICAgdGVybSA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QodGVybSAhPSBudWxsLCAnRXhwZWN0aW5nIGFuIGV4cHJlc3Npb24gdG8gZm9sbG93IHJldHVybiBrZXl3b3JkJywgbG9va2FoZWFkLCB0aGlzLnJlc3QpO1xuICAgIH1cblxuICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuICAgIHJldHVybiBuZXcgVC5SZXR1cm5TdGF0ZW1lbnQoe1xuICAgICAgZXhwcmVzc2lvbjogdGVybVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgIGxldCBraW5kO1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG4gICAgbGV0IGtpbmRTeW4gPSBsb29rYWhlYWQ7XG4gICAgbGV0IHBoYXNlID0gdGhpcy5jb250ZXh0LnBoYXNlO1xuXG4gICAgaWYgKGtpbmRTeW4gJiZcbiAgICAgICAgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bi5yZXNvbHZlKHBoYXNlKSkgPT09IFZhcmlhYmxlRGVjbFRyYW5zZm9ybSkge1xuICAgICAga2luZCA9ICd2YXInO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5biAmJlxuICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bi5yZXNvbHZlKHBoYXNlKSkgPT09IExldERlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmQgPSAnbGV0JztcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW4gJiZcbiAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW4ucmVzb2x2ZShwaGFzZSkpID09PSBDb25zdERlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmQgPSAnY29uc3QnO1xuICAgIH0gZWxzZSBpZiAoa2luZFN5biAmJlxuICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmVudi5nZXQoa2luZFN5bi5yZXNvbHZlKHBoYXNlKSkgPT09IFN5bnRheERlY2xUcmFuc2Zvcm0pIHtcbiAgICAgIGtpbmQgPSAnc3ludGF4JztcbiAgICB9IGVsc2UgaWYgKGtpbmRTeW4gJiZcbiAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5lbnYuZ2V0KGtpbmRTeW4ucmVzb2x2ZShwaGFzZSkpID09PSBTeW50YXhyZWNEZWNsVHJhbnNmb3JtKSB7XG4gICAgICBraW5kID0gJ3N5bnRheHJlYyc7XG4gICAgfVxuXG4gICAgbGV0IGRlY2xzID0gTGlzdCgpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCB0ZXJtID0gdGhpcy5lbmZvcmVzdFZhcmlhYmxlRGVjbGFyYXRvcih7IGlzU3ludGF4OiBraW5kID09PSAnc3ludGF4JyB8fCBraW5kID09PSAnc3ludGF4cmVjJyB9KTtcbiAgICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGRlY2xzID0gZGVjbHMuY29uY2F0KHRlcm0pO1xuXG4gICAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnLCcpKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBULlZhcmlhYmxlRGVjbGFyYXRpb24oe1xuICAgICAga2luZDoga2luZCxcbiAgICAgIGRlY2xhcmF0b3JzOiBkZWNsc1xuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RWYXJpYWJsZURlY2xhcmF0b3IoeyBpc1N5bnRheCB9OiB7IGlzU3ludGF4OiBib29sZWFufSkge1xuICAgIGxldCBpZCA9IHRoaXMuZW5mb3Jlc3RCaW5kaW5nVGFyZ2V0KHsgYWxsb3dQdW5jdHVhdG9yOiBpc1N5bnRheCB9KTtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG5cbiAgICBsZXQgaW5pdDtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnPScpKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcih0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGluaXQgPSBlbmYuZW5mb3Jlc3QoJ2V4cHJlc3Npb24nKTtcbiAgICAgIHRoaXMucmVzdCA9IGVuZi5yZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBULlZhcmlhYmxlRGVjbGFyYXRvcih7XG4gICAgICBiaW5kaW5nOiBpZCxcbiAgICAgIGluaXQ6IGluaXRcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0RXhwcmVzc2lvblN0YXRlbWVudCgpIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnJlc3QuZ2V0KDApO1xuICAgIGxldCBleHByID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb24oKTtcbiAgICBpZiAoZXhwciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihzdGFydCwgJ25vdCBhIHZhbGlkIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICByZXR1cm4gbmV3IFQuRXhwcmVzc2lvblN0YXRlbWVudCh7XG4gICAgICBleHByZXNzaW9uOiBleHByXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdEV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgJywnKSkge1xuICAgICAgd2hpbGUgKHRoaXMucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksICcsJykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0b3IgPSB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG4gICAgICAgIGxldCByaWdodCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgICBsZWZ0ID0gbmV3IFQuQmluYXJ5RXhwcmVzc2lvbih7bGVmdCwgb3BlcmF0b3I6IG9wZXJhdG9yLnZhbCgpLCByaWdodH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRlcm0gPSBudWxsO1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpIHtcbiAgICB0aGlzLnRlcm0gPSBudWxsO1xuICAgIHRoaXMub3BDdHggPSB7XG4gICAgICBwcmVjOiAwLFxuICAgICAgY29tYmluZTogKHgpID0+IHgsXG4gICAgICBzdGFjazogTGlzdCgpXG4gICAgfTtcblxuICAgIGRvIHtcbiAgICAgIGxldCB0ZXJtID0gdGhpcy5lbmZvcmVzdEFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAvLyBubyBjaGFuZ2UgbWVhbnMgd2UndmUgZG9uZSBhcyBtdWNoIGVuZm9yZXN0aW5nIGFzIHBvc3NpYmxlXG4gICAgICAvLyBpZiBub3RoaW5nIGNoYW5nZWQsIG1heWJlIHdlIGp1c3QgbmVlZCB0byBwb3AgdGhlIGV4cHIgc3RhY2tcbiAgICAgIGlmICh0ZXJtID09PSBFWFBSX0xPT1BfTk9fQ0hBTkdFICYmIHRoaXMub3BDdHguc3RhY2suc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5vcEN0eC5jb21iaW5lKHRoaXMudGVybSk7XG4gICAgICAgIGxldCB7cHJlYywgY29tYmluZX0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgICAgdGhpcy5vcEN0eC5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5vcEN0eC5zdGFjayA9IHRoaXMub3BDdHguc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9OT19DSEFOR0UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0gPT09IEVYUFJfTE9PUF9PUEVSQVRPUiB8fCB0ZXJtID09PSBFWFBSX0xPT1BfRVhQQU5TSU9OKSB7XG4gICAgICAgIC8vIG9wZXJhdG9yIG1lYW5zIGFuIG9wQ3R4IHdhcyBwdXNoZWQgb24gdGhlIHN0YWNrXG4gICAgICAgIHRoaXMudGVybSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpOyAgLy8gZ2V0IGEgZml4cG9pbnRcbiAgICByZXR1cm4gdGhpcy50ZXJtO1xuICB9XG5cbiAgZW5mb3Jlc3RBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNDb21waWxldGltZVRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICB0aGlzLmV4cGFuZE1hY3JvKCk7XG4gICAgICBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNUZXJtKGxvb2thaGVhZCkgJiYgbG9va2FoZWFkIGluc3RhbmNlb2YgVC5FeHByZXNzaW9uKSB7XG4gICAgICAvLyBUT0RPOiBjaGVjayB0aGF0IHRoaXMgaXMgYWN0dWFsbHkgYW4gZXhwcmVzc2lvblxuICAgICAgcmV0dXJuIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAneWllbGQnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RZaWVsZEV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2NsYXNzJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0Q2xhc3Moe2lzRXhwcjogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgbG9va2FoZWFkICYmXG4gICAgICAodGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkKSB8fCB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZCkpICYmXG4gICAgICAgdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKDEpLCAnPT4nKSAmJlxuICAgICAgIHRoaXMubGluZU51bWJlckVxKGxvb2thaGVhZCwgdGhpcy5wZWVrKDEpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKTtcbiAgICB9XG5cblxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3ludGF4VGVtcGxhdGUobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RTeW50YXhUZW1wbGF0ZSgpO1xuICAgIH1cblxuICAgIC8vICgkeDpleHByKVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1BhcmVucyhsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gbmV3IFQuUGFyZW50aGVzaXplZEV4cHJlc3Npb24oe1xuICAgICAgICBpbm5lcjogdGhpcy5tYXRjaFBhcmVucygpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIChcbiAgICAgIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3RoaXMnKSB8fFxuICAgICAgdGhpcy5pc0lkZW50aWZpZXIobG9va2FoZWFkKSB8fFxuICAgICAgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnbGV0JykgfHxcbiAgICAgIHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3lpZWxkJykgfHxcbiAgICAgIHRoaXMuaXNOdW1lcmljTGl0ZXJhbChsb29rYWhlYWQpIHx8XG4gICAgICB0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWQpIHx8XG4gICAgICB0aGlzLmlzVGVtcGxhdGUobG9va2FoZWFkKSB8fFxuICAgICAgdGhpcy5pc0Jvb2xlYW5MaXRlcmFsKGxvb2thaGVhZCkgfHxcbiAgICAgIHRoaXMuaXNOdWxsTGl0ZXJhbChsb29rYWhlYWQpIHx8XG4gICAgICB0aGlzLmlzUmVndWxhckV4cHJlc3Npb24obG9va2FoZWFkKSB8fFxuICAgICAgdGhpcy5pc0ZuRGVjbFRyYW5zZm9ybShsb29rYWhlYWQpIHx8XG4gICAgICB0aGlzLmlzQnJhY2VzKGxvb2thaGVhZCkgfHxcbiAgICAgIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWQpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIC8vIHByZWZpeCB1bmFyeVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc09wZXJhdG9yKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VW5hcnlFeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVmFyQmluZGluZ1RyYW5zZm9ybShsb29rYWhlYWQpICYmIGxvb2thaGVhZCBpbnN0YW5jZW9mIFQuUmF3U3ludGF4KSB7XG4gICAgICBsZXQgbG9va3N0eCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGxldCBpZCA9IHRoaXMuZ2V0RnJvbUNvbXBpbGV0aW1lRW52aXJvbm1lbnQobG9va3N0eCkuaWQ7XG4gICAgICBpZiAoaWQgIT09IGxvb2tzdHgpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMucmVzdCA9IExpc3Qub2YoaWQpLmNvbmNhdCh0aGlzLnJlc3QpO1xuICAgICAgICByZXR1cm4gRVhQUl9MT09QX0VYUEFOU0lPTjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHRoaXMudGVybSA9PT0gbnVsbCAmJiAoXG4gICAgICB0aGlzLmlzTmV3VHJhbnNmb3JtKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAnc3VwZXInKSkpIHx8XG4gICAgICAgIC8vIGFuZCB0aGVuIGNoZWNrIHRoZSBjYXNlcyB3aGVyZSB0aGUgdGVybSBwYXJ0IG9mIHAgaXMgc29tZXRoaW5nLi4uXG4gICAgICAgICh0aGlzLnRlcm0gJiYgKFxuICAgICAgICAgIC8vICR4OmV4cHIgLiAkcHJvcDppZGVudFxuICAgICAgICAgICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICcuJykgJiYgKFxuICAgICAgICAgICAgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpKSB8fCB0aGlzLmlzS2V5d29yZCh0aGlzLnBlZWsoMSkpKSkgfHxcbiAgICAgICAgICAgIC8vICR4OmV4cHIgWyAkYjpleHByIF1cbiAgICAgICAgICAgIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWQpIHx8XG4gICAgICAgICAgICAvLyAkeDpleHByICguLi4pXG4gICAgICAgICAgICB0aGlzLmlzUGFyZW5zKGxvb2thaGVhZClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TGVmdEhhbmRTaWRlRXhwcmVzc2lvbih7IGFsbG93Q2FsbDogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyAkeDppZCBgLi4uYFxuICAgIGlmKHRoaXMudGVybSAmJiB0aGlzLmlzVGVtcGxhdGUobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICB9XG5cbiAgICAvLyBwb3N0Zml4IHVuYXJ5XG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzVXBkYXRlT3BlcmF0b3IobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgLy8gJGw6ZXhwciAkb3A6YmluYXJ5T3BlcmF0b3IgJHI6ZXhwclxuICAgIGlmICh0aGlzLnRlcm0gJiYgdGhpcy5pc09wZXJhdG9yKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0QmluYXJ5RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIC8vICR4OmV4cHIgPSAkaW5pdDpleHByXG4gICAgaWYgKHRoaXMudGVybSAmJiB0aGlzLmlzQXNzaWduKGxvb2thaGVhZCkpIHtcbiAgICAgIGxldCBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRoaXMudGVybSk7XG4gICAgICBsZXQgb3AgPSB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG5cbiAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3Rlcih0aGlzLnJlc3QsIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBpbml0ID0gZW5mLmVuZm9yZXN0KCdleHByZXNzaW9uJyk7XG4gICAgICB0aGlzLnJlc3QgPSBlbmYucmVzdDtcblxuICAgICAgaWYgKG9wLnZhbCgpID09PSAnPScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBULkFzc2lnbm1lbnRFeHByZXNzaW9uKHtcbiAgICAgICAgICBiaW5kaW5nLFxuICAgICAgICAgIGV4cHJlc3Npb246IGluaXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFQuQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbih7XG4gICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICBvcGVyYXRvcjogb3AudmFsKCksXG4gICAgICAgICAgZXhwcmVzc2lvbjogaW5pdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZXJtICYmIHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgJz8nKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRVhQUl9MT09QX05PX0NIQU5HRTtcbiAgfVxuXG4gIGVuZm9yZXN0UHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIC8vICR4OlRoaXNFeHByZXNzaW9uXG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzS2V5d29yZChsb29rYWhlYWQsICd0aGlzJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0VGhpc0V4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgLy8gJHg6aWRlbnRcbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ2xldCcpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3lpZWxkJykpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdElkZW50aWZpZXJFeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc051bWVyaWNMaXRlcmFsKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0TnVtZXJpY0xpdGVyYWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdFN0cmluZ0xpdGVyYWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzVGVtcGxhdGUobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGVybSA9PT0gbnVsbCAmJiB0aGlzLmlzQm9vbGVhbkxpdGVyYWwobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCb29sZWFuTGl0ZXJhbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNOdWxsTGl0ZXJhbChsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE51bGxMaXRlcmFsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc1JlZ3VsYXJFeHByZXNzaW9uKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZm9yZXN0UmVndWxhckV4cHJlc3Npb25MaXRlcmFsKCk7XG4gICAgfVxuICAgIC8vICR4OkZ1bmN0aW9uRXhwcmVzc2lvblxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0ZuRGVjbFRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEZ1bmN0aW9uKHtpc0V4cHI6IHRydWV9KTtcbiAgICB9XG4gICAgLy8geyAkcDpwcm9wICgsKSAuLi4gfVxuICAgIGlmICh0aGlzLnRlcm0gPT09IG51bGwgJiYgdGhpcy5pc0JyYWNlcyhsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdE9iamVjdEV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgLy8gWyR4OmV4cHIgKCwpIC4uLl1cbiAgICBpZiAodGhpcy50ZXJtID09PSBudWxsICYmIHRoaXMuaXNCcmFja2V0cyhsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmZvcmVzdEFycmF5RXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsICdOb3QgYSBwcmltYXJ5IGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIGVuZm9yZXN0TGVmdEhhbmRTaWRlRXhwcmVzc2lvbih7IGFsbG93Q2FsbCB9OiB7IGFsbG93Q2FsbDogYm9vbGVhbiB9KSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuXG4gICAgaWYgKHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCwgJ3N1cGVyJykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy50ZXJtID0gbmV3IFQuU3VwZXIoe30pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld1RyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICB0aGlzLnRlcm0gPSB0aGlzLmVuZm9yZXN0TmV3RXhwcmVzc2lvbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCAndGhpcycpKSB7XG4gICAgICB0aGlzLnRlcm0gPSB0aGlzLmVuZm9yZXN0VGhpc0V4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAodGhpcy5pc1BhcmVucyhsb29rYWhlYWQpKSB7XG4gICAgICAgIGlmICghYWxsb3dDYWxsKSB7XG4gICAgICAgICAgLy8gd2UncmUgZGVhbGluZyB3aXRoIGEgbmV3IGV4cHJlc3Npb25cbiAgICAgICAgICBpZiAodGhpcy50ZXJtICYmXG4gICAgICAgICAgICAgIChpc0lkZW50aWZpZXJFeHByZXNzaW9uKHRoaXMudGVybSkgfHxcbiAgICAgICAgICAgICAgIGlzU3RhdGljTWVtYmVyRXhwcmVzc2lvbih0aGlzLnRlcm0pIHx8XG4gICAgICAgICAgICAgICBpc0NvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbih0aGlzLnRlcm0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVybTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5lbmZvcmVzdENhbGxFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZCkpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy50ZXJtID8gdGhpcy5lbmZvcmVzdENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbigpIDogdGhpcy5lbmZvcmVzdFByaW1hcnlFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgJy4nKSAmJiAoXG4gICAgICAgIHRoaXMuaXNJZGVudGlmaWVyKHRoaXMucGVlaygxKSkgfHwgdGhpcy5pc0tleXdvcmQodGhpcy5wZWVrKDEpKSkpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5lbmZvcmVzdFN0YXRpY01lbWJlckV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZCkpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5lbmZvcmVzdFRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2VzKGxvb2thaGVhZCkpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gdGhpcy5lbmZvcmVzdFByaW1hcnlFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZCkpIHtcbiAgICAgICAgdGhpcy50ZXJtID0gbmV3IFQuSWRlbnRpZmllckV4cHJlc3Npb24oeyBuYW1lOiB0aGlzLmVuZm9yZXN0SWRlbnRpZmllcigpIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBlbmZvcmVzdEJvb2xlYW5MaXRlcmFsKCkge1xuICAgIHJldHVybiBuZXcgVC5MaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24oe1xuICAgICAgdmFsdWU6IHRoaXMubWF0Y2hSYXdTeW50YXgoKS52YWwoKSA9PT0gJ3RydWUnXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdFRlbXBsYXRlTGl0ZXJhbCgpIHtcbiAgICByZXR1cm4gbmV3IFQuVGVtcGxhdGVFeHByZXNzaW9uKHtcbiAgICAgIHRhZzogdGhpcy50ZXJtLFxuICAgICAgZWxlbWVudHM6IHRoaXMuZW5mb3Jlc3RUZW1wbGF0ZUVsZW1lbnRzKClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0U3RyaW5nTGl0ZXJhbCgpIHtcbiAgICByZXR1cm4gbmV3IFQuTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb24oe1xuICAgICAgdmFsdWU6IHRoaXMubWF0Y2hSYXdTeW50YXgoKS52YWwoKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3ROdW1lcmljTGl0ZXJhbCgpIHtcbiAgICBsZXQgbnVtID0gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIGlmIChudW0udmFsKCkgPT09IDEgLyAwKSB7XG4gICAgICByZXR1cm4gbmV3IFQuTGl0ZXJhbEluZmluaXR5RXhwcmVzc2lvbih7fSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVC5MaXRlcmFsTnVtZXJpY0V4cHJlc3Npb24oe1xuICAgICAgdmFsdWU6IG51bS52YWwoKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RJZGVudGlmaWVyRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gbmV3IFQuSWRlbnRpZmllckV4cHJlc3Npb24oe1xuICAgICAgbmFtZTogdGhpcy5tYXRjaFJhd1N5bnRheCgpXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdFJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbCgpIHtcbiAgICBsZXQgcmVTdHggPSB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG5cbiAgICBsZXQgbGFzdFNsYXNoID0gcmVTdHgudG9rZW4udmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICBsZXQgcGF0dGVybiA9IHJlU3R4LnRva2VuLnZhbHVlLnNsaWNlKDEsIGxhc3RTbGFzaCk7XG4gICAgbGV0IGZsYWdzID0gcmVTdHgudG9rZW4udmFsdWUuc2xpY2UobGFzdFNsYXNoICsgMSk7XG4gICAgcmV0dXJuIG5ldyBULkxpdGVyYWxSZWdFeHBFeHByZXNzaW9uKHtcbiAgICAgIHBhdHRlcm4sIGZsYWdzXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdE51bGxMaXRlcmFsKCkge1xuICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIHJldHVybiBuZXcgVC5MaXRlcmFsTnVsbEV4cHJlc3Npb24oe30pO1xuICB9XG5cbiAgZW5mb3Jlc3RUaGlzRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gbmV3IFQuVGhpc0V4cHJlc3Npb24oe1xuICAgICAgc3R4OiB0aGlzLm1hdGNoUmF3U3ludGF4KClcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0QXJndW1lbnRMaXN0KCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodGhpcy5yZXN0LnNpemUgPiAwKSB7XG4gICAgICBsZXQgYXJnO1xuICAgICAgaWYgKHRoaXMuaXNQdW5jdHVhdG9yKHRoaXMucGVlaygpLCAnLi4uJykpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGFyZyA9IG5ldyBULlNwcmVhZEVsZW1lbnQoe1xuICAgICAgICAgIGV4cHJlc3Npb246IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnID0gdGhpcy5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXN0LnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKCcsJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChhcmcpO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdChyZXN1bHQpO1xuICB9XG5cbiAgZW5mb3Jlc3ROZXdFeHByZXNzaW9uKCkge1xuICAgIHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksICcuJykgJiYgdGhpcy5pc0lkZW50aWZpZXIodGhpcy5wZWVrKDEpLCAndGFyZ2V0JykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gbmV3IFQuTmV3VGFyZ2V0RXhwcmVzc2lvbih7fSk7XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZSA9IHRoaXMuZW5mb3Jlc3RMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKHsgYWxsb3dDYWxsOiBmYWxzZSB9KTtcbiAgICBsZXQgYXJncztcbiAgICBpZiAodGhpcy5pc1BhcmVucyh0aGlzLnBlZWsoKSkpIHtcbiAgICAgIGFyZ3MgPSB0aGlzLm1hdGNoUGFyZW5zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBMaXN0KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVC5OZXdFeHByZXNzaW9uKHtcbiAgICAgIGNhbGxlZSxcbiAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RDb21wdXRlZE1lbWJlckV4cHJlc3Npb24oKSB7XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICByZXR1cm4gbmV3IFQuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKHtcbiAgICAgIG9iamVjdDogdGhpcy50ZXJtLFxuICAgICAgZXhwcmVzc2lvbjogZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpXG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHRlcm06IFRlcm0pIHtcbiAgICBzd2l0Y2ggKHRlcm0udHlwZSkge1xuICAgICAgY2FzZSAnSWRlbnRpZmllckV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gbmV3IFQuQmluZGluZ0lkZW50aWZpZXIoe25hbWU6IHRlcm0ubmFtZX0pO1xuXG4gICAgICBjYXNlICdQYXJlbnRoZXNpemVkRXhwcmVzc2lvbic6XG4gICAgICAgIGlmICh0ZXJtLmlubmVyLnNpemUgPT09IDEgJiYgdGhpcy5pc0lkZW50aWZpZXIodGVybS5pbm5lci5nZXQoMCkpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBULkJpbmRpbmdJZGVudGlmaWVyKHsgbmFtZTogdGVybS5pbm5lci5nZXQoMCkudmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVybTtcbiAgICAgIGNhc2UgJ0RhdGFQcm9wZXJ0eSc6XG4gICAgICAgIHJldHVybiBuZXcgVC5CaW5kaW5nUHJvcGVydHlQcm9wZXJ0eSh7XG4gICAgICAgICAgbmFtZTogdGVybS5uYW1lLFxuICAgICAgICAgIGJpbmRpbmc6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KHRlcm0uZXhwcmVzc2lvbilcbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdTaG9ydGhhbmRQcm9wZXJ0eSc6XG4gICAgICAgIHJldHVybiBuZXcgVC5CaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyKHtcbiAgICAgICAgICBiaW5kaW5nOiBuZXcgVC5CaW5kaW5nSWRlbnRpZmllcih7IG5hbWU6IHRlcm0ubmFtZSB9KSxcbiAgICAgICAgICBpbml0OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBuZXcgVC5PYmplY3RCaW5kaW5nKHtcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB0ZXJtLnByb3BlcnRpZXMubWFwKHQgPT4gdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nKHQpKVxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6IHtcbiAgICAgICAgbGV0IGxhc3QgPSB0ZXJtLmVsZW1lbnRzLmxhc3QoKTtcbiAgICAgICAgaWYgKGxhc3QgIT0gbnVsbCAmJiBsYXN0LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50Jykge1xuICAgICAgICAgIHJldHVybiBuZXcgVC5BcnJheUJpbmRpbmcoe1xuICAgICAgICAgICAgZWxlbWVudHM6IHRlcm0uZWxlbWVudHMuc2xpY2UoMCwgLTEpLm1hcCh0ID0+IHQgJiYgdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nV2l0aERlZmF1bHQodCkpLFxuICAgICAgICAgICAgcmVzdEVsZW1lbnQ6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZ1dpdGhEZWZhdWx0KGxhc3QuZXhwcmVzc2lvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFQuQXJyYXlCaW5kaW5nKHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiB0ZXJtLmVsZW1lbnRzLm1hcCh0ID0+IHQgJiYgdGhpcy50cmFuc2Zvcm1EZXN0cnVjdHVyaW5nV2l0aERlZmF1bHQodCkpLFxuICAgICAgICAgICAgcmVzdEVsZW1lbnQ6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnU3RhdGljUHJvcGVydHlOYW1lJzpcbiAgICAgICAgcmV0dXJuIG5ldyBULkJpbmRpbmdJZGVudGlmaWVyKHtcbiAgICAgICAgICBuYW1lOiB0ZXJtLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAnQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ1N0YXRpY01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnQXJyYXlCaW5kaW5nJzpcbiAgICAgIGNhc2UgJ0JpbmRpbmdJZGVudGlmaWVyJzpcbiAgICAgIGNhc2UgJ0JpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXInOlxuICAgICAgY2FzZSAnQmluZGluZ1Byb3BlcnR5UHJvcGVydHknOlxuICAgICAgY2FzZSAnQmluZGluZ1dpdGhEZWZhdWx0JzpcbiAgICAgIGNhc2UgJ09iamVjdEJpbmRpbmcnOlxuICAgICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCAnbm90IGltcGxlbWVudGVkIHlldCBmb3IgJyArIHRlcm0udHlwZSk7XG4gIH1cblxuICB0cmFuc2Zvcm1EZXN0cnVjdHVyaW5nV2l0aERlZmF1bHQodGVybTogVGVybSkge1xuICAgIHN3aXRjaCAodGVybS50eXBlKSB7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiBuZXcgVC5CaW5kaW5nV2l0aERlZmF1bHQoe1xuICAgICAgICAgIGJpbmRpbmc6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyh0ZXJtLmJpbmRpbmcpLFxuICAgICAgICAgIGluaXQ6IHRlcm0uZXhwcmVzc2lvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmcodGVybSk7XG4gIH1cblxuICBlbmZvcmVzdENhbGxFeHByZXNzaW9uKCkge1xuICAgIGxldCBwYXJlbiA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICByZXR1cm4gbmV3IFQuQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgY2FsbGVlOiB0aGlzLnRlcm0sXG4gICAgICBhcmd1bWVudHM6IHBhcmVuXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdEFycm93RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgZW5mO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcih0aGlzLnBlZWsoKSkpIHtcbiAgICAgIGVuZiA9IG5ldyBFbmZvcmVzdGVyKExpc3Qub2YodGhpcy5hZHZhbmNlKCkpLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgICAgZW5mID0gbmV3IEVuZm9yZXN0ZXIocCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgICBsZXQgcGFyYW1zID0gZW5mLmVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpO1xuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKCc9PicpO1xuXG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHRoaXMuaXNCcmFjZXModGhpcy5wZWVrKCkpKSB7XG4gICAgICBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICAgIHJldHVybiBuZXcgVC5BcnJvd0V4cHJlc3Npb25FKHsgcGFyYW1zLCBib2R5IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMucmVzdCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgYm9keSA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICB0aGlzLnJlc3QgPSBlbmYucmVzdDtcbiAgICAgIHJldHVybiBuZXcgVC5BcnJvd0V4cHJlc3Npb24oeyBwYXJhbXMsIGJvZHkgfSk7XG4gICAgfVxuICB9XG5cblxuICBlbmZvcmVzdFlpZWxkRXhwcmVzc2lvbigpIHtcbiAgICBsZXQga3dkID0gdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJyk7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuXG4gICAgaWYgKHRoaXMucmVzdC5zaXplID09PSAwIHx8IChsb29rYWhlYWQgJiYgIXRoaXMubGluZU51bWJlckVxKGt3ZCwgbG9va2FoZWFkKSkpIHtcbiAgICAgIHJldHVybiBuZXcgVC5ZaWVsZEV4cHJlc3Npb24oe1xuICAgICAgICBleHByZXNzaW9uOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlzR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksICcqJykpIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBsZXQgZXhwciA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uKCk7XG4gICAgICByZXR1cm4gbmV3IChpc0dlbmVyYXRvciA/IFQuWWllbGRHZW5lcmF0b3JFeHByZXNzaW9uIDogVC5ZaWVsZEV4cHJlc3Npb24pKHtcbiAgICAgICAgZXhwcmVzc2lvbjogZXhwclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZW5mb3Jlc3RTeW50YXhUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFQuU3ludGF4VGVtcGxhdGUoe1xuICAgICAgdGVtcGxhdGU6IHRoaXMubWF0Y2hSYXdEZWxpbWl0ZXIoKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RTdGF0aWNNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgIGxldCBvYmplY3QgPSB0aGlzLnRlcm07XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgbGV0IHByb3BlcnR5ID0gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuXG4gICAgcmV0dXJuIG5ldyBULlN0YXRpY01lbWJlckV4cHJlc3Npb24oe1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0QXJyYXlFeHByZXNzaW9uKCkge1xuICAgIGxldCBhcnIgPSB0aGlzLm1hdGNoU3F1YXJlcygpO1xuXG4gICAgbGV0IGVsZW1lbnRzID0gW107XG5cbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIoYXJyLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG5cbiAgICB3aGlsZSAoZW5mLnJlc3Quc2l6ZSA+IDApIHtcbiAgICAgIGxldCBsb29rYWhlYWQgPSBlbmYucGVlaygpO1xuICAgICAgaWYgKGVuZi5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnLCcpKSB7XG4gICAgICAgIGVuZi5hZHZhbmNlKCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZi5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnLi4uJykpIHtcbiAgICAgICAgZW5mLmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZW5mLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyBleHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChuZXcgVC5TcHJlYWRFbGVtZW50KHsgZXhwcmVzc2lvbiB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGVybSA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGlmICh0ZXJtID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlbmYuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0ZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGVybSk7XG4gICAgICAgIGVuZi5jb25zdW1lQ29tbWEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFQuQXJyYXlFeHByZXNzaW9uKHtcbiAgICAgIGVsZW1lbnRzOiBMaXN0KGVsZW1lbnRzKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RPYmplY3RFeHByZXNzaW9uKCkge1xuICAgIGxldCBvYmogPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuXG4gICAgbGV0IHByb3BlcnRpZXMgPSBMaXN0KCk7XG5cbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIob2JqLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG5cbiAgICBsZXQgbGFzdFByb3AgPSBudWxsO1xuICAgIHdoaWxlIChlbmYucmVzdC5zaXplID4gMCkge1xuICAgICAgbGV0IHByb3AgPSBlbmYuZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKTtcbiAgICAgIGVuZi5jb25zdW1lQ29tbWEoKTtcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNvbmNhdChwcm9wKTtcblxuICAgICAgaWYgKGxhc3RQcm9wID09PSBwcm9wKSB7XG4gICAgICAgIHRocm93IGVuZi5jcmVhdGVFcnJvcihwcm9wLCAnaW52YWxpZCBzeW50YXggaW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBsYXN0UHJvcCA9IHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBULk9iamVjdEV4cHJlc3Npb24oe1xuICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RQcm9wZXJ0eURlZmluaXRpb24oKSB7XG5cbiAgICBsZXQge21ldGhvZE9yS2V5LCBraW5kfSA9IHRoaXMuZW5mb3Jlc3RNZXRob2REZWZpbml0aW9uKCk7XG5cbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgJ21ldGhvZCc6XG4gICAgICAgIHJldHVybiBtZXRob2RPcktleTtcbiAgICAgIGNhc2UgJ2lkZW50aWZpZXInOlxuICAgICAgICBpZiAodGhpcy5pc0Fzc2lnbih0aGlzLnBlZWsoKSkpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICBsZXQgaW5pdCA9IHRoaXMuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgVC5CaW5kaW5nUHJvcGVydHlJZGVudGlmaWVyKHtcbiAgICAgICAgICAgIGluaXQsIGJpbmRpbmc6IHRoaXMudHJhbnNmb3JtRGVzdHJ1Y3R1cmluZyhtZXRob2RPcktleSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc1B1bmN0dWF0b3IodGhpcy5wZWVrKCksICc6JykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFQuU2hvcnRoYW5kUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogbWV0aG9kT3JLZXkudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWF0Y2hQdW5jdHVhdG9yKCc6Jyk7XG4gICAgbGV0IGV4cHIgPSB0aGlzLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcblxuICAgIHJldHVybiBuZXcgVC5EYXRhUHJvcGVydHkoe1xuICAgICAgbmFtZTogbWV0aG9kT3JLZXksXG4gICAgICBleHByZXNzaW9uOiBleHByXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdE1ldGhvZERlZmluaXRpb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIGxldCBpc0dlbmVyYXRvciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICcqJykpIHtcbiAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQsICdnZXQnKSAmJiB0aGlzLmlzUHJvcGVydHlOYW1lKHRoaXMucGVlaygxKSkpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbGV0IHtuYW1lfSA9IHRoaXMuZW5mb3Jlc3RQcm9wZXJ0eU5hbWUoKTtcbiAgICAgIHRoaXMubWF0Y2hQYXJlbnMoKTtcbiAgICAgIGxldCBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE9yS2V5OiBuZXcgVC5HZXR0ZXIoeyBuYW1lLCBib2R5IH0pLFxuICAgICAgICBraW5kOiAnbWV0aG9kJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyKGxvb2thaGVhZCwgJ3NldCcpICYmIHRoaXMuaXNQcm9wZXJ0eU5hbWUodGhpcy5wZWVrKDEpKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICBsZXQge25hbWV9ID0gdGhpcy5lbmZvcmVzdFByb3BlcnR5TmFtZSgpO1xuICAgICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMubWF0Y2hQYXJlbnMoKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgbGV0IHBhcmFtID0gZW5mLmVuZm9yZXN0QmluZGluZ0VsZW1lbnQoKTtcbiAgICAgIGxldCBib2R5ID0gdGhpcy5tYXRjaEN1cmxpZXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE9yS2V5OiBuZXcgVC5TZXR0ZXIoeyBuYW1lLCBwYXJhbSwgYm9keSB9KSxcbiAgICAgICAga2luZDogJ21ldGhvZCdcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCB7bmFtZX0gPSB0aGlzLmVuZm9yZXN0UHJvcGVydHlOYW1lKCk7XG4gICAgaWYgKHRoaXMuaXNQYXJlbnModGhpcy5wZWVrKCkpKSB7XG4gICAgICBsZXQgcGFyYW1zID0gdGhpcy5tYXRjaFBhcmVucygpO1xuICAgICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHBhcmFtcywgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgICAgbGV0IGZvcm1hbFBhcmFtcyA9IGVuZi5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcblxuICAgICAgbGV0IGJvZHkgPSB0aGlzLm1hdGNoQ3VybGllcygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kT3JLZXk6IG5ldyBULk1ldGhvZCh7XG4gICAgICAgICAgaXNHZW5lcmF0b3IsXG4gICAgICAgICAgbmFtZSwgcGFyYW1zOiBmb3JtYWxQYXJhbXMsIGJvZHlcbiAgICAgICAgfSksXG4gICAgICAgIGtpbmQ6ICdtZXRob2QnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kT3JLZXk6IG5hbWUsXG4gICAgICBraW5kOiB0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQpIHx8IHRoaXMuaXNLZXl3b3JkKGxvb2thaGVhZCkgPyAnaWRlbnRpZmllcicgOiAncHJvcGVydHknXG4gICAgfTtcbiAgfVxuXG4gIGVuZm9yZXN0UHJvcGVydHlOYW1lKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcblxuICAgIGlmICh0aGlzLmlzU3RyaW5nTGl0ZXJhbChsb29rYWhlYWQpIHx8IHRoaXMuaXNOdW1lcmljTGl0ZXJhbChsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuZXcgVC5TdGF0aWNQcm9wZXJ0eU5hbWUoe1xuICAgICAgICAgIHZhbHVlOiB0aGlzLm1hdGNoUmF3U3ludGF4KClcbiAgICAgICAgfSksXG4gICAgICAgIGJpbmRpbmc6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnJhY2tldHMobG9va2FoZWFkKSkge1xuICAgICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHRoaXMubWF0Y2hTcXVhcmVzKCksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGxldCBleHByID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbkxvb3AoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5ldyBULkNvbXB1dGVkUHJvcGVydHlOYW1lKHtcbiAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgIH0pLFxuICAgICAgICBiaW5kaW5nOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgbmFtZSA9IHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmV3IFQuU3RhdGljUHJvcGVydHlOYW1lKHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICBiaW5kaW5nOiBuZXcgVC5CaW5kaW5nSWRlbnRpZmllcih7IG5hbWUgfSlcbiAgICB9O1xuICB9XG5cbiAgZW5mb3Jlc3RGdW5jdGlvbih7aXNFeHByLCBpbkRlZmF1bHR9OiB7aXNFeHByPzogYm9vbGVhbiwgaW5EZWZhdWx0PzogYm9vbGVhbn0pIHtcbiAgICBsZXQgbmFtZSA9IG51bGwsIHBhcmFtcywgYm9keTtcbiAgICBsZXQgaXNHZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAvLyBlYXQgdGhlIGZ1bmN0aW9uIGtleXdvcmRcbiAgICBsZXQgZm5LZXl3b3JkID0gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcblxuICAgIGlmICh0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICcqJykpIHtcbiAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUGFyZW5zKGxvb2thaGVhZCkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLmVuZm9yZXN0QmluZGluZ0lkZW50aWZpZXIoKTtcbiAgICB9IGVsc2UgaWYgKGluRGVmYXVsdCkge1xuICAgICAgbmFtZSA9IG5ldyBULkJpbmRpbmdJZGVudGlmaWVyKHtcbiAgICAgICAgbmFtZTogU3ludGF4LmZyb21JZGVudGlmaWVyKCcqZGVmYXVsdConLCBmbktleXdvcmQpXG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIHBhcmFtcyA9IHRoaXMubWF0Y2hQYXJlbnMoKTtcblxuXG4gICAgYm9keSA9IHRoaXMubWF0Y2hDdXJsaWVzKCk7XG5cbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIocGFyYW1zLCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGZvcm1hbFBhcmFtcyA9IGVuZi5lbmZvcmVzdEZvcm1hbFBhcmFtZXRlcnMoKTtcblxuICAgIHJldHVybiBuZXcgKGlzRXhwciA/IFQuRnVuY3Rpb25FeHByZXNzaW9uRSA6IFQuRnVuY3Rpb25EZWNsYXJhdGlvbkUpKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpc0dlbmVyYXRvcjogaXNHZW5lcmF0b3IsXG4gICAgICBwYXJhbXM6IGZvcm1hbFBhcmFtcyxcbiAgICAgIGJvZHk6IGJvZHlcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0Rm9ybWFsUGFyYW1ldGVycygpIHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBsZXQgcmVzdCA9IG51bGw7XG4gICAgd2hpbGUgKHRoaXMucmVzdC5zaXplICE9PSAwKSB7XG4gICAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkLCAnLi4uJykpIHtcbiAgICAgICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoJy4uLicpO1xuICAgICAgICByZXN0ID0gdGhpcy5lbmZvcmVzdEJpbmRpbmdJZGVudGlmaWVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh0aGlzLmVuZm9yZXN0UGFyYW0oKSk7XG4gICAgICB0aGlzLmNvbnN1bWVDb21tYSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFQuRm9ybWFsUGFyYW1ldGVycyh7XG4gICAgICBpdGVtczogTGlzdChpdGVtcyksIHJlc3RcbiAgICB9KTtcbiAgfVxuXG4gIGVuZm9yZXN0UGFyYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5mb3Jlc3RCaW5kaW5nRWxlbWVudCgpO1xuICB9XG5cbiAgZW5mb3Jlc3RVcGRhdGVFeHByZXNzaW9uKCkge1xuICAgIGxldCBvcGVyYXRvciA9IHRoaXMubWF0Y2hVbmFyeU9wZXJhdG9yKCk7XG5cbiAgICByZXR1cm4gbmV3IFQuVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICBpc1ByZWZpeDogZmFsc2UsXG4gICAgICBvcGVyYXRvcjogb3BlcmF0b3IudmFsKCksXG4gICAgICBvcGVyYW5kOiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmcodGhpcy50ZXJtKVxuICAgIH0pO1xuICB9XG5cbiAgZW5mb3Jlc3RVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgbGV0IG9wZXJhdG9yID0gdGhpcy5tYXRjaFVuYXJ5T3BlcmF0b3IoKTtcbiAgICB0aGlzLm9wQ3R4LnN0YWNrID0gdGhpcy5vcEN0eC5zdGFjay5wdXNoKHtcbiAgICAgIHByZWM6IHRoaXMub3BDdHgucHJlYyxcbiAgICAgIGNvbWJpbmU6IHRoaXMub3BDdHguY29tYmluZVxuICAgIH0pO1xuICAgIC8vIFRPRE86IGFsbCBidWlsdGlucyBhcmUgMTQsIGN1c3RvbSBvcGVyYXRvcnMgd2lsbCBjaGFuZ2UgdGhpc1xuICAgIHRoaXMub3BDdHgucHJlYyA9IDE0O1xuICAgIHRoaXMub3BDdHguY29tYmluZSA9IHJpZ2h0VGVybSA9PiB7XG4gICAgICBpZiAob3BlcmF0b3IudmFsKCkgPT09ICcrKycgfHwgb3BlcmF0b3IudmFsKCkgPT09ICctLScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBULlVwZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvci52YWwoKSxcbiAgICAgICAgICBvcGVyYW5kOiB0aGlzLnRyYW5zZm9ybURlc3RydWN0dXJpbmcocmlnaHRUZXJtKSxcbiAgICAgICAgICBpc1ByZWZpeDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVC5VbmFyeUV4cHJlc3Npb24oe1xuICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvci52YWwoKSxcbiAgICAgICAgICBvcGVyYW5kOiByaWdodFRlcm1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRVhQUl9MT09QX09QRVJBVE9SO1xuICB9XG5cbiAgZW5mb3Jlc3RDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgLy8gZmlyc3QsIHBvcCB0aGUgb3BlcmF0b3Igc3RhY2tcbiAgICBsZXQgdGVzdCA9IHRoaXMub3BDdHguY29tYmluZSh0aGlzLnRlcm0pO1xuICAgIGlmICh0aGlzLm9wQ3R4LnN0YWNrLnNpemUgPiAwKSB7XG4gICAgICBsZXQgeyBwcmVjLCBjb21iaW5lIH0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgIHRoaXMub3BDdHguc3RhY2sgPSB0aGlzLm9wQ3R4LnN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgIHRoaXMub3BDdHguY29tYmluZSA9IGNvbWJpbmU7XG4gICAgfVxuXG4gICAgdGhpcy5tYXRjaFB1bmN0dWF0b3IoJz8nKTtcbiAgICBsZXQgZW5mID0gbmV3IEVuZm9yZXN0ZXIodGhpcy5yZXN0LCBMaXN0KCksIHRoaXMuY29udGV4dCk7XG4gICAgbGV0IGNvbnNlcXVlbnQgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIGVuZi5tYXRjaFB1bmN0dWF0b3IoJzonKTtcbiAgICBlbmYgPSBuZXcgRW5mb3Jlc3RlcihlbmYucmVzdCwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIGxldCBhbHRlcm5hdGUgPSBlbmYuZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCgpO1xuICAgIHRoaXMucmVzdCA9IGVuZi5yZXN0O1xuICAgIHJldHVybiBuZXcgVC5Db25kaXRpb25hbEV4cHJlc3Npb24oe1xuICAgICAgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlXG4gICAgfSk7XG4gIH1cblxuICBlbmZvcmVzdEJpbmFyeUV4cHJlc3Npb24oKSB7XG5cbiAgICBsZXQgbGVmdFRlcm0gPSB0aGlzLnRlcm07XG4gICAgbGV0IG9wU3R4ID0gdGhpcy5wZWVrKCk7XG5cbiAgICBpZiAoKG9wU3R4IGluc3RhbmNlb2YgVC5SYXdTeW50YXgpICYmXG4gICAgICAgIG9wZXJhdG9yTHQodGhpcy5vcEN0eC5wcmVjLFxuICAgICAgICAgICAgICAgICAgIGdldE9wZXJhdG9yUHJlYyhvcFN0eC52YWx1ZS52YWwoKSksXG4gICAgICAgICAgICAgICAgICAgZ2V0T3BlcmF0b3JBc3NvYyhvcFN0eC52YWx1ZS52YWwoKSkpKSB7XG4gICAgICBsZXQgb3AgPSBvcFN0eC52YWx1ZTtcbiAgICAgIHRoaXMub3BDdHguc3RhY2sgPSB0aGlzLm9wQ3R4LnN0YWNrLnB1c2goe1xuICAgICAgICBwcmVjOiB0aGlzLm9wQ3R4LnByZWMsXG4gICAgICAgIGNvbWJpbmU6IHRoaXMub3BDdHguY29tYmluZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wQ3R4LnByZWMgPSBnZXRPcGVyYXRvclByZWMob3AudmFsKCkpO1xuICAgICAgdGhpcy5vcEN0eC5jb21iaW5lID0gKHJpZ2h0VGVybSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFQuQmluYXJ5RXhwcmVzc2lvbih7XG4gICAgICAgICAgbGVmdDogbGVmdFRlcm0sXG4gICAgICAgICAgb3BlcmF0b3I6IG9wLnZhbCgpLFxuICAgICAgICAgIHJpZ2h0OiByaWdodFRlcm1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gRVhQUl9MT09QX09QRVJBVE9SO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGVybSA9IHRoaXMub3BDdHguY29tYmluZShsZWZ0VGVybSk7XG4gICAgICAvLyB0aGlzLnJlc3QgZG9lcyBub3QgY2hhbmdlXG4gICAgICBsZXQgeyBwcmVjLCBjb21iaW5lIH0gPSB0aGlzLm9wQ3R4LnN0YWNrLmxhc3QoKTtcbiAgICAgIHRoaXMub3BDdHguc3RhY2sgPSB0aGlzLm9wQ3R4LnN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5vcEN0eC5wcmVjID0gcHJlYztcbiAgICAgIHRoaXMub3BDdHguY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gIH1cblxuICBlbmZvcmVzdFRlbXBsYXRlRWxlbWVudHMoKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMubWF0Y2hUZW1wbGF0ZSgpO1xuICAgIGxldCBlbGVtZW50cyA9IGxvb2thaGVhZC50b2tlbi5pdGVtcy5tYXAoaXQgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZWxpbWl0ZXIoaXQpKSB7XG4gICAgICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3RlcihpdC5pbm5lci5zbGljZSgxLCBpdC5pbm5lci5zaXplIC0gMSksIExpc3QoKSwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGVuZi5lbmZvcmVzdCgnZXhwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBULlRlbXBsYXRlRWxlbWVudCh7XG4gICAgICAgIHJhd1ZhbHVlOiBpdC5zbGljZS50ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICBleHBhbmRNYWNybygpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgd2hpbGUgKHRoaXMuaXNDb21waWxldGltZVRyYW5zZm9ybShsb29rYWhlYWQpKSB7XG4gICAgICBsZXQgbmFtZSA9IHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcblxuICAgICAgbGV0IHN5bnRheFRyYW5zZm9ybSA9IHRoaXMuZ2V0RnJvbUNvbXBpbGV0aW1lRW52aXJvbm1lbnQobmFtZSk7XG4gICAgICBpZiAoc3ludGF4VHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihuYW1lLCBgVGhlIG1hY3JvICR7bmFtZS5yZXNvbHZlKHRoaXMuY29udGV4dC5waGFzZSl9IGRvZXMgbm90IGhhdmUgYSBib3VuZCB2YWx1ZWApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ludGF4VHJhbnNmb3JtLnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZSwgYFRoZSBtYWNybyAke25hbWUucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpfSB3YXMgbm90IGJvdW5kIHRvIGEgY2FsbGFibGUgdmFsdWU6ICR7c3ludGF4VHJhbnNmb3JtLnZhbHVlfWApO1xuICAgICAgfVxuICAgICAgbGV0IHVzZVNpdGVTY29wZSA9IGZyZXNoU2NvcGUoJ3UnKTtcbiAgICAgIGxldCBpbnRyb2R1Y2VkU2NvcGUgPSBmcmVzaFNjb3BlKCdpJyk7XG4gICAgICAvLyBUT0RPOiBuZWVkcyB0byBiZSBhIGxpc3Qgb2Ygc2NvcGVzIEkgdGhpbmtcbiAgICAgIHRoaXMuY29udGV4dC51c2VTY29wZSA9IHVzZVNpdGVTY29wZTtcblxuICAgICAgbGV0IGN0eCA9IG5ldyBNYWNyb0NvbnRleHQodGhpcywgbmFtZSwgdGhpcy5jb250ZXh0LCB1c2VTaXRlU2NvcGUsIGludHJvZHVjZWRTY29wZSk7XG5cbiAgICAgIGxldCByZXN1bHQgPSBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKHN5bnRheFRyYW5zZm9ybS52YWx1ZS5jYWxsKG51bGwsIGN0eCkpO1xuICAgICAgaWYgKCFMaXN0LmlzTGlzdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZSwgJ21hY3JvIG11c3QgcmV0dXJuIGEgbGlzdCBidXQgZ290OiAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGxldCBzY29wZVJlZHVjZXIgPSBuZXcgU2NvcGVSZWR1Y2VyKFt7c2NvcGU6IGludHJvZHVjZWRTY29wZSwgcGhhc2U6IEFMTF9QSEFTRVMsIGZsaXA6IHRydWV9XSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCB0cnVlKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAodGVybXMgPT4ge1xuICAgICAgICBpZiAodGVybXMgaW5zdGFuY2VvZiBTeW50YXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFQuUmF3U3ludGF4KHtcbiAgICAgICAgICAgIHZhbHVlOiB0ZXJtc1xuICAgICAgICAgIH0pLnJlZHVjZShzY29wZVJlZHVjZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKCEodGVybXMgaW5zdGFuY2VvZiBUZXJtKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobmFtZSwgJ21hY3JvIG11c3QgcmV0dXJuIHN5bnRheCBvYmplY3RzIG9yIHRlcm1zIGJ1dCBnb3Q6ICcgKyB0ZXJtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlcm1zLnJlZHVjZShzY29wZVJlZHVjZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucmVzdCA9IHJlc3VsdC5jb25jYXQoY3R4Ll9yZXN0KHRoaXMpKTtcbiAgICAgIGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuXG4gICAgaWYgKGxvb2thaGVhZCAmJiB0aGlzLmlzUHVuY3R1YXRvcihsb29rYWhlYWQsICc7JykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN1bWVDb21tYSgpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG5cbiAgICBpZiAobG9va2FoZWFkICYmIHRoaXMuaXNQdW5jdHVhdG9yKGxvb2thaGVhZCwgJywnKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgc2FmZUNoZWNrKG9iajogU3ludGF4IHwgVGVybSwgdHlwZTogYW55LCB2YWw6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRlcm0pIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBULlJhd1N5bnRheCkge1xuICAgICAgICByZXR1cm4gb2JqLnZhbHVlICYmICh0eXBlb2Ygb2JqLnZhbHVlLm1hdGNoID09PSAnZnVuY3Rpb24nID8gb2JqLnZhbHVlLm1hdGNoKHR5cGUsIHZhbCkgOiBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFQuUmF3RGVsaW1pdGVyKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnZGVsaW1pdGVyJyB8fCBvYmoua2luZCA9PT0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iai5tYXRjaCA9PT0gJ2Z1bmN0aW9uJyA/IG9iai5tYXRjaCh0eXBlLCB2YWwpIDogZmFsc2UpO1xuICB9XG5cbiAgaXNUZXJtKHRlcm06IGFueSkge1xuICAgIHJldHVybiB0ZXJtICYmICh0ZXJtIGluc3RhbmNlb2YgVGVybSk7XG4gIH1cblxuICBpc0VPRihvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlQ2hlY2sob2JqLCAnZW9mJyk7XG4gIH1cblxuICBpc0lkZW50aWZpZXIob2JqOiBTeW50YXggfCBUZXJtLCB2YWw6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ2lkZW50aWZpZXInLCB2YWwpO1xuICB9XG5cbiAgaXNQcm9wZXJ0eU5hbWUob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJZGVudGlmaWVyKG9iaikgfHwgdGhpcy5pc0tleXdvcmQob2JqKSB8fFxuICAgICAgICAgICB0aGlzLmlzTnVtZXJpY0xpdGVyYWwob2JqKSB8fCB0aGlzLmlzU3RyaW5nTGl0ZXJhbChvYmopIHx8IHRoaXMuaXNCcmFja2V0cyhvYmopO1xuICB9XG5cbiAgaXNOdW1lcmljTGl0ZXJhbChvYmo6IFN5bnRheCB8IFRlcm0sIHZhbDogP3N0cmluZyA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlQ2hlY2sob2JqLCAnbnVtYmVyJywgdmFsKTtcbiAgfVxuXG4gIGlzU3RyaW5nTGl0ZXJhbChvYmo6IFN5bnRheCB8IFRlcm0sIHZhbDogP3N0cmluZyA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlQ2hlY2sob2JqLCAnc3RyaW5nJywgdmFsKTtcbiAgfVxuXG4gIGlzVGVtcGxhdGUob2JqOiBTeW50YXggfCBUZXJtLCB2YWw6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ3RlbXBsYXRlJywgdmFsKTtcbiAgfVxuXG4gIGlzU3ludGF4VGVtcGxhdGUob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ3N5bnRheFRlbXBsYXRlJyk7XG4gIH1cblxuICBpc0Jvb2xlYW5MaXRlcmFsKG9iajogU3ludGF4IHwgVGVybSwgdmFsOiA/c3RyaW5nID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVDaGVjayhvYmosICdib29sZWFuJywgdmFsKTtcbiAgfVxuXG4gIGlzTnVsbExpdGVyYWwob2JqOiBTeW50YXggfCBUZXJtLCB2YWw6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ251bGwnLCB2YWwpO1xuICB9XG5cbiAgaXNSZWd1bGFyRXhwcmVzc2lvbihvYmo6IFN5bnRheCB8IFRlcm0sIHZhbDogP3N0cmluZyA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlQ2hlY2sob2JqLCAncmVndWxhckV4cHJlc3Npb24nLCB2YWwpO1xuICB9XG5cbiAgaXNEZWxpbWl0ZXIob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ2RlbGltaXRlcicpO1xuICB9XG5cbiAgaXNQYXJlbnMob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ3BhcmVucycpO1xuICB9XG5cbiAgaXNCcmFjZXMob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ2JyYWNlcycpO1xuICB9XG5cbiAgaXNCcmFja2V0cyhvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlQ2hlY2sob2JqLCAnYnJhY2tldHMnKTtcbiAgfVxuXG4gIGlzQXNzaWduKG9iajogU3ludGF4IHwgVGVybSwgdmFsOiA/c3RyaW5nID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVDaGVjayhvYmosICdhc3NpZ24nLCB2YWwpO1xuICB9XG5cblxuICBpc0tleXdvcmQob2JqOiBTeW50YXggfCBUZXJtLCB2YWw6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ2tleXdvcmQnLCB2YWwpO1xuICB9XG5cbiAgaXNQdW5jdHVhdG9yKG9iajogU3ludGF4IHwgVGVybSwgdmFsOiA/c3RyaW5nID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVDaGVjayhvYmosICdwdW5jdHVhdG9yJywgdmFsKTtcbiAgfVxuXG4gIGlzT3BlcmF0b3Iob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuICh0aGlzLnNhZmVDaGVjayhvYmosICdwdW5jdHVhdG9yJykgfHxcbiAgICAgICAgICAgIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ2lkZW50aWZpZXInKSB8fFxuICAgICAgICAgICAgdGhpcy5zYWZlQ2hlY2sob2JqLCAna2V5d29yZCcpKSAmJlxuICAgICAgICAgICAgKChvYmogaW5zdGFuY2VvZiBULlJhd1N5bnRheCAmJiBpc09wZXJhdG9yKG9iai52YWx1ZSkpIHx8XG4gICAgICAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFN5bnRheCAmJiBpc09wZXJhdG9yKG9iaikpKTtcbiAgfVxuXG4gIGlzVXBkYXRlT3BlcmF0b3Iob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZUNoZWNrKG9iaiwgJ3B1bmN0dWF0b3InLCAnKysnKSB8fFxuICAgICAgICAgICB0aGlzLnNhZmVDaGVjayhvYmosICdwdW5jdHVhdG9yJywgJy0tJyk7XG4gIH1cblxuICBzYWZlUmVzb2x2ZShvYmo6IFN5bnRheCB8IFRlcm0sIHBoYXNlOiBudW1iZXIgfCB7fSkge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBULlJhd1N5bnRheCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoudmFsdWUucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJyA/IEp1c3Qob2JqLnZhbHVlLnJlc29sdmUocGhhc2UpKSA6IE5vdGhpbmcoKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFN5bnRheCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJyA/IEp1c3Qob2JqLnJlc29sdmUocGhhc2UpKSA6IE5vdGhpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIE5vdGhpbmcoKTtcbiAgfVxuXG4gIGlzVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSwgdHJhbnM6IGFueSkge1xuICAgIHJldHVybiB0aGlzLnNhZmVSZXNvbHZlKG9iaiwgdGhpcy5jb250ZXh0LnBoYXNlKVxuICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHRoaXMuY29udGV4dC5lbnYuZ2V0KG5hbWUpID09PSB0cmFucyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdG9yZS5nZXQobmFtZSkgPT09IHRyYW5zKVxuICAgICAgICAgICAgICAgLmdldE9yRWxzZShmYWxzZSk7XG4gIH1cblxuICBpc1RyYW5zZm9ybUluc3RhbmNlKG9iajogU3ludGF4IHwgVGVybSwgdHJhbnM6IGFueSkge1xuICAgIHJldHVybiB0aGlzLnNhZmVSZXNvbHZlKG9iaiwgdGhpcy5jb250ZXh0LnBoYXNlKVxuICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHRoaXMuY29udGV4dC5lbnYuZ2V0KG5hbWUpIGluc3RhbmNlb2YgdHJhbnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RvcmUuZ2V0KG5hbWUpIGluc3RhbmNlb2YgdHJhbnMpXG4gICAgICAgICAgICAgICAuZ2V0T3JFbHNlKGZhbHNlKTtcbiAgfVxuXG4gIGlzRm5EZWNsVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgRnVuY3Rpb25EZWNsVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzVmFyRGVjbFRyYW5zZm9ybShvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5pc1RyYW5zZm9ybShvYmosIFZhcmlhYmxlRGVjbFRyYW5zZm9ybSk7XG4gIH1cblxuICBpc0xldERlY2xUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBMZXREZWNsVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzQ29uc3REZWNsVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgQ29uc3REZWNsVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzU3ludGF4RGVjbFRyYW5zZm9ybShvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5pc1RyYW5zZm9ybShvYmosIFN5bnRheERlY2xUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNTeW50YXhyZWNEZWNsVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgU3ludGF4cmVjRGVjbFRyYW5zZm9ybSk7XG4gIH1cblxuICBpc1JldHVyblN0bXRUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBSZXR1cm5TdGF0ZW1lbnRUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNXaGlsZVRyYW5zZm9ybShvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5pc1RyYW5zZm9ybShvYmosIFdoaWxlVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzRm9yVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgRm9yVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzU3dpdGNoVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgU3dpdGNoVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzQnJlYWtUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBCcmVha1RyYW5zZm9ybSk7XG4gIH1cblxuICBpc0NvbnRpbnVlVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgQ29udGludWVUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNEb1RyYW5zZm9ybShvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5pc1RyYW5zZm9ybShvYmosIERvVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzRGVidWdnZXJUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBEZWJ1Z2dlclRyYW5zZm9ybSk7XG4gIH1cblxuICBpc1dpdGhUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBXaXRoVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzVHJ5VHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgVHJ5VHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlzVGhyb3dUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBUaHJvd1RyYW5zZm9ybSk7XG4gIH1cblxuICBpc0lmVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtKG9iaiwgSWZUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNOZXdUcmFuc2Zvcm0ob2JqOiBTeW50YXggfCBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUcmFuc2Zvcm0ob2JqLCBOZXdUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNDb21waWxldGltZVRyYW5zZm9ybShvYmo6IFN5bnRheCB8IFRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5pc1RyYW5zZm9ybUluc3RhbmNlKG9iaiwgQ29tcGlsZXRpbWVUcmFuc2Zvcm0pO1xuICB9XG5cbiAgaXNWYXJCaW5kaW5nVHJhbnNmb3JtKG9iajogU3ludGF4IHwgVGVybSkge1xuICAgIHJldHVybiB0aGlzLmlzVHJhbnNmb3JtSW5zdGFuY2Uob2JqLCBWYXJCaW5kaW5nVHJhbnNmb3JtKTtcbiAgfVxuXG4gIGdldEZyb21Db21waWxldGltZUVudmlyb25tZW50KHRlcm06IFN5bnRheCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQuZW52Lmhhcyh0ZXJtLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZW52LmdldCh0ZXJtLnJlc29sdmUodGhpcy5jb250ZXh0LnBoYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3RvcmUuZ2V0KHRlcm0ucmVzb2x2ZSh0aGlzLmNvbnRleHQucGhhc2UpKTtcbiAgfVxuXG4gIGxpbmVOdW1iZXJFcShhOiA/KFQuVGVybSB8IFN5bnRheCksIGI6ID8oU3ludGF4IHwgVC5UZXJtKSkge1xuICAgIGlmICghKGEgJiYgYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldExpbmVOdW1iZXIoYSkgPT09IGdldExpbmVOdW1iZXIoYik7XG4gIH1cblxuICBtYXRjaFJhd0RlbGltaXRlcigpOiBMaXN0PFQuU3ludGF4VGVybT4ge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAobG9va2FoZWFkIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQuaW5uZXI7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIGEgUmF3RGVsaW1pdGVyJyk7XG4gIH1cblxuICBtYXRjaFJhd1N5bnRheCgpOiBTeW50YXgge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLmFkdmFuY2UoKTtcbiAgICBpZiAobG9va2FoZWFkIGluc3RhbmNlb2YgVC5SYXdTeW50YXgpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudmFsdWU7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIGEgUmF3U3ludGF4Jyk7XG4gIH1cblxuICBtYXRjaElkZW50aWZpZXIodmFsPzogc3RyaW5nKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzSWRlbnRpZmllcihsb29rYWhlYWQsIHZhbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIGFuIGlkZW50aWZpZXInKTtcbiAgfVxuXG4gIG1hdGNoS2V5d29yZCh2YWw6IHN0cmluZykge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0tleXdvcmQobG9va2FoZWFkLCB2YWwpKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyAnICsgdmFsKTtcbiAgfVxuXG4gIG1hdGNoTGl0ZXJhbCgpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNOdW1lcmljTGl0ZXJhbChsb29rYWhlYWQpIHx8XG4gICAgICAgIHRoaXMuaXNTdHJpbmdMaXRlcmFsKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc0Jvb2xlYW5MaXRlcmFsKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc051bGxMaXRlcmFsKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlKGxvb2thaGVhZCkgfHxcbiAgICAgICAgdGhpcy5pc1JlZ3VsYXJFeHByZXNzaW9uKGxvb2thaGVhZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoUmF3U3ludGF4KCk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIGEgbGl0ZXJhbCcpO1xuICB9XG5cbiAgbWF0Y2hTdHJpbmdMaXRlcmFsKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc1N0cmluZ0xpdGVyYWwobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihsb29rYWhlYWQsICdleHBlY3RpbmcgYSBzdHJpbmcgbGl0ZXJhbCcpO1xuICB9XG5cbiAgbWF0Y2hUZW1wbGF0ZSgpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKHRoaXMuaXNUZW1wbGF0ZShsb29rYWhlYWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyBhIHRlbXBsYXRlIGxpdGVyYWwnKTtcbiAgfVxuXG4gIG1hdGNoUGFyZW5zKCk6IExpc3Q8VC5TeW50YXhUZXJtPiB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMucGVlaygpO1xuICAgIGlmICh0aGlzLmlzUGFyZW5zKGxvb2thaGVhZCkpIHtcbiAgICAgIGxldCBpbm5lciA9IHRoaXMubWF0Y2hSYXdEZWxpbWl0ZXIoKTtcbiAgICAgIHJldHVybiBpbm5lci5zbGljZSgxLCBpbm5lci5zaXplIC0gMSk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIHBhcmVucycpO1xuICB9XG5cbiAgbWF0Y2hDdXJsaWVzKCkge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNlcyhsb29rYWhlYWQpKSB7XG4gICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hdGNoUmF3RGVsaW1pdGVyKCk7XG4gICAgICByZXR1cm4gaW5uZXIuc2xpY2UoMSwgaW5uZXIuc2l6ZSAtIDEpO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyBjdXJseSBicmFjZXMnKTtcbiAgfVxuXG4gIG1hdGNoU3F1YXJlcygpOiBMaXN0PFQuU3ludGF4VGVybT4ge1xuICAgIGxldCBsb29rYWhlYWQgPSB0aGlzLnBlZWsoKTtcbiAgICBpZiAodGhpcy5pc0JyYWNrZXRzKGxvb2thaGVhZCkpIHtcbiAgICAgIGxldCBpbm5lciA9IHRoaXMubWF0Y2hSYXdEZWxpbWl0ZXIoKTtcbiAgICAgIHJldHVybiBpbm5lci5zbGljZSgxLCBpbm5lci5zaXplIC0gMSk7XG4gICAgfVxuICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IobG9va2FoZWFkLCAnZXhwZWN0aW5nIHNxdWFyZSBicmFjZXMnKTtcbiAgfVxuXG4gIG1hdGNoVW5hcnlPcGVyYXRvcigpIHtcbiAgICBsZXQgbG9va2FoZWFkID0gdGhpcy5tYXRjaFJhd1N5bnRheCgpO1xuICAgIGlmIChpc1VuYXJ5T3BlcmF0b3IobG9va2FoZWFkKSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZDtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihsb29rYWhlYWQsICdleHBlY3RpbmcgYSB1bmFyeSBvcGVyYXRvcicpO1xuICB9XG5cbiAgbWF0Y2hQdW5jdHVhdG9yKHZhbDogc3RyaW5nKSB7XG4gICAgbGV0IGxvb2thaGVhZCA9IHRoaXMubWF0Y2hSYXdTeW50YXgoKTtcbiAgICBpZiAodGhpcy5pc1B1bmN0dWF0b3IobG9va2FoZWFkKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChsb29rYWhlYWQudmFsKCkgPT09IHZhbCkge1xuICAgICAgICAgIHJldHVybiBsb29rYWhlYWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihsb29rYWhlYWQsXG4gICAgICAgICAgICAnZXhwZWN0aW5nIGEgJyArIHZhbCArICcgcHVuY3R1YXRvcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9va2FoZWFkO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGxvb2thaGVhZCwgJ2V4cGVjdGluZyBhIHB1bmN0dWF0b3InKTtcbiAgfVxuXG4gIGNyZWF0ZUVycm9yKHN0eDogU3ludGF4IHwgVGVybSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgbGV0IGN0eCA9ICcnO1xuICAgIGxldCBvZmZlbmRpbmcgPSBzdHg7XG4gICAgaWYgKHRoaXMucmVzdC5zaXplID4gMCkge1xuICAgICAgY3R4ID0gdGhpcy5yZXN0LnNsaWNlKDAsIDIwKS5tYXAodGVybSA9PiB7XG4gICAgICAgIGlmICh0ZXJtIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGVybS5pbm5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTGlzdC5vZih0ZXJtKTtcbiAgICAgIH0pLmZsYXR0ZW4oKS5tYXAocyA9PiB7XG4gICAgICAgIGxldCBzdmFsID0gcyBpbnN0YW5jZW9mIFQuUmF3U3ludGF4ID8gcy52YWx1ZS52YWwoKSA6IHMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHMgPT09IG9mZmVuZGluZykge1xuICAgICAgICAgIHJldHVybiAnX18nICsgc3ZhbCArICdfXyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN2YWw7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eCA9IG9mZmVuZGluZy50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UgKyAnXFxuJyArIGN0eCk7XG5cbiAgfVxufVxuIl19

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.default = class extends S.default.CloneReducer {

	  constructor(scopes, bindings) {
	    super();
	    this.scopes = scopes;
	    this.bindings = bindings;
	  }

	  applyScopes(s) {
	    return this.scopes.reduce((acc, sc) => {
	      return acc.addScope(sc.scope, this.bindings, sc.phase, { flip: sc.flip });
	    }, s);
	  }

	  reduceBindingIdentifier(t, s) {
	    return new S.BindingIdentifier({
	      name: this.applyScopes(s.name)
	    });
	  }

	  reduceIdentifierExpression(t, s) {
	    return new S.IdentifierExpression({
	      name: this.applyScopes(s.name)
	    });
	  }

	  reduceRawSyntax(t, s) {
	    // TODO: fix this once reading tokens is reasonable
	    if (s.value.isTemplate()) {
	      s.value.token.items = s.value.token.items.map(t => {
	        if (t instanceof S.default) {
	          return t.reduce(this);
	        }
	        return t;
	      });
	    }
	    return new S.RawSyntax({
	      value: this.applyScopes(s.value)
	    });
	  }
	};
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY29wZS1yZWR1Y2VyLmpzIl0sIm5hbWVzIjpbIlMiLCJDbG9uZVJlZHVjZXIiLCJjb25zdHJ1Y3RvciIsInNjb3BlcyIsImJpbmRpbmdzIiwiYXBwbHlTY29wZXMiLCJzIiwicmVkdWNlIiwiYWNjIiwic2MiLCJhZGRTY29wZSIsInNjb3BlIiwicGhhc2UiLCJmbGlwIiwicmVkdWNlQmluZGluZ0lkZW50aWZpZXIiLCJ0IiwiQmluZGluZ0lkZW50aWZpZXIiLCJuYW1lIiwicmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24iLCJJZGVudGlmaWVyRXhwcmVzc2lvbiIsInJlZHVjZVJhd1N5bnRheCIsInZhbHVlIiwiaXNUZW1wbGF0ZSIsInRva2VuIiwiaXRlbXMiLCJtYXAiLCJSYXdTeW50YXgiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOztJQUFrQkEsQzs7OztrQkFLSCxjQUxHQSxDQUtXLFNBQUtDLFlBQW5CLENBQWdDOztBQUk3Q0MsY0FBWUMsTUFBWixFQUFzRkMsUUFBdEYsRUFBNEc7QUFDMUc7QUFDQSxTQUFLRCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNEOztBQUVEQyxjQUFZQyxDQUFaLEVBQXVCO0FBQ3JCLFdBQU8sS0FBS0gsTUFBTCxDQUFZSSxNQUFaLENBQW1CLENBQUNDLEdBQUQsRUFBTUMsRUFBTixLQUFhO0FBQ3JDLGFBQU9ELElBQUlFLFFBQUosQ0FBYUQsR0FBR0UsS0FBaEIsRUFBdUIsS0FBS1AsUUFBNUIsRUFBc0NLLEdBQUdHLEtBQXpDLEVBQWdELEVBQUVDLE1BQU1KLEdBQUdJLElBQVgsRUFBaEQsQ0FBUDtBQUNELEtBRk0sRUFFSlAsQ0FGSSxDQUFQO0FBR0Q7O0FBRURRLDBCQUF3QkMsQ0FBeEIsRUFBaUNULENBQWpDLEVBQXNEO0FBQ3BELFdBQU8sSUFBSU4sRUFBRWdCLGlCQUFOLENBQXdCO0FBQzdCQyxZQUFNLEtBQUtaLFdBQUwsQ0FBaUJDLEVBQUVXLElBQW5CO0FBRHVCLEtBQXhCLENBQVA7QUFHRDs7QUFFREMsNkJBQTJCSCxDQUEzQixFQUFvQ1QsQ0FBcEMsRUFBeUQ7QUFDdkQsV0FBTyxJQUFJTixFQUFFbUIsb0JBQU4sQ0FBMkI7QUFDaENGLFlBQU0sS0FBS1osV0FBTCxDQUFpQkMsRUFBRVcsSUFBbkI7QUFEMEIsS0FBM0IsQ0FBUDtBQUdEOztBQUVERyxrQkFBZ0JMLENBQWhCLEVBQXlCVCxDQUF6QixFQUErQztBQUM3QztBQUNBLFFBQUlBLEVBQUVlLEtBQUYsQ0FBUUMsVUFBUixFQUFKLEVBQTBCO0FBQ3hCaEIsUUFBRWUsS0FBRixDQUFRRSxLQUFSLENBQWNDLEtBQWQsR0FBc0JsQixFQUFFZSxLQUFGLENBQVFFLEtBQVIsQ0FBY0MsS0FBZCxDQUFvQkMsR0FBcEIsQ0FBd0JWLEtBQUs7QUFDakQsWUFBSUEsYUFyQ01mLENBcUNOLFFBQUosRUFBdUI7QUFDckIsaUJBQU9lLEVBQUVSLE1BQUYsQ0FBUyxJQUFULENBQVA7QUFDRDtBQUNELGVBQU9RLENBQVA7QUFDRCxPQUxxQixDQUF0QjtBQU1EO0FBQ0QsV0FBTyxJQUFJZixFQUFFMEIsU0FBTixDQUFnQjtBQUNyQkwsYUFBTyxLQUFLaEIsV0FBTCxDQUFpQkMsRUFBRWUsS0FBbkI7QUFEYyxLQUFoQixDQUFQO0FBR0Q7QUF6QzRDLEMiLCJmaWxlIjoic2NvcGUtcmVkdWNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgVGVybSwgKiBhcyBTIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0IHR5cGUgU3ludGF4IGZyb20gJy4vc3ludGF4JztcbmltcG9ydCB0eXBlIHsgU3ltYm9sQ2xhc3MgfSBmcm9tICcuL3N5bWJvbCc7XG5pbXBvcnQgdHlwZSBCaW5kaW5nTWFwIGZyb20gJy4vYmluZGluZy1tYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFRlcm0uQ2xvbmVSZWR1Y2VyIHtcbiAgc2NvcGVzOiBBcnJheTx7IHNjb3BlOiBTeW1ib2xDbGFzcywgcGhhc2U6IG51bWJlciB8IHt9LCBmbGlwOiBib29sZWFuIH0+O1xuICBiaW5kaW5nczogQmluZGluZ01hcDtcblxuICBjb25zdHJ1Y3RvcihzY29wZXM6IEFycmF5PHsgc2NvcGU6IFN5bWJvbENsYXNzLCBwaGFzZTogbnVtYmVyIHwge30sIGZsaXA6IGJvb2xlYW4gfT4sIGJpbmRpbmdzOiBCaW5kaW5nTWFwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjb3BlcyA9IHNjb3BlcztcbiAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gIH1cblxuICBhcHBseVNjb3BlcyhzOiBTeW50YXgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZXMucmVkdWNlKChhY2MsIHNjKSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmFkZFNjb3BlKHNjLnNjb3BlLCB0aGlzLmJpbmRpbmdzLCBzYy5waGFzZSwgeyBmbGlwOiBzYy5mbGlwIH0pO1xuICAgIH0sIHMpO1xuICB9XG5cbiAgcmVkdWNlQmluZGluZ0lkZW50aWZpZXIodDogVGVybSwgczogeyBuYW1lOiBTeW50YXggfSkge1xuICAgIHJldHVybiBuZXcgUy5CaW5kaW5nSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiB0aGlzLmFwcGx5U2NvcGVzKHMubmFtZSlcbiAgICB9KTtcbiAgfVxuXG4gIHJlZHVjZUlkZW50aWZpZXJFeHByZXNzaW9uKHQ6IFRlcm0sIHM6IHsgbmFtZTogU3ludGF4IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuSWRlbnRpZmllckV4cHJlc3Npb24oe1xuICAgICAgbmFtZTogdGhpcy5hcHBseVNjb3BlcyhzLm5hbWUpXG4gICAgfSk7XG4gIH1cblxuICByZWR1Y2VSYXdTeW50YXgodDogVGVybSwgczogeyB2YWx1ZTogU3ludGF4IH0pIHtcbiAgICAvLyBUT0RPOiBmaXggdGhpcyBvbmNlIHJlYWRpbmcgdG9rZW5zIGlzIHJlYXNvbmFibGVcbiAgICBpZiAocy52YWx1ZS5pc1RlbXBsYXRlKCkpIHtcbiAgICAgIHMudmFsdWUudG9rZW4uaXRlbXMgPSBzLnZhbHVlLnRva2VuLml0ZW1zLm1hcCh0ID0+IHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBUZXJtKSB7XG4gICAgICAgICAgcmV0dXJuIHQucmVkdWNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUy5SYXdTeW50YXgoe1xuICAgICAgdmFsdWU6IHRoaXMuYXBwbHlTY29wZXMocy52YWx1ZSlcbiAgICB9KTtcbiAgfVxufVxuIl19

/***/ },
/* 51 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.operatorLt = operatorLt;
	exports.getOperatorPrec = getOperatorPrec;
	exports.getOperatorAssoc = getOperatorAssoc;
	exports.isUnaryOperator = isUnaryOperator;
	exports.isOperator = isOperator;
	const unaryOperators = {
	  '+': true,
	  '-': true,
	  '!': true,
	  '~': true,
	  '++': true,
	  '--': true,
	  'typeof': true,
	  'void': true,
	  'delete': true
	};
	const binaryOperatorPrecedence = {
	  '*': 13,
	  '/': 13,
	  '%': 13,
	  '+': 12,
	  '-': 12,
	  '>>': 11,
	  '<<': 11,
	  '>>>': 11,
	  '<': 10,
	  '<=': 10,
	  '>': 10,
	  '>=': 10,
	  'in': 10,
	  'instanceof': 10,
	  '==': 9,
	  '!=': 9,
	  '===': 9,
	  '!==': 9,
	  '&': 8,
	  '^': 7,
	  '|': 6,
	  '&&': 5,
	  '||': 4
	};

	var operatorAssoc = {
	  '*': 'left',
	  '/': 'left',
	  '%': 'left',
	  '+': 'left',
	  '-': 'left',
	  '>>': 'left',
	  '<<': 'left',
	  '>>>': 'left',
	  '<': 'left',
	  '<=': 'left',
	  '>': 'left',
	  '>=': 'left',
	  'in': 'left',
	  'instanceof': 'left',
	  '==': 'left',
	  '!=': 'left',
	  '===': 'left',
	  '!==': 'left',
	  '&': 'left',
	  '^': 'left',
	  '|': 'left',
	  '&&': 'left',
	  '||': 'left'
	};

	function operatorLt(left, right, assoc) {
	  if (assoc === 'left') {
	    return left < right;
	  } else {
	    return left <= right;
	  }
	}

	function getOperatorPrec(op) {
	  return binaryOperatorPrecedence[op];
	}
	function getOperatorAssoc(op) {
	  return operatorAssoc[op];
	}

	function isUnaryOperator(op) {
	  return (op.match('punctuator') || op.match('identifier') || op.match('keyword')) && unaryOperators.hasOwnProperty(op.val());
	}

	function isOperator(op) {
	  if (op.match('punctuator') || op.match('identifier') || op.match('keyword')) {
	    return binaryOperatorPrecedence.hasOwnProperty(op) || unaryOperators.hasOwnProperty(op.val());
	  }
	  return false;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vcGVyYXRvcnMuanMiXSwibmFtZXMiOlsib3BlcmF0b3JMdCIsImdldE9wZXJhdG9yUHJlYyIsImdldE9wZXJhdG9yQXNzb2MiLCJpc1VuYXJ5T3BlcmF0b3IiLCJpc09wZXJhdG9yIiwidW5hcnlPcGVyYXRvcnMiLCJiaW5hcnlPcGVyYXRvclByZWNlZGVuY2UiLCJvcGVyYXRvckFzc29jIiwibGVmdCIsInJpZ2h0IiwiYXNzb2MiLCJvcCIsIm1hdGNoIiwiaGFzT3duUHJvcGVydHkiLCJ2YWwiXSwibWFwcGluZ3MiOiI7Ozs7O1FBK0RnQkEsVSxHQUFBQSxVO1FBUUFDLGUsR0FBQUEsZTtRQUdBQyxnQixHQUFBQSxnQjtRQUlBQyxlLEdBQUFBLGU7UUFLQUMsVSxHQUFBQSxVO0FBbkZoQixNQUFNQyxpQkFBaUI7QUFDckIsT0FBSyxJQURnQjtBQUVyQixPQUFLLElBRmdCO0FBR3JCLE9BQUssSUFIZ0I7QUFJckIsT0FBSyxJQUpnQjtBQUtyQixRQUFNLElBTGU7QUFNckIsUUFBTSxJQU5lO0FBT3JCLFlBQVUsSUFQVztBQVFyQixVQUFRLElBUmE7QUFTckIsWUFBVTtBQVRXLENBQXZCO0FBV0EsTUFBTUMsMkJBQTJCO0FBQy9CLE9BQUssRUFEMEI7QUFFL0IsT0FBSyxFQUYwQjtBQUcvQixPQUFLLEVBSDBCO0FBSS9CLE9BQUssRUFKMEI7QUFLL0IsT0FBSyxFQUwwQjtBQU0vQixRQUFNLEVBTnlCO0FBTy9CLFFBQU0sRUFQeUI7QUFRL0IsU0FBTyxFQVJ3QjtBQVMvQixPQUFLLEVBVDBCO0FBVS9CLFFBQU0sRUFWeUI7QUFXL0IsT0FBSyxFQVgwQjtBQVkvQixRQUFNLEVBWnlCO0FBYS9CLFFBQU0sRUFieUI7QUFjL0IsZ0JBQWMsRUFkaUI7QUFlL0IsUUFBTSxDQWZ5QjtBQWdCL0IsUUFBTSxDQWhCeUI7QUFpQi9CLFNBQU8sQ0FqQndCO0FBa0IvQixTQUFPLENBbEJ3QjtBQW1CL0IsT0FBSyxDQW5CMEI7QUFvQi9CLE9BQUssQ0FwQjBCO0FBcUIvQixPQUFLLENBckIwQjtBQXNCL0IsUUFBTSxDQXRCeUI7QUF1Qi9CLFFBQU07QUF2QnlCLENBQWpDOztBQTBCQSxJQUFJQyxnQkFBZ0I7QUFDbEIsT0FBSyxNQURhO0FBRWxCLE9BQUssTUFGYTtBQUdsQixPQUFLLE1BSGE7QUFJbEIsT0FBSyxNQUphO0FBS2xCLE9BQUssTUFMYTtBQU1sQixRQUFNLE1BTlk7QUFPbEIsUUFBTSxNQVBZO0FBUWxCLFNBQU8sTUFSVztBQVNsQixPQUFLLE1BVGE7QUFVbEIsUUFBTSxNQVZZO0FBV2xCLE9BQUssTUFYYTtBQVlsQixRQUFNLE1BWlk7QUFhbEIsUUFBTSxNQWJZO0FBY2xCLGdCQUFjLE1BZEk7QUFlbEIsUUFBTSxNQWZZO0FBZ0JsQixRQUFNLE1BaEJZO0FBaUJsQixTQUFPLE1BakJXO0FBa0JsQixTQUFPLE1BbEJXO0FBbUJsQixPQUFLLE1BbkJhO0FBb0JsQixPQUFLLE1BcEJhO0FBcUJsQixPQUFLLE1BckJhO0FBc0JsQixRQUFNLE1BdEJZO0FBdUJsQixRQUFNO0FBdkJZLENBQXBCOztBQTBCTyxTQUFTUCxVQUFULENBQW9CUSxJQUFwQixFQUEwQkMsS0FBMUIsRUFBaUNDLEtBQWpDLEVBQXdDO0FBQzdDLE1BQUlBLFVBQVUsTUFBZCxFQUFzQjtBQUNwQixXQUFPRixPQUFPQyxLQUFkO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0QsUUFBUUMsS0FBZjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU1IsZUFBVCxDQUF5QlUsRUFBekIsRUFBNkI7QUFDbEMsU0FBT0wseUJBQXlCSyxFQUF6QixDQUFQO0FBQ0Q7QUFDTSxTQUFTVCxnQkFBVCxDQUEwQlMsRUFBMUIsRUFBOEI7QUFDbkMsU0FBT0osY0FBY0ksRUFBZCxDQUFQO0FBQ0Q7O0FBRU0sU0FBU1IsZUFBVCxDQUF5QlEsRUFBekIsRUFBNkI7QUFDbEMsU0FBTyxDQUFDQSxHQUFHQyxLQUFILENBQVMsWUFBVCxLQUEwQkQsR0FBR0MsS0FBSCxDQUFTLFlBQVQsQ0FBMUIsSUFBb0RELEdBQUdDLEtBQUgsQ0FBUyxTQUFULENBQXJELEtBQ0RQLGVBQWVRLGNBQWYsQ0FBOEJGLEdBQUdHLEdBQUgsRUFBOUIsQ0FETjtBQUVEOztBQUVNLFNBQVNWLFVBQVQsQ0FBb0JPLEVBQXBCLEVBQXdCO0FBQzdCLE1BQUlBLEdBQUdDLEtBQUgsQ0FBUyxZQUFULEtBQTBCRCxHQUFHQyxLQUFILENBQVMsWUFBVCxDQUExQixJQUFvREQsR0FBR0MsS0FBSCxDQUFTLFNBQVQsQ0FBeEQsRUFBNkU7QUFDM0UsV0FBT04seUJBQXlCTyxjQUF6QixDQUF3Q0YsRUFBeEMsS0FBK0NOLGVBQWVRLGNBQWYsQ0FBOEJGLEdBQUdHLEdBQUgsRUFBOUIsQ0FBdEQ7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNEIiwiZmlsZSI6Im9wZXJhdG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHVuYXJ5T3BlcmF0b3JzID0ge1xuICAnKyc6IHRydWUsXG4gICctJzogdHJ1ZSxcbiAgJyEnOiB0cnVlLFxuICAnfic6IHRydWUsXG4gICcrKyc6IHRydWUsXG4gICctLSc6IHRydWUsXG4gICd0eXBlb2YnOiB0cnVlLFxuICAndm9pZCc6IHRydWUsXG4gICdkZWxldGUnOiB0cnVlLFxufTtcbmNvbnN0IGJpbmFyeU9wZXJhdG9yUHJlY2VkZW5jZSA9IHtcbiAgJyonOiAxMyxcbiAgJy8nOiAxMyxcbiAgJyUnOiAxMyxcbiAgJysnOiAxMixcbiAgJy0nOiAxMixcbiAgJz4+JzogMTEsXG4gICc8PCc6IDExLFxuICAnPj4+JzogMTEsXG4gICc8JzogMTAsXG4gICc8PSc6IDEwLFxuICAnPic6IDEwLFxuICAnPj0nOiAxMCxcbiAgJ2luJzogMTAsXG4gICdpbnN0YW5jZW9mJzogMTAsXG4gICc9PSc6IDksXG4gICchPSc6IDksXG4gICc9PT0nOiA5LFxuICAnIT09JzogOSxcbiAgJyYnOiA4LFxuICAnXic6IDcsXG4gICd8JzogNixcbiAgJyYmJzogNSxcbiAgJ3x8JzogNCxcbn07XG5cbnZhciBvcGVyYXRvckFzc29jID0ge1xuICAnKic6ICdsZWZ0JyxcbiAgJy8nOiAnbGVmdCcsXG4gICclJzogJ2xlZnQnLFxuICAnKyc6ICdsZWZ0JyxcbiAgJy0nOiAnbGVmdCcsXG4gICc+Pic6ICdsZWZ0JyxcbiAgJzw8JzogJ2xlZnQnLFxuICAnPj4+JzogJ2xlZnQnLFxuICAnPCc6ICdsZWZ0JyxcbiAgJzw9JzogJ2xlZnQnLFxuICAnPic6ICdsZWZ0JyxcbiAgJz49JzogJ2xlZnQnLFxuICAnaW4nOiAnbGVmdCcsXG4gICdpbnN0YW5jZW9mJzogJ2xlZnQnLFxuICAnPT0nOiAnbGVmdCcsXG4gICchPSc6ICdsZWZ0JyxcbiAgJz09PSc6ICdsZWZ0JyxcbiAgJyE9PSc6ICdsZWZ0JyxcbiAgJyYnOiAnbGVmdCcsXG4gICdeJzogJ2xlZnQnLFxuICAnfCc6ICdsZWZ0JyxcbiAgJyYmJzogJ2xlZnQnLFxuICAnfHwnOiAnbGVmdCcsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gb3BlcmF0b3JMdChsZWZ0LCByaWdodCwgYXNzb2MpIHtcbiAgaWYgKGFzc29jID09PSAnbGVmdCcpIHtcbiAgICByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsZWZ0IDw9IHJpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRvclByZWMob3ApIHtcbiAgcmV0dXJuIGJpbmFyeU9wZXJhdG9yUHJlY2VkZW5jZVtvcF07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0b3JBc3NvYyhvcCkge1xuICByZXR1cm4gb3BlcmF0b3JBc3NvY1tvcF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuYXJ5T3BlcmF0b3Iob3ApIHtcbiAgcmV0dXJuIChvcC5tYXRjaCgncHVuY3R1YXRvcicpIHx8IG9wLm1hdGNoKCdpZGVudGlmaWVyJykgfHwgb3AubWF0Y2goJ2tleXdvcmQnKSkgJiZcbiAgICAgICAgdW5hcnlPcGVyYXRvcnMuaGFzT3duUHJvcGVydHkob3AudmFsKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYXRvcihvcCkge1xuICBpZiAob3AubWF0Y2goJ3B1bmN0dWF0b3InKSB8fCBvcC5tYXRjaCgnaWRlbnRpZmllcicpIHx8IG9wLm1hdGNoKCdrZXl3b3JkJykpIHtcbiAgICByZXR1cm4gYmluYXJ5T3BlcmF0b3JQcmVjZWRlbmNlLmhhc093blByb3BlcnR5KG9wKSB8fCB1bmFyeU9wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShvcC52YWwoKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl19

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.expandCompiletime = expandCompiletime;
	exports.sanitizeReplacementValues = sanitizeReplacementValues;
	exports.evalRuntimeValues = evalRuntimeValues;
	exports.evalCompiletimeValue = evalCompiletimeValue;

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _immutable = __webpack_require__(10);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _shiftCodegen = __webpack_require__(53);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	var _terms = __webpack_require__(48);

	var _sweetToShiftReducer = __webpack_require__(63);

	var _sweetToShiftReducer2 = _interopRequireDefault(_sweetToShiftReducer);

	var _termExpander = __webpack_require__(47);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _env = __webpack_require__(44);

	var _env2 = _interopRequireDefault(_env);

	var _macroContext = __webpack_require__(64);

	var _templateProcessor = __webpack_require__(65);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function expandCompiletime(term, context) {
	  // each compiletime value needs to be expanded with a fresh
	  // environment and in the next higher phase
	  let syntaxExpander = new _termExpander2.default(_.merge(context, {
	    phase: context.phase + 1,
	    env: new _env2.default(),
	    store: context.store
	  }));

	  return syntaxExpander.expand(term);
	}

	function sanitizeReplacementValues(values) {
	  if (Array.isArray(values)) {
	    return sanitizeReplacementValues((0, _immutable.List)(values));
	  } else if (_immutable.List.isList(values)) {
	    return values.map(sanitizeReplacementValues);
	  } else if (values == null) {
	    throw new Error('replacement values for syntax template must not be null or undefined');
	  } else if (typeof values.next === 'function') {
	    return sanitizeReplacementValues((0, _immutable.List)(values));
	  }
	  return (0, _macroContext.unwrap)(values);
	}

	function evalRuntimeValues(terms, context) {
	  let prepped = terms.reduce((acc, term) => {
	    if ((0, _terms.isExport)(term)) {
	      if ((0, _terms.isVariableDeclaration)(term.declaration)) {
	        return acc.concat(new S.VariableDeclarationStatement({
	          declaration: term.declaration
	        })).concat(term.declaration.declarators.map(decl => {
	          return new S.ExpressionStatement({
	            expression: new S.AssignmentExpression({
	              binding: new S.StaticMemberExpression({
	                object: new S.IdentifierExpression({
	                  name: _syntax2.default.fromIdentifier('exports')
	                }),
	                property: decl.binding.name
	              }),
	              expression: new S.IdentifierExpression({
	                name: decl.binding.name
	              })
	            })
	          });
	        }));
	      } else if (term.declaration instanceof S.FunctionDeclaration) {
	        return acc.concat(term.declaration);
	      }
	    } else if ((0, _terms.isImport)(term)) {
	      return acc;
	    }
	    return acc.concat(term);
	  }, (0, _immutable.List)());

	  let parsed = new S.Module({
	    directives: (0, _immutable.List)(),
	    items: prepped
	  }).reduce(new _sweetToShiftReducer2.default(context.phase));

	  let gen = (0, _shiftCodegen2.default)(parsed, new _shiftCodegen.FormattedCodeGen());
	  let result = context.transform(gen);

	  let exportsObj = {};
	  context.store.set('exports', exportsObj);

	  context.loader.eval(result.code, context.store);
	  // vm.runInContext(result.code, context.store.getNodeContext());
	  return exportsObj;
	}

	// (Expression, Context) -> [function]
	function evalCompiletimeValue(expr, context) {
	  let sandbox = {
	    syntaxTemplate: function (ident, ...values) {
	      return (0, _templateProcessor.replaceTemplate)(context.templateMap.get(ident), sanitizeReplacementValues(values));
	    }
	  };

	  let sandboxKeys = (0, _immutable.List)(Object.keys(sandbox));
	  let sandboxVals = sandboxKeys.map(k => sandbox[k]).toArray();

	  let parsed = new S.Module({
	    directives: (0, _immutable.List)(),
	    items: _immutable.List.of(new S.ExpressionStatement({
	      expression: new S.FunctionExpression({
	        isGenerator: false,
	        name: null,
	        params: new S.FormalParameters({
	          items: sandboxKeys.map(param => {
	            return new S.BindingIdentifier({
	              name: _syntax2.default.from('identifier', param)
	            });
	          }),
	          rest: null
	        }),
	        body: new S.FunctionBody({
	          directives: _immutable.List.of(new S.Directive({
	            rawValue: 'use strict'
	          })),
	          statements: _immutable.List.of(new S.ReturnStatement({
	            expression: expr
	          }))
	        })
	      })
	    }))
	  }).reduce(new _sweetToShiftReducer2.default(context.phase));

	  let gen = (0, _shiftCodegen2.default)(parsed, new _shiftCodegen.FormattedCodeGen());
	  let result = context.transform(gen);

	  let val = context.loader.eval(result.code, context.store);
	  // let val = vm.runInContext(result.code, context.store.getNodeContext());
	  return val.apply(undefined, sandboxVals);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2FkLXN5bnRheC5qcyJdLCJuYW1lcyI6WyJleHBhbmRDb21waWxldGltZSIsInNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXMiLCJldmFsUnVudGltZVZhbHVlcyIsImV2YWxDb21waWxldGltZVZhbHVlIiwiUyIsIl8iLCJ0ZXJtIiwiY29udGV4dCIsInN5bnRheEV4cGFuZGVyIiwibWVyZ2UiLCJwaGFzZSIsImVudiIsInN0b3JlIiwiZXhwYW5kIiwidmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNMaXN0IiwibWFwIiwiRXJyb3IiLCJuZXh0IiwidGVybXMiLCJwcmVwcGVkIiwicmVkdWNlIiwiYWNjIiwiZGVjbGFyYXRpb24iLCJjb25jYXQiLCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50IiwiZGVjbGFyYXRvcnMiLCJkZWNsIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsImV4cHJlc3Npb24iLCJBc3NpZ25tZW50RXhwcmVzc2lvbiIsImJpbmRpbmciLCJTdGF0aWNNZW1iZXJFeHByZXNzaW9uIiwib2JqZWN0IiwiSWRlbnRpZmllckV4cHJlc3Npb24iLCJuYW1lIiwiZnJvbUlkZW50aWZpZXIiLCJwcm9wZXJ0eSIsIkZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwYXJzZWQiLCJNb2R1bGUiLCJkaXJlY3RpdmVzIiwiaXRlbXMiLCJnZW4iLCJyZXN1bHQiLCJ0cmFuc2Zvcm0iLCJleHBvcnRzT2JqIiwic2V0IiwibG9hZGVyIiwiZXZhbCIsImNvZGUiLCJleHByIiwic2FuZGJveCIsInN5bnRheFRlbXBsYXRlIiwiaWRlbnQiLCJ0ZW1wbGF0ZU1hcCIsImdldCIsInNhbmRib3hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsInNhbmRib3hWYWxzIiwiayIsInRvQXJyYXkiLCJvZiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsImlzR2VuZXJhdG9yIiwicGFyYW1zIiwiRm9ybWFsUGFyYW1ldGVycyIsInBhcmFtIiwiQmluZGluZ0lkZW50aWZpZXIiLCJmcm9tIiwicmVzdCIsImJvZHkiLCJGdW5jdGlvbkJvZHkiLCJEaXJlY3RpdmUiLCJyYXdWYWx1ZSIsInN0YXRlbWVudHMiLCJSZXR1cm5TdGF0ZW1lbnQiLCJ2YWwiLCJhcHBseSIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFjZ0JBLGlCLEdBQUFBLGlCO1FBWUFDLHlCLEdBQUFBLHlCO1FBYUFDLGlCLEdBQUFBLGlCO1FBK0NBQyxvQixHQUFBQSxvQjs7QUF0RmhCOztJQUFZQyxDOztBQUNaOztJQUFZQyxDOztBQUNaOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFFQTs7Ozs7O0FBRU8sU0FBU0wsaUJBQVQsQ0FBMkJNLElBQTNCLEVBQWlDQyxPQUFqQyxFQUEwQztBQUMvQztBQUNBO0FBQ0EsTUFBSUMsaUJBQWlCLDJCQUFpQkgsRUFBRUksS0FBRixDQUFRRixPQUFSLEVBQWlCO0FBQ3JERyxXQUFPSCxRQUFRRyxLQUFSLEdBQWdCLENBRDhCO0FBRXJEQyxTQUFLLG1CQUZnRDtBQUdyREMsV0FBT0wsUUFBUUs7QUFIc0MsR0FBakIsQ0FBakIsQ0FBckI7O0FBTUEsU0FBT0osZUFBZUssTUFBZixDQUFzQlAsSUFBdEIsQ0FBUDtBQUNEOztBQUVNLFNBQVNMLHlCQUFULENBQW1DYSxNQUFuQyxFQUEyQztBQUNoRCxNQUFJQyxNQUFNQyxPQUFOLENBQWNGLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixXQUFPYiwwQkFBMEIscUJBQUthLE1BQUwsQ0FBMUIsQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLGdCQUFLRyxNQUFMLENBQVlILE1BQVosQ0FBSixFQUF5QjtBQUM5QixXQUFPQSxPQUFPSSxHQUFQLENBQVdqQix5QkFBWCxDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlhLFVBQVUsSUFBZCxFQUFvQjtBQUN6QixVQUFNLElBQUlLLEtBQUosQ0FBVSxzRUFBVixDQUFOO0FBQ0QsR0FGTSxNQUVBLElBQUksT0FBT0wsT0FBT00sSUFB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Q0FBa0JGLEdBQWxCLENBQWI7O0FBRUEsTUFBSW1DLE1BQU16RSxRQUFRMkMsTUFBUixDQUFlQyxJQUFmLENBQW9CTCxPQUFPTSxJQUEzQixFQUFpQzdDLFFBQVFLLEtBQXpDLENBQVY7QUFDQTtBQUNBLFNBQU9vRSxJQUFJQyxLQUFKLENBQVVDLFNBQVYsRUFBcUJwQixXQUFyQixDQUFQO0FBQ0QiLCJmaWxlIjoibG9hZC1zeW50YXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBTIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdyYW1kYSc7XG5pbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCBTeW50YXggZnJvbSAnLi9zeW50YXgnO1xuaW1wb3J0IGNvZGVnZW4sIHsgRm9ybWF0dGVkQ29kZUdlbiB9IGZyb20gJ3NoaWZ0LWNvZGVnZW4nO1xuaW1wb3J0IHsgaXNWYXJpYWJsZURlY2xhcmF0aW9uLCBpc0ltcG9ydCwgaXNFeHBvcnQgfSBmcm9tICcuL3Rlcm1zJztcbmltcG9ydCBTd2VldFRvU2hpZnRSZWR1Y2VyIGZyb20gJy4vc3dlZXQtdG8tc2hpZnQtcmVkdWNlcic7XG5pbXBvcnQgVGVybUV4cGFuZGVyIGZyb20gJy4vdGVybS1leHBhbmRlcic7XG5pbXBvcnQgRW52IGZyb20gJy4vZW52JztcblxuaW1wb3J0IHsgdW53cmFwIH0gZnJvbSAnLi9tYWNyby1jb250ZXh0JztcblxuaW1wb3J0IHsgcmVwbGFjZVRlbXBsYXRlIH0gZnJvbSAnLi90ZW1wbGF0ZS1wcm9jZXNzb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kQ29tcGlsZXRpbWUodGVybSwgY29udGV4dCkge1xuICAvLyBlYWNoIGNvbXBpbGV0aW1lIHZhbHVlIG5lZWRzIHRvIGJlIGV4cGFuZGVkIHdpdGggYSBmcmVzaFxuICAvLyBlbnZpcm9ubWVudCBhbmQgaW4gdGhlIG5leHQgaGlnaGVyIHBoYXNlXG4gIGxldCBzeW50YXhFeHBhbmRlciA9IG5ldyBUZXJtRXhwYW5kZXIoXy5tZXJnZShjb250ZXh0LCB7XG4gICAgcGhhc2U6IGNvbnRleHQucGhhc2UgKyAxLFxuICAgIGVudjogbmV3IEVudigpLFxuICAgIHN0b3JlOiBjb250ZXh0LnN0b3JlXG4gIH0pKTtcblxuICByZXR1cm4gc3ludGF4RXhwYW5kZXIuZXhwYW5kKHRlcm0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVSZXBsYWNlbWVudFZhbHVlcyh2YWx1ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKExpc3QodmFsdWVzKSk7XG4gIH0gZWxzZSBpZiAoTGlzdC5pc0xpc3QodmFsdWVzKSkge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKHNhbml0aXplUmVwbGFjZW1lbnRWYWx1ZXMpO1xuICB9IGVsc2UgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlbWVudCB2YWx1ZXMgZm9yIHN5bnRheCB0ZW1wbGF0ZSBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKExpc3QodmFsdWVzKSk7XG4gIH1cbiAgcmV0dXJuIHVud3JhcCh2YWx1ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbFJ1bnRpbWVWYWx1ZXModGVybXMsIGNvbnRleHQpIHtcbiAgbGV0IHByZXBwZWQgPSB0ZXJtcy5yZWR1Y2UoKGFjYywgdGVybSkgPT4ge1xuICAgIGlmIChpc0V4cG9ydCh0ZXJtKSkge1xuICAgICAgaWYgKGlzVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChuZXcgUy5WYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHtcbiAgICAgICAgICBkZWNsYXJhdGlvbjogdGVybS5kZWNsYXJhdGlvblxuICAgICAgICB9KSkuY29uY2F0KHRlcm0uZGVjbGFyYXRpb24uZGVjbGFyYXRvcnMubWFwKGRlY2wgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgUy5FeHByZXNzaW9uU3RhdGVtZW50KHtcbiAgICAgICAgICAgIGV4cHJlc3Npb246IG5ldyBTLkFzc2lnbm1lbnRFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgYmluZGluZzogbmV3IFMuU3RhdGljTWVtYmVyRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgUy5JZGVudGlmaWVyRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBTeW50YXguZnJvbUlkZW50aWZpZXIoJ2V4cG9ydHMnKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBkZWNsLmJpbmRpbmcubmFtZVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbmV3IFMuSWRlbnRpZmllckV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgIG5hbWU6IGRlY2wuYmluZGluZy5uYW1lXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKHRlcm0uZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBTLkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodGVybS5kZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ltcG9ydCh0ZXJtKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgcmV0dXJuIGFjYy5jb25jYXQodGVybSk7XG4gIH0sIExpc3QoKSk7XG5cbiAgbGV0IHBhcnNlZCA9IG5ldyBTLk1vZHVsZSh7XG4gICAgZGlyZWN0aXZlczogTGlzdCgpLFxuICAgIGl0ZW1zOiBwcmVwcGVkXG4gIH0pLnJlZHVjZShuZXcgU3dlZXRUb1NoaWZ0UmVkdWNlcihjb250ZXh0LnBoYXNlKSk7XG5cbiAgbGV0IGdlbiA9IGNvZGVnZW4ocGFyc2VkLCBuZXcgRm9ybWF0dGVkQ29kZUdlbik7XG4gIGxldCByZXN1bHQgPSBjb250ZXh0LnRyYW5zZm9ybShnZW4pO1xuXG4gIGxldCBleHBvcnRzT2JqID0ge307XG4gIGNvbnRleHQuc3RvcmUuc2V0KCdleHBvcnRzJywgZXhwb3J0c09iaik7XG5cbiAgY29udGV4dC5sb2FkZXIuZXZhbChyZXN1bHQuY29kZSwgY29udGV4dC5zdG9yZSk7XG4gIC8vIHZtLnJ1bkluQ29udGV4dChyZXN1bHQuY29kZSwgY29udGV4dC5zdG9yZS5nZXROb2RlQ29udGV4dCgpKTtcbiAgcmV0dXJuIGV4cG9ydHNPYmo7XG59XG5cbi8vIChFeHByZXNzaW9uLCBDb250ZXh0KSAtPiBbZnVuY3Rpb25dXG5leHBvcnQgZnVuY3Rpb24gZXZhbENvbXBpbGV0aW1lVmFsdWUoZXhwcjogUy5FeHByZXNzaW9uLCBjb250ZXh0OiBhbnkpIHtcbiAgbGV0IHNhbmRib3ggPSB7XG4gICAgc3ludGF4VGVtcGxhdGU6IGZ1bmN0aW9uKGlkZW50LCAuLi52YWx1ZXMpIHtcbiAgICAgIHJldHVybiByZXBsYWNlVGVtcGxhdGUoY29udGV4dC50ZW1wbGF0ZU1hcC5nZXQoaWRlbnQpLCBzYW5pdGl6ZVJlcGxhY2VtZW50VmFsdWVzKHZhbHVlcykpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgc2FuZGJveEtleXMgPSBMaXN0KE9iamVjdC5rZXlzKHNhbmRib3gpKTtcbiAgbGV0IHNhbmRib3hWYWxzID0gc2FuZGJveEtleXMubWFwKGsgPT4gc2FuZGJveFtrXSkudG9BcnJheSgpO1xuXG4gIGxldCBwYXJzZWQgPSBuZXcgUy5Nb2R1bGUoe1xuICAgIGRpcmVjdGl2ZXM6IExpc3QoKSxcbiAgICBpdGVtczogTGlzdC5vZihuZXcgUy5FeHByZXNzaW9uU3RhdGVtZW50KHtcbiAgICAgIGV4cHJlc3Npb246IG5ldyBTLkZ1bmN0aW9uRXhwcmVzc2lvbih7XG4gICAgICAgIGlzR2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgcGFyYW1zOiBuZXcgUy5Gb3JtYWxQYXJhbWV0ZXJzKHtcbiAgICAgICAgICBpdGVtczogc2FuZGJveEtleXMubWFwKHBhcmFtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUy5CaW5kaW5nSWRlbnRpZmllcih7XG4gICAgICAgICAgICAgIG5hbWU6IFN5bnRheC5mcm9tKCdpZGVudGlmaWVyJywgcGFyYW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByZXN0OiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICBib2R5OiBuZXcgUy5GdW5jdGlvbkJvZHkoe1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IExpc3Qub2YobmV3IFMuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHJhd1ZhbHVlOiAndXNlIHN0cmljdCdcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgc3RhdGVtZW50czogTGlzdC5vZihuZXcgUy5SZXR1cm5TdGF0ZW1lbnQoe1xuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwclxuICAgICAgICAgIH0pKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSlcbiAgfSkucmVkdWNlKG5ldyBTd2VldFRvU2hpZnRSZWR1Y2VyKGNvbnRleHQucGhhc2UpKTtcblxuICBsZXQgZ2VuID0gY29kZWdlbihwYXJzZWQsIG5ldyBGb3JtYXR0ZWRDb2RlR2VuKTtcbiAgbGV0IHJlc3VsdCA9IGNvbnRleHQudHJhbnNmb3JtKGdlbik7XG5cbiAgbGV0IHZhbCA9IGNvbnRleHQubG9hZGVyLmV2YWwocmVzdWx0LmNvZGUsIGNvbnRleHQuc3RvcmUpO1xuICAvLyBsZXQgdmFsID0gdm0ucnVuSW5Db250ZXh0KHJlc3VsdC5jb2RlLCBjb250ZXh0LnN0b3JlLmdldE5vZGVDb250ZXh0KCkpO1xuICByZXR1cm4gdmFsLmFwcGx5KHVuZGVmaW5lZCwgc2FuZGJveFZhbHMpO1xufVxuIl19

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SemiOp = exports.CommaSep = exports.Semi = exports.Seq = exports.ContainsIn = exports.NoIn = exports.Brace = exports.Bracket = exports.Paren = exports.NumberCodeRep = exports.Token = exports.Empty = exports.CodeRep = exports.escapeStringLiteral = exports.getPrecedence = exports.Precedence = exports.Sep = exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.MinimalCodeGen = undefined;
	exports.default = codeGen;

	var _minimalCodegen = __webpack_require__(54);

	Object.defineProperty(exports, "MinimalCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _minimalCodegen.default;
	  }
	});

	var _formattedCodegen = __webpack_require__(57);

	Object.defineProperty(exports, "ExtensibleCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.ExtensibleCodeGen;
	  }
	});
	Object.defineProperty(exports, "FormattedCodeGen", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.FormattedCodeGen;
	  }
	});
	Object.defineProperty(exports, "Sep", {
	  enumerable: true,
	  get: function get() {
	    return _formattedCodegen.Sep;
	  }
	});

	var _coderep = __webpack_require__(56);

	Object.defineProperty(exports, "Precedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Precedence;
	  }
	});
	Object.defineProperty(exports, "getPrecedence", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.getPrecedence;
	  }
	});
	Object.defineProperty(exports, "escapeStringLiteral", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.escapeStringLiteral;
	  }
	});
	Object.defineProperty(exports, "CodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CodeRep;
	  }
	});
	Object.defineProperty(exports, "Empty", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Empty;
	  }
	});
	Object.defineProperty(exports, "Token", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Token;
	  }
	});
	Object.defineProperty(exports, "NumberCodeRep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NumberCodeRep;
	  }
	});
	Object.defineProperty(exports, "Paren", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Paren;
	  }
	});
	Object.defineProperty(exports, "Bracket", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Bracket;
	  }
	});
	Object.defineProperty(exports, "Brace", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Brace;
	  }
	});
	Object.defineProperty(exports, "NoIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.NoIn;
	  }
	});
	Object.defineProperty(exports, "ContainsIn", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.ContainsIn;
	  }
	});
	Object.defineProperty(exports, "Seq", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Seq;
	  }
	});
	Object.defineProperty(exports, "Semi", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.Semi;
	  }
	});
	Object.defineProperty(exports, "CommaSep", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.CommaSep;
	  }
	});
	Object.defineProperty(exports, "SemiOp", {
	  enumerable: true,
	  get: function get() {
	    return _coderep.SemiOp;
	  }
	});

	var _shiftReducer = __webpack_require__(58);

	var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

	var _token_stream = __webpack_require__(62);

	var _minimalCodegen2 = _interopRequireDefault(_minimalCodegen);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function codeGen(script) {
	  var generator = arguments.length <= 1 || arguments[1] === undefined ? new _minimalCodegen2.default() : arguments[1];

	  var ts = new _token_stream.TokenStream();
	  var rep = (0, _shiftReducer2.default)(generator, script);
	  rep.emit(ts);
	  return ts.result;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _objectAssign = __webpack_require__(55);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(14);

	var _coderep = __webpack_require__(56);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function p(node, precedence, a) {
	  return (0, _coderep.getPrecedence)(node) < precedence ? paren(a) : a;
	}

	function t(token) {
	  return new _coderep.Token(token);
	}

	function paren(rep) {
	  return new _coderep.Paren(rep);
	}

	function brace(rep) {
	  return new _coderep.Brace(rep);
	}

	function bracket(rep) {
	  return new _coderep.Bracket(rep);
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function semi() {
	  return new _coderep.Semi();
	}

	function semiOp() {
	  return new _coderep.SemiOp();
	}

	function empty() {
	  return new _coderep.Empty();
	}

	function commaSep(pieces) {
	  return new _coderep.CommaSep(pieces);
	}

	function getAssignmentExpr(state) {
	  return state ? state.containsGroup ? paren(state) : state : empty();
	}

	var MinimalCodeGen = function () {
	  function MinimalCodeGen() {
	    _classCallCheck(this, MinimalCodeGen);
	  }

	  _createClass(MinimalCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(paren(original.children[0]), semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return bracket(empty());
	      }

	      var content = commaSep(elements.map(getAssignmentExpr));
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, t(","));
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(t("..."), p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t("="), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = paren(leftCode);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = paren(rightCode);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(t("..."), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(t("..."), restElement)]);
	        content = commaSep(elements.map(getAssignmentExpr));
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, t(","));
	        }
	      }
	      return bracket(content);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, t("="), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, t(":"), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return brace(seq.apply(undefined, _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return block;
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(t("break"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(p(node.callee, (0, _coderep.getPrecedence)(node), callee), paren(commaSep(args))), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(t("catch"), paren(binding), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(t("class"), name);
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = t("class");
	      if (name != null) {
	        state = seq(state, name);
	      }
	      if (_super != null) {
	        state = seq(state, t("extends"), _super);
	      }
	      state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      if (!node.isStatic) return method;
	      return seq(t("static"), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return bracket(expression);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(p(node.test, _coderep.Precedence.LogicalOR, test), t("?"), p(node.consequent, _coderep.Precedence.Assignment, consequent), t(":"), p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(t("continue"), label ? t(label) : empty(), semiOp());
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, t(":"), getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(t("debugger"), semiOp());
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(t("do"), body, t("while"), paren(test), semiOp());
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return semi();
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? paren(expression) : expression, semiOp());
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = paren(left);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(leftP, t("in"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(left.startsWithLet ? paren(left) : left, t("of"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(t("for"), paren(seq(init ? noIn(markContainsIn(init)) : empty(), semi(), test || empty(), semi(), update || empty())), body), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(t("function"), node.isGenerator ? t("*") : empty(), node.name.name === "*default*" ? empty() : name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(t("function"), node.isGenerator ? t("*") : empty(), name ? name : empty(), paren(params), brace(body));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return commaSep(items.concat(rest == null ? [] : [seq(t("..."), rest)]));
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = paren(params);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = brace(body);
	      } else if (body.startsWithCurly) {
	        body = paren(body);
	      }
	      return seq(params, t("=>"), p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(t("get"), name, paren(empty()), brace(body));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = brace(consequent);
	      }
	      return (0, _objectAssign2.default)(seq(t("if"), paren(test), consequent, alternate ? seq(t("else"), alternate) : empty()), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(brace(commaSep(namedImports)));
	      }
	      if (bindings.length === 0) {
	        return seq(t("import"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	      }
	      return seq(t("import"), commaSep(bindings), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(t("import"), defaultBinding == null ? empty() : seq(defaultBinding, t(",")), t("*"), t("as"), namespaceBinding, t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(t(node.name), t("as"), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(t("export"), t("*"), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(t("export"), brace(commaSep(namedExports)), node.moduleSpecifier == null ? empty() : seq(t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp()));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, semiOp());
	      }
	      return seq(t("export"), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? paren(body) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, semiOp());
	      }
	      return seq(t("export default"), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return t(node.exportedName);
	      return seq(t(node.name), t("as"), t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(t(label + ":"), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? t("*") : empty(), name, paren(params), brace(body));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? paren(callee) : p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(t("new"), calleeRep, args.length === 0 ? empty() : paren(commaSep(args)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return t("new.target");
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = brace(commaSep(properties));
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(p(node.operand, _coderep.Precedence.New, operand), t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(t(node.operator), p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(t("return"), expression || empty(), semiOp());
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(t("set"), name, paren(param), brace(body));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(t("case"), test, t(":"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(t("default:"), seq.apply(undefined, _toConsumableArray(consequent)));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(cases))));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases)))));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : p(node.tag, (0, _coderep.getPrecedence)(node), tag);
	      var templateData = "";
	      state = seq(state, t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, t(d));
	        } else {
	          state = seq(state, elements[i]);
	        }
	      }
	      state = seq(state, t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(t("throw"), expression, semiOp());
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(t("try"), body, catchClause);
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(t("try"), body, catchClause || empty(), t("finally"), finalizer);
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return t("yield");
	      return seq(t("yield"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(t("yield"), t("*"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(t(delim + node.rawValue + delim), semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(t(node.kind), commaSep(declarators));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, semiOp());
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = paren(init);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, t("="), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(t("while"), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(t("with"), paren(object), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return MinimalCodeGen;
	}();

	exports.default = MinimalCodeGen;

/***/ },
/* 55 */
/***/ function(module, exports) {

	'use strict';
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function ownEnumerableKeys(obj) {
		var keys = Object.getOwnPropertyNames(obj);

		if (Object.getOwnPropertySymbols) {
			keys = keys.concat(Object.getOwnPropertySymbols(obj));
		}

		return keys.filter(function (key) {
			return propIsEnumerable.call(obj, key);
		});
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = ownEnumerableKeys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrecedence = getPrecedence;
	exports.escapeStringLiteral = escapeStringLiteral;

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Precedence = {
	  Sequence: 0,
	  Yield: 1,
	  Assignment: 1,
	  Conditional: 2,
	  ArrowFunction: 2,
	  LogicalOR: 3,
	  LogicalAND: 4,
	  BitwiseOR: 5,
	  BitwiseXOR: 6,
	  BitwiseAND: 7,
	  Equality: 8,
	  Relational: 9,
	  BitwiseSHIFT: 10,
	  Additive: 11,
	  Multiplicative: 12,
	  Prefix: 13,
	  Postfix: 14,
	  New: 15,
	  Call: 16,
	  TaggedTemplate: 17,
	  Member: 18,
	  Primary: 19
	};

	exports.Precedence = Precedence;

	var BinaryPrecedence = {
	  ",": Precedence.Sequence,
	  "||": Precedence.LogicalOR,
	  "&&": Precedence.LogicalAND,
	  "|": Precedence.BitwiseOR,
	  "^": Precedence.BitwiseXOR,
	  "&": Precedence.BitwiseAND,
	  "==": Precedence.Equality,
	  "!=": Precedence.Equality,
	  "===": Precedence.Equality,
	  "!==": Precedence.Equality,
	  "<": Precedence.Relational,
	  ">": Precedence.Relational,
	  "<=": Precedence.Relational,
	  ">=": Precedence.Relational,
	  "in": Precedence.Relational,
	  "instanceof": Precedence.Relational,
	  "<<": Precedence.BitwiseSHIFT,
	  ">>": Precedence.BitwiseSHIFT,
	  ">>>": Precedence.BitwiseSHIFT,
	  "+": Precedence.Additive,
	  "-": Precedence.Additive,
	  "*": Precedence.Multiplicative,
	  "%": Precedence.Multiplicative,
	  "/": Precedence.Multiplicative
	};

	function getPrecedence(node) {
	  switch (node.type) {
	    case "ArrayExpression":
	    case "FunctionExpression":
	    case "IdentifierExpression":
	    case "LiteralBooleanExpression":
	    case "LiteralNullExpression":
	    case "LiteralNumericExpression":
	    case "LiteralInfinityExpression":
	    case "LiteralRegExpExpression":
	    case "LiteralStringExpression":
	    case "ObjectExpression":
	    case "ThisExpression":
	      return Precedence.Primary;

	    case "ArrowExpression":
	    case "AssignmentExpression":
	    case "CompoundAssignmentExpression":
	    case "YieldExpression":
	    case "YieldGeneratorExpression":
	      return Precedence.Assignment;

	    case "ConditionalExpression":
	      return Precedence.Conditional;

	    case "ComputedMemberExpression":
	    case "StaticMemberExpression":
	      switch (node.object.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.object);
	        default:
	          return Precedence.Member;
	      }

	    case "TemplateExpression":
	      if (node.tag == null) return Precedence.Member;
	      switch (node.tag.type) {
	        case "CallExpression":
	        case "ComputedMemberExpression":
	        case "StaticMemberExpression":
	        case "TemplateExpression":
	          return getPrecedence(node.tag);
	        default:
	          return Precedence.Member;
	      }

	    case "BinaryExpression":
	      return BinaryPrecedence[node.operator];

	    case "CallExpression":
	      return Precedence.Call;
	    case "NewExpression":
	      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;
	    case "UpdateExpression":
	      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;
	    case "UnaryExpression":
	      return Precedence.Prefix;
	  }
	}

	function escapeStringLiteral(stringValue) {
	  var result = "";
	  var nSingle = 0,
	      nDouble = 0;
	  for (var i = 0, l = stringValue.length; i < l; ++i) {
	    var ch = stringValue[i];
	    if (ch === "\"") {
	      ++nDouble;
	    } else if (ch === "'") {
	      ++nSingle;
	    }
	  }
	  var delim = nDouble > nSingle ? "'" : "\"";
	  result += delim;
	  for (var i = 0; i < stringValue.length; i++) {
	    var ch = stringValue.charAt(i);
	    switch (ch) {
	      case delim:
	        result += "\\" + delim;
	        break;
	      case "\b":
	        result += "\\b";
	        break;
	      case "\t":
	        result += "\\t";
	        break;
	      case "\n":
	        result += "\\n";
	        break;
	      case "\u000b":
	        result += "\\v";
	        break;
	      case "\f":
	        result += "\\f";
	        break;
	      case "\r":
	        result += "\\r";
	        break;
	      case "\\":
	        result += "\\\\";
	        break;
	      case "\u2028":
	        result += "\\u2028";
	        break;
	      case "\u2029":
	        result += "\\u2029";
	        break;
	      default:
	        result += ch;
	        break;
	    }
	  }
	  result += delim;
	  return result;
	}

	var CodeRep = exports.CodeRep = function () {
	  function CodeRep() {
	    _classCallCheck(this, CodeRep);

	    this.containsIn = false;
	    this.containsGroup = false;
	    // restricted lookaheads: {, function, class, let, let [
	    this.startsWithCurly = false;
	    this.startsWithFunctionOrClass = false;
	    this.startsWithLet = false;
	    this.startsWithLetSquareBracket = false;
	    this.endsWithMissingElse = false;
	  }

	  _createClass(CodeRep, [{
	    key: "forEach",
	    value: function forEach(f) {
	      // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.
	      f(this);
	    }
	  }]);

	  return CodeRep;
	}();

	var Empty = exports.Empty = function (_CodeRep) {
	  _inherits(Empty, _CodeRep);

	  function Empty() {
	    _classCallCheck(this, Empty);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Empty).call(this));
	  }

	  _createClass(Empty, [{
	    key: "emit",
	    value: function emit() {}
	  }]);

	  return Empty;
	}(CodeRep);

	var Token = exports.Token = function (_CodeRep2) {
	  _inherits(Token, _CodeRep2);

	  function Token(token) {
	    _classCallCheck(this, Token);

	    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Token).call(this));

	    _this2.token = token;
	    return _this2;
	  }

	  _createClass(Token, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put(this.token);
	    }
	  }]);

	  return Token;
	}(CodeRep);

	var NumberCodeRep = exports.NumberCodeRep = function (_CodeRep3) {
	  _inherits(NumberCodeRep, _CodeRep3);

	  function NumberCodeRep(number) {
	    _classCallCheck(this, NumberCodeRep);

	    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberCodeRep).call(this));

	    _this3.number = number;
	    return _this3;
	  }

	  _createClass(NumberCodeRep, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putNumber(this.number);
	    }
	  }]);

	  return NumberCodeRep;
	}(CodeRep);

	var Paren = exports.Paren = function (_CodeRep4) {
	  _inherits(Paren, _CodeRep4);

	  function Paren(expr) {
	    _classCallCheck(this, Paren);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Paren).call(this));

	    _this4.expr = expr;
	    return _this4;
	  }

	  _createClass(Paren, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("(");
	      this.expr.emit(ts, false);
	      ts.put(")");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Paren;
	}(CodeRep);

	var Bracket = exports.Bracket = function (_CodeRep5) {
	  _inherits(Bracket, _CodeRep5);

	  function Bracket(expr) {
	    _classCallCheck(this, Bracket);

	    var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Bracket).call(this));

	    _this5.expr = expr;
	    return _this5;
	  }

	  _createClass(Bracket, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("[");
	      this.expr.emit(ts, false);
	      ts.put("]");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Bracket;
	}(CodeRep);

	var Brace = exports.Brace = function (_CodeRep6) {
	  _inherits(Brace, _CodeRep6);

	  function Brace(expr) {
	    _classCallCheck(this, Brace);

	    var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(Brace).call(this));

	    _this6.expr = expr;
	    return _this6;
	  }

	  _createClass(Brace, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("{");
	      this.expr.emit(ts, false);
	      ts.put("}");
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return Brace;
	}(CodeRep);

	var NoIn = exports.NoIn = function (_CodeRep7) {
	  _inherits(NoIn, _CodeRep7);

	  function NoIn(expr) {
	    _classCallCheck(this, NoIn);

	    var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(NoIn).call(this));

	    _this7.expr = expr;
	    return _this7;
	  }

	  _createClass(NoIn, [{
	    key: "emit",
	    value: function emit(ts) {
	      this.expr.emit(ts, true);
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return NoIn;
	}(CodeRep);

	var ContainsIn = exports.ContainsIn = function (_CodeRep8) {
	  _inherits(ContainsIn, _CodeRep8);

	  function ContainsIn(expr) {
	    _classCallCheck(this, ContainsIn);

	    var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainsIn).call(this));

	    _this8.expr = expr;
	    return _this8;
	  }

	  _createClass(ContainsIn, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      if (noIn) {
	        ts.put("(");
	        this.expr.emit(ts, false);
	        ts.put(")");
	      } else {
	        this.expr.emit(ts, false);
	      }
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.expr.forEach(f);
	    }
	  }]);

	  return ContainsIn;
	}(CodeRep);

	var Seq = exports.Seq = function (_CodeRep9) {
	  _inherits(Seq, _CodeRep9);

	  function Seq(children) {
	    _classCallCheck(this, Seq);

	    var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(Seq).call(this));

	    _this9.children = children;
	    return _this9;
	  }

	  _createClass(Seq, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      this.children.forEach(function (cr) {
	        return cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return Seq;
	}(CodeRep);

	var Semi = exports.Semi = function (_Token) {
	  _inherits(Semi, _Token);

	  function Semi() {
	    _classCallCheck(this, Semi);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Semi).call(this, ";"));
	  }

	  return Semi;
	}(Token);

	var CommaSep = exports.CommaSep = function (_CodeRep10) {
	  _inherits(CommaSep, _CodeRep10);

	  function CommaSep(children) {
	    _classCallCheck(this, CommaSep);

	    var _this11 = _possibleConstructorReturn(this, Object.getPrototypeOf(CommaSep).call(this));

	    _this11.children = children;
	    return _this11;
	  }

	  _createClass(CommaSep, [{
	    key: "emit",
	    value: function emit(ts, noIn) {
	      var first = true;
	      this.children.forEach(function (cr) {
	        if (first) {
	          first = false;
	        } else {
	          ts.put(",");
	        }
	        cr.emit(ts, noIn);
	      });
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(f) {
	      f(this);
	      this.children.forEach(function (x) {
	        return x.forEach(f);
	      });
	    }
	  }]);

	  return CommaSep;
	}(CodeRep);

	var SemiOp = exports.SemiOp = function (_CodeRep11) {
	  _inherits(SemiOp, _CodeRep11);

	  function SemiOp() {
	    _classCallCheck(this, SemiOp);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(SemiOp).call(this));
	  }

	  _createClass(SemiOp, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.putOptionalSemi();
	    }
	  }]);

	  return SemiOp;
	}(CodeRep);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.Sep = undefined;

	var _objectAssign = __webpack_require__(55);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _esutils = __webpack_require__(14);

	var _coderep = __webpack_require__(56);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function empty() {
	  return new _coderep.Empty();
	}

	function noIn(rep) {
	  return new _coderep.NoIn(rep);
	}

	function markContainsIn(state) {
	  return state.containsIn ? new _coderep.ContainsIn(state) : state;
	}

	function seq() {
	  for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
	    reps[_key] = arguments[_key];
	  }

	  return new _coderep.Seq(reps);
	}

	function isEmpty(codeRep) {
	  return codeRep instanceof _coderep.Empty || codeRep instanceof Linebreak || codeRep instanceof _coderep.Seq && codeRep.children.every(isEmpty);
	}

	var Sep = {};
	var separatorNames = ["ARRAY_EMPTY", "ARRAY_BEFORE_COMMA", "ARRAY_AFTER_COMMA", "SPREAD", "BEFORE_DEFAULT_EQUALS", "AFTER_DEFAULT_EQUALS", "REST", "OBJECT_BEFORE_COMMA", "OBJECT_AFTER_COMMA", "BEFORE_PROP", "AFTER_PROP", "BEFORE_JUMP_LABEL", "ARGS_BEFORE_COMMA", "ARGS_AFTER_COMMA", "CALL", "BEFORE_CATCH_BINDING", "AFTER_CATCH_BINDING", "BEFORE_CLASS_NAME", "BEFORE_EXTENDS", "AFTER_EXTENDS", "BEFORE_CLASS_DECLARATION_ELEMENTS", "BEFORE_CLASS_EXPRESSION_ELEMENTS", "AFTER_STATIC", "BEFORE_CLASS_ELEMENT", "AFTER_CLASS_ELEMENT", "BEFORE_TERNARY_QUESTION", "AFTER_TERNARY_QUESTION", "BEFORE_TERNARY_COLON", "AFTER_TERNARY_COLON", "COMPUTED_MEMBER_EXPRESSION", "AFTER_DO", "BEFORE_DOWHILE_WHILE", "AFTER_DOWHILE_WHILE", "AFTER_FORIN_FOR", "BEFORE_FORIN_IN", "AFTER_FORIN_FOR", "BEFORE_FORIN_BODY", "AFTER_FOROF_FOR", "BEFORE_FOROF_OF", "AFTER_FOROF_FOR", "BEFORE_FOROF_BODY", "AFTER_FOR_FOR", "BEFORE_FOR_INIT", "AFTER_FOR_INIT", "EMPTY_FOR_INIT", "BEFORE_FOR_TEST", "AFTER_FOR_TEST", "EMPTY_FOR_TEST", "BEFORE_FOR_UPDATE", "AFTER_FOR_UPDATE", "EMPTY_FOR_UPDATE", "BEFORE_FOR_BODY", "BEFORE_GENERATOR_STAR", "AFTER_GENERATOR_STAR", "BEFORE_FUNCTION_PARAMS", "BEFORE_FUNCTION_DECLARATION_BODY", "BEFORE_FUNCTION_EXPRESSION_BODY", "AFTER_FUNCTION_DIRECTIVES", "BEFORE_ARROW", "AFTER_ARROW", "AFTER_GET", "BEFORE_GET_PARAMS", "BEFORE_GET_BODY", "AFTER_IF", "AFTER_IF_TEST", "BEFORE_ELSE", "AFTER_ELSE", "PARAMETER_BEFORE_COMMA", "PARAMETER_AFTER_COMMA", "NAMED_IMPORT_BEFORE_COMMA", "NAMED_IMPORT_AFTER_COMMA", "IMPORT_BEFORE_COMMA", "IMPORT_AFTER_COMMA", "BEFORE_IMPORT_BINDINGS", "BEFORE_IMPORT_MODULE", "AFTER_IMPORT_BINDINGS", "AFTER_FROM", "BEFORE_IMPORT_NAMESPACE", "BEFORE_IMPORT_STAR", "AFTER_IMPORT_STAR", "AFTER_IMPORT_AS", "AFTER_NAMESPACE_BINDING", "BEFORE_IMPORT_AS", "AFTER_IMPORT_AS", "EXPORTS_BEFORE_COMMA", "EXPORTS_AFTER_COMMA", "BEFORE_EXPORT_STAR", "AFTER_EXPORT_STAR", "BEFORE_EXPORT_BINDINGS", "AFTER_EXPORT_BINDINGS", "AFTER_EXPORT", "EXPORT_DEFAULT", "AFTER_EXPORT_DEFAULT", "BEFORE_EXPORT_AS", "AFTER_EXPORT_AS", "BEFORE_LABEL_COLON", "AFTER_LABEL_COLON", "AFTER_METHOD_GENERATOR_STAR", "AFTER_METHOD_NAME", "BEFORE_METHOD_BODY", "AFTER_MODULE_DIRECTIVES", "AFTER_NEW", "BEFORE_NEW_ARGS", "EMPTY_NEW_CALL", "NEW_TARGET_BEFORE_DOT", "NEW_TARGET_AFTER_DOT", "RETURN", "AFTER_SET", "BEFORE_SET_PARAMS", "BEFORE_SET_BODY", "AFTER_SCRIPT_DIRECTIVES", "BEFORE_STATIC_MEMBER_DOT", "AFTER_STATIC_MEMBER_DOT", "BEFORE_CASE_TEST", "AFTER_CASE_TEST", "BEFORE_CASE_BODY", "AFTER_CASE_BODY", "DEFAULT", "AFTER_DEFAULT_BODY", "BEFORE_SWITCH_DISCRIM", "BEFORE_SWITCH_BODY", "TEMPLATE_TAG", "BEFORE_TEMPLATE_EXPRESSION", "AFTER_TEMPLATE_EXPRESSION", "THROW", "AFTER_TRY", "BEFORE_CATCH", "BEFORE_FINALLY", "AFTER_FINALLY", "VARIABLE_DECLARATION", "YIELD", "BEFORE_YIELD_STAR", "AFTER_YIELD_STAR", "DECLARATORS_BEFORE_COMMA", "DECLARATORS_AFTER_COMMA", "BEFORE_INIT_EQUALS", "AFTER_INIT_EQUALS", "AFTER_WHILE", "BEFORE_WHILE_BODY", "AFTER_WITH", "BEFORE_WITH_BODY", "PAREN_AVOIDING_DIRECTIVE_BEFORE", "PAREN_AVOIDING_DIRECTIVE_AFTER", "PRECEDENCE_BEFORE", "PRECEDENCE_AFTER", "EXPRESSION_PAREN_BEFORE", "EXPRESSION_PAREN_AFTER", "CALL_PAREN_BEFORE", "CALL_PAREN_AFTER", "CALL_PAREN_EMPTY", "CATCH_PAREN_BEFORE", "CATCH_PAREN_AFTER", "DO_WHILE_TEST_PAREN_BEFORE", "DO_WHILE_TEST_PAREN_AFTER", "EXPRESSION_STATEMENT_PAREN_BEFORE", "EXPRESSION_STATEMENT_PAREN_AFTER", "FOR_IN_LET_PAREN_BEFORE", "FOR_IN_LET_PAREN_AFTER", "FOR_IN_PAREN_BEFORE", "FOR_IN_PAREN_AFTER", "FOR_OF_LET_PAREN_BEFORE", "FOR_OF_LET_PAREN_AFTER", "FOR_OF_PAREN_BEFORE", "FOR_OF_PAREN_AFTER", "PARAMETERS_PAREN_BEFORE", "PARAMETERS_PAREN_AFTER", "PARAMETERS_PAREN_EMPTY", "ARROW_PARAMETERS_PAREN_BEFORE", "ARROW_PARAMETERS_PAREN_AFTER", "ARROW_PARAMETERS_PAREN_EMPTY", "ARROW_BODY_PAREN_BEFORE", "ARROW_BODY_PAREN_AFTER", "GETTER_PARAMS", "IF_PAREN_BEFORE", "IF_PAREN_AFTER", "EXPORT_PAREN_BEFORE", "EXPORT_PAREN_AFTER", "NEW_CALLEE_PAREN_BEFORE", "NEW_CALLEE_PAREN_AFTER", "NEW_PAREN_BEFORE", "NEW_PAREN_AFTER", "NEW_PAREN_EMPTY", "SETTER_PARAM_BEFORE", "SETTER_PARAM_AFTER", "SWITCH_DISCRIM_PAREN_BEFORE", "SWITCH_DISCRIM_PAREN_AFTER", "WHILE_TEST_PAREN_BEFORE", "WHILE_TEST_PAREN_AFTER", "WITH_PAREN_BEFORE", "WITH_PAREN_AFTER", "OBJECT_BRACE_INITIAL", "OBJECT_BRACE_FINAL", "OBJECT_EMPTY", "BLOCK_BRACE_INITIAL", "BLOCK_BRACE_FINAL", "BLOCK_EMPTY", "CLASS_BRACE_INITIAL", "CLASS_BRACE_FINAL", "CLASS_EMPTY", "CLASS_EXPRESSION_BRACE_INITIAL", "CLASS_EXPRESSION_BRACE_FINAL", "CLASS_EXPRESSION_BRACE_EMPTY", "FUNCTION_BRACE_INITIAL", "FUNCTION_BRACE_FINAL", "FUNCTION_EMPTY", "FUNCTION_EXPRESSION_BRACE_INITIAL", "FUNCTION_EXPRESSION_BRACE_FINAL", "FUNCTION_EXPRESSION_EMPTY", "ARROW_BRACE_INITIAL", "ARROW_BRACE_FINAL", "ARROW_BRACE_EMPTY", "GET_BRACE_INTIAL", "GET_BRACE_FINAL", "GET_BRACE_EMPTY", "MISSING_ELSE_INTIIAL", "MISSING_ELSE_FINAL", "MISSING_ELSE_EMPTY", "IMPORT_BRACE_INTIAL", "IMPORT_BRACE_FINAL", "IMPORT_BRACE_EMPTY", "EXPORT_BRACE_INITIAL", "EXPORT_BRACE_FINAL", "EXPORT_BRACE_EMPTY", "METHOD_BRACE_INTIAL", "METHOD_BRACE_FINAL", "METHOD_BRACE_EMPTY", "SET_BRACE_INTIIAL", "SET_BRACE_FINAL", "SET_BRACE_EMPTY", "SWITCH_BRACE_INTIAL", "SWITCH_BRACE_FINAL", "SWITCH_BRACE_EMPTY", "ARRAY_INITIAL", "ARRAY_FINAL", "COMPUTED_MEMBER_BRACKET_INTIAL", "COMPUTED_MEMBER_BRACKET_FINAL", "COMPUTED_PROPERTY_BRACKET_INTIAL", "COMPUTED_PROPERTY_BRACKET_FINAL"];
	for (var i = 0; i < separatorNames.length; ++i) {
	  Sep[separatorNames[i]] = { type: separatorNames[i] };
	}

	Sep.BEFORE_ASSIGN_OP = function (op) {
	  return {
	    type: "BEFORE_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.AFTER_ASSIGN_OP = function (op) {
	  return {
	    type: "AFTER_ASSIGN_OP",
	    op: op
	  };
	};

	Sep.BEFORE_BINOP = function (op) {
	  return {
	    type: "BEFORE_BINOP",
	    op: op
	  };
	};

	Sep.AFTER_BINOP = function (op) {
	  return {
	    type: "AFTER_BINOP",
	    op: op
	  };
	};

	Sep.BEFORE_POSTFIX = function (op) {
	  return {
	    type: "BEFORE_POSTFIX",
	    op: op
	  };
	};

	Sep.UNARY = function (op) {
	  return {
	    type: "UNARY",
	    op: op
	  };
	};

	Sep.AFTER_STATEMENT = function (node) {
	  return {
	    type: "AFTER_STATEMENT",
	    node: node
	  };
	};

	Sep.BEFORE_FUNCTION_NAME = function (node) {
	  return {
	    type: "BEFORE_FUNCTION_NAME",
	    node: node
	  };
	};
	exports.Sep = Sep;

	var ExtensibleCodeGen = exports.ExtensibleCodeGen = function () {
	  function ExtensibleCodeGen() {
	    _classCallCheck(this, ExtensibleCodeGen);
	  }

	  _createClass(ExtensibleCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp());
	      }
	      return original;
	    }
	  }, {
	    key: "t",
	    value: function t(token) {
	      return new _coderep.Token(token);
	    }
	  }, {
	    key: "p",
	    value: function p(node, precedence, a) {
	      return (0, _coderep.getPrecedence)(node) < precedence ? this.paren(a, Sep.PRECEDENCE_BEFORE, Sep.PRECEDENCE_AFTER) : a;
	    }
	  }, {
	    key: "getAssignmentExpr",
	    value: function getAssignmentExpr(state) {
	      return state ? state.containsGroup ? this.paren(state, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER) : state : empty();
	    }
	  }, {
	    key: "paren",
	    value: function paren(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Paren(this.sep(empty));
	      }
	      return new _coderep.Paren(seq(first ? this.sep(first) : new _coderep.Empty(), rep, last ? this.sep(last) : new _coderep.Empty()));
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Brace(this.sep(empty));
	      }
	      return new _coderep.Brace(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "bracket",
	    value: function bracket(rep, first, last, empty) {
	      if (isEmpty(rep)) {
	        return new _coderep.Bracket(this.sep(empty));
	      }
	      return new _coderep.Bracket(seq(this.sep(first), rep, this.sep(last)));
	    }
	  }, {
	    key: "commaSep",
	    value: function commaSep(pieces, before, after) {
	      var _this = this;

	      var first = true;
	      pieces = pieces.map(function (p) {
	        if (first) {
	          first = false;
	          return p;
	        } else {
	          return seq(_this.sep(before), _this.t(","), _this.sep(after), p);
	        }
	      });
	      return seq.apply(undefined, _toConsumableArray(pieces));
	    }
	  }, {
	    key: "semiOp",
	    value: function semiOp() {
	      return new _coderep.SemiOp();
	    }
	  }, {
	    key: "sep",
	    value: function sep(kind) {
	      return new _coderep.Empty();
	    }
	  }, {
	    key: "reduceArrayExpression",
	    value: function reduceArrayExpression(node, _ref) {
	      var _this2 = this;

	      var elements = _ref.elements;

	      if (elements.length === 0) {
	        return this.bracket(empty(), null, null, Sep.ARRAY_EMPTY);
	      }

	      var content = this.commaSep(elements.map(function (e) {
	        return _this2.getAssignmentExpr(e);
	      }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	      if (elements.length > 0 && elements[elements.length - 1] == null) {
	        content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL);
	    }
	  }, {
	    key: "reduceSpreadElement",
	    value: function reduceSpreadElement(node, _ref2) {
	      var expression = _ref2.expression;

	      return seq(this.t("..."), this.sep(Sep.SPREAD), this.p(node.expression, _coderep.Precedence.Assignment, expression));
	    }
	  }, {
	    key: "reduceAssignmentExpression",
	    value: function reduceAssignmentExpression(node, _ref3) {
	      var binding = _ref3.binding;
	      var expression = _ref3.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP("=")), this.t("="), this.sep(Sep.AFTER_ASSIGN_OP("=")), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceCompoundAssignmentExpression",
	    value: function reduceCompoundAssignmentExpression(node, _ref4) {
	      var binding = _ref4.binding;
	      var expression = _ref4.expression;

	      var leftCode = binding;
	      var rightCode = expression;
	      var containsIn = expression.containsIn;
	      var startsWithCurly = binding.startsWithCurly;
	      var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
	      if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        containsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_ASSIGN_OP(node.operator)), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
	    }
	  }, {
	    key: "reduceBinaryExpression",
	    value: function reduceBinaryExpression(node, _ref5) {
	      var left = _ref5.left;
	      var right = _ref5.right;

	      var leftCode = left;
	      var startsWithCurly = left.startsWithCurly;
	      var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
	      var leftContainsIn = left.containsIn;
	      if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
	        leftCode = this.paren(leftCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        startsWithCurly = false;
	        startsWithLetSquareBracket = false;
	        startsWithFunctionOrClass = false;
	        leftContainsIn = false;
	      }
	      var rightCode = right;
	      var rightContainsIn = right.containsIn;
	      if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
	        rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        rightContainsIn = false;
	      }
	      return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_BINOP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_BINOP(node.operator)), rightCode), {
	        containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
	        containsGroup: node.operator == ",",
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceBindingWithDefault",
	    value: function reduceBindingWithDefault(node, _ref6) {
	      var binding = _ref6.binding;
	      var init = _ref6.init;

	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingIdentifier",
	    value: function reduceBindingIdentifier(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceArrayBinding",
	    value: function reduceArrayBinding(node, _ref7) {
	      var _this3 = this;

	      var elements = _ref7.elements;
	      var restElement = _ref7.restElement;

	      var content = undefined;
	      if (elements.length === 0) {
	        content = restElement == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), restElement);
	      } else {
	        elements = elements.concat(restElement == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), restElement)]);
	        content = this.commaSep(elements.map(function (e) {
	          return _this3.getAssignmentExpr(e);
	        }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
	        if (elements.length > 0 && elements[elements.length - 1] == null) {
	          content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
	        }
	      }
	      return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
	    }
	  }, {
	    key: "reduceObjectBinding",
	    value: function reduceObjectBinding(node, _ref8) {
	      var properties = _ref8.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceBindingPropertyIdentifier",
	    value: function reduceBindingPropertyIdentifier(node, _ref9) {
	      var binding = _ref9.binding;
	      var init = _ref9.init;

	      if (node.init == null) return binding;
	      return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), init);
	    }
	  }, {
	    key: "reduceBindingPropertyProperty",
	    value: function reduceBindingPropertyProperty(node, _ref10) {
	      var name = _ref10.name;
	      var binding = _ref10.binding;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
	    }
	  }, {
	    key: "reduceBlock",
	    value: function reduceBlock(node, _ref11) {
	      var statements = _ref11.statements;

	      return this.brace(seq.apply(undefined, _toConsumableArray(statements)), node, Sep.BLOCK_BRACE_INITIAL, Sep.BLOCK_BRACE_FINAL, Sep.BLOCK_EMPTY);
	    }
	  }, {
	    key: "reduceBlockStatement",
	    value: function reduceBlockStatement(node, _ref12) {
	      var block = _ref12.block;

	      return seq(block, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceBreakStatement",
	    value: function reduceBreakStatement(node, _ref13) {
	      var label = _ref13.label;

	      return seq(this.t("break"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceCallExpression",
	    value: function reduceCallExpression(node, _ref14) {
	      var callee = _ref14.callee;
	      var args = _ref14.arguments;

	      return (0, _objectAssign2.default)(seq(this.p(node.callee, (0, _coderep.getPrecedence)(node), callee), this.sep(Sep.CALL), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.CALL_PAREN_BEFORE, Sep.CALL_PAREN_AFTER, Sep.CALL_PAREN_EMPTY)), {
	        startsWithCurly: callee.startsWithCurly,
	        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
	        startsWithFunctionOrClass: callee.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceCatchClause",
	    value: function reduceCatchClause(node, _ref15) {
	      var binding = _ref15.binding;
	      var body = _ref15.body;

	      return seq(this.t("catch"), this.sep(Sep.BEFORE_CATCH_BINDING), this.paren(binding, Sep.CATCH_PAREN_BEFORE, Sep.CATCH_PAREN_AFTER), this.sep(Sep.AFTER_CATCH_BINDING), body);
	    }
	  }, {
	    key: "reduceClassDeclaration",
	    value: function reduceClassDeclaration(node, _ref16) {
	      var name = _ref16.name;
	      var _super = _ref16.super;
	      var elements = _ref16.elements;

	      var state = seq(this.t("class"), this.sep(Sep.BEFORE_CLASS_NAME), name);
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_DECLARATION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_BRACE_INITIAL, Sep.CLASS_BRACE_FINAL, Sep.CLASS_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	      return state;
	    }
	  }, {
	    key: "reduceClassExpression",
	    value: function reduceClassExpression(node, _ref17) {
	      var name = _ref17.name;
	      var _super = _ref17.super;
	      var elements = _ref17.elements;

	      var state = this.t("class");
	      if (name != null) {
	        state = seq(state, this.sep(Sep.BEFORE_CLASS_NAME), name);
	      }
	      if (_super != null) {
	        state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), _super);
	      }
	      state = seq(state, this.sep(Sep.BEFORE_CLASS_EXPRESSION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_EXPRESSION_BRACE_INITIAL, Sep.CLASS_EXPRESSION_BRACE_FINAL, Sep.CLASS_EXPRESSION_BRACE_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceClassElement",
	    value: function reduceClassElement(node, _ref18) {
	      var method = _ref18.method;

	      method = seq(this.sep(Sep.BEFORE_CLASS_ELEMENT), method, this.sep(Sep.AFTER_CLASS_ELEMENT));
	      if (!node.isStatic) return method;
	      return seq(this.t("static"), this.sep(Sep.AFTER_STATIC), method);
	    }
	  }, {
	    key: "reduceComputedMemberExpression",
	    value: function reduceComputedMemberExpression(node, _ref19) {
	      var object = _ref19.object;
	      var expression = _ref19.expression;

	      var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
	      return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_EXPRESSION), this.bracket(expression, Sep.COMPUTED_MEMBER_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_BRACKET_FINAL)), {
	        startsWithLet: object.startsWithLet,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithCurly: object.startsWithCurly,
	        startsWithFunctionOrClass: object.startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceComputedPropertyName",
	    value: function reduceComputedPropertyName(node, _ref20) {
	      var expression = _ref20.expression;

	      return this.bracket(expression, Sep.COMPUTED_PROPERTY_BRACKET_INTIAL, Sep.COMPUTED_PROPERTY_BRACKET_FINAL);
	    }
	  }, {
	    key: "reduceConditionalExpression",
	    value: function reduceConditionalExpression(node, _ref21) {
	      var test = _ref21.test;
	      var consequent = _ref21.consequent;
	      var alternate = _ref21.alternate;

	      var containsIn = test.containsIn || alternate.containsIn;
	      var startsWithCurly = test.startsWithCurly;
	      var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
	      var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
	      return (0, _objectAssign2.default)(seq(this.p(node.test, _coderep.Precedence.LogicalOR, test), this.sep(Sep.BEFORE_TERNARY_QUESTION), this.t("?"), this.sep(Sep.AFTER_TERNARY_QUESTION), this.p(node.consequent, _coderep.Precedence.Assignment, consequent), this.sep(Sep.BEFORE_TERNARY_COLON), this.t(":"), this.sep(Sep.AFTER_TERNARY_COLON), this.p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
	        containsIn: containsIn,
	        startsWithCurly: startsWithCurly,
	        startsWithLetSquareBracket: startsWithLetSquareBracket,
	        startsWithFunctionOrClass: startsWithFunctionOrClass
	      });
	    }
	  }, {
	    key: "reduceContinueStatement",
	    value: function reduceContinueStatement(node, _ref22) {
	      var label = _ref22.label;

	      return seq(this.t("continue"), label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDataProperty",
	    value: function reduceDataProperty(node, _ref23) {
	      var name = _ref23.name;
	      var expression = _ref23.expression;

	      return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), this.getAssignmentExpr(expression));
	    }
	  }, {
	    key: "reduceDebuggerStatement",
	    value: function reduceDebuggerStatement(node) {
	      return seq(this.t("debugger"), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref24) {
	      var body = _ref24.body;
	      var test = _ref24.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), body, this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceEmptyStatement",
	    value: function reduceEmptyStatement(node) {
	      return seq(this.t(";"), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExpressionStatement",
	    value: function reduceExpressionStatement(node, _ref25) {
	      var expression = _ref25.expression;

	      var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
	      return seq(needsParens ? this.paren(expression, Sep.EXPRESSION_STATEMENT_PAREN_BEFORE, Sep.EXPRESSION_STATEMENT_PAREN_AFTER) : expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceForInStatement",
	    value: function reduceForInStatement(node, _ref26) {
	      var left = _ref26.left;
	      var right = _ref26.right;
	      var body = _ref26.body;

	      var leftP = left;
	      switch (node.left.type) {
	        case "VariableDeclaration":
	          leftP = noIn(markContainsIn(left));
	          break;
	        case "BindingIdentifier":
	          if (node.left.name === "let") {
	            leftP = this.paren(left, Sep.FOR_IN_LET_PAREN_BEFORE, Sep.FOR_IN_LET_PAREN_BEFORE);
	          }
	          break;
	      }
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FORIN_FOR), this.paren(seq(leftP, this.sep(Sep.BEFORE_FORIN_IN), this.t("in"), this.sep(Sep.AFTER_FORIN_FOR), right), Sep.FOR_IN_PAREN_BEFORE, Sep.FOR_IN_PAREN_AFTER), this.sep(Sep.BEFORE_FORIN_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForOfStatement",
	    value: function reduceForOfStatement(node, _ref27) {
	      var left = _ref27.left;
	      var right = _ref27.right;
	      var body = _ref27.body;

	      left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOROF_FOR), this.paren(seq(left.startsWithLet ? this.paren(left, Sep.FOR_OF_LET_PAREN_BEFORE, Sep.FOR_OF_LET_PAREN_AFTER) : left, this.sep(Sep.BEFORE_FOROF_OF), this.t("of"), this.sep(Sep.AFTER_FOROF_FOR), right), Sep.FOR_OF_PAREN_BEFORE, Sep.FOR_OF_PAREN_AFTER), this.sep(Sep.BEFORE_FOROF_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceForStatement",
	    value: function reduceForStatement(node, _ref28) {
	      var init = _ref28.init;
	      var test = _ref28.test;
	      var update = _ref28.update;
	      var body = _ref28.body;

	      return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOR_FOR), this.paren(seq(init ? seq(this.sep(Sep.BEFORE_FOR_INIT), noIn(markContainsIn(init)), this.sep(Sep.AFTER_FOR_INIT)) : this.sep(Sep.EMPTY_FOR_INIT), this.t(";"), test ? seq(this.sep(Sep.BEFORE_FOR_TEST), test, this.sep(Sep.AFTER_FOR_TEST)) : this.sep(Sep.EMPTY_FOR_TEST), this.t(";"), update ? seq(this.sep(Sep.BEFORE_FOR_UPDATE), update, this.sep(Sep.AFTER_FOR_UPDATE)) : this.sep(Sep.EMPTY_FOR_UPDATE))), this.sep(Sep.BEFORE_FOR_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), {
	        endsWithMissingElse: body.endsWithMissingElse
	      });
	    }
	  }, {
	    key: "reduceFunctionBody",
	    value: function reduceFunctionBody(node, _ref29) {
	      var directives = _ref29.directives;
	      var statements = _ref29.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_FUNCTION_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceFunctionDeclaration",
	    value: function reduceFunctionDeclaration(node, _ref30) {
	      var name = _ref30.name;
	      var params = _ref30.params;
	      var body = _ref30.body;

	      return seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), node.name.name === "*default*" ? empty() : name, this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_DECLARATION_BODY), this.brace(body, node, Sep.FUNCTION_BRACE_INITIAL, Sep.FUNCTION_BRACE_FINAL, Sep.FUNCTION_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceFunctionExpression",
	    value: function reduceFunctionExpression(node, _ref31) {
	      var name = _ref31.name;
	      var params = _ref31.params;
	      var body = _ref31.body;

	      var state = seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), name ? name : empty(), this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_EXPRESSION_BODY), this.brace(body, node, Sep.FUNCTION_EXPRESSION_BRACE_INITIAL, Sep.FUNCTION_EXPRESSION_BRACE_FINAL, Sep.FUNCTION_EXPRESSION_EMPTY));
	      state.startsWithFunctionOrClass = true;
	      return state;
	    }
	  }, {
	    key: "reduceFormalParameters",
	    value: function reduceFormalParameters(node, _ref32) {
	      var items = _ref32.items;
	      var rest = _ref32.rest;

	      return this.commaSep(items.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]), Sep.PARAMETER_BEFORE_COMMA, Sep.PARAMETER_AFTER_COMMA);
	    }
	  }, {
	    key: "reduceArrowExpression",
	    value: function reduceArrowExpression(node, _ref33) {
	      var params = _ref33.params;
	      var body = _ref33.body;

	      if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
	        params = this.paren(params, Sep.ARROW_PARAMETERS_PAREN_BEFORE, Sep.ARROW_PARAMETERS_PAREN_AFTER, Sep.ARROW_PARAMETERS_PAREN_EMPTY);
	      }
	      if (node.body.type === "FunctionBody") {
	        body = this.brace(body, node, Sep.ARROW_BRACE_INITIAL, Sep.ARROW_BRACE_FINAL, Sep.ARROW_BRACE_EMPTY);
	      } else if (body.startsWithCurly) {
	        body = this.paren(body, Sep.ARROW_BODY_PAREN_BEFORE, Sep.ARROW_BODY_PAREN_AFTER);
	      }
	      return seq(params, this.sep(Sep.BEFORE_ARROW), this.t("=>"), this.sep(Sep.AFTER_ARROW), this.p(node.body, _coderep.Precedence.Assignment, body));
	    }
	  }, {
	    key: "reduceGetter",
	    value: function reduceGetter(node, _ref34) {
	      var name = _ref34.name;
	      var body = _ref34.body;

	      return seq(this.t("get"), this.sep(Sep.AFTER_GET), name, this.sep(Sep.BEFORE_GET_PARAMS), this.paren(empty(), null, null, Sep.GETTER_PARAMS), this.sep(Sep.BEFORE_GET_BODY), this.brace(body, node, Sep.GET_BRACE_INTIAL, Sep.GET_BRACE_FINAL, Sep.GET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceIdentifierExpression",
	    value: function reduceIdentifierExpression(node) {
	      var a = this.t(node.name);
	      if (node.name === "let") {
	        a.startsWithLet = true;
	      }
	      return a;
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref35) {
	      var test = _ref35.test;
	      var consequent = _ref35.consequent;
	      var alternate = _ref35.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node, Sep.MISSING_ELSE_INTIIAL, Sep.MISSING_ELSE_FINAL, Sep.MISSING_ELSE_EMPTY);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), consequent, alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), alternate) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceImport",
	    value: function reduceImport(node, _ref36) {
	      var defaultBinding = _ref36.defaultBinding;
	      var namedImports = _ref36.namedImports;

	      var bindings = [];
	      if (defaultBinding != null) {
	        bindings.push(defaultBinding);
	      }
	      if (namedImports.length > 0) {
	        bindings.push(this.brace(this.commaSep(namedImports, Sep.NAMED_IMPORT_BEFORE_COMMA, Sep.NAMED_IMPORT_AFTER_COMMA), node, Sep.IMPORT_BRACE_INTIAL, Sep.IMPORT_BRACE_FINAL, Sep.IMPORT_BRACE_EMPTY));
	      }
	      if (bindings.length === 0) {
	        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_MODULE), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_BINDINGS), this.commaSep(bindings, Sep.IMPORT_BEFORE_COMMA, Sep.IMPORT_AFTER_COMMA), this.sep(Sep.AFTER_IMPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportNamespace",
	    value: function reduceImportNamespace(node, _ref37) {
	      var defaultBinding = _ref37.defaultBinding;
	      var namespaceBinding = _ref37.namespaceBinding;

	      return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_NAMESPACE), defaultBinding == null ? empty() : seq(defaultBinding, this.sep(Sep.IMPORT_BEFORE_COMMA), this.t(","), this.sep(Sep.IMPORT_AFTER_COMMA)), this.sep(Sep.BEFORE_IMPORT_STAR), this.t("*"), this.sep(Sep.AFTER_IMPORT_STAR), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), namespaceBinding, this.sep(Sep.AFTER_NAMESPACE_BINDING), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceImportSpecifier",
	    value: function reduceImportSpecifier(node, _ref38) {
	      var binding = _ref38.binding;

	      if (node.name == null) return binding;
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_IMPORT_AS), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), binding);
	    }
	  }, {
	    key: "reduceExportAllFrom",
	    value: function reduceExportAllFrom(node) {
	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_STAR), this.t("*"), this.sep(Sep.AFTER_EXPORT_STAR), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceExportFrom",
	    value: function reduceExportFrom(node, _ref39) {
	      var namedExports = _ref39.namedExports;

	      return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), node.moduleSpecifier == null ? empty() : seq(this.sep(Sep.AFTER_EXPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node))));
	    }
	  }, {
	    key: "reduceExport",
	    value: function reduceExport(node, _ref40) {
	      var declaration = _ref40.declaration;

	      switch (node.declaration.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          declaration = seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.AFTER_EXPORT), declaration);
	    }
	  }, {
	    key: "reduceExportDefault",
	    value: function reduceExportDefault(node, _ref41) {
	      var body = _ref41.body;

	      body = body.startsWithFunctionOrClass ? this.paren(body, Sep.EXPORT_PAREN_BEFORE, Sep.EXPORT_PAREN_AFTER) : body;
	      switch (node.body.type) {
	        case "FunctionDeclaration":
	        case "ClassDeclaration":
	          break;
	        default:
	          body = seq(body, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	      }
	      return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), body);
	    }
	  }, {
	    key: "reduceExportSpecifier",
	    value: function reduceExportSpecifier(node) {
	      if (node.name == null) return this.t(node.exportedName);
	      return seq(this.t(node.name), this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
	    }
	  }, {
	    key: "reduceLabeledStatement",
	    value: function reduceLabeledStatement(node, _ref42) {
	      var label = _ref42.label;
	      var body = _ref42.body;

	      return (0, _objectAssign2.default)(seq(this.t(label), this.sep(Sep.BEFORE_LABEL_COLON), this.t(":"), this.sep(Sep.AFTER_LABEL_COLON), body), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceLiteralBooleanExpression",
	    value: function reduceLiteralBooleanExpression(node) {
	      return this.t(node.value.toString());
	    }
	  }, {
	    key: "reduceLiteralNullExpression",
	    value: function reduceLiteralNullExpression(node) {
	      return this.t("null");
	    }
	  }, {
	    key: "reduceLiteralInfinityExpression",
	    value: function reduceLiteralInfinityExpression(node) {
	      return this.t("2e308");
	    }
	  }, {
	    key: "reduceLiteralNumericExpression",
	    value: function reduceLiteralNumericExpression(node) {
	      return new _coderep.NumberCodeRep(node.value);
	    }
	  }, {
	    key: "reduceLiteralRegExpExpression",
	    value: function reduceLiteralRegExpExpression(node) {
	      return this.t("/" + node.pattern + "/" + node.flags);
	    }
	  }, {
	    key: "reduceLiteralStringExpression",
	    value: function reduceLiteralStringExpression(node) {
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceMethod",
	    value: function reduceMethod(node, _ref43) {
	      var name = _ref43.name;
	      var params = _ref43.params;
	      var body = _ref43.body;

	      return seq(node.isGenerator ? seq(this.t("*"), this.sep(Sep.AFTER_METHOD_GENERATOR_STAR)) : empty(), name, this.sep(Sep.AFTER_METHOD_NAME), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_METHOD_BODY), this.brace(body, node, Sep.METHOD_BRACE_INTIAL, Sep.METHOD_BRACE_FINAL, Sep.METHOD_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceModule",
	    value: function reduceModule(node, _ref44) {
	      var directives = _ref44.directives;
	      var items = _ref44.items;

	      if (items.length) {
	        items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_MODULE_DIRECTIVES) : empty()], _toConsumableArray(items)));
	    }
	  }, {
	    key: "reduceNewExpression",
	    value: function reduceNewExpression(node, _ref45) {
	      var callee = _ref45.callee;
	      var args = _ref45.arguments;

	      var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? this.paren(callee, Sep.NEW_CALLEE_PAREN_BEFORE, Sep.NEW_CALLEE_PAREN_AFTER) : this.p(node.callee, (0, _coderep.getPrecedence)(node), callee);
	      return seq(this.t("new"), this.sep(Sep.AFTER_NEW), calleeRep, args.length === 0 ? this.sep(Sep.EMPTY_NEW_CALL) : seq(this.sep(Sep.BEFORE_NEW_ARGS), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.NEW_PAREN_BEFORE, Sep.NEW_PAREN_AFTER, Sep.NEW_PAREN_EMPTY)));
	    }
	  }, {
	    key: "reduceNewTargetExpression",
	    value: function reduceNewTargetExpression() {
	      return seq(this.t("new"), this.sep(Sep.NEW_TARGET_BEFORE_DOT), this.t("."), this.sep(Sep.NEW_TARGET_AFTER_DOT), this.t("target"));
	    }
	  }, {
	    key: "reduceObjectExpression",
	    value: function reduceObjectExpression(node, _ref46) {
	      var properties = _ref46.properties;

	      var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
	      state.startsWithCurly = true;
	      return state;
	    }
	  }, {
	    key: "reduceUpdateExpression",
	    value: function reduceUpdateExpression(node, _ref47) {
	      var operand = _ref47.operand;

	      if (node.isPrefix) {
	        return this.reduceUnaryExpression.apply(this, arguments);
	      } else {
	        return (0, _objectAssign2.default)(seq(this.p(node.operand, _coderep.Precedence.New, operand), this.sep(Sep.BEFORE_POSTFIX(node.operator)), this.t(node.operator)), {
	          startsWithCurly: operand.startsWithCurly,
	          startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
	          startsWithFunctionOrClass: operand.startsWithFunctionOrClass
	        });
	      }
	    }
	  }, {
	    key: "reduceUnaryExpression",
	    value: function reduceUnaryExpression(node, _ref48) {
	      var operand = _ref48.operand;

	      return seq(this.t(node.operator), this.sep(Sep.UNARY(node.operator)), this.p(node.operand, (0, _coderep.getPrecedence)(node), operand));
	    }
	  }, {
	    key: "reduceReturnStatement",
	    value: function reduceReturnStatement(node, _ref49) {
	      var expression = _ref49.expression;

	      return seq(this.t("return"), expression ? seq(this.sep(Sep.RETURN), expression) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceScript",
	    value: function reduceScript(node, _ref50) {
	      var directives = _ref50.directives;
	      var statements = _ref50.statements;

	      if (statements.length) {
	        statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
	      }
	      return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_SCRIPT_DIRECTIVES) : empty()], _toConsumableArray(statements)));
	    }
	  }, {
	    key: "reduceSetter",
	    value: function reduceSetter(node, _ref51) {
	      var name = _ref51.name;
	      var param = _ref51.param;
	      var body = _ref51.body;

	      return seq(this.t("set"), this.sep(Sep.AFTER_SET), name, this.sep(Sep.BEFORE_SET_PARAMS), this.paren(param, Sep.SETTER_PARAM_BEFORE, Sep.SETTER_PARAM_AFTER), this.sep(Sep.BEFORE_SET_BODY), this.brace(body, node, Sep.SET_BRACE_INTIIAL, Sep.SET_BRACE_FINAL, Sep.SET_BRACE_EMPTY));
	    }
	  }, {
	    key: "reduceShorthandProperty",
	    value: function reduceShorthandProperty(node) {
	      return this.t(node.name);
	    }
	  }, {
	    key: "reduceStaticMemberExpression",
	    value: function reduceStaticMemberExpression(node, _ref52) {
	      var object = _ref52.object;
	      var property = _ref52.property;

	      var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_DOT), this.t(property));
	      state.startsWithLet = object.startsWithLet;
	      state.startsWithCurly = object.startsWithCurly;
	      state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
	      state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
	      return state;
	    }
	  }, {
	    key: "reduceStaticPropertyName",
	    value: function reduceStaticPropertyName(node) {
	      var n;
	      if (_esutils.keyword.isIdentifierNameES6(node.value)) {
	        return this.t(node.value);
	      } else if (n = parseFloat(node.value), n === n) {
	        return new _coderep.NumberCodeRep(n);
	      }
	      return this.t((0, _coderep.escapeStringLiteral)(node.value));
	    }
	  }, {
	    key: "reduceSuper",
	    value: function reduceSuper() {
	      return this.t("super");
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref53) {
	      var test = _ref53.test;
	      var consequent = _ref53.consequent;

	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref54) {
	      var consequent = _ref54.consequent;

	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "reduceSwitchStatement",
	    value: function reduceSwitchStatement(node, _ref55) {
	      var discriminant = _ref55.discriminant;
	      var cases = _ref55.cases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(cases)), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceSwitchStatementWithDefault",
	    value: function reduceSwitchStatementWithDefault(node, _ref56) {
	      var discriminant = _ref56.discriminant;
	      var preDefaultCases = _ref56.preDefaultCases;
	      var defaultCase = _ref56.defaultCase;
	      var postDefaultCases = _ref56.postDefaultCases;

	      return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases))), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTemplateExpression",
	    value: function reduceTemplateExpression(node, _ref57) {
	      var tag = _ref57.tag;
	      var elements = _ref57.elements;

	      var state = node.tag == null ? empty() : seq(this.p(node.tag, (0, _coderep.getPrecedence)(node), tag), this.sep(Sep.TEMPLATE_TAG));
	      var templateData = "";
	      state = seq(state, this.t("`"));
	      for (var i = 0, l = node.elements.length; i < l; ++i) {
	        if (node.elements[i].type === "TemplateElement") {
	          var d = "";
	          if (i > 0) d += "}";
	          d += node.elements[i].rawValue;
	          if (i < l - 1) d += "${";
	          state = seq(state, this.t(d));
	        } else {
	          state = seq(state, this.sep(Sep.BEFORE_TEMPLATE_EXPRESSION), elements[i], this.sep(Sep.AFTER_TEMPLATE_EXPRESSION));
	        }
	      }
	      state = seq(state, this.t("`"));
	      if (node.tag != null) {
	        state.startsWithCurly = tag.startsWithCurly;
	        state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
	        state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
	      }
	      return state;
	    }
	  }, {
	    key: "reduceTemplateElement",
	    value: function reduceTemplateElement(node) {
	      return this.t(node.rawValue);
	    }
	  }, {
	    key: "reduceThisExpression",
	    value: function reduceThisExpression(node) {
	      return this.t("this");
	    }
	  }, {
	    key: "reduceThrowStatement",
	    value: function reduceThrowStatement(node, _ref58) {
	      var expression = _ref58.expression;

	      return seq(this.t("throw"), this.sep(Sep.THROW), expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryCatchStatement",
	    value: function reduceTryCatchStatement(node, _ref59) {
	      var body = _ref59.body;
	      var catchClause = _ref59.catchClause;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, this.sep(Sep.BEFORE_CATCH), catchClause, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceTryFinallyStatement",
	    value: function reduceTryFinallyStatement(node, _ref60) {
	      var body = _ref60.body;
	      var catchClause = _ref60.catchClause;
	      var finalizer = _ref60.finalizer;

	      return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, catchClause ? seq(this.sep(Sep.BEFORE_CATCH), catchClause) : empty(), this.sep(Sep.BEFORE_FINALLY), this.t("finally"), this.sep(Sep.AFTER_FINALLY), finalizer, this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceYieldExpression",
	    value: function reduceYieldExpression(node, _ref61) {
	      var expression = _ref61.expression;

	      if (node.expression == null) return this.t("yield");
	      return seq(this.t("yield"), this.sep(Sep.YIELD), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceYieldGeneratorExpression",
	    value: function reduceYieldGeneratorExpression(node, _ref62) {
	      var expression = _ref62.expression;

	      return seq(this.t("yield"), this.sep(Sep.BEFORE_YIELD_STAR), this.t("*"), this.sep(Sep.AFTER_YIELD_STAR), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
	    }
	  }, {
	    key: "reduceDirective",
	    value: function reduceDirective(node) {
	      var delim = /^(?:[^"\\]|\\.)*$/.test(node.rawValue) ? "\"" : "'";
	      return seq(this.t(delim + node.rawValue + delim), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclaration",
	    value: function reduceVariableDeclaration(node, _ref63) {
	      var declarators = _ref63.declarators;

	      return seq(this.t(node.kind), this.sep(Sep.VARIABLE_DECLARATION), this.commaSep(declarators, Sep.DECLARATORS_BEFORE_COMMA, Sep.DECLARATORS_AFTER_COMMA));
	    }
	  }, {
	    key: "reduceVariableDeclarationStatement",
	    value: function reduceVariableDeclarationStatement(node, _ref64) {
	      var declaration = _ref64.declaration;

	      return seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceVariableDeclarator",
	    value: function reduceVariableDeclarator(node, _ref65) {
	      var binding = _ref65.binding;
	      var init = _ref65.init;

	      var containsIn = init && init.containsIn && !init.containsGroup;
	      if (init) {
	        if (init.containsGroup) {
	          init = this.paren(init, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
	        } else {
	          init = markContainsIn(init);
	        }
	      }
	      return (0, _objectAssign2.default)(init == null ? binding : seq(binding, this.sep(Sep.BEFORE_INIT_EQUALS), this.t("="), this.sep(Sep.AFTER_INIT_EQUALS), init), { containsIn: containsIn });
	    }
	  }, {
	    key: "reduceWhileStatement",
	    value: function reduceWhileStatement(node, _ref66) {
	      var test = _ref66.test;
	      var body = _ref66.body;

	      return (0, _objectAssign2.default)(seq(this.t("while"), this.sep(Sep.AFTER_WHILE), this.paren(test, Sep.WHILE_TEST_PAREN_BEFORE, Sep.WHILE_TEST_PAREN_AFTER), this.sep(Sep.BEFORE_WHILE_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }, {
	    key: "reduceWithStatement",
	    value: function reduceWithStatement(node, _ref67) {
	      var object = _ref67.object;
	      var body = _ref67.body;

	      return (0, _objectAssign2.default)(seq(this.t("with"), this.sep(Sep.AFTER_WITH), this.paren(object, Sep.WITH_PAREN_BEFORE, Sep.WITH_PAREN_AFTER), this.sep(Sep.BEFORE_WITH_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
	    }
	  }]);

	  return ExtensibleCodeGen;
	}();

	var INDENT = "  ";

	var Linebreak = function (_CodeRep) {
	  _inherits(Linebreak, _CodeRep);

	  function Linebreak() {
	    _classCallCheck(this, Linebreak);

	    var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Linebreak).call(this));

	    _this4.indentation = 0;
	    return _this4;
	  }

	  _createClass(Linebreak, [{
	    key: "emit",
	    value: function emit(ts) {
	      ts.put("\n");
	      for (var i = 0; i < this.indentation; ++i) {
	        ts.put(INDENT);
	      }
	    }
	  }]);

	  return Linebreak;
	}(_coderep.CodeRep);

	function withoutTrailingLinebreak(state) {
	  if (state && state instanceof _coderep.Seq) {
	    var lastChild = state.children[state.children.length - 1];
	    /* istanbul ignore next */
	    while (lastChild instanceof _coderep.Empty) {
	      state.children.pop();
	      lastChild = state.children[state.children.length - 1];
	    }
	    /* istanbul ignore else */
	    if (lastChild instanceof _coderep.Seq) {
	      withoutTrailingLinebreak(lastChild);
	    } else if (lastChild instanceof Linebreak) {
	      state.children.pop();
	    }
	  }
	  return state;
	}

	function indent(rep, includingFinal) {
	  var finalLinebreak = undefined;
	  function indentNode(node) {
	    if (node instanceof Linebreak) {
	      finalLinebreak = node;
	      ++node.indentation;
	    }
	  }
	  rep.forEach(indentNode);
	  if (!includingFinal) {
	    --finalLinebreak.indentation;
	  }
	  return rep;
	}

	var FormattedCodeGen = exports.FormattedCodeGen = function (_ExtensibleCodeGen) {
	  _inherits(FormattedCodeGen, _ExtensibleCodeGen);

	  function FormattedCodeGen() {
	    _classCallCheck(this, FormattedCodeGen);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(FormattedCodeGen).apply(this, arguments));
	  }

	  _createClass(FormattedCodeGen, [{
	    key: "parenToAvoidBeingDirective",
	    value: function parenToAvoidBeingDirective(element, original) {
	      if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
	        return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(element)));
	      }
	      return original;
	    }
	  }, {
	    key: "brace",
	    value: function brace(rep, node) {
	      if (isEmpty(rep)) {
	        return this.t("{}");
	      }

	      switch (node.type) {
	        case "ObjectBinding":
	        case "Import":
	        case "ExportFrom":
	        case "ObjectExpression":
	          return new _coderep.Brace(rep);
	      }

	      rep = seq(new Linebreak(), rep);
	      indent(rep, false);
	      return new _coderep.Brace(rep);
	    }
	  }, {
	    key: "reduceDoWhileStatement",
	    value: function reduceDoWhileStatement(node, _ref68) {
	      var body = _ref68.body;
	      var test = _ref68.test;

	      return seq(this.t("do"), this.sep(Sep.AFTER_DO), withoutTrailingLinebreak(body), this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
	    }
	  }, {
	    key: "reduceIfStatement",
	    value: function reduceIfStatement(node, _ref69) {
	      var test = _ref69.test;
	      var consequent = _ref69.consequent;
	      var alternate = _ref69.alternate;

	      if (alternate && consequent.endsWithMissingElse) {
	        consequent = this.brace(consequent, node);
	      }
	      return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), withoutTrailingLinebreak(consequent), alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), withoutTrailingLinebreak(alternate)) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
	    }
	  }, {
	    key: "reduceSwitchCase",
	    value: function reduceSwitchCase(node, _ref70) {
	      var test = _ref70.test;
	      var consequent = _ref70.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), consequent, this.sep(Sep.AFTER_CASE_BODY));
	    }
	  }, {
	    key: "reduceSwitchDefault",
	    value: function reduceSwitchDefault(node, _ref71) {
	      var consequent = _ref71.consequent;

	      consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
	      return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), consequent, this.sep(Sep.AFTER_DEFAULT_BODY));
	    }
	  }, {
	    key: "sep",
	    value: function sep(separator) {
	      switch (separator.type) {
	        case "ARRAY_AFTER_COMMA":
	        case "OBJECT_AFTER_COMMA":
	        case "ARGS_AFTER_COMMA":
	        case "PARAMETER_AFTER_COMMA":
	        case "DECLARATORS_AFTER_COMMA":
	        case "NAMED_IMPORT_AFTER_COMMA":
	        case "IMPORT_AFTER_COMMA":
	        case "BEFORE_DEFAULT_EQUALS":
	        case "AFTER_DEFAULT_EQUALS":
	        case "AFTER_PROP":
	        case "BEFORE_JUMP_LABEL":
	        case "BEFORE_CATCH":
	        case "BEFORE_CATCH_BINDING":
	        case "AFTER_CATCH_BINDING":
	        case "BEFORE_CLASS_NAME":
	        case "BEFORE_EXTENDS":
	        case "AFTER_EXTENDS":
	        case "BEFORE_CLASS_DECLARATION_ELEMENTS":
	        case "BEFORE_CLASS_EXPRESSION_ELEMENTS":
	        case "AFTER_STATIC":
	        case "BEFORE_TERNARY_QUESTION":
	        case "AFTER_TERNARY_QUESTION":
	        case "BEFORE_TERNARY_COLON":
	        case "AFTER_TERNARY_COLON":
	        case "AFTER_DO":
	        case "BEFORE_DOWHILE_WHILE":
	        case "AFTER_DOWHILE_WHILE":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_IN":
	        case "AFTER_FORIN_FOR":
	        case "BEFORE_FORIN_BODY":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_OF":
	        case "AFTER_FOROF_FOR":
	        case "BEFORE_FOROF_BODY":
	        case "AFTER_FOR_FOR":
	        case "BEFORE_FOR_TEST":
	        case "BEFORE_FOR_UPDATE":
	        case "BEFORE_FOR_BODY":
	        case "BEFORE_FUNCTION_DECLARATION_BODY":
	        case "BEFORE_FUNCTION_EXPRESSION_BODY":
	        case "BEFORE_ARROW":
	        case "AFTER_ARROW":
	        case "AFTER_GET":
	        case "BEFORE_GET_BODY":
	        case "AFTER_IF":
	        case "AFTER_IF_TEST":
	        case "BEFORE_ELSE":
	        case "AFTER_ELSE":
	        case "BEFORE_IMPORT_BINDINGS":
	        case "BEFORE_IMPORT_MODULE":
	        case "AFTER_IMPORT_BINDINGS":
	        case "AFTER_FROM":
	        case "BEFORE_IMPORT_NAMESPACE":
	        case "BEFORE_IMPORT_STAR":
	        case "AFTER_IMPORT_STAR":
	        case "AFTER_IMPORT_AS":
	        case "AFTER_NAMESPACE_BINDING":
	        case "BEFORE_IMPORT_AS":
	        case "AFTER_IMPORT_AS":
	        case "EXPORTS_AFTER_COMMA":
	        case "BEFORE_EXPORT_STAR":
	        case "AFTER_EXPORT_STAR":
	        case "BEFORE_EXPORT_BINDINGS":
	        case "AFTER_EXPORT_BINDINGS":
	        case "AFTER_EXPORT":
	        case "AFTER_EXPORT_DEFAULT":
	        case "BEFORE_EXPORT_AS":
	        case "AFTER_EXPORT_AS":
	        case "AFTER_LABEL_COLON":
	        case "BEFORE_METHOD_BODY":
	        case "AFTER_NEW":
	        case "RETURN":
	        case "AFTER_SET":
	        case "BEFORE_SET_BODY":
	        case "BEFORE_SET_PARAMS":
	        case "BEFORE_CASE_TEST":
	        case "BEFORE_SWITCH_DISCRIM":
	        case "BEFORE_SWITCH_BODY":
	        case "THROW":
	        case "AFTER_TRY":
	        case "BEFORE_CATCH":
	        case "BEFORE_FINALLY":
	        case "AFTER_FINALLY":
	        case "VARIABLE_DECLARATION":
	        case "YIELD":
	        case "AFTER_YIELD_STAR":
	        case "DECLARATORS_AFTER_COMMA":
	        case "BEFORE_INIT_EQUALS":
	        case "AFTER_INIT_EQUALS":
	        case "AFTER_WHILE":
	        case "BEFORE_WHILE_BODY":
	        case "AFTER_WITH":
	        case "BEFORE_WITH_BODY":
	        case "BEFORE_FUNCTION_NAME":
	        case "AFTER_BINOP":
	        case "BEFORE_ASSIGN_OP":
	        case "AFTER_ASSIGN_OP":
	          return this.t(" ");
	        case "AFTER_STATEMENT":
	          switch (separator.node.type) {
	            case "ForInStatement":
	            case "ForOfStatement":
	            case "ForStatement":
	            case "WhileStatement":
	            case "WithStatement":
	              return empty(); // because those already end with an AFTER_STATEMENT
	            default:
	              return new Linebreak();
	          }
	        case "AFTER_CLASS_ELEMENT":
	        case "BEFORE_CASE_BODY":
	        case "AFTER_CASE_BODY":
	        case "AFTER_DEFAULT_BODY":
	          return new Linebreak();
	        case "BEFORE_BINOP":
	          return separator.op === "," ? empty() : this.t(" ");
	        case "UNARY":
	          return separator.op === "delete" || separator.op === "void" || separator.op === "typeof" ? this.t(" ") : empty();
	        default:
	          return empty();
	      }
	    }
	  }]);

	  return FormattedCodeGen;
	}(ExtensibleCodeGen);

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MonoidalReducer = exports.CloneReducer = undefined;
	exports.default = reduce;

	var _cloneReducer = __webpack_require__(59);

	Object.defineProperty(exports, "CloneReducer", {
	  enumerable: true,
	  get: function get() {
	    return _cloneReducer.default;
	  }
	});

	var _monoidalReducer = __webpack_require__(61);

	Object.defineProperty(exports, "MonoidalReducer", {
	  enumerable: true,
	  get: function get() {
	    return _monoidalReducer.default;
	  }
	});

	var _shiftSpec = __webpack_require__(60);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function transformWithSpec(transformer, node, spec) {
	  switch (spec.typeName) {
	    case "Enum":
	    case "String":
	    case "Number":
	    case "Boolean":
	    case "SourceSpan":
	      return node;
	    case "Const":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, spec.argument);
	    case "Maybe":
	      return node && transformWithSpec(transformer, node, spec.argument);
	    case "List":
	      return node.map(function (e) {
	        return transformWithSpec(transformer, e, spec.argument);
	      });
	    case "Union":
	      // TODO: checked version
	      return transformWithSpec(transformer, node, _shiftSpec2.default[node.type]);
	    default:
	      var state = {};
	      spec.fields.forEach(function (field) {
	        var v = transformWithSpec(transformer, node[field.name], field.type);
	        state[field.name] = v == null ? null : v;
	      });
	      if (typeof transformer["reduce" + node.type] !== "function") {
	        throw new Error("Encountered " + node.type + ", which the provided reducer does not handle.");
	      }
	      return transformer["reduce" + node.type](node, state);
	  }
	} /**
	   * Copyright 2014 Shape Security, Inc.
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License")
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   */

	function reduce(reducer, reducible) {
	  return transformWithSpec(reducer, reducible, _shiftSpec2.default[reducible.type]);
	}

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(60);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                           *
	                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                           * you may not use this file except in compliance with the License.
	                                                                                                                                                           * You may obtain a copy of the License at
	                                                                                                                                                           *
	                                                                                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                           *
	                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                           * See the License for the specific language governing permissions and
	                                                                                                                                                           * limitations under the License.
	                                                                                                                                                           */

	var CloneReducer = function CloneReducer() {
	  _classCallCheck(this, CloneReducer);
	};

	exports.default = CloneReducer;

	for (var typeName in _shiftSpec2.default) {
	  var type = _shiftSpec2.default[typeName];
	  Object.defineProperty(CloneReducer.prototype, "reduce" + typeName, {
	    value: function value(node, state) {
	      return state;
	    }
	  });
	}

/***/ },
/* 60 */
/***/ function(module, exports) {

	// Generated by src/generate-spec.js. 

	/**
	 * Copyright 2015 Shape Security, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	// Hack to make Babel6 import this as a module.
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Meta data generated from spec.idl.
	exports.default = (function() {
	  var SPEC = {};

	  var BOOLEAN = { typeName: "Boolean" };
	  var DOUBLE = { typeName: "Number" };
	  var STRING = { typeName: "String" };
	  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
	  function List(arg) { return { typeName: "List", argument: arg }; }
	  function Const(arg) { return { typeName: "Const", argument: arg }; }
	  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }

	  var TYPE_INDICATOR = {
	    typeName: "Enum",
	    values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
	  };

	  var VariableDeclarationKind = {
	    typeName: "Enum",
	    values: ["var", "let", "const"]
	  };

	  var CompoundAssignmentOperator = {
	    typeName: "Enum",
	    values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
	  };

	  var BinaryOperator = {
	    typeName: "Enum",
	    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
	  };

	  var UnaryOperator = {
	    typeName: "Enum",
	    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
	  };

	  var UpdateOperator = {
	    typeName: "Enum",
	    values: ["++", "--"]
	  };

	  var SourceLocation = SPEC.SourceLocation = {};
	  var SourceSpan = SPEC.SourceSpan = {};
	  var BindingWithDefault = SPEC.BindingWithDefault = {};
	  var BindingIdentifier = SPEC.BindingIdentifier = {};
	  var ArrayBinding = SPEC.ArrayBinding = {};
	  var ObjectBinding = SPEC.ObjectBinding = {};
	  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
	  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
	  var ClassExpression = SPEC.ClassExpression = {};
	  var ClassDeclaration = SPEC.ClassDeclaration = {};
	  var ClassElement = SPEC.ClassElement = {};
	  var Module = SPEC.Module = {};
	  var Import = SPEC.Import = {};
	  var ImportNamespace = SPEC.ImportNamespace = {};
	  var ImportSpecifier = SPEC.ImportSpecifier = {};
	  var ExportAllFrom = SPEC.ExportAllFrom = {};
	  var ExportFrom = SPEC.ExportFrom = {};
	  var Export = SPEC.Export = {};
	  var ExportDefault = SPEC.ExportDefault = {};
	  var ExportSpecifier = SPEC.ExportSpecifier = {};
	  var Method = SPEC.Method = {};
	  var Getter = SPEC.Getter = {};
	  var Setter = SPEC.Setter = {};
	  var DataProperty = SPEC.DataProperty = {};
	  var ShorthandProperty = SPEC.ShorthandProperty = {};
	  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
	  var StaticPropertyName = SPEC.StaticPropertyName = {};
	  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
	  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
	  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
	  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
	  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
	  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
	  var ArrayExpression = SPEC.ArrayExpression = {};
	  var ArrowExpression = SPEC.ArrowExpression = {};
	  var AssignmentExpression = SPEC.AssignmentExpression = {};
	  var BinaryExpression = SPEC.BinaryExpression = {};
	  var CallExpression = SPEC.CallExpression = {};
	  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
	  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
	  var ConditionalExpression = SPEC.ConditionalExpression = {};
	  var FunctionExpression = SPEC.FunctionExpression = {};
	  var IdentifierExpression = SPEC.IdentifierExpression = {};
	  var NewExpression = SPEC.NewExpression = {};
	  var NewTargetExpression = SPEC.NewTargetExpression = {};
	  var ObjectExpression = SPEC.ObjectExpression = {};
	  var UnaryExpression = SPEC.UnaryExpression = {};
	  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
	  var TemplateExpression = SPEC.TemplateExpression = {};
	  var ThisExpression = SPEC.ThisExpression = {};
	  var UpdateExpression = SPEC.UpdateExpression = {};
	  var YieldExpression = SPEC.YieldExpression = {};
	  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
	  var BlockStatement = SPEC.BlockStatement = {};
	  var BreakStatement = SPEC.BreakStatement = {};
	  var ContinueStatement = SPEC.ContinueStatement = {};
	  var DebuggerStatement = SPEC.DebuggerStatement = {};
	  var DoWhileStatement = SPEC.DoWhileStatement = {};
	  var EmptyStatement = SPEC.EmptyStatement = {};
	  var ExpressionStatement = SPEC.ExpressionStatement = {};
	  var ForInStatement = SPEC.ForInStatement = {};
	  var ForOfStatement = SPEC.ForOfStatement = {};
	  var ForStatement = SPEC.ForStatement = {};
	  var IfStatement = SPEC.IfStatement = {};
	  var LabeledStatement = SPEC.LabeledStatement = {};
	  var ReturnStatement = SPEC.ReturnStatement = {};
	  var SwitchStatement = SPEC.SwitchStatement = {};
	  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
	  var ThrowStatement = SPEC.ThrowStatement = {};
	  var TryCatchStatement = SPEC.TryCatchStatement = {};
	  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
	  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
	  var WhileStatement = SPEC.WhileStatement = {};
	  var WithStatement = SPEC.WithStatement = {};
	  var Block = SPEC.Block = {};
	  var CatchClause = SPEC.CatchClause = {};
	  var Directive = SPEC.Directive = {};
	  var FormalParameters = SPEC.FormalParameters = {};
	  var FunctionBody = SPEC.FunctionBody = {};
	  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
	  var Script = SPEC.Script = {};
	  var SpreadElement = SPEC.SpreadElement = {};
	  var Super = SPEC.Super = {};
	  var SwitchCase = SPEC.SwitchCase = {};
	  var SwitchDefault = SPEC.SwitchDefault = {};
	  var TemplateElement = SPEC.TemplateElement = {};
	  var VariableDeclaration = SPEC.VariableDeclaration = {};
	  var VariableDeclarator = SPEC.VariableDeclarator = {};

	  var Class = Union(ClassExpression, ClassDeclaration);
	  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
	  var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
	  var ImportDeclaration = Union(Import, ImportNamespace);
	  var MethodDefinition = Union(Method, Getter, Setter);
	  var NamedObjectProperty = Union(MethodDefinition, DataProperty);
	  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
	  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
	  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
	  var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
	  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
	  var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
	  var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
	  var Function = Union(FunctionExpression, FunctionDeclaration);

	  SourceLocation.typeName = "SourceLocation";
	  SourceLocation.fields = [
	    { name: "line", type: DOUBLE },
	    { name: "column", type: DOUBLE },
	    { name: "offset", type: DOUBLE },
	  ];

	  SourceSpan.typeName = "SourceSpan";
	  SourceSpan.fields = [
	    { name: "source", type: Maybe(STRING) },
	    { name: "start", type: SourceLocation },
	    { name: "end", type: SourceLocation },
	  ];

	  BindingWithDefault.typeName = "BindingWithDefault";
	  BindingWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Expression },
	  ];

	  BindingIdentifier.typeName = "BindingIdentifier";
	  BindingIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ArrayBinding.typeName = "ArrayBinding";
	  ArrayBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) },
	    { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) },
	  ];

	  ObjectBinding.typeName = "ObjectBinding";
	  ObjectBinding.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(BindingProperty) },
	  ];

	  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
	  BindingPropertyIdentifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: BindingIdentifier },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  BindingPropertyProperty.typeName = "BindingPropertyProperty";
	  BindingPropertyProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	  ];

	  ClassExpression.typeName = "ClassExpression";
	  ClassExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassDeclaration.typeName = "ClassDeclaration";
	  ClassDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: BindingIdentifier },
	    { name: "super", type: Maybe(Expression) },
	    { name: "elements", type: List(ClassElement) },
	  ];

	  ClassElement.typeName = "ClassElement";
	  ClassElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isStatic", type: BOOLEAN },
	    { name: "method", type: MethodDefinition },
	  ];

	  Module.typeName = "Module";
	  Module.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) },
	  ];

	  Import.typeName = "Import";
	  Import.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namedImports", type: List(ImportSpecifier) },
	  ];

	  ImportNamespace.typeName = "ImportNamespace";
	  ImportNamespace.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
	    { name: "namespaceBinding", type: BindingIdentifier },
	  ];

	  ImportSpecifier.typeName = "ImportSpecifier";
	  ImportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "binding", type: BindingIdentifier },
	  ];

	  ExportAllFrom.typeName = "ExportAllFrom";
	  ExportAllFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "moduleSpecifier", type: STRING },
	  ];

	  ExportFrom.typeName = "ExportFrom";
	  ExportFrom.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "namedExports", type: List(ExportSpecifier) },
	    { name: "moduleSpecifier", type: Maybe(STRING) },
	  ];

	  Export.typeName = "Export";
	  Export.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) },
	  ];

	  ExportDefault.typeName = "ExportDefault";
	  ExportDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) },
	  ];

	  ExportSpecifier.typeName = "ExportSpecifier";
	  ExportSpecifier.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: Maybe(STRING) },
	    { name: "exportedName", type: STRING },
	  ];

	  Method.typeName = "Method";
	  Method.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Getter.typeName = "Getter";
	  Getter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "body", type: FunctionBody },
	  ];

	  Setter.typeName = "Setter";
	  Setter.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) },
	    { name: "body", type: FunctionBody },
	  ];

	  DataProperty.typeName = "DataProperty";
	  DataProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: PropertyName },
	    { name: "expression", type: Expression },
	  ];

	  ShorthandProperty.typeName = "ShorthandProperty";
	  ShorthandProperty.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  ComputedPropertyName.typeName = "ComputedPropertyName";
	  ComputedPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  StaticPropertyName.typeName = "StaticPropertyName";
	  StaticPropertyName.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
	  LiteralBooleanExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: BOOLEAN },
	  ];

	  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
	  LiteralInfinityExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNullExpression.typeName = "LiteralNullExpression";
	  LiteralNullExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  LiteralNumericExpression.typeName = "LiteralNumericExpression";
	  LiteralNumericExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: DOUBLE },
	  ];

	  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
	  LiteralRegExpExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "pattern", type: STRING },
	    { name: "flags", type: STRING },
	  ];

	  LiteralStringExpression.typeName = "LiteralStringExpression";
	  LiteralStringExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "value", type: STRING },
	  ];

	  ArrayExpression.typeName = "ArrayExpression";
	  ArrayExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) },
	  ];

	  ArrowExpression.typeName = "ArrowExpression";
	  ArrowExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: Union(FunctionBody, Expression) },
	  ];

	  AssignmentExpression.typeName = "AssignmentExpression";
	  AssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  BinaryExpression.typeName = "BinaryExpression";
	  BinaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: BinaryOperator },
	    { name: "left", type: Expression },
	    { name: "right", type: Expression },
	  ];

	  CallExpression.typeName = "CallExpression";
	  CallExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Union(Expression, Super) },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
	  CompoundAssignmentExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: CompoundAssignmentOperator },
	    { name: "binding", type: Union(BindingIdentifier, MemberExpression) },
	    { name: "expression", type: Expression },
	  ];

	  ComputedMemberExpression.typeName = "ComputedMemberExpression";
	  ComputedMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "expression", type: Expression },
	  ];

	  ConditionalExpression.typeName = "ConditionalExpression";
	  ConditionalExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Expression },
	    { name: "alternate", type: Expression },
	  ];

	  FunctionExpression.typeName = "FunctionExpression";
	  FunctionExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: Maybe(BindingIdentifier) },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  IdentifierExpression.typeName = "IdentifierExpression";
	  IdentifierExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "name", type: STRING },
	  ];

	  NewExpression.typeName = "NewExpression";
	  NewExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "callee", type: Expression },
	    { name: "arguments", type: List(Union(SpreadElement, Expression)) },
	  ];

	  NewTargetExpression.typeName = "NewTargetExpression";
	  NewTargetExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ObjectExpression.typeName = "ObjectExpression";
	  ObjectExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "properties", type: List(ObjectProperty) },
	  ];

	  UnaryExpression.typeName = "UnaryExpression";
	  UnaryExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "operator", type: UnaryOperator },
	    { name: "operand", type: Expression },
	  ];

	  StaticMemberExpression.typeName = "StaticMemberExpression";
	  StaticMemberExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Union(Expression, Super) },
	    { name: "property", type: STRING },
	  ];

	  TemplateExpression.typeName = "TemplateExpression";
	  TemplateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "tag", type: Maybe(Expression) },
	    { name: "elements", type: List(Union(Expression, TemplateElement)) },
	  ];

	  ThisExpression.typeName = "ThisExpression";
	  ThisExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  UpdateExpression.typeName = "UpdateExpression";
	  UpdateExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isPrefix", type: BOOLEAN },
	    { name: "operator", type: UpdateOperator },
	    { name: "operand", type: Union(BindingIdentifier, MemberExpression) },
	  ];

	  YieldExpression.typeName = "YieldExpression";
	  YieldExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
	  YieldGeneratorExpression.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  BlockStatement.typeName = "BlockStatement";
	  BlockStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "block", type: Block },
	  ];

	  BreakStatement.typeName = "BreakStatement";
	  BreakStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  ContinueStatement.typeName = "ContinueStatement";
	  ContinueStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: Maybe(STRING) },
	  ];

	  DebuggerStatement.typeName = "DebuggerStatement";
	  DebuggerStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  DoWhileStatement.typeName = "DoWhileStatement";
	  DoWhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Statement },
	    { name: "test", type: Expression },
	  ];

	  EmptyStatement.typeName = "EmptyStatement";
	  EmptyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  ExpressionStatement.typeName = "ExpressionStatement";
	  ExpressionStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  ForInStatement.typeName = "ForInStatement";
	  ForInStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForOfStatement.typeName = "ForOfStatement";
	  ForOfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "right", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  ForStatement.typeName = "ForStatement";
	  ForStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) },
	    { name: "test", type: Maybe(Expression) },
	    { name: "update", type: Maybe(Expression) },
	    { name: "body", type: Statement },
	  ];

	  IfStatement.typeName = "IfStatement";
	  IfStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: Statement },
	    { name: "alternate", type: Maybe(Statement) },
	  ];

	  LabeledStatement.typeName = "LabeledStatement";
	  LabeledStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "label", type: STRING },
	    { name: "body", type: Statement },
	  ];

	  ReturnStatement.typeName = "ReturnStatement";
	  ReturnStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Maybe(Expression) },
	  ];

	  SwitchStatement.typeName = "SwitchStatement";
	  SwitchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "cases", type: List(SwitchCase) },
	  ];

	  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
	  SwitchStatementWithDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "discriminant", type: Expression },
	    { name: "preDefaultCases", type: List(SwitchCase) },
	    { name: "defaultCase", type: SwitchDefault },
	    { name: "postDefaultCases", type: List(SwitchCase) },
	  ];

	  ThrowStatement.typeName = "ThrowStatement";
	  ThrowStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  TryCatchStatement.typeName = "TryCatchStatement";
	  TryCatchStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: CatchClause },
	  ];

	  TryFinallyStatement.typeName = "TryFinallyStatement";
	  TryFinallyStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "body", type: Block },
	    { name: "catchClause", type: Maybe(CatchClause) },
	    { name: "finalizer", type: Block },
	  ];

	  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
	  VariableDeclarationStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "declaration", type: VariableDeclaration },
	  ];

	  WhileStatement.typeName = "WhileStatement";
	  WhileStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  WithStatement.typeName = "WithStatement";
	  WithStatement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "object", type: Expression },
	    { name: "body", type: Statement },
	  ];

	  Block.typeName = "Block";
	  Block.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "statements", type: List(Statement) },
	  ];

	  CatchClause.typeName = "CatchClause";
	  CatchClause.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "body", type: Block },
	  ];

	  Directive.typeName = "Directive";
	  Directive.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  FormalParameters.typeName = "FormalParameters";
	  FormalParameters.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) },
	    { name: "rest", type: Maybe(BindingIdentifier) },
	  ];

	  FunctionBody.typeName = "FunctionBody";
	  FunctionBody.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  FunctionDeclaration.typeName = "FunctionDeclaration";
	  FunctionDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "isGenerator", type: BOOLEAN },
	    { name: "name", type: BindingIdentifier },
	    { name: "params", type: FormalParameters },
	    { name: "body", type: FunctionBody },
	  ];

	  Script.typeName = "Script";
	  Script.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "directives", type: List(Directive) },
	    { name: "statements", type: List(Statement) },
	  ];

	  SpreadElement.typeName = "SpreadElement";
	  SpreadElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "expression", type: Expression },
	  ];

	  Super.typeName = "Super";
	  Super.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" },
	    { name: "loc", type: Maybe(SourceSpan) },
	  ];

	  SwitchCase.typeName = "SwitchCase";
	  SwitchCase.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "test", type: Expression },
	    { name: "consequent", type: List(Statement) },
	  ];

	  SwitchDefault.typeName = "SwitchDefault";
	  SwitchDefault.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "consequent", type: List(Statement) },
	  ];

	  TemplateElement.typeName = "TemplateElement";
	  TemplateElement.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "rawValue", type: STRING },
	  ];

	  VariableDeclaration.typeName = "VariableDeclaration";
	  VariableDeclaration.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "kind", type: VariableDeclarationKind },
	    { name: "declarators", type: List(VariableDeclarator) },
	  ];

	  VariableDeclarator.typeName = "VariableDeclarator";
	  VariableDeclarator.fields = [
	    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
	    { name: "loc", type: Maybe(SourceSpan) },
	    { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) },
	    { name: "init", type: Maybe(Expression) },
	  ];

	  return SPEC;
	}());


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                   * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                   * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                   *
	                                                                                                                                                                                                                                                   * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                   * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                   * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                   * limitations under the License.
	                                                                                                                                                                                                                                                   */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shiftSpec = __webpack_require__(60);

	var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var methods = {};

	function id(x) {
	  return x;
	}

	function handlerForFieldOfType(type) {
	  switch (type.typeName) {
	    case "Enum":
	    case "String":
	    case "Boolean":
	    case "Number":
	    case "SourceSpan":
	      return null;
	    case "Const":
	      return handlerForFieldOfType(type.argument);
	    case "Maybe":
	      {
	        var _ret = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              return t == null ? this.identity : subHandler.call(this, t);
	            }
	          };
	        }();

	        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	      }
	    case "List":
	      {
	        var _ret2 = function () {
	          var subHandler = handlerForFieldOfType(type.argument);
	          if (subHandler == null) return {
	              v: null
	            };
	          return {
	            v: function v(t) {
	              var _this = this;

	              return this.fold(t.map(function (x) {
	                return subHandler.call(_this, x);
	              }));
	            }
	          };
	        }();

	        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
	      }
	    default:
	      return id;
	  }
	}

	var _loop = function _loop(typeName) {
	  var type = _shiftSpec2.default[typeName];

	  var handlers = {};
	  type.fields.forEach(function (field) {
	    var handler = handlerForFieldOfType(field.type);
	    if (handler != null) handlers[field.name] = handler;
	  });
	  var fieldNames = Object.keys(handlers);

	  methods["reduce" + typeName] = {
	    value: function value(node, state) {
	      var _this3 = this;

	      return this.fold(fieldNames.map(function (fieldName) {
	        return handlers[fieldName].call(_this3, state[fieldName]);
	      }));
	    }
	  };
	};

	for (var typeName in _shiftSpec2.default) {
	  _loop(typeName);
	}

	var MonoidalReducer = function () {
	  function MonoidalReducer(monoid) {
	    _classCallCheck(this, MonoidalReducer);

	    this.identity = monoid.empty();
	    var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
	    this.append = function (a, b) {
	      return concat.call(a, b);
	    };
	  }

	  _createClass(MonoidalReducer, [{
	    key: "fold",
	    value: function fold(list, a) {
	      var _this2 = this;

	      return list.reduce(function (memo, x) {
	        return _this2.append(memo, x);
	      }, a == null ? this.identity : a);
	    }
	  }]);

	  return MonoidalReducer;
	}();

	exports.default = MonoidalReducer;

	Object.defineProperties(MonoidalReducer.prototype, methods);

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2014 Shape Security, Inc.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TokenStream = undefined;

	var _esutils = __webpack_require__(14);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function numberDot(fragment) {
	  if (fragment.indexOf(".") < 0 && fragment.indexOf("e") < 0) {
	    return "..";
	  }
	  return ".";
	}

	function renderNumber(n) {
	  var s;
	  if (n >= 1e3 && n % 10 === 0) {
	    s = n.toString(10);
	    if (/[eE]/.test(s)) {
	      return s.replace(/[eE]\+/, "e");
	    }
	    return n.toString(10).replace(/0+$/, function (match) {
	      return "e" + match.length;
	    });
	  } else if (n % 1 === 0) {
	    if (n > 1e15 && n < 1e20) {
	      return "0x" + n.toString(16).toUpperCase();
	    }
	    return n.toString(10).replace(/[eE]\+/, "e");
	  } else {
	    return n.toString(10).replace(/^0\./, ".").replace(/[eE]\+/, "e");
	  }
	}

	var TokenStream = exports.TokenStream = function () {
	  function TokenStream() {
	    _classCallCheck(this, TokenStream);

	    this.result = "";
	    this.lastNumber = null;
	    this.lastChar = null;
	    this.optionalSemi = false;
	  }

	  _createClass(TokenStream, [{
	    key: "putNumber",
	    value: function putNumber(number) {
	      var tokenStr = renderNumber(number);
	      this.put(tokenStr);
	      this.lastNumber = tokenStr;
	    }
	  }, {
	    key: "putOptionalSemi",
	    value: function putOptionalSemi() {
	      this.optionalSemi = true;
	    }
	  }, {
	    key: "put",
	    value: function put(tokenStr) {
	      if (this.optionalSemi) {
	        this.optionalSemi = false;
	        if (tokenStr !== "}") {
	          this.put(";");
	        }
	      }
	      if (this.lastNumber !== null && tokenStr.length == 1) {
	        if (tokenStr === ".") {
	          this.result += numberDot(this.lastNumber);
	          this.lastNumber = null;
	          this.lastChar = ".";
	          return;
	        }
	      }
	      this.lastNumber = null;
	      var rightChar = tokenStr.charAt(0);
	      var lastChar = this.lastChar;
	      this.lastChar = tokenStr.charAt(tokenStr.length - 1);
	      if (lastChar && ((lastChar == "+" || lastChar == "-") && lastChar == rightChar || _esutils.code.isIdentifierPartES6(lastChar.charCodeAt(0)) && _esutils.code.isIdentifierPartES6(rightChar.charCodeAt(0)) || lastChar == "/" && rightChar == "i")) {
	        this.result += " ";
	      }

	      this.result += tokenStr;
	    }
	  }]);

	  return TokenStream;
	}();

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	var _immutable = __webpack_require__(10);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.default = class extends S.default.CloneReducer {

	  constructor(phase) {
	    super();
	    this.phase = phase;
	  }

	  reduceModule(t, s) {
	    return new S.Module({
	      directives: s.directives.toArray(),
	      items: s.items.toArray()
	    });
	  }

	  reduceIdentifierExpression(t, s) {
	    return new S.IdentifierExpression({
	      name: s.name.resolve(this.phase)
	    });
	  }

	  reduceStaticPropertyName(t, s) {
	    return new S.StaticPropertyName({
	      value: s.value.val().toString()
	    });
	  }

	  reduceBindingIdentifier(t, s) {
	    return new S.BindingIdentifier({
	      name: s.name.resolve(this.phase)
	    });
	  }

	  reduceStaticMemberExpression(t, s) {
	    return new S.StaticMemberExpression({
	      object: s.object,
	      property: s.property.val()
	    });
	  }

	  reduceFunctionBody(t, s) {
	    return new S.FunctionBody({
	      directives: s.directives.toArray(),
	      statements: s.statements.toArray()
	    });
	  }

	  reduceVariableDeclarationStatement(t, s) {
	    if (t.declaration.kind === 'syntax' || t.declaration.kind === 'syntaxrec') {
	      return new S.EmptyStatement();
	    }
	    return new S.VariableDeclarationStatement({
	      declaration: s.declaration
	    });
	  }

	  reduceVariableDeclaration(t, s) {
	    return new S.VariableDeclaration({
	      kind: s.kind,
	      declarators: s.declarators.toArray()
	    });
	  }

	  reduceCallExpression(t, s) {
	    return new S.CallExpression({
	      callee: s.callee,
	      arguments: s.arguments.toArray()
	    });
	  }

	  reduceArrayExpression(t, s) {
	    return new S.ArrayExpression({
	      elements: s.elements.toArray()
	    });
	  }

	  reduceImport() {
	    return new S.EmptyStatement({});
	  }

	  reduceBlock(t, s) {
	    return new S.Block({
	      statements: s.statements.toArray()
	    });
	  }
	};
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zd2VldC10by1zaGlmdC1yZWR1Y2VyLmpzIl0sIm5hbWVzIjpbIlMiLCJDbG9uZVJlZHVjZXIiLCJjb25zdHJ1Y3RvciIsInBoYXNlIiwicmVkdWNlTW9kdWxlIiwidCIsInMiLCJNb2R1bGUiLCJkaXJlY3RpdmVzIiwidG9BcnJheSIsIml0ZW1zIiwicmVkdWNlSWRlbnRpZmllckV4cHJlc3Npb24iLCJJZGVudGlmaWVyRXhwcmVzc2lvbiIsIm5hbWUiLCJyZXNvbHZlIiwicmVkdWNlU3RhdGljUHJvcGVydHlOYW1lIiwiU3RhdGljUHJvcGVydHlOYW1lIiwidmFsdWUiLCJ2YWwiLCJ0b1N0cmluZyIsInJlZHVjZUJpbmRpbmdJZGVudGlmaWVyIiwiQmluZGluZ0lkZW50aWZpZXIiLCJyZWR1Y2VTdGF0aWNNZW1iZXJFeHByZXNzaW9uIiwiU3RhdGljTWVtYmVyRXhwcmVzc2lvbiIsIm9iamVjdCIsInByb3BlcnR5IiwicmVkdWNlRnVuY3Rpb25Cb2R5IiwiRnVuY3Rpb25Cb2R5Iiwic3RhdGVtZW50cyIsInJlZHVjZVZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQiLCJkZWNsYXJhdGlvbiIsImtpbmQiLCJFbXB0eVN0YXRlbWVudCIsIlZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQiLCJyZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWNsYXJhdGlvbiIsImRlY2xhcmF0b3JzIiwicmVkdWNlQ2FsbEV4cHJlc3Npb24iLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsImFyZ3VtZW50cyIsInJlZHVjZUFycmF5RXhwcmVzc2lvbiIsIkFycmF5RXhwcmVzc2lvbiIsImVsZW1lbnRzIiwicmVkdWNlSW1wb3J0IiwicmVkdWNlQmxvY2siLCJCbG9jayJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7O0lBQWtCQSxDOztBQUNsQjs7OztrQkFHZSxjQUpHQSxDQUlXLFNBQUtDLFlBQW5CLENBQWdDOztBQUc3Q0MsY0FB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YSxjQUFZeEMsQ0FBWixFQUFxQkMsQ0FBckIsRUFBbUQ7QUFDakQsV0FBTyxJQUFJTixFQUFFOEMsS0FBTixDQUFZO0FBQ2pCbEIsa0JBQVl0QixFQUFFc0IsVUFBRixDQUFhbkIsT0FBYjtBQURLLEtBQVosQ0FBUDtBQUdEO0FBcEY0QyxDIiwiZmlsZSI6InN3ZWV0LXRvLXNoaWZ0LXJlZHVjZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IFRlcm0sICogYXMgUyBmcm9tICdzd2VldC1zcGVjJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHR5cGUgU3ludGF4IGZyb20gJy4vc3ludGF4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBUZXJtLkNsb25lUmVkdWNlciB7XG4gIHBoYXNlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocGhhc2U6IG51bWJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICB9XG5cbiAgcmVkdWNlTW9kdWxlKHQ6IFRlcm0sIHM6IHsgZGlyZWN0aXZlczogTGlzdDxhbnk+LCBpdGVtczogTGlzdDxhbnk+IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuTW9kdWxlKHtcbiAgICAgIGRpcmVjdGl2ZXM6IHMuZGlyZWN0aXZlcy50b0FycmF5KCksXG4gICAgICBpdGVtczogcy5pdGVtcy50b0FycmF5KClcbiAgICB9KTtcbiAgfVxuXG4gIHJlZHVjZUlkZW50aWZpZXJFeHByZXNzaW9uKHQ6IFRlcm0sIHM6IHsgbmFtZTogU3ludGF4IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuSWRlbnRpZmllckV4cHJlc3Npb24oe1xuICAgICAgbmFtZTogcy5uYW1lLnJlc29sdmUodGhpcy5waGFzZSlcbiAgICB9KTtcbiAgfVxuXG4gIHJlZHVjZVN0YXRpY1Byb3BlcnR5TmFtZSh0OiBUZXJtLCBzOiB7IHZhbHVlOiBTeW50YXggfSkge1xuICAgIHJldHVybiBuZXcgUy5TdGF0aWNQcm9wZXJ0eU5hbWUoe1xuICAgICAgdmFsdWU6IHMudmFsdWUudmFsKCkudG9TdHJpbmcoKVxuICAgIH0pO1xuICB9XG5cbiAgcmVkdWNlQmluZGluZ0lkZW50aWZpZXIodDogVGVybSwgczogeyBuYW1lOiBTeW50YXggfSkge1xuICAgIHJldHVybiBuZXcgUy5CaW5kaW5nSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiBzLm5hbWUucmVzb2x2ZSh0aGlzLnBoYXNlKVxuICAgIH0pO1xuICB9XG5cbiAgcmVkdWNlU3RhdGljTWVtYmVyRXhwcmVzc2lvbih0OiBUZXJtLCBzOiB7IG9iamVjdDogYW55LCBwcm9wZXJ0eTogU3ludGF4IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuU3RhdGljTWVtYmVyRXhwcmVzc2lvbih7XG4gICAgICBvYmplY3Q6IHMub2JqZWN0LFxuICAgICAgcHJvcGVydHk6IHMucHJvcGVydHkudmFsKClcbiAgICB9KTtcbiAgfVxuXG4gIHJlZHVjZUZ1bmN0aW9uQm9keSh0OiBUZXJtLCBzOiB7IHN0YXRlbWVudHM6IExpc3Q8YW55PiwgZGlyZWN0aXZlczogTGlzdDxhbnk+IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuRnVuY3Rpb25Cb2R5KHtcbiAgICAgIGRpcmVjdGl2ZXM6IHMuZGlyZWN0aXZlcy50b0FycmF5KCksXG4gICAgICBzdGF0ZW1lbnRzOiBzLnN0YXRlbWVudHMudG9BcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICByZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHQ6IFRlcm0sIHM6IHsgZGVjbGFyYXRpb246IGFueSB9KSB7XG4gICAgaWYgKHQuZGVjbGFyYXRpb24ua2luZCA9PT0gJ3N5bnRheCcgfHwgdC5kZWNsYXJhdGlvbi5raW5kID09PSAnc3ludGF4cmVjJykge1xuICAgICAgcmV0dXJuIG5ldyBTLkVtcHR5U3RhdGVtZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUy5WYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KHtcbiAgICAgIGRlY2xhcmF0aW9uOiBzLmRlY2xhcmF0aW9uXG4gICAgfSk7XG4gIH1cblxuICByZWR1Y2VWYXJpYWJsZURlY2xhcmF0aW9uKHQ6IFRlcm0sIHM6IHsga2luZDogYW55LCBkZWNsYXJhdG9yczogTGlzdDxhbnk+IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuVmFyaWFibGVEZWNsYXJhdGlvbih7XG4gICAgICBraW5kOiBzLmtpbmQsXG4gICAgICBkZWNsYXJhdG9yczogcy5kZWNsYXJhdG9ycy50b0FycmF5KClcbiAgICB9KTtcbiAgfVxuXG4gIHJlZHVjZUNhbGxFeHByZXNzaW9uKHQ6IFRlcm0sIHM6IHsgY2FsbGVlOiBhbnksIGFyZ3VtZW50czogTGlzdDxhbnk+IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgY2FsbGVlOiBzLmNhbGxlZSxcbiAgICAgIGFyZ3VtZW50czogcy5hcmd1bWVudHMudG9BcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICByZWR1Y2VBcnJheUV4cHJlc3Npb24odDogVGVybSwgczogeyBlbGVtZW50czogTGlzdDxhbnk+IH0pIHtcbiAgICByZXR1cm4gbmV3IFMuQXJyYXlFeHByZXNzaW9uKHtcbiAgICAgIGVsZW1lbnRzOiBzLmVsZW1lbnRzLnRvQXJyYXkoKVxuICAgIH0pO1xuICB9XG5cbiAgcmVkdWNlSW1wb3J0KCkge1xuICAgIHJldHVybiBuZXcgUy5FbXB0eVN0YXRlbWVudCh7fSk7XG4gIH1cblxuICByZWR1Y2VCbG9jayh0OiBUZXJtLCBzOiB7IHN0YXRlbWVudHM6IExpc3Q8YW55PiB9KSB7XG4gICAgcmV0dXJuIG5ldyBTLkJsb2NrKHtcbiAgICAgIHN0YXRlbWVudHM6IHMuc3RhdGVtZW50cy50b0FycmF5KClcbiAgICB9KTtcbiAgfVxufVxuIl19

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SyntaxOrTermWrapper = undefined;
	exports.wrapInTerms = wrapInTerms;
	exports.unwrap = unwrap;

	var _errors = __webpack_require__(39);

	var _immutable = __webpack_require__(10);

	var _enforester = __webpack_require__(49);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _scopeReducer = __webpack_require__(50);

	var _scopeReducer2 = _interopRequireDefault(_scopeReducer);

	var _sweetSpec = __webpack_require__(41);

	var T = _interopRequireWildcard(_sweetSpec);

	var S = _interopRequireWildcard(_sweetSpec);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function wrapInTerms(stx) {
	  return stx.map(s => {
	    if (s.isTemplate()) {
	      s.token.items = s.token.items.map(t => {
	        if (t instanceof _syntax2.default) {
	          return wrapInTerms(_immutable.List.of(t)).first();
	        }
	        return t;
	      });
	    } else if (s.isParens() || s.isBraces() || s.isBrackets() || s.isSyntaxTemplate()) {
	      return new S.RawDelimiter({
	        kind: s.isBraces() ? 'braces' : s.isParens() ? 'parens' : s.isBrackets() ? 'brackets' : 'syntaxTemplate',
	        inner: wrapInTerms(s.token)
	      });
	    }
	    return new S.RawSyntax({
	      value: s
	    });
	  });
	}

	const symWrap = Symbol('wrapper');
	const privateData = new WeakMap();

	const getVal = t => {
	  if (t instanceof T.RawSyntax) {
	    return t.value.val();
	  }
	  return null;
	};

	class SyntaxOrTermWrapper {
	  constructor(s, context = {}) {
	    this[symWrap] = s;
	    this.context = context;
	  }

	  from(type, value) {
	    let stx = this[symWrap];
	    if (typeof stx.from === 'function') {
	      return stx.from(type, value);
	    }
	  }
	  fromNull() {
	    return this.from('null', null);
	  }

	  fromNumber(value) {
	    return this.from('number', value);
	  }

	  fromString(value) {
	    return this.from('string', value);
	  }

	  fromPunctuator(value) {
	    return this.from('punctuator', value);
	  }

	  fromKeyword(value) {
	    return this.from('keyword', value);
	  }

	  fromIdentifier(value) {
	    return this.from('identifier', value);
	  }

	  fromRegularExpression(value) {
	    return this.from('regularExpression', value);
	  }

	  match(type, value) {
	    let stx = this[symWrap];
	    if (typeof stx.match === 'function') {
	      return stx.match(type, value);
	    }
	  }

	  isIdentifier(value) {
	    return this.match('identifier', value);
	  }

	  isAssign(value) {
	    return this.match('assign', value);
	  }

	  isBooleanLiteral(value) {
	    return this.match('boolean', value);
	  }

	  isKeyword(value) {
	    return this.match('keyword', value);
	  }

	  isNullLiteral(value) {
	    return this.match('null', value);
	  }

	  isNumericLiteral(value) {
	    return this.match('number', value);
	  }

	  isPunctuator(value) {
	    return this.match('punctuator', value);
	  }

	  isStringLiteral(value) {
	    return this.match('string', value);
	  }

	  isRegularExpression(value) {
	    return this.match('regularExpression', value);
	  }

	  isTemplate(value) {
	    return this.match('template', value);
	  }

	  isDelimiter(value) {
	    return this.match('delimiter', value);
	  }

	  isParens(value) {
	    return this.match('parens', value);
	  }

	  isBraces(value) {
	    return this.match('braces', value);
	  }

	  isBrackets(value) {
	    return this.match('brackets', value);
	  }

	  isSyntaxTemplate(value) {
	    return this.match('syntaxTemplate', value);
	  }

	  isEOF(value) {
	    return this.match('eof', value);
	  }

	  lineNumber() {
	    return this[symWrap].lineNumber();
	  }

	  val() {
	    return getVal(this[symWrap]);
	  }

	  inner() {
	    let stx = this[symWrap];
	    if (!(stx instanceof T.RawDelimiter)) {
	      throw new Error('Can only get inner syntax on a delimiter');
	    }

	    let enf = new _enforester.Enforester(stx.inner.slice(1, stx.inner.size - 1), (0, _immutable.List)(), this.context);
	    return new MacroContext(enf, 'inner', this.context);
	  }
	}

	exports.SyntaxOrTermWrapper = SyntaxOrTermWrapper;
	function unwrap(x) {
	  if (x instanceof SyntaxOrTermWrapper) {
	    return x[symWrap];
	  }
	  return x;
	}

	function cloneEnforester(enf) {
	  const { rest, prev, context } = enf;
	  return new _enforester.Enforester(rest, prev, context);
	}

	function Marker() {}

	/*
	ctx :: {
	  of: (Syntax) -> ctx
	  next: (String) -> Syntax or Term
	}
	*/
	class MacroContext {

	  constructor(enf, name, context, useScope, introducedScope) {
	    const startMarker = new Marker();
	    const startEnf = cloneEnforester(enf);
	    const priv = {
	      name,
	      context,
	      enf: startEnf,
	      startMarker,
	      markers: new Map([[startMarker, enf]])
	    };

	    if (useScope && introducedScope) {
	      priv.noScopes = false;
	      priv.useScope = useScope;
	      priv.introducedScope = introducedScope;
	    } else {
	      priv.noScopes = true;
	    }
	    privateData.set(this, priv);
	    this.reset(); // set current enforester

	    this[Symbol.iterator] = () => this;
	  }

	  name() {
	    const { name, context } = privateData.get(this);
	    return new SyntaxOrTermWrapper(name, context);
	  }

	  expand(type) {
	    const { enf, context } = privateData.get(this);
	    if (enf.rest.size === 0) {
	      return {
	        done: true,
	        value: null
	      };
	    }
	    enf.expandMacro();
	    let originalRest = enf.rest;
	    let value;
	    switch (type) {
	      case 'AssignmentExpression':
	      case 'expr':
	        value = enf.enforestExpressionLoop();
	        break;
	      case 'Expression':
	        value = enf.enforestExpression();
	        break;
	      case 'Statement':
	      case 'stmt':
	        value = enf.enforestStatement();
	        break;
	      case 'BlockStatement':
	      case 'WhileStatement':
	      case 'IfStatement':
	      case 'ForStatement':
	      case 'SwitchStatement':
	      case 'BreakStatement':
	      case 'ContinueStatement':
	      case 'DebuggerStatement':
	      case 'WithStatement':
	      case 'TryStatement':
	      case 'ThrowStatement':
	      case 'ClassDeclaration':
	      case 'FunctionDeclaration':
	      case 'LabeledStatement':
	      case 'VariableDeclarationStatement':
	      case 'ReturnStatement':
	      case 'ExpressionStatement':
	        value = enf.enforestStatement();
	        (0, _errors.expect)(_.whereEq({ type }, value), `Expecting a ${ type }`, value, originalRest);
	        break;
	      case 'YieldExpression':
	        value = enf.enforestYieldExpression();
	        break;
	      case 'ClassExpression':
	        value = enf.enforestClass({ isExpr: true });
	        break;
	      case 'ArrowExpression':
	        value = enf.enforestArrowExpression();
	        break;
	      case 'NewExpression':
	        value = enf.enforestNewExpression();
	        break;
	      case 'ThisExpression':
	      case 'FunctionExpression':
	      case 'IdentifierExpression':
	      case 'LiteralNumericExpression':
	      case 'LiteralInfinityExpression':
	      case 'LiteralStringExpression':
	      case 'TemplateExpression':
	      case 'LiteralBooleanExpression':
	      case 'LiteralNullExpression':
	      case 'LiteralRegExpExpression':
	      case 'ObjectExpression':
	      case 'ArrayExpression':
	        value = enf.enforestPrimaryExpression();
	        break;
	      case 'UnaryExpression':
	      case 'UpdateExpression':
	      case 'BinaryExpression':
	      case 'StaticMemberExpression':
	      case 'ComputedMemberExpression':
	      case 'CompoundAssignmentExpression':
	      case 'ConditionalExpression':
	        value = enf.enforestExpressionLoop();
	        (0, _errors.expect)(_.whereEq({ type }, value), `Expecting a ${ type }`, value, originalRest);
	        break;
	      default:
	        throw new Error('Unknown term type: ' + type);
	    }
	    return {
	      done: false,
	      value: new SyntaxOrTermWrapper(value, context)
	    };
	  }

	  _rest(enf) {
	    const priv = privateData.get(this);
	    if (priv.markers.get(priv.startMarker) === enf) {
	      return priv.enf.rest;
	    }
	    throw Error('Unauthorized access!');
	  }

	  reset(marker) {
	    const priv = privateData.get(this);
	    let enf;
	    if (marker == null) {
	      // go to the beginning
	      enf = priv.markers.get(priv.startMarker);
	    } else if (marker && marker instanceof Marker) {
	      // marker could be from another context
	      if (priv.markers.has(marker)) {
	        enf = priv.markers.get(marker);
	      } else {
	        throw new Error('marker must originate from this context');
	      }
	    } else {
	      throw new Error('marker must be an instance of Marker');
	    }
	    priv.enf = cloneEnforester(enf);
	  }

	  mark() {
	    const priv = privateData.get(this);
	    let marker;

	    // the idea here is that marking at the beginning shouldn't happen more than once.
	    // We can reuse startMarker.
	    if (priv.enf.rest === priv.markers.get(priv.startMarker).rest) {
	      marker = priv.startMarker;
	    } else if (priv.enf.rest.isEmpty()) {
	      // same reason as above
	      if (!priv.endMarker) priv.endMarker = new Marker();
	      marker = priv.endMarker;
	    } else {
	      //TODO(optimization/dubious): check that there isn't already a marker for this index?
	      marker = new Marker();
	    }
	    if (!priv.markers.has(marker)) {
	      priv.markers.set(marker, cloneEnforester(priv.enf));
	    }
	    return marker;
	  }

	  next() {
	    const { enf, noScopes, useScope, introducedScope, context } = privateData.get(this);
	    if (enf.rest.size === 0) {
	      return {
	        done: true,
	        value: null
	      };
	    }
	    let value = enf.advance();
	    if (!noScopes) {
	      value = value.reduce(new _scopeReducer2.default([{ scope: useScope, phase: _syntax.ALL_PHASES, flip: false }, { scope: introducedScope, phase: _syntax.ALL_PHASES, flip: true }], context.bindings));
	    }
	    return {
	      done: false,
	      value: new SyntaxOrTermWrapper(value, context)
	    };
	  }
	}
	exports.default = MacroContext;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYWNyby1jb250ZXh0LmpzIl0sIm5hbWVzIjpbIndyYXBJblRlcm1zIiwidW53cmFwIiwiXyIsIlQiLCJTIiwic3R4IiwibWFwIiwicyIsImlzVGVtcGxhdGUiLCJ0b2tlbiIsIml0ZW1zIiwidCIsIm9mIiwiZmlyc3QiLCJpc1BhcmVucyIsImlzQnJhY2VzIiwiaXNCcmFja2V0cyIsImlzU3ludGF4VGVtcGxhdGUiLCJSYXdEZWxpbWl0ZXIiLCJraW5kIiwiaW5uZXIiLCJSYXdTeW50YXgiLCJ2YWx1ZSIsInN5bVdyYXAiLCJTeW1ib2wiLCJwcml2YXRlRGF0YSIsIldlYWtNYXAiLCJnZXRWYWwiLCJ2YWwiLCJTeW50YXhPclRlcm1XcmFwcGVyIiwiY29uc3RydWN0b3IiLCJjb250ZXh0IiwiZnJvbSIsInR5cGUiLCJmcm9tTnVsbCIsImZyb21OdW1iZXIiLCJmcm9tU3RyaW5nIiwiZnJvbVB1bmN0dWF0b3IiLCJmcm9tS2V5d29yZCIsImZyb21JZGVudGlmaWVyIiwiZnJvbVJlZ3VsYXJFeHByZXNzaW9uIiwibWF0Y2giLCJpc0lkZW50aWZpZXIiLCJpc0Fzc2lnbiIsImlzQm9vbGVhbkxpdGVyYWwiLCJpc0tleXdvcmQiLCJpc051bGxMaXRlcmFsIiwiaXNOdW1lcmljTGl0ZXJhbCIsImlzUHVuY3R1YXRvciIsImlzU3RyaW5nTGl0ZXJhbCIsImlzUmVndWxhckV4cHJlc3Npb24iLCJpc0RlbGltaXRlciIsImlzRU9GIiwibGluZU51bWJlciIsIkVycm9yIiwiZW5mIiwic2xpY2UiLCJzaXplIiwiTWFjcm9Db250ZXh0IiwieCIsImNsb25lRW5mb3Jlc3RlciIsInJlc3QiLCJwcmV2IiwiTWFya2VyIiwibmFtZSIsInVzZVNjb3BlIiwiaW50cm9kdWNlZFNjb3BlIiwic3RhcnRNYXJrZXIiLCJzdGFydEVuZiIsInByaXYiLCJtYXJrZXJzIiwiTWFwIiwibm9TY29wZXMiLCJzZXQiLCJyZXNldCIsIml0ZXJhdG9yIiwiZ2V0IiwiZXhwYW5kIiwiZG9uZSIsImV4cGFuZE1hY3JvIiwib3JpZ2luYWxSZXN0IiwiZW5mb3Jlc3RFeHByZXNzaW9uTG9vcCIsImVuZm9yZXN0RXhwcmVzc2lvbiIsImVuZm9yZXN0U3RhdGVtZW50Iiwid2hlcmVFcSIsImVuZm9yZXN0WWllbGRFeHByZXNzaW9uIiwiZW5mb3Jlc3RDbGFzcyIsImlzRXhwciIsImVuZm9yZXN0QXJyb3dFeHByZXNzaW9uIiwiZW5mb3Jlc3ROZXdFeHByZXNzaW9uIiwiZW5mb3Jlc3RQcmltYXJ5RXhwcmVzc2lvbiIsIl9yZXN0IiwibWFya2VyIiwiaGFzIiwibWFyayIsImlzRW1wdHkiLCJlbmRNYXJrZXIiLCJuZXh0IiwiYWR2YW5jZSIsInJlZHVjZSIsInNjb3BlIiwicGhhc2UiLCJmbGlwIiwiYmluZGluZ3MiXSwibWFwcGluZ3MiOiI7Ozs7OztRQVVnQkEsVyxHQUFBQSxXO1FBa0tBQyxNLEdBQUFBLE07O0FBNUtoQjs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztJQUFZQyxDOztBQUNaOzs7O0FBQ0E7O0lBQVlDLEM7O0lBQ01DLEM7Ozs7OztBQUdYLFNBQVNKLFdBQVQsQ0FBcUJLLEdBQXJCLEVBQW9EO0FBQ3pELFNBQU9BLElBQUlDLEdBQUosQ0FBUUMsS0FBSztBQUNsQixRQUFJQSxFQUFFQyxVQUFGLEVBQUosRUFBb0I7QUFDbEJELFFBQUVFLEtBQUYsQ0FBUUMsS0FBUixHQUFnQkgsRUFBRUUsS0FBRixDQUFRQyxLQUFSLENBQWNKLEdBQWQsQ0FBa0JLLEtBQUs7QUFDckMsWUFBSUEsNkJBQUosRUFBeUI7QUFDdkIsaUJBQU9YLFlBQVksZ0JBQUtZLEVBQUwsQ0FBUUQsQ0FBUixDQUFaLEVBQXdCRSxLQUF4QixFQUFQO0FBQ0Q7QUFDRCxlQUFPRixDQUFQO0FBQ0QsT0FMZSxDQUFoQjtBQU1ELEtBUEQsTUFPTyxJQUFJSixFQUFFTyxRQUFGLE1BQWdCUCxFQUFFUSxRQUFGLEVBQWhCLElBQWdDUixFQUFFUyxVQUFGLEVBQWhDLElBQWtEVCxFQUFFVSxnQkFBRixF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UCxLQUF4QixFQUErQlMsT0FBL0I7QUFGRixLQUFQO0FBSUQ7QUEzTCtCO2tCQUFiMkIsWSIsImZpbGUiOiJtYWNyby1jb250ZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgeyBFbmZvcmVzdGVyIH0gZnJvbSAnLi9lbmZvcmVzdGVyJztcbmltcG9ydCB7IEFMTF9QSEFTRVMgfSBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3JhbWRhJztcbmltcG9ydCBTY29wZVJlZHVjZXIgZnJvbSAnLi9zY29wZS1yZWR1Y2VyJztcbmltcG9ydCAqIGFzIFQgZnJvbSAnc3dlZXQtc3BlYyc7XG5pbXBvcnQgVGVybSwgKiBhcyBTIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0IFN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwSW5UZXJtcyhzdHg6IExpc3Q8U3ludGF4Pik6IExpc3Q8VGVybT4ge1xuICByZXR1cm4gc3R4Lm1hcChzID0+IHtcbiAgICBpZiAocy5pc1RlbXBsYXRlKCkpIHtcbiAgICAgIHMudG9rZW4uaXRlbXMgPSBzLnRva2VuLml0ZW1zLm1hcCh0ID0+IHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBTeW50YXgpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcEluVGVybXMoTGlzdC5vZih0KSkuZmlyc3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocy5pc1BhcmVucygpIHx8IHMuaXNCcmFjZXMoKSB8fCBzLmlzQnJhY2tldHMoKSB8fCBzLmlzU3ludGF4VGVtcGxhdGUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBTLlJhd0RlbGltaXRlcih7XG4gICAgICAgIGtpbmQ6IHMuaXNCcmFjZXMoKSA/ICdicmFjZXMnIDogcy5pc1BhcmVucygpID8gJ3BhcmVucycgOiBzLmlzQnJhY2tldHMoKSA/ICdicmFja2V0cycgOiAnc3ludGF4VGVtcGxhdGUnLFxuICAgICAgICBpbm5lcjogd3JhcEluVGVybXMocy50b2tlbilcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFMuUmF3U3ludGF4KHtcbiAgICAgIHZhbHVlOiBzXG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbmNvbnN0IHN5bVdyYXAgPSBTeW1ib2woJ3dyYXBwZXInKTtcbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgZ2V0VmFsID0gdCA9PiB7XG4gIGlmICh0IGluc3RhbmNlb2YgVC5SYXdTeW50YXgpIHtcbiAgICByZXR1cm4gdC52YWx1ZS52YWwoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjbGFzcyBTeW50YXhPclRlcm1XcmFwcGVyIHtcbiAgY29uc3RydWN0b3IocywgY29udGV4dCA9IHt9KSB7XG4gICAgdGhpc1tzeW1XcmFwXSA9IHM7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGZyb20odHlwZSwgdmFsdWUpIHtcbiAgICBsZXQgc3R4ID0gdGhpc1tzeW1XcmFwXTtcbiAgICBpZiAodHlwZW9mIHN0eC5mcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3R4LmZyb20odHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBmcm9tTnVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKCdudWxsJywgbnVsbCk7XG4gIH1cblxuICBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSgnbnVtYmVyJywgdmFsdWUpO1xuICB9XG5cbiAgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZyb20oJ3N0cmluZycsIHZhbHVlKTtcbiAgfVxuXG4gIGZyb21QdW5jdHVhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSgncHVuY3R1YXRvcicsIHZhbHVlKTtcbiAgfVxuXG4gIGZyb21LZXl3b3JkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSgna2V5d29yZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGZyb21JZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSgnaWRlbnRpZmllcicsIHZhbHVlKTtcbiAgfVxuXG4gIGZyb21SZWd1bGFyRXhwcmVzc2lvbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZyb20oJ3JlZ3VsYXJFeHByZXNzaW9uJywgdmFsdWUpO1xuICB9XG5cbiAgbWF0Y2godHlwZSwgdmFsdWUpIHtcbiAgICBsZXQgc3R4ID0gdGhpc1tzeW1XcmFwXTtcbiAgICBpZiAodHlwZW9mIHN0eC5tYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHN0eC5tYXRjaCh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaXNJZGVudGlmaWVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2lkZW50aWZpZXInLCB2YWx1ZSk7XG4gIH1cblxuICBpc0Fzc2lnbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdhc3NpZ24nLCB2YWx1ZSk7XG4gIH1cblxuICBpc0Jvb2xlYW5MaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2Jvb2xlYW4nLCB2YWx1ZSk7XG4gIH1cblxuICBpc0tleXdvcmQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgna2V5d29yZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGlzTnVsbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnbnVsbCcsIHZhbHVlKTtcbiAgfVxuXG4gIGlzTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnbnVtYmVyJywgdmFsdWUpO1xuICB9XG5cbiAgaXNQdW5jdHVhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ3B1bmN0dWF0b3InLCB2YWx1ZSk7XG4gIH1cblxuICBpc1N0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgnc3RyaW5nJywgdmFsdWUpO1xuICB9XG5cbiAgaXNSZWd1bGFyRXhwcmVzc2lvbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdyZWd1bGFyRXhwcmVzc2lvbicsIHZhbHVlKTtcbiAgfVxuXG4gIGlzVGVtcGxhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgndGVtcGxhdGUnLCB2YWx1ZSk7XG4gIH1cblxuICBpc0RlbGltaXRlcih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdkZWxpbWl0ZXInLCB2YWx1ZSk7XG4gIH1cblxuICBpc1BhcmVucyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdwYXJlbnMnLCB2YWx1ZSk7XG4gIH1cblxuICBpc0JyYWNlcyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdicmFjZXMnLCB2YWx1ZSk7XG4gIH1cblxuICBpc0JyYWNrZXRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2JyYWNrZXRzJywgdmFsdWUpO1xuICB9XG5cbiAgaXNTeW50YXhUZW1wbGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKCdzeW50YXhUZW1wbGF0ZScsIHZhbHVlKTtcbiAgfVxuXG4gIGlzRU9GKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goJ2VvZicsIHZhbHVlKTtcbiAgfVxuXG4gIGxpbmVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltV3JhcF0ubGluZU51bWJlcigpO1xuICB9XG5cbiAgdmFsKCkge1xuICAgIHJldHVybiBnZXRWYWwodGhpc1tzeW1XcmFwXSk7XG4gIH1cblxuICBpbm5lcigpIHtcbiAgICBsZXQgc3R4ID0gdGhpc1tzeW1XcmFwXTtcbiAgICBpZiAoIShzdHggaW5zdGFuY2VvZiBULlJhd0RlbGltaXRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgZ2V0IGlubmVyIHN5bnRheCBvbiBhIGRlbGltaXRlcicpO1xuICAgIH1cblxuICAgIGxldCBlbmYgPSBuZXcgRW5mb3Jlc3RlcihzdHguaW5uZXIuc2xpY2UoMSwgc3R4LmlubmVyLnNpemUgLSAxKSwgTGlzdCgpLCB0aGlzLmNvbnRleHQpO1xuICAgIHJldHVybiBuZXcgTWFjcm9Db250ZXh0KGVuZiwgJ2lubmVyJywgdGhpcy5jb250ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHgpIHtcbiAgaWYgKHggaW5zdGFuY2VvZiBTeW50YXhPclRlcm1XcmFwcGVyKSB7XG4gICAgcmV0dXJuIHhbc3ltV3JhcF07XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGNsb25lRW5mb3Jlc3RlcihlbmYpIHtcbiAgY29uc3QgeyByZXN0LCBwcmV2LCBjb250ZXh0IH0gPSBlbmY7XG4gIHJldHVybiBuZXcgRW5mb3Jlc3RlcihyZXN0LCBwcmV2LCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gTWFya2VyICgpIHt9XG5cbi8qXG5jdHggOjoge1xuICBvZjogKFN5bnRheCkgLT4gY3R4XG4gIG5leHQ6IChTdHJpbmcpIC0+IFN5bnRheCBvciBUZXJtXG59XG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFjcm9Db250ZXh0IHtcblxuICBjb25zdHJ1Y3RvcihlbmYsIG5hbWUsIGNvbnRleHQsIHVzZVNjb3BlLCBpbnRyb2R1Y2VkU2NvcGUpIHtcbiAgICBjb25zdCBzdGFydE1hcmtlciA9IG5ldyBNYXJrZXIoKTtcbiAgICBjb25zdCBzdGFydEVuZiA9IGNsb25lRW5mb3Jlc3RlcihlbmYpO1xuICAgIGNvbnN0IHByaXYgPSB7XG4gICAgICBuYW1lLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVuZjogc3RhcnRFbmYsXG4gICAgICBzdGFydE1hcmtlcixcbiAgICAgIG1hcmtlcnM6IG5ldyBNYXAoW1tzdGFydE1hcmtlciwgZW5mXV0pLFxuICAgIH07XG5cbiAgICBpZiAodXNlU2NvcGUgJiYgaW50cm9kdWNlZFNjb3BlKSB7XG4gICAgICBwcml2Lm5vU2NvcGVzID0gZmFsc2U7XG4gICAgICBwcml2LnVzZVNjb3BlID0gdXNlU2NvcGU7XG4gICAgICBwcml2LmludHJvZHVjZWRTY29wZSA9IGludHJvZHVjZWRTY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpdi5ub1Njb3BlcyA9IHRydWU7XG4gICAgfVxuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCBwcml2KTtcbiAgICB0aGlzLnJlc2V0KCk7IC8vIHNldCBjdXJyZW50IGVuZm9yZXN0ZXJcblxuICAgIHRoaXNbU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHRoaXM7XG4gIH1cblxuICBuYW1lKCkge1xuICAgIGNvbnN0IHsgbmFtZSwgY29udGV4dCB9ID0gcHJpdmF0ZURhdGEuZ2V0KHRoaXMpO1xuICAgIHJldHVybiBuZXcgU3ludGF4T3JUZXJtV3JhcHBlcihuYW1lLCBjb250ZXh0KTtcbiAgfVxuXG4gIGV4cGFuZCh0eXBlKSB7XG4gICAgY29uc3QgeyBlbmYsIGNvbnRleHQgfSA9IHByaXZhdGVEYXRhLmdldCh0aGlzKTtcbiAgICBpZiAoZW5mLnJlc3Quc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGVuZi5leHBhbmRNYWNybygpO1xuICAgIGxldCBvcmlnaW5hbFJlc3QgPSBlbmYucmVzdDtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ2V4cHInOlxuICAgICAgICB2YWx1ZSA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRXhwcmVzc2lvbic6XG4gICAgICAgIHZhbHVlID0gZW5mLmVuZm9yZXN0RXhwcmVzc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N0YXRlbWVudCc6XG4gICAgICBjYXNlICdzdG10JzpcbiAgICAgICAgdmFsdWUgPSBlbmYuZW5mb3Jlc3RTdGF0ZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0NsYXNzRGVjbGFyYXRpb24nOlxuICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICB2YWx1ZSA9IGVuZi5lbmZvcmVzdFN0YXRlbWVudCgpO1xuICAgICAgICBleHBlY3QoXy53aGVyZUVxKHt0eXBlfSwgdmFsdWUpLCBgRXhwZWN0aW5nIGEgJHt0eXBlfWAsIHZhbHVlLCBvcmlnaW5hbFJlc3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1lpZWxkRXhwcmVzc2lvbic6XG4gICAgICAgIHZhbHVlID0gZW5mLmVuZm9yZXN0WWllbGRFeHByZXNzaW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ2xhc3NFeHByZXNzaW9uJzpcbiAgICAgICAgdmFsdWUgPSBlbmYuZW5mb3Jlc3RDbGFzcyh7aXNFeHByOiB0cnVlfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dFeHByZXNzaW9uJzpcbiAgICAgICAgdmFsdWUgPSBlbmYuZW5mb3Jlc3RBcnJvd0V4cHJlc3Npb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOZXdFeHByZXNzaW9uJzpcbiAgICAgICAgdmFsdWUgPSBlbmYuZW5mb3Jlc3ROZXdFeHByZXNzaW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXJFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xpdGVyYWxOdW1lcmljRXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMaXRlcmFsSW5maW5pdHlFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xpdGVyYWxTdHJpbmdFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ1RlbXBsYXRlRXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMaXRlcmFsQm9vbGVhbkV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTGl0ZXJhbE51bGxFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xpdGVyYWxSZWdFeHBFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ09iamVjdEV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgdmFsdWUgPSBlbmYuZW5mb3Jlc3RQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnU3RhdGljTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdDb21wdXRlZE1lbWJlckV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnQ29tcG91bmRBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICB2YWx1ZSA9IGVuZi5lbmZvcmVzdEV4cHJlc3Npb25Mb29wKCk7XG4gICAgICAgIGV4cGVjdChfLndoZXJlRXEoe3R5cGV9LCB2YWx1ZSksIGBFeHBlY3RpbmcgYSAke3R5cGV9YCwgdmFsdWUsIG9yaWdpbmFsUmVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRlcm0gdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbmV3IFN5bnRheE9yVGVybVdyYXBwZXIodmFsdWUsIGNvbnRleHQpXG4gICAgfTtcbiAgfVxuXG4gIF9yZXN0KGVuZikge1xuICAgIGNvbnN0IHByaXYgPSBwcml2YXRlRGF0YS5nZXQodGhpcyk7XG4gICAgaWYgKHByaXYubWFya2Vycy5nZXQocHJpdi5zdGFydE1hcmtlcikgPT09IGVuZikge1xuICAgICAgcmV0dXJuIHByaXYuZW5mLnJlc3Q7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdVbmF1dGhvcml6ZWQgYWNjZXNzIScpO1xuICB9XG5cbiAgcmVzZXQobWFya2VyKSB7XG4gICAgY29uc3QgcHJpdiA9IHByaXZhdGVEYXRhLmdldCh0aGlzKTtcbiAgICBsZXQgZW5mO1xuICAgIGlmIChtYXJrZXIgPT0gbnVsbCkge1xuICAgICAgLy8gZ28gdG8gdGhlIGJlZ2lubmluZ1xuICAgICAgZW5mID0gcHJpdi5tYXJrZXJzLmdldChwcml2LnN0YXJ0TWFya2VyKTtcbiAgICB9IGVsc2UgaWYgKG1hcmtlciAmJiBtYXJrZXIgaW5zdGFuY2VvZiBNYXJrZXIpIHtcbiAgICAgIC8vIG1hcmtlciBjb3VsZCBiZSBmcm9tIGFub3RoZXIgY29udGV4dFxuICAgICAgaWYgKHByaXYubWFya2Vycy5oYXMobWFya2VyKSkge1xuICAgICAgICBlbmYgPSBwcml2Lm1hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlciBtdXN0IG9yaWdpbmF0ZSBmcm9tIHRoaXMgY29udGV4dCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIE1hcmtlcicpO1xuICAgIH1cbiAgICBwcml2LmVuZiA9IGNsb25lRW5mb3Jlc3RlcihlbmYpO1xuICB9XG5cbiAgbWFyaygpIHtcbiAgICBjb25zdCBwcml2ID0gcHJpdmF0ZURhdGEuZ2V0KHRoaXMpO1xuICAgIGxldCBtYXJrZXI7XG5cbiAgICAvLyB0aGUgaWRlYSBoZXJlIGlzIHRoYXQgbWFya2luZyBhdCB0aGUgYmVnaW5uaW5nIHNob3VsZG4ndCBoYXBwZW4gbW9yZSB0aGFuIG9uY2UuXG4gICAgLy8gV2UgY2FuIHJldXNlIHN0YXJ0TWFya2VyLlxuICAgIGlmIChwcml2LmVuZi5yZXN0ID09PSBwcml2Lm1hcmtlcnMuZ2V0KHByaXYuc3RhcnRNYXJrZXIpLnJlc3QpIHtcbiAgICAgIG1hcmtlciA9IHByaXYuc3RhcnRNYXJrZXI7XG4gICAgfSBlbHNlIGlmIChwcml2LmVuZi5yZXN0LmlzRW1wdHkoKSkge1xuICAgICAgLy8gc2FtZSByZWFzb24gYXMgYWJvdmVcbiAgICAgIGlmICghcHJpdi5lbmRNYXJrZXIpIHByaXYuZW5kTWFya2VyID0gbmV3IE1hcmtlcigpO1xuICAgICAgbWFya2VyID0gcHJpdi5lbmRNYXJrZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vVE9ETyhvcHRpbWl6YXRpb24vZHViaW91cyk6IGNoZWNrIHRoYXQgdGhlcmUgaXNuJ3QgYWxyZWFkeSBhIG1hcmtlciBmb3IgdGhpcyBpbmRleD9cbiAgICAgIG1hcmtlciA9IG5ldyBNYXJrZXIoKTtcbiAgICB9XG4gICAgaWYgKCFwcml2Lm1hcmtlcnMuaGFzKG1hcmtlcikpIHtcbiAgICAgIHByaXYubWFya2Vycy5zZXQobWFya2VyLCBjbG9uZUVuZm9yZXN0ZXIocHJpdi5lbmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcjtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgY29uc3QgeyBlbmYsIG5vU2NvcGVzLCB1c2VTY29wZSwgaW50cm9kdWNlZFNjb3BlLCBjb250ZXh0IH0gPSBwcml2YXRlRGF0YS5nZXQodGhpcyk7XG4gICAgaWYgKGVuZi5yZXN0LnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSBlbmYuYWR2YW5jZSgpO1xuICAgIGlmICghbm9TY29wZXMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVkdWNlKG5ldyBTY29wZVJlZHVjZXIoW1xuICAgICAgICB7IHNjb3BlOiB1c2VTY29wZSwgcGhhc2U6IEFMTF9QSEFTRVMsIGZsaXA6IGZhbHNlIH0sXG4gICAgICAgIHsgc2NvcGU6IGludHJvZHVjZWRTY29wZSwgcGhhc2U6IEFMTF9QSEFTRVMsIGZsaXA6IHRydWV9XG4gICAgICBdLCBjb250ZXh0LmJpbmRpbmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBuZXcgU3ludGF4T3JUZXJtV3JhcHBlcih2YWx1ZSwgY29udGV4dClcbiAgICB9O1xuICB9XG59XG4iXX0=

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.processTemplate = processTemplate;
	exports.replaceTemplate = replaceTemplate;

	var _immutable = __webpack_require__(10);

	var _ramda = __webpack_require__(18);

	var _ramda2 = _interopRequireDefault(_ramda);

	var _errors = __webpack_require__(39);

	var _sweetSpec = __webpack_require__(41);

	var T = _interopRequireWildcard(_sweetSpec);

	var _syntax = __webpack_require__(38);

	var _syntax2 = _interopRequireDefault(_syntax);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	Given a syntax list like:

	  [foo, bar, $, { 42, +, 24 }, baz]

	convert it to:

	  [foo, bar, $, { 0 }, baz]

	and return another list with the interpolated values at the corresponding
	positions.

	Requires either lookahead/lookbehind of one (to see the $).
	*/

	const isDolar = s => s instanceof T.RawSyntax && typeof s.value.match === 'function' && s.value.match('identifier') && s.value.val() === '$';

	const isDelimiter = s => s instanceof T.RawDelimiter;
	const isBraces = s => s instanceof T.RawDelimiter && s.kind === 'braces';
	const isParens = s => s instanceof T.RawDelimiter && s.kind === 'parens';
	const isBrackets = s => s instanceof T.RawDelimiter && s.kind === 'brackets';

	const mkDelimiter = (kind, inner, from) => {
	  return new T.RawDelimiter({
	    kind,
	    inner: _immutable.List.of(from.inner.first()).concat(inner).concat(from.inner.last())
	  });
	};

	const insertIntoDelimiter = _ramda2.default.cond([[isBraces, (s, r) => mkDelimiter('braces', r, s)], [isParens, (s, r) => mkDelimiter('parens', r, s)], [isBrackets, (s, r) => mkDelimiter('brackets', r, s)]]);

	const process = (acc, s) => {
	  if (isBraces(s) && isDolar(acc.template.last())) {
	    let idx = _syntax2.default.fromNumber(acc.interp.size, s.inner.first().value);
	    return {
	      template: acc.template.push(mkDelimiter('braces', _immutable.List.of(new T.RawSyntax({
	        value: idx
	      })), s)),
	      interp: acc.interp.push(s.inner.slice(1, s.inner.size - 1))
	    };
	  } else if (isDelimiter(s)) {
	    let innerResult = processTemplate(s.inner.slice(1, s.inner.size - 1), acc.interp);
	    return {
	      template: acc.template.push(insertIntoDelimiter(s, innerResult.template)),
	      interp: innerResult.interp
	    };
	  } else {
	    return {
	      template: acc.template.push(s),
	      interp: acc.interp
	    };
	  }
	};

	function getLineNumber(t) {
	  if (t instanceof T.RawSyntax) {
	    return t.value.lineNumber();
	  }
	  return t.inner.first().value.lineNumber();
	}

	function setLineNumber(t, lineNumber) {
	  if (t instanceof T.RawSyntax) {
	    return t.extend({
	      value: t.value.setLineNumber(lineNumber)
	    });
	  } else if (t instanceof T.RawDelimiter) {
	    return t.extend({
	      inner: t.inner.map(tt => setLineNumber(tt, lineNumber))
	    });
	  } else if (_immutable.List.isList(t)) {
	    return t.map(tt => setLineNumber(tt, lineNumber));
	  }
	  // TODO: need to handle line numbers for all AST nodes
	  return t;
	}

	function cloneLineNumber(to, from) {
	  if (from && to) {
	    return setLineNumber(to, getLineNumber(from));
	  }
	  return to;
	}

	const replace = (acc, s) => {
	  let last = acc.template.get(-1);
	  let beforeLast = acc.template.get(-2);
	  if (isBraces(s) && isDolar(last)) {
	    let index = s.inner.get(1).value.val();
	    (0, _errors.assert)(acc.rep.size > index, 'unknown replacement value');
	    // TODO: figure out holistic solution to line nubmers and ASI
	    let replacement = cloneLineNumber(acc.rep.get(index), beforeLast);
	    // let replacement = acc.rep.get(index);
	    return {
	      template: acc.template.pop().concat(replacement),
	      rep: acc.rep
	    };
	  } else if (isDelimiter(s)) {
	    let innerResult = replaceTemplate(s.inner.slice(1, s.inner.size - 1), acc.rep);
	    return {
	      template: acc.template.push(insertIntoDelimiter(s, innerResult)),
	      rep: acc.rep
	    };
	  } else {
	    return {
	      template: acc.template.push(s),
	      rep: acc.rep
	    };
	  }
	};

	function processTemplate(temp, interp = (0, _immutable.List)()) {
	  return temp.reduce(process, { template: (0, _immutable.List)(), interp });
	}

	function replaceTemplate(temp, rep) {
	  return temp.reduce(replace, { template: (0, _immutable.List)(), rep }).template;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZW1wbGF0ZS1wcm9jZXNzb3IuanMiXSwibmFtZXMiOlsicHJvY2Vzc1RlbXBsYXRlIiwicmVwbGFjZVRlbXBsYXRlIiwiVCIsImlzRG9sYXIiLCJzIiwiUmF3U3ludGF4IiwidmFsdWUiLCJtYXRjaCIsInZhbCIsImlzRGVsaW1pdGVyIiwiUmF3RGVsaW1pdGVyIiwiaXNCcmFjZXMiLCJraW5kIiwiaXNQYXJlbnMiLCJpc0JyYWNrZXRzIiwibWtEZWxpbWl0ZXIiLCJpbm5lciIsImZyb20iLCJvZiIsImZpcnN0IiwiY29uY2F0IiwibGFzdCIsImluc2VydEludG9EZWxpbWl0ZXIiLCJjb25kIiwiciIsInByb2Nlc3MiLCJhY2MiLCJ0ZW1wbGF0ZSIsImlkeCIsImZyb21OdW1iZXIiLCJpbnRlcnAiLCJzaXplIiwicHVzaCIsInNsaWNlIiwiaW5uZXJSZXN1bHQiLCJnZXRMaW5lTnVtYmVyIiwidCIsImxpbmVOdW1iZXIiLCJzZXRMaW5lTnVtYmVyIiwiZXh0ZW5kIiwibWFwIiwidHQiLCJpc0xpc3QiLCJjbG9uZUxpbmVOdW1iZXIiLCJ0byIsInJlcGxhY2UiLCJnZXQiLCJiZWZvcmVMYXN0IiwiaW5kZXgiLCJyZXAiLCJyZXBsYWNlbWVudCIsInBvcCIsInRlbXAiLCJyZWR1Y2UiXSwibWFwcGluZ3MiOiI7Ozs7O1FBOEhnQkEsZSxHQUFBQSxlO1FBSUFDLGUsR0FBQUEsZTs7QUFqSWhCOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0lBQVlDLEM7O0FBQ1o7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE1BQU1DLFVBQVdDLENBQUQsSUFBc0JBLGFBQWFGLEVBQUVHLFNBQWhCLElBQ0MsT0FBT0QsRUFBRUUsS0FBRixDQUFRQyxLQUFmLEtBQXlCLFVBRDFCLElBRUNILEVBQUVFLEtBQUYsQ0FBUUMsS0FBUixDQUFjLFlBQWQsQ0FGRCxJQUdDSCxFQUFFRSxLQUFGLENBQVFFLEdBQVIsT0FBa0IsR0FIeEQ7O0FBSUEsTUFBTUMsY0FB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QUFDTHRCLGdCQUFVRCxJQUFJQyxRQUFKLENBQWFLLElBQWIsQ0FBa0I1QixDQUFsQixDQURMO0FBRUw2QyxXQUFLdkIsSUFBSXVCO0FBRkosS0FBUDtBQUlEO0FBQ0YsQ0F6QkQ7O0FBMkJPLFNBQVNqRCxlQUFULENBQXlCb0QsSUFBekIsRUFBbUR0QixTQUE2QixzQkFBaEYsRUFBd0Y7QUFDN0YsU0FBT3NCLEtBQUtDLE1BQUwsQ0FBWTVCLE9BQVosRUFBcUIsRUFBRUUsVUFBVSxzQkFBWixFQUFvQkcsTUFBcEIsRUFBckIsQ0FBUDtBQUNEOztBQUVNLFNBQVM3QixlQUFULENBQXlCbUQsSUFBekIsRUFBbURILEdBQW5ELEVBQTZEO0FBQ2xFLFNBQU9HLEtBQUtDLE1BQUwsQ0FBWVIsT0FBWixFQUFxQixFQUFFbEIsVUFBVSxzQkFBWixFQUFvQnNCLEdBQXBCLEVBQXJCLEVBQWdEdEIsUUFBdkQ7QUFDRCIsImZpbGUiOiJ0ZW1wbGF0ZS1wcm9jZXNzb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgXyBmcm9tICdyYW1kYSc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyBUIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0IFN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5cbi8qXG5HaXZlbiBhIHN5bnRheCBsaXN0IGxpa2U6XG5cbiAgW2ZvbywgYmFyLCAkLCB7IDQyLCArLCAyNCB9LCBiYXpdXG5cbmNvbnZlcnQgaXQgdG86XG5cbiAgW2ZvbywgYmFyLCAkLCB7IDAgfSwgYmF6XVxuXG5hbmQgcmV0dXJuIGFub3RoZXIgbGlzdCB3aXRoIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIGF0IHRoZSBjb3JyZXNwb25kaW5nXG5wb3NpdGlvbnMuXG5cblJlcXVpcmVzIGVpdGhlciBsb29rYWhlYWQvbG9va2JlaGluZCBvZiBvbmUgKHRvIHNlZSB0aGUgJCkuXG4qL1xuXG5jb25zdCBpc0RvbGFyID0gKHM6IFQuU3ludGF4VGVybSkgPT4gKHMgaW5zdGFuY2VvZiBULlJhd1N5bnRheCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHMudmFsdWUubWF0Y2ggPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy52YWx1ZS5tYXRjaCgnaWRlbnRpZmllcicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMudmFsdWUudmFsKCkgPT09ICckJztcbmNvbnN0IGlzRGVsaW1pdGVyID0gKHM6IFQuU3ludGF4VGVybSkgPT4gKHMgaW5zdGFuY2VvZiBULlJhd0RlbGltaXRlcik7XG5jb25zdCBpc0JyYWNlcyAgICA9IChzOiBULlN5bnRheFRlcm0pID0+IChzIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIpICYmIHMua2luZCA9PT0gJ2JyYWNlcyc7XG5jb25zdCBpc1BhcmVucyAgICA9IChzOiBULlN5bnRheFRlcm0pID0+IChzIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIpICYmIHMua2luZCA9PT0gJ3BhcmVucyc7XG5jb25zdCBpc0JyYWNrZXRzICA9IChzOiBULlN5bnRheFRlcm0pID0+IChzIGluc3RhbmNlb2YgVC5SYXdEZWxpbWl0ZXIpICYmIHMua2luZCA9PT0gJ2JyYWNrZXRzJztcblxudHlwZSBEZWxpbUtpbmQgPSAnYnJhY2VzJyB8ICdwYXJlbnMnIHwgJ2JyYWNrZXRzJztcblxuY29uc3QgbWtEZWxpbWl0ZXIgPSAoa2luZDogRGVsaW1LaW5kLCBpbm5lcjogTGlzdDxULlN5bnRheFRlcm0+LCBmcm9tOiBULlJhd0RlbGltaXRlcikgPT4ge1xuICByZXR1cm4gbmV3IFQuUmF3RGVsaW1pdGVyKHtcbiAgICBraW5kLFxuICAgIGlubmVyOiBMaXN0Lm9mKGZyb20uaW5uZXIuZmlyc3QoKSkuY29uY2F0KGlubmVyKS5jb25jYXQoZnJvbS5pbm5lci5sYXN0KCkpXG4gIH0pO1xufVxuXG5jb25zdCBpbnNlcnRJbnRvRGVsaW1pdGVyID0gXy5jb25kKFtcbiAgW2lzQnJhY2VzLCAocywgcikgPT4gbWtEZWxpbWl0ZXIoJ2JyYWNlcycsIHIsIHMpXSxcbiAgW2lzUGFyZW5zLCAocywgcikgPT4gbWtEZWxpbWl0ZXIoJ3BhcmVucycsIHIsIHMpXSxcbiAgW2lzQnJhY2tldHMsIChzLCByKSA9PiBta0RlbGltaXRlcignYnJhY2tldHMnLCByLCBzKV1cbl0pO1xuXG5jb25zdCBwcm9jZXNzID0gKGFjYzogeyB0ZW1wbGF0ZTogTGlzdDxULlN5bnRheFRlcm0+LCBpbnRlcnA6IExpc3Q8TGlzdDxULlN5bnRheFRlcm0+PiB9LCBzOiBULlN5bnRheFRlcm0pID0+IHtcbiAgaWYgKGlzQnJhY2VzKHMpICYmIGlzRG9sYXIoYWNjLnRlbXBsYXRlLmxhc3QoKSkpIHtcbiAgICBsZXQgaWR4ID0gU3ludGF4LmZyb21OdW1iZXIoYWNjLmludGVycC5zaXplLCBzLmlubmVyLmZpcnN0KCkudmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZTogYWNjLnRlbXBsYXRlLnB1c2gobWtEZWxpbWl0ZXIoJ2JyYWNlcycsIExpc3Qub2YobmV3IFQuUmF3U3ludGF4KHtcbiAgICAgICAgdmFsdWU6IGlkeFxuICAgICAgfSkpLCBzKSksXG4gICAgICBpbnRlcnA6IGFjYy5pbnRlcnAucHVzaChzLmlubmVyLnNsaWNlKDEsIHMuaW5uZXIuc2l6ZSAtIDEpKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNEZWxpbWl0ZXIocykpIHtcbiAgICBsZXQgaW5uZXJSZXN1bHQgPSBwcm9jZXNzVGVtcGxhdGUocy5pbm5lci5zbGljZSgxLCBzLmlubmVyLnNpemUgLSAxKSwgYWNjLmludGVycCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiBhY2MudGVtcGxhdGUucHVzaChpbnNlcnRJbnRvRGVsaW1pdGVyKHMsIGlubmVyUmVzdWx0LnRlbXBsYXRlKSksXG4gICAgICBpbnRlcnA6IGlubmVyUmVzdWx0LmludGVycFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiBhY2MudGVtcGxhdGUucHVzaChzKSxcbiAgICAgIGludGVycDogYWNjLmludGVycFxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVOdW1iZXIodDogVC5TeW50YXhUZXJtKSB7XG4gIGlmICh0IGluc3RhbmNlb2YgVC5SYXdTeW50YXgpIHtcbiAgICByZXR1cm4gdC52YWx1ZS5saW5lTnVtYmVyKCk7XG4gIH1cbiAgcmV0dXJuIHQuaW5uZXIuZmlyc3QoKS52YWx1ZS5saW5lTnVtYmVyKCk7XG59XG5cbmZ1bmN0aW9uIHNldExpbmVOdW1iZXIodDogVC5UZXJtIHwgTGlzdDxULlRlcm0+LCBsaW5lTnVtYmVyOiBudW1iZXIpIHtcbiAgaWYgKHQgaW5zdGFuY2VvZiBULlJhd1N5bnRheCkge1xuICAgIHJldHVybiB0LmV4dGVuZCh7XG4gICAgICB2YWx1ZTogdC52YWx1ZS5zZXRMaW5lTnVtYmVyKGxpbmVOdW1iZXIpXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIFQuUmF3RGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIHQuZXh0ZW5kKHtcbiAgICAgIGlubmVyOiB0LmlubmVyLm1hcCh0dCA9PiBzZXRMaW5lTnVtYmVyKHR0LCBsaW5lTnVtYmVyKSlcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChMaXN0LmlzTGlzdCh0KSkge1xuICAgIHJldHVybiB0Lm1hcCh0dCA9PiBzZXRMaW5lTnVtYmVyKHR0LCBsaW5lTnVtYmVyKSk7XG4gIH1cbiAgLy8gVE9ETzogbmVlZCB0byBoYW5kbGUgbGluZSBudW1iZXJzIGZvciBhbGwgQVNUIG5vZGVzXG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBjbG9uZUxpbmVOdW1iZXIodG86IFQuVGVybSwgZnJvbTogVC5TeW50YXhUZXJtKSB7XG4gIGlmIChmcm9tICYmIHRvKSB7XG4gICAgcmV0dXJuIHNldExpbmVOdW1iZXIodG8sIGdldExpbmVOdW1iZXIoZnJvbSkpO1xuICB9XG4gIHJldHVybiB0bztcbn1cblxuY29uc3QgcmVwbGFjZSA9IChhY2M6IHsgdGVtcGxhdGU6IExpc3Q8VC5TeW50YXhUZXJtPiwgcmVwOiBMaXN0PFQuVGVybSB8IExpc3Q8VC5UZXJtPj4gfSwgczogVC5TeW50YXhUZXJtKSA9PiB7XG4gIGxldCBsYXN0ID0gYWNjLnRlbXBsYXRlLmdldCgtMSk7XG4gIGxldCBiZWZvcmVMYXN0ID0gYWNjLnRlbXBsYXRlLmdldCgtMik7XG4gIGlmIChpc0JyYWNlcyhzKSAmJiBpc0RvbGFyKGxhc3QpKSB7XG4gICAgbGV0IGluZGV4ID0gcy5pbm5lci5nZXQoMSkudmFsdWUudmFsKCk7XG4gICAgYXNzZXJ0KGFjYy5yZXAuc2l6ZSA+IGluZGV4LCAndW5rbm93biByZXBsYWNlbWVudCB2YWx1ZScpO1xuICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG9saXN0aWMgc29sdXRpb24gdG8gbGluZSBudWJtZXJzIGFuZCBBU0lcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSBjbG9uZUxpbmVOdW1iZXIoYWNjLnJlcC5nZXQoaW5kZXgpLCBiZWZvcmVMYXN0KTtcbiAgICAvLyBsZXQgcmVwbGFjZW1lbnQgPSBhY2MucmVwLmdldChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiBhY2MudGVtcGxhdGUucG9wKCkuY29uY2F0KHJlcGxhY2VtZW50KSxcbiAgICAgIHJlcDogYWNjLnJlcFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNEZWxpbWl0ZXIocykpIHtcbiAgICBsZXQgaW5uZXJSZXN1bHQgPSByZXBsYWNlVGVtcGxhdGUocy5pbm5lci5zbGljZSgxLCBzLmlubmVyLnNpemUgLSAxKSwgYWNjLnJlcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbXBsYXRlOiBhY2MudGVtcGxhdGUucHVzaChpbnNlcnRJbnRvRGVsaW1pdGVyKHMsIGlubmVyUmVzdWx0KSksXG4gICAgICByZXA6IGFjYy5yZXBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZTogYWNjLnRlbXBsYXRlLnB1c2gocyksXG4gICAgICByZXA6IGFjYy5yZXBcbiAgICB9O1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlKHRlbXA6IExpc3Q8VC5TeW50YXhUZXJtPiwgaW50ZXJwOiBMaXN0PFQuU3ludGF4VGVybT4gPSBMaXN0KCkpIHtcbiAgcmV0dXJuIHRlbXAucmVkdWNlKHByb2Nlc3MsIHsgdGVtcGxhdGU6IExpc3QoKSwgaW50ZXJwIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXA6IExpc3Q8VC5TeW50YXhUZXJtPiwgcmVwOiBhbnkpIHtcbiAgcmV0dXJuIHRlbXAucmVkdWNlKHJlcGxhY2UsIHsgdGVtcGxhdGU6IExpc3QoKSwgcmVwIH0pLnRlbXBsYXRlO1xufVxuIl19

/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class ASTDispatcher {
	  constructor(prefix, errorIfMissing) {
	    this.errorIfMissing = errorIfMissing;
	    this.prefix = prefix;
	  }

	  dispatch(term) {
	    let field = this.prefix + term.type;
	    if (typeof this[field] === 'function') {
	      return this[field](term);
	    } else if (!this.errorIfMissing) {
	      return term;
	    }
	    throw new Error(`Missing implementation for: ${ field }`);
	  }
	}
	exports.default = ASTDispatcher;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hc3QtZGlzcGF0Y2hlci5qcyJdLCJuYW1lcyI6WyJBU1REaXNwYXRjaGVyIiwiY29uc3RydWN0b3IiLCJwcmVmaXgiLCJlcnJvcklmTWlzc2luZyIsImRpc3BhdGNoIiwidGVybSIsImZpZWxkIiwidHlwZSIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFlLE1BQU1BLGFBQU4sQ0FBb0I7QUFDakNDLGNBQVlDLE1BQVosRUFBb0JDLGNBQXBCLEVBQW9DO0FBQ2xDLFNBQUtBLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsU0FBS0QsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7O0FBRURFLFdBQVNDLElBQVQsRUFBZTtBQUNiLFFBQUlDLFFBQVEsS0FBS0osTUFBTCxHQUFjRyxLQUFLRSxJQUEvQjtBQUNBLFFBQUksT0FBTyxLQUFLRCxLQUFMLENBQVAsS0FBdUIsVUFBM0IsRUFBdUM7QUFDckMsYUFBTyxLQUFLQSxLQUFMLEVBQVlELElBQVosQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsS0FBS0YsY0FBVixFQUEwQjtBQUMvQixhQUFPRSxJQUFQO0FBQ0Q7QUFDRCxVQUFNLElBQUlHLEtBQUosQ0FBVyxnQ0FBOEJGLEtBQU0sR0FBL0MsQ0FBTjtBQUNEO0FBZGdDO2tCQUFkTixhIiwiZmlsZSI6ImFzdC1kaXNwYXRjaGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKHByZWZpeCwgZXJyb3JJZk1pc3NpbmcpIHtcbiAgICB0aGlzLmVycm9ySWZNaXNzaW5nID0gZXJyb3JJZk1pc3Npbmc7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cblxuICBkaXNwYXRjaCh0ZXJtKSB7XG4gICAgbGV0IGZpZWxkID0gdGhpcy5wcmVmaXggKyB0ZXJtLnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2ZpZWxkXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXNbZmllbGRdKHRlcm0pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZXJyb3JJZk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiB0ZXJtO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgaW1wbGVtZW50YXRpb24gZm9yOiAke2ZpZWxkfWApO1xuICB9XG59XG4iXX0=

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	var _immutable = __webpack_require__(10);

	var _enforester = __webpack_require__(49);

	var _termExpander = __webpack_require__(47);

	var _termExpander2 = _interopRequireDefault(_termExpander);

	var _env = __webpack_require__(44);

	var _env2 = _interopRequireDefault(_env);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _terms = __webpack_require__(48);

	var T = _interopRequireWildcard(_terms);

	var _symbol = __webpack_require__(43);

	var _transforms = __webpack_require__(45);

	var _errors = __webpack_require__(39);

	var _loadSyntax = __webpack_require__(52);

	var _scope = __webpack_require__(42);

	var _syntax = __webpack_require__(38);

	var _astDispatcher = __webpack_require__(66);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	var _syntax2 = __webpack_require__(38);

	var _syntax3 = _interopRequireDefault(_syntax2);

	var _scopeReducer = __webpack_require__(50);

	var _scopeReducer2 = _interopRequireDefault(_scopeReducer);

	var _moduleVisitor = __webpack_require__(68);

	var _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	class RegisterBindingsReducer extends S.default.CloneReducer {

	  constructor(useScope, phase, skipDup, bindings, env) {
	    super();
	    this.useScope = useScope;
	    this.phase = phase;
	    this.bindings = bindings;
	    this.skipDup = skipDup;
	    this.env = env;
	  }

	  reduceBindingIdentifier(t, s) {
	    let newName = s.name.removeScope(this.useScope, this.phase);
	    let newBinding = (0, _symbol.gensym)(newName.val());
	    this.bindings.add(newName, {
	      binding: newBinding,
	      phase: this.phase,
	      skipDup: this.skipDup
	    });
	    this.env.set(newBinding.toString(), new _transforms.VarBindingTransform(newName));
	    return t.extend({
	      name: newName
	    });
	  }
	}


	class RegisterSyntaxBindingsReducer extends S.default.CloneReducer {

	  constructor(useScope, phase, bindings, env, val) {
	    super();
	    this.useScope = useScope;
	    this.phase = phase;
	    this.bindings = bindings;
	    this.env = env;
	    this.val = val;
	  }

	  reduceBindingIdentifier(t, s) {
	    let newName = s.name.removeScope(this.useScope, this.phase);
	    let newBinding = (0, _symbol.gensym)(newName.val());
	    this.bindings.add(newName, {
	      binding: newBinding,
	      phase: this.phase,
	      skipDup: false
	    });
	    let resolvedName = newName.resolve(this.phase);
	    this.env.set(resolvedName, new _transforms.CompiletimeTransform(this.val));
	    return t.extend({
	      name: newName
	    });
	  }
	}

	function bindImports(impTerm, exModule, context) {
	  let names = [];
	  let phase = impTerm.forSyntax ? context.phase + 1 : context.phase;
	  impTerm.namedImports.forEach(specifier => {
	    let name = specifier.binding.name;
	    let exportName = findNameInExports(name, exModule.exportEntries());
	    if (exportName != null) {
	      let newBinding = (0, _symbol.gensym)(name.val());
	      context.store.set(newBinding.toString(), new _transforms.VarBindingTransform(name));
	      context.bindings.addForward(name, exportName, newBinding, phase);
	      names.push(name);
	    }
	  });
	  return (0, _immutable.List)(names);
	}

	function findNameInExports(name, exp) {
	  let foundNames = exp.reduce((acc, e) => {
	    if (T.isExportFrom(e)) {
	      return acc.concat(e.namedExports.reduce((acc, specifier) => {
	        if (specifier.exportedName.val() === name.val()) {
	          return acc.concat(specifier.exportedName);
	        }
	        return acc;
	      }, (0, _immutable.List)()));
	    } else if (T.isExport(e)) {
	      if (e.declaration.name && e.declaration.name.name) {
	        if (e.declaration.name.name.val() === name.val()) {
	          return acc.concat(e.declaration.name.name);
	        }
	        return acc;
	      }
	      return acc.concat(e.declaration.declarators.reduce((acc, decl) => {
	        if (decl.binding.name.val() === name.val()) {
	          return acc.concat(decl.binding.name);
	        }
	        return acc;
	      }, (0, _immutable.List)()));
	    }
	    return acc;
	  }, (0, _immutable.List)());
	  (0, _errors.assert)(foundNames.size <= 1, 'expecting no more than 1 matching name in exports');
	  return foundNames.get(0);
	}

	function removeNames(impTerm, names) {
	  let namedImports = impTerm.namedImports.filter(specifier => !names.contains(specifier.binding.name));
	  return impTerm.extend({ namedImports });
	}

	// function bindAllSyntaxExports(exModule, toSynth, context) {
	//   let phase = context.phase;
	//   exModule.exportEntries.forEach(ex => {
	//     if (isExportSyntax(ex)) {
	//       ex.declaration.declarators.forEach(decl => {
	//         let name = decl.binding.name;
	//         let newBinding = gensym(name.val());
	//         let storeName = exModule.moduleSpecifier + ":" + name.val() + ":" + phase;
	//         let synthStx = Syntax.fromIdentifier(name.val(), toSynth);
	//         let storeStx = Syntax.fromIdentifier(storeName, toSynth);
	//         context.bindings.addForward(synthStx, storeStx, newBinding, phase);
	//       });
	//     }
	//   });
	// }

	class TokenExpander extends _astDispatcher2.default {
	  constructor(context) {
	    super('expand', false);
	    this.context = context;
	  }

	  expand(stxl) {
	    let result = [];
	    if (stxl.size === 0) {
	      return (0, _immutable.List)(result);
	    }
	    let prev = (0, _immutable.List)();
	    let enf = new _enforester.Enforester(stxl, prev, this.context);

	    while (!enf.done) {
	      result.push(this.dispatch(enf.enforest()));
	    }

	    return (0, _immutable.List)(result);
	  }

	  expandVariableDeclarationStatement(term) {
	    return term.extend({
	      declaration: this.registerVariableDeclaration(term.declaration)
	    });
	  }

	  expandFunctionDeclaration(term) {
	    return this.registerFunctionOrClass(term);
	  }

	  // TODO: think about function expressions

	  expandImport(term) {
	    let path = term.moduleSpecifier.val();
	    let mod;
	    let visitor = new _moduleVisitor2.default(this.context);
	    if (term.forSyntax) {
	      mod = this.context.loader.get(path, this.context.phase + 1, this.context.cwd);
	      this.context.store = visitor.visit(mod, this.context.phase + 1, this.context.store);
	      this.context.store = visitor.invoke(mod, this.context.phase + 1, this.context.store);
	    } else {
	      mod = this.context.loader.get(path, this.context.phase, this.context.cwd);
	      this.context.store = visitor.visit(mod, this.context.phase, this.context.store);
	      // this.context.store = this.context.modules.visit(mod, this.context.phase, this.context.store);
	    }
	    let boundNames = bindImports(term, mod, this.context);
	    return removeNames(term, boundNames);
	  }

	  expandExport(term) {
	    if (T.isFunctionDeclaration(term.declaration) || T.isClassDeclaration(term.declaration)) {
	      return term.extend({
	        declaration: this.registerFunctionOrClass(term.declaration)
	      });
	    } else if (T.isVariableDeclaration(term.declaration)) {
	      return term.extend({
	        declaration: this.registerVariableDeclaration(term.declaration)
	      });
	    }
	    return term;
	  }

	  registerFunctionOrClass(term) {
	    let red = new RegisterBindingsReducer(this.context.useScope, this.context.phase, false, this.context.bindings, this.context.env);
	    return term.extend({
	      name: term.name.reduce(red)
	    });
	  }

	  registerVariableDeclaration(term) {
	    if (term.kind === 'syntax' || term.kind === 'syntaxrec') {
	      return this.registerSyntaxDeclaration(term);
	    }
	    let red = new RegisterBindingsReducer(this.context.useScope, this.context.phase, term.kind === 'var', this.context.bindings, this.context.env);
	    return term.extend({
	      declarators: term.declarators.map(decl => {
	        return decl.extend({
	          binding: decl.binding.reduce(red)
	        });
	      })
	    });
	  }

	  registerSyntaxDeclaration(term) {
	    if (term.kind === 'syntax') {
	      // syntax id^{a, b} = <init>^{a, b}
	      // ->
	      // syntaxrec id^{a,b,c} = function() { return <<id^{a}>> }
	      // syntaxrec id^{a,b} = <init>^{a,b,c}
	      let scope = (0, _scope.freshScope)('nonrec');
	      let scopeReducer = new _scopeReducer2.default([{ scope: scope, phase: _syntax.ALL_PHASES, flip: false }], this.context.bindings);
	      term = term.extend({
	        declarators: term.declarators.map(decl => {
	          let name = decl.binding.name;
	          let nameAdded = name.addScope(scope, this.context.bindings, _syntax.ALL_PHASES);
	          let nameRemoved = name.removeScope(this.context.currentScope[this.context.currentScope.length - 1], this.context.phase);
	          let newBinding = (0, _symbol.gensym)(name.val());
	          this.context.bindings.addForward(nameAdded, nameRemoved, newBinding, this.context.phase);
	          return decl.extend({
	            init: decl.init.reduce(scopeReducer)
	          });
	        })
	      });
	    }
	    // for syntax declarations we need to load the compiletime value
	    // into the environment
	    return term.extend({
	      declarators: term.declarators.map(decl => {
	        // each compiletime value needs to be expanded with a fresh
	        // environment and in the next higher phase
	        let syntaxExpander = new _termExpander2.default(_.merge(this.context, {
	          phase: this.context.phase + 1,
	          env: new _env2.default(),
	          store: this.context.store
	        }));

	        let init = syntaxExpander.expand(decl.init);
	        let val = (0, _loadSyntax.evalCompiletimeValue)(init, _.merge(this.context, {
	          phase: this.context.phase + 1
	        }));
	        let red = new RegisterSyntaxBindingsReducer(this.context.useScope, this.context.phase, this.context.bindings, this.context.env, val);
	        return decl.extend({ binding: decl.binding.reduce(red), init });
	      })
	    });
	  }

	  // registerSyntaxDeclarator(term) {
	  //
	  // }
	}
	exports.default = TokenExpander;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90b2tlbi1leHBhbmRlci5qcyJdLCJuYW1lcyI6WyJTIiwiXyIsIlQiLCJSZWdpc3RlckJpbmRpbmdzUmVkdWNlciIsIkNsb25lUmVkdWNlciIsImNvbnN0cnVjdG9yIiwidXNlU2NvcGUiLCJwaGFzZSIsInNraXBEdXAiLCJiaW5kaW5ncyIsImVudiIsInJlZHVjZUJpbmRpbmdJZGVudGlmaWVyIiwidCIsInMiLCJuZXdOYW1lIiwibmFtZSIsInJlbW92ZVNjb3BlIiwibmV3QmluZGluZyIsInZhbCIsImFkZCIsImJpbmRpbmciLCJzZXQiLCJ0b1N0cmluZyIsImV4dGVuZCIsIlJlZ2lzdGVyU3ludGF4QmluZGluZ3NSZWR1Y2VyIiwicmVzb2x2ZWROYW1lIiwicmVzb2x2ZSIsImJpbmRJbXBvcnRzIiwiaW1wVGVybSIsImV4TW9kdWxlIiwiY29udGV4dCIsIm5hbWVzIiwiZm9yU3ludGF4IiwibmFtZWRJbXBvcnRzIiwiZm9yRWFjaCIsInNwZWNpZmllciIsImV4cG9ydE5hbWUiLCJmaW5kTmFtZUluRXhwb3J0cyIsImV4cG9ydEVudHJpZXMiLCJzdG9yZSIsImFkZEZvcndhcmQiLCJwdXNoIiwiZXhwIiwiZm91bmROYW1lcyIsInJlZHVjZSIsImFjYyIsImUiLCJpc0V4cG9ydEZyb20iLCJjb25jYXQiLCJuYW1lZEV4cG9ydHMiLCJleHBvcnRlZE5hbWUiLCJpc0V4cG9ydCIsImRlY2xhcmF0aW9uIiwiZGVjbGFyYXRvcnMiLCJkZWNsIiwic2l6ZSIsImdldCIsInJlbW92ZU5hbWVzIiwiZmlsdGVyIiwiY29udGFpbnMiLCJUb2tlbkV4cGFuZGVyIiwiZXhwYW5kIiwic3R4bCIsInJlc3VsdCIsInByZXYiLCJlbmYiLCJkb25lIiwiZGlzcGF0Y2giLCJlbmZvcmVzdCIsImV4cGFuZFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQiLCJ0ZXJtIiwicmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uIiwiZXhwYW5kRnVuY3Rpb25EZWNsYXJhdGlvbiIsInJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzIiwiZXhwYW5kSW1wb3J0IiwicGF0aCIsIm1vZHVsZVNwZWNpZmllciIsIm1vZCIsInZpc2l0b3IiLCJsb2FkZXIiLCJjd2QiLCJ2aXNpdCIsImludm9rZSIsImJvdW5kTmFtZXMiLCJleHBhbmRFeHBvcnQiLCJpc0Z1bmN0aW9uRGVjbGFyYXRpb24iLCJpc0NsYXNzRGVjbGFyYXRpb24iLCJpc1ZhcmlhYmxlRGVjbGFyYXRpb24iLCJyZWQiLCJraW5kIiwicmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbiIsIm1hcCIsInNjb3BlIiwic2NvcGVSZWR1Y2VyIiwiZmxpcCIsIm5hbWVBZGRlZCIsImFkZFNjb3BlIiwibmFtZVJlbW92ZWQiLCJjdXJyZW50U2NvcGUiLCJsZW5ndGgiLCJpbml0Iiwic3ludGF4RXhwYW5kZXIiLCJtZXJnZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7O0lBQWtCQSxDOztBQUNsQjs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlDLEM7O0FBQ1o7O0lBQVlDLEM7O0FBQ1o7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBR0EsTUFBTUMsdUJBQU4sU0FuQmtCSCxDQW1Cb0IsU0FBS0ksWUFBM0MsQ0FBd0Q7O0FBT3REQyxjQUFZQyxRQUFaLEVBQTJCQyxLQUEzQixFQUEwQ0MsT0FBMUMsRUFBNERDLFFBQTVELEVBQTJFQyxHQUEzRSxFQUFxRjtBQUNuRjtBQUNBLFNBQUtKLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLRSxHQUFMLEdBQVdBLEdBQVg7QUFDRDs7QUFFREMsMEJBQXdCQyxDQUF4QixFQUFpQ0MsQ0FBakMsRUFBc0Q7QUFDcEQsUUFBSUMsVUFBVUQsRUFBRUUsSUFB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SyxtQkFGcUQ7QUFHMUQ2QixpQkFBTyxLQUFLVCxPQUFMLENBQWFTO0FBSHNDLFNBQXRCLENBQWpCLENBQXJCOztBQU1BLFlBQUk2RCxPQUFPQyxlQUFleEMsTUFBZixDQUFzQlAsS0FBSzhDLElBQTNCLENBQVg7QUFDQSxZQUFJbEYsTUFBTSxzQ0FBcUJrRixJQUFyQixFQUEyQm5HLEVBQUVxRyxLQUFGLENBQVEsS0FBS3hFLE9BQWIsRUFBc0I7QUFDekR2QixpQkFBTyxLQUFLdUIsT0FBTCxDQUFhdkIsS0FBYixHQUFxQjtBQUQ2QixTQUF0QixDQUEzQixDQUFWO0FBR0EsWUFBSWlGLE1BQU0sSUFBSWhFLDZCQUFKLENBQ1IsS0FBS00sT0FBTCxDQUFheEIsUUFETCxFQUVSLEtBQUt3QixPQUFMLENBQWF2QixLQUZMLEVBR1IsS0FBS3VCLE9BQUwsQ0FBYXJCLFFBSEwsRUFJUixLQUFLcUIsT0FBTCxDQUFhcEIsR0FKTCxFQUtSUSxHQUxRLENBQVY7QUFNQSxlQUFPb0MsS0FBSy9CLE1BQUwsQ0FBWSxFQUFFSCxTQUFTa0MsS0FBS2xDLE9BQUwsQ0FBYXdCLE1BQWIsQ0FBb0I0QyxHQUFwQixDQUFYLEVBQXFDWSxJQUFyQyxFQUFaLENBQVA7QUFDRCxPQXBCWTtBQURJLEtBQVosQ0FBUDtBQXVCRDs7QUFFRDtBQUNBO0FBQ0E7QUFsSnVEO2tCQUFwQ3hDLGEiLCJmaWxlIjoidG9rZW4tZXhwYW5kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IFRlcm0sICogYXMgUyBmcm9tICdzd2VldC1zcGVjJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgIEVuZm9yZXN0ZXIgfSBmcm9tICcuL2VuZm9yZXN0ZXInO1xuaW1wb3J0IFRlcm1FeHBhbmRlciBmcm9tICcuL3Rlcm0tZXhwYW5kZXIuanMnO1xuaW1wb3J0IEVudiBmcm9tICcuL2Vudic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3JhbWRhJztcbmltcG9ydCAqIGFzIFQgZnJvbSAnLi90ZXJtcyc7XG5pbXBvcnQgeyBnZW5zeW0gfSBmcm9tICcuL3N5bWJvbCc7XG5pbXBvcnQgeyBWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybSB9IGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5pbXBvcnQgeyAgYXNzZXJ0IH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgZXZhbENvbXBpbGV0aW1lVmFsdWUgfSBmcm9tICcuL2xvYWQtc3ludGF4JztcbmltcG9ydCB7ICBmcmVzaFNjb3BlIH0gZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgeyBBTExfUEhBU0VTIH0gZnJvbSAnLi9zeW50YXgnO1xuaW1wb3J0IEFTVERpc3BhdGNoZXIgZnJvbSAnLi9hc3QtZGlzcGF0Y2hlcic7XG5pbXBvcnQgU3ludGF4IGZyb20gJy4vc3ludGF4LmpzJztcbmltcG9ydCBTY29wZVJlZHVjZXIgZnJvbSAnLi9zY29wZS1yZWR1Y2VyJztcbmltcG9ydCBNb2R1bGVWaXNpdG9yIGZyb20gJy4vbW9kdWxlLXZpc2l0b3InO1xuXG5cbmNsYXNzIFJlZ2lzdGVyQmluZGluZ3NSZWR1Y2VyIGV4dGVuZHMgVGVybS5DbG9uZVJlZHVjZXIge1xuICB1c2VTY29wZTogYW55O1xuICBwaGFzZTogbnVtYmVyO1xuICBiaW5kaW5nczogYW55O1xuICBza2lwRHVwOiBib29sZWFuO1xuICBlbnY6IEVudjtcblxuICBjb25zdHJ1Y3Rvcih1c2VTY29wZTogYW55LCBwaGFzZTogbnVtYmVyLCBza2lwRHVwOiBib29sZWFuLCBiaW5kaW5nczogYW55LCBlbnY6IEVudikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51c2VTY29wZSA9IHVzZVNjb3BlO1xuICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgdGhpcy5za2lwRHVwID0gc2tpcER1cDtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgfVxuXG4gIHJlZHVjZUJpbmRpbmdJZGVudGlmaWVyKHQ6IFRlcm0sIHM6IHsgbmFtZTogU3ludGF4IH0pIHtcbiAgICBsZXQgbmV3TmFtZSA9IHMubmFtZS5yZW1vdmVTY29wZSh0aGlzLnVzZVNjb3BlLCB0aGlzLnBoYXNlKTtcbiAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuZXdOYW1lLnZhbCgpKTtcbiAgICB0aGlzLmJpbmRpbmdzLmFkZChuZXdOYW1lLCB7XG4gICAgICBiaW5kaW5nOiBuZXdCaW5kaW5nLFxuICAgICAgcGhhc2U6IHRoaXMucGhhc2UsXG4gICAgICBza2lwRHVwOiB0aGlzLnNraXBEdXBcbiAgICB9KTtcbiAgICB0aGlzLmVudi5zZXQobmV3QmluZGluZy50b1N0cmluZygpLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShuZXdOYW1lKSk7XG4gICAgcmV0dXJuIHQuZXh0ZW5kKHtcbiAgICAgIG5hbWU6IG5ld05hbWVcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBSZWdpc3RlclN5bnRheEJpbmRpbmdzUmVkdWNlciBleHRlbmRzIFRlcm0uQ2xvbmVSZWR1Y2VyIHtcbiAgdXNlU2NvcGU6IGFueTtcbiAgcGhhc2U6IG51bWJlcjtcbiAgYmluZGluZ3M6IGFueTtcbiAgZW52OiBFbnY7XG4gIHZhbDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHVzZVNjb3BlOiBhbnksIHBoYXNlOiBudW1iZXIsIGJpbmRpbmdzOiBhbnksIGVudjogRW52LCB2YWw6IGFueSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51c2VTY29wZSA9IHVzZVNjb3BlO1xuICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH1cblxuICByZWR1Y2VCaW5kaW5nSWRlbnRpZmllcih0OiBUZXJtLCBzOiB7IG5hbWU6IFN5bnRheCB9KSB7XG4gICAgbGV0IG5ld05hbWUgPSBzLm5hbWUucmVtb3ZlU2NvcGUodGhpcy51c2VTY29wZSwgdGhpcy5waGFzZSk7XG4gICAgbGV0IG5ld0JpbmRpbmcgPSBnZW5zeW0obmV3TmFtZS52YWwoKSk7XG4gICAgdGhpcy5iaW5kaW5ncy5hZGQobmV3TmFtZSwge1xuICAgICAgYmluZGluZzogbmV3QmluZGluZyxcbiAgICAgIHBoYXNlOiB0aGlzLnBoYXNlLFxuICAgICAgc2tpcER1cDogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgcmVzb2x2ZWROYW1lID0gbmV3TmFtZS5yZXNvbHZlKHRoaXMucGhhc2UpO1xuICAgIHRoaXMuZW52LnNldChyZXNvbHZlZE5hbWUsIG5ldyBDb21waWxldGltZVRyYW5zZm9ybSh0aGlzLnZhbCkpO1xuICAgIHJldHVybiB0LmV4dGVuZCh7XG4gICAgICBuYW1lOiBuZXdOYW1lXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEltcG9ydHMoaW1wVGVybSwgZXhNb2R1bGUsIGNvbnRleHQpIHtcbiAgbGV0IG5hbWVzID0gW107XG4gIGxldCBwaGFzZSA9IGltcFRlcm0uZm9yU3ludGF4ID8gY29udGV4dC5waGFzZSArIDEgOiBjb250ZXh0LnBoYXNlO1xuICBpbXBUZXJtLm5hbWVkSW1wb3J0cy5mb3JFYWNoKHNwZWNpZmllciA9PiB7XG4gICAgbGV0IG5hbWUgPSBzcGVjaWZpZXIuYmluZGluZy5uYW1lO1xuICAgIGxldCBleHBvcnROYW1lID0gZmluZE5hbWVJbkV4cG9ydHMobmFtZSwgZXhNb2R1bGUuZXhwb3J0RW50cmllcygpKTtcbiAgICBpZiAoZXhwb3J0TmFtZSAhPSBudWxsKSB7XG4gICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuYW1lLnZhbCgpKTtcbiAgICAgIGNvbnRleHQuc3RvcmUuc2V0KG5ld0JpbmRpbmcudG9TdHJpbmcoKSwgbmV3IFZhckJpbmRpbmdUcmFuc2Zvcm0obmFtZSkpO1xuICAgICAgY29udGV4dC5iaW5kaW5ncy5hZGRGb3J3YXJkKG5hbWUsIGV4cG9ydE5hbWUsIG5ld0JpbmRpbmcsIHBoYXNlKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIExpc3QobmFtZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZpbmROYW1lSW5FeHBvcnRzKG5hbWUsIGV4cCkge1xuICBsZXQgZm91bmROYW1lcyA9IGV4cC5yZWR1Y2UoKGFjYywgZSkgPT4ge1xuICAgIGlmIChULmlzRXhwb3J0RnJvbShlKSkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoZS5uYW1lZEV4cG9ydHMucmVkdWNlKChhY2MsIHNwZWNpZmllcikgPT4ge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLmV4cG9ydGVkTmFtZS52YWwoKSA9PT0gbmFtZS52YWwoKSkge1xuICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHNwZWNpZmllci5leHBvcnRlZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBMaXN0KCkpKTtcbiAgICB9IGVsc2UgaWYgKFQuaXNFeHBvcnQoZSkpIHtcbiAgICAgIGlmIChlLmRlY2xhcmF0aW9uLm5hbWUgJiYgZS5kZWNsYXJhdGlvbi5uYW1lLm5hbWUpIHtcbiAgICAgICAgaWYgKGUuZGVjbGFyYXRpb24ubmFtZS5uYW1lLnZhbCgpID09PSBuYW1lLnZhbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoZS5kZWNsYXJhdGlvbi5uYW1lLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChlLmRlY2xhcmF0aW9uLmRlY2xhcmF0b3JzLnJlZHVjZSgoYWNjLCBkZWNsKSA9PiB7XG4gICAgICAgIGlmIChkZWNsLmJpbmRpbmcubmFtZS52YWwoKSA9PT0gbmFtZS52YWwoKSkge1xuICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KGRlY2wuYmluZGluZy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgTGlzdCgpKSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIExpc3QoKSk7XG4gIGFzc2VydChmb3VuZE5hbWVzLnNpemUgPD0gMSwgJ2V4cGVjdGluZyBubyBtb3JlIHRoYW4gMSBtYXRjaGluZyBuYW1lIGluIGV4cG9ydHMnKTtcbiAgcmV0dXJuIGZvdW5kTmFtZXMuZ2V0KDApO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOYW1lcyhpbXBUZXJtLCBuYW1lcykge1xuICBsZXQgbmFtZWRJbXBvcnRzID0gaW1wVGVybS5uYW1lZEltcG9ydHMuZmlsdGVyKHNwZWNpZmllciA9PiAhbmFtZXMuY29udGFpbnMoc3BlY2lmaWVyLmJpbmRpbmcubmFtZSkpO1xuICByZXR1cm4gaW1wVGVybS5leHRlbmQoeyBuYW1lZEltcG9ydHMgfSk7XG59XG5cbi8vIGZ1bmN0aW9uIGJpbmRBbGxTeW50YXhFeHBvcnRzKGV4TW9kdWxlLCB0b1N5bnRoLCBjb250ZXh0KSB7XG4vLyAgIGxldCBwaGFzZSA9IGNvbnRleHQucGhhc2U7XG4vLyAgIGV4TW9kdWxlLmV4cG9ydEVudHJpZXMuZm9yRWFjaChleCA9PiB7XG4vLyAgICAgaWYgKGlzRXhwb3J0U3ludGF4KGV4KSkge1xuLy8gICAgICAgZXguZGVjbGFyYXRpb24uZGVjbGFyYXRvcnMuZm9yRWFjaChkZWNsID0+IHtcbi8vICAgICAgICAgbGV0IG5hbWUgPSBkZWNsLmJpbmRpbmcubmFtZTtcbi8vICAgICAgICAgbGV0IG5ld0JpbmRpbmcgPSBnZW5zeW0obmFtZS52YWwoKSk7XG4vLyAgICAgICAgIGxldCBzdG9yZU5hbWUgPSBleE1vZHVsZS5tb2R1bGVTcGVjaWZpZXIgKyBcIjpcIiArIG5hbWUudmFsKCkgKyBcIjpcIiArIHBoYXNlO1xuLy8gICAgICAgICBsZXQgc3ludGhTdHggPSBTeW50YXguZnJvbUlkZW50aWZpZXIobmFtZS52YWwoKSwgdG9TeW50aCk7XG4vLyAgICAgICAgIGxldCBzdG9yZVN0eCA9IFN5bnRheC5mcm9tSWRlbnRpZmllcihzdG9yZU5hbWUsIHRvU3ludGgpO1xuLy8gICAgICAgICBjb250ZXh0LmJpbmRpbmdzLmFkZEZvcndhcmQoc3ludGhTdHgsIHN0b3JlU3R4LCBuZXdCaW5kaW5nLCBwaGFzZSk7XG4vLyAgICAgICB9KTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy8gfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbkV4cGFuZGVyIGV4dGVuZHMgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IGFueSkge1xuICAgIHN1cGVyKCdleHBhbmQnLCBmYWxzZSk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGV4cGFuZChzdHhsOiBMaXN0PFN5bnRheD4pIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHN0eGwuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIExpc3QocmVzdWx0KTtcbiAgICB9XG4gICAgbGV0IHByZXYgPSBMaXN0KCk7XG4gICAgbGV0IGVuZiA9IG5ldyBFbmZvcmVzdGVyKHN0eGwsIHByZXYsIHRoaXMuY29udGV4dCk7XG5cbiAgICB3aGlsZSAoIWVuZi5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaCh0aGlzLmRpc3BhdGNoKGVuZi5lbmZvcmVzdCgpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpc3QocmVzdWx0KTtcbiAgfVxuXG4gIGV4cGFuZFZhcmlhYmxlRGVjbGFyYXRpb25TdGF0ZW1lbnQodGVybTogUy5WYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHRlcm0uZXh0ZW5kKHtcbiAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLnJlZ2lzdGVyVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uKVxuICAgIH0pO1xuICB9XG5cbiAgZXhwYW5kRnVuY3Rpb25EZWNsYXJhdGlvbih0ZXJtOiBUZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJGdW5jdGlvbk9yQ2xhc3ModGVybSk7XG4gIH1cblxuICAvLyBUT0RPOiB0aGluayBhYm91dCBmdW5jdGlvbiBleHByZXNzaW9uc1xuXG4gIGV4cGFuZEltcG9ydCh0ZXJtOiBUZXJtKSB7XG4gICAgbGV0IHBhdGggPSB0ZXJtLm1vZHVsZVNwZWNpZmllci52YWwoKTtcbiAgICBsZXQgbW9kO1xuICAgIGxldCB2aXNpdG9yID0gbmV3IE1vZHVsZVZpc2l0b3IodGhpcy5jb250ZXh0KTtcbiAgICBpZiAodGVybS5mb3JTeW50YXgpIHtcbiAgICAgIG1vZCA9IHRoaXMuY29udGV4dC5sb2FkZXIuZ2V0KHBhdGgsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5jd2QpO1xuICAgICAgdGhpcy5jb250ZXh0LnN0b3JlID0gdmlzaXRvci52aXNpdChtb2QsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB2aXNpdG9yLmludm9rZShtb2QsIHRoaXMuY29udGV4dC5waGFzZSArIDEsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IHRoaXMuY29udGV4dC5sb2FkZXIuZ2V0KHBhdGgsIHRoaXMuY29udGV4dC5waGFzZSwgdGhpcy5jb250ZXh0LmN3ZCk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcmUgPSB2aXNpdG9yLnZpc2l0KG1vZCwgdGhpcy5jb250ZXh0LnBoYXNlLCB0aGlzLmNvbnRleHQuc3RvcmUpO1xuICAgICAgLy8gdGhpcy5jb250ZXh0LnN0b3JlID0gdGhpcy5jb250ZXh0Lm1vZHVsZXMudmlzaXQobW9kLCB0aGlzLmNvbnRleHQucGhhc2UsIHRoaXMuY29udGV4dC5zdG9yZSk7XG4gICAgfVxuICAgIGxldCBib3VuZE5hbWVzID0gYmluZEltcG9ydHModGVybSwgbW9kLCB0aGlzLmNvbnRleHQpO1xuICAgIHJldHVybiByZW1vdmVOYW1lcyh0ZXJtLCBib3VuZE5hbWVzKTtcbiAgfVxuXG4gIGV4cGFuZEV4cG9ydCh0ZXJtOiBUZXJtKSB7XG4gICAgaWYgKFQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKHRlcm0uZGVjbGFyYXRpb24pIHx8IFQuaXNDbGFzc0RlY2xhcmF0aW9uKHRlcm0uZGVjbGFyYXRpb24pKSB7XG4gICAgICByZXR1cm4gdGVybS5leHRlbmQoe1xuICAgICAgICBkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3RlckZ1bmN0aW9uT3JDbGFzcyh0ZXJtLmRlY2xhcmF0aW9uKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChULmlzVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHRlcm0uZXh0ZW5kKHtcbiAgICAgICAgZGVjbGFyYXRpb246IHRoaXMucmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm0uZGVjbGFyYXRpb24pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICByZWdpc3RlckZ1bmN0aW9uT3JDbGFzcyh0ZXJtOiBUZXJtKSB7XG4gICAgbGV0IHJlZCA9IG5ldyBSZWdpc3RlckJpbmRpbmdzUmVkdWNlcihcbiAgICAgIHRoaXMuY29udGV4dC51c2VTY29wZSxcbiAgICAgIHRoaXMuY29udGV4dC5waGFzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLFxuICAgICAgdGhpcy5jb250ZXh0LmVudlxuICAgICk7XG4gICAgcmV0dXJuIHRlcm0uZXh0ZW5kKHtcbiAgICAgIG5hbWU6IHRlcm0ubmFtZS5yZWR1Y2UocmVkKVxuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm06IFRlcm0pIHtcbiAgICBpZiAodGVybS5raW5kID09PSAnc3ludGF4JyB8fCB0ZXJtLmtpbmQgPT09ICdzeW50YXhyZWMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN5bnRheERlY2xhcmF0aW9uKHRlcm0pO1xuICAgIH1cbiAgICBsZXQgcmVkID0gbmV3IFJlZ2lzdGVyQmluZGluZ3NSZWR1Y2VyKFxuICAgICAgdGhpcy5jb250ZXh0LnVzZVNjb3BlLFxuICAgICAgdGhpcy5jb250ZXh0LnBoYXNlLFxuICAgICAgdGVybS5raW5kID09PSAndmFyJyxcbiAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncyxcbiAgICAgIHRoaXMuY29udGV4dC5lbnZcbiAgICApO1xuICAgIHJldHVybiB0ZXJtLmV4dGVuZCh7XG4gICAgICBkZWNsYXJhdG9yczogdGVybS5kZWNsYXJhdG9ycy5tYXAoZGVjbCA9PiB7XG4gICAgICAgIHJldHVybiBkZWNsLmV4dGVuZCh7XG4gICAgICAgICAgYmluZGluZzogZGVjbC5iaW5kaW5nLnJlZHVjZShyZWQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbih0ZXJtOiBUZXJtKSB7XG4gICAgaWYgKHRlcm0ua2luZCA9PT0gJ3N5bnRheCcpIHtcbiAgICAgIC8vIHN5bnRheCBpZF57YSwgYn0gPSA8aW5pdD5ee2EsIGJ9XG4gICAgICAvLyAtPlxuICAgICAgLy8gc3ludGF4cmVjIGlkXnthLGIsY30gPSBmdW5jdGlvbigpIHsgcmV0dXJuIDw8aWRee2F9Pj4gfVxuICAgICAgLy8gc3ludGF4cmVjIGlkXnthLGJ9ID0gPGluaXQ+XnthLGIsY31cbiAgICAgIGxldCBzY29wZSA9IGZyZXNoU2NvcGUoJ25vbnJlYycpO1xuICAgICAgbGV0IHNjb3BlUmVkdWNlciA9IG5ldyBTY29wZVJlZHVjZXIoW3sgc2NvcGU6IHNjb3BlLCBwaGFzZTogQUxMX1BIQVNFUywgZmxpcDogZmFsc2UgfV0sIHRoaXMuY29udGV4dC5iaW5kaW5ncyk7XG4gICAgICB0ZXJtID0gdGVybS5leHRlbmQoe1xuICAgICAgICBkZWNsYXJhdG9yczogdGVybS5kZWNsYXJhdG9ycy5tYXAoZGVjbCA9PiB7XG4gICAgICAgICAgbGV0IG5hbWUgPSBkZWNsLmJpbmRpbmcubmFtZTtcbiAgICAgICAgICBsZXQgbmFtZUFkZGVkID0gbmFtZS5hZGRTY29wZShzY29wZSwgdGhpcy5jb250ZXh0LmJpbmRpbmdzLCBBTExfUEhBU0VTKTtcbiAgICAgICAgICBsZXQgbmFtZVJlbW92ZWQgPSBuYW1lLnJlbW92ZVNjb3BlKHRoaXMuY29udGV4dC5jdXJyZW50U2NvcGVbdGhpcy5jb250ZXh0LmN1cnJlbnRTY29wZS5sZW5ndGggLSAxXSwgdGhpcy5jb250ZXh0LnBoYXNlKTtcbiAgICAgICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShuYW1lLnZhbCgpKTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MuYWRkRm9yd2FyZChuYW1lQWRkZWQsIG5hbWVSZW1vdmVkLCBuZXdCaW5kaW5nLCB0aGlzLmNvbnRleHQucGhhc2UpO1xuICAgICAgICAgIHJldHVybiBkZWNsLmV4dGVuZCh7XG4gICAgICAgICAgICBpbml0OiBkZWNsLmluaXQucmVkdWNlKHNjb3BlUmVkdWNlcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBmb3Igc3ludGF4IGRlY2xhcmF0aW9ucyB3ZSBuZWVkIHRvIGxvYWQgdGhlIGNvbXBpbGV0aW1lIHZhbHVlXG4gICAgLy8gaW50byB0aGUgZW52aXJvbm1lbnRcbiAgICByZXR1cm4gdGVybS5leHRlbmQoe1xuICAgICAgZGVjbGFyYXRvcnM6IHRlcm0uZGVjbGFyYXRvcnMubWFwKGRlY2wgPT4ge1xuICAgICAgICAvLyBlYWNoIGNvbXBpbGV0aW1lIHZhbHVlIG5lZWRzIHRvIGJlIGV4cGFuZGVkIHdpdGggYSBmcmVzaFxuICAgICAgICAvLyBlbnZpcm9ubWVudCBhbmQgaW4gdGhlIG5leHQgaGlnaGVyIHBoYXNlXG4gICAgICAgIGxldCBzeW50YXhFeHBhbmRlciA9IG5ldyBUZXJtRXhwYW5kZXIoXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtcbiAgICAgICAgICBwaGFzZTogdGhpcy5jb250ZXh0LnBoYXNlICsgMSxcbiAgICAgICAgICBlbnY6IG5ldyBFbnYoKSxcbiAgICAgICAgICBzdG9yZTogdGhpcy5jb250ZXh0LnN0b3JlXG4gICAgICAgIH0pKTtcblxuICAgICAgICBsZXQgaW5pdCA9IHN5bnRheEV4cGFuZGVyLmV4cGFuZChkZWNsLmluaXQpO1xuICAgICAgICBsZXQgdmFsID0gZXZhbENvbXBpbGV0aW1lVmFsdWUoaW5pdCwgXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtcbiAgICAgICAgICBwaGFzZTogdGhpcy5jb250ZXh0LnBoYXNlICsgMVxuICAgICAgICB9KSk7XG4gICAgICAgIGxldCByZWQgPSBuZXcgUmVnaXN0ZXJTeW50YXhCaW5kaW5nc1JlZHVjZXIoXG4gICAgICAgICAgdGhpcy5jb250ZXh0LnVzZVNjb3BlLFxuICAgICAgICAgIHRoaXMuY29udGV4dC5waGFzZSxcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZGluZ3MsXG4gICAgICAgICAgdGhpcy5jb250ZXh0LmVudixcbiAgICAgICAgICB2YWwpO1xuICAgICAgICByZXR1cm4gZGVjbC5leHRlbmQoeyBiaW5kaW5nOiBkZWNsLmJpbmRpbmcucmVkdWNlKHJlZCksIGluaXQgfSk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVnaXN0ZXJTeW50YXhEZWNsYXJhdG9yKHRlcm0pIHtcbiAgLy9cbiAgLy8gfVxufVxuIl19

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _loadSyntax = __webpack_require__(52);

	var _terms = __webpack_require__(48);

	var T = _interopRequireWildcard(_terms);

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	var _symbol = __webpack_require__(43);

	var _transforms = __webpack_require__(45);

	var _hygieneUtils = __webpack_require__(69);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	exports.default = class {

	  constructor(context) {
	    this.context = context;
	  }

	  visit(mod, phase, store) {
	    // TODO: recursively visit imports
	    mod.items.forEach(term => {
	      if (T.isSyntaxDeclarationStatement(term)) {
	        this.registerSyntaxDeclaration(term.declaration, phase, store);
	      } else if (term instanceof S.Export && term.declaration instanceof S.VariableDeclaration && term.declaration.kind === 'syntax') {
	        this.registerSyntaxDeclaration(term.declaration, phase, store);
	      }
	    });
	    return store;
	  }

	  invoke(mod, phase, store) {
	    // TODO: recursively visit imports
	    let body = mod.runtimeItems().map(term => {
	      if (T.isVariableDeclarationStatement(term)) {
	        this.registerVariableDeclaration(term.declaration, phase, store);
	      } else if (T.isFunctionDeclaration(term)) {
	        this.registerFunctionOrClass(term, phase, store);
	      }
	      return term;
	    });
	    (0, _loadSyntax.evalRuntimeValues)(body, _.merge(this.context, {
	      store, phase
	    }));
	    return store;
	  }

	  registerSyntaxDeclaration(term, phase, store) {
	    term.declarators.forEach(decl => {
	      let val = (0, _loadSyntax.evalCompiletimeValue)(decl.init, _.merge(this.context, {
	        phase: phase + 1, store
	      }));

	      (0, _hygieneUtils.collectBindings)(decl.binding).forEach(stx => {
	        if (phase !== 0) {
	          // phase 0 bindings extend the binding map during compilation
	          let newBinding = (0, _symbol.gensym)(stx.val());
	          this.context.bindings.add(stx, {
	            binding: newBinding,
	            phase: phase,
	            skipDup: false
	          });
	        }
	        let resolvedName = stx.resolve(phase);
	        store.set(resolvedName, new _transforms.CompiletimeTransform(val));
	      });
	    });
	  }

	  registerVariableDeclaration(term, phase, store) {
	    term.declarators.forEach(decl => {
	      (0, _hygieneUtils.collectBindings)(decl.binding).forEach(stx => {
	        if (phase !== 0) {
	          // phase 0 bindings extend the binding map during compilation
	          let newBinding = (0, _symbol.gensym)(stx.val());
	          this.context.bindings.add(stx, {
	            binding: newBinding,
	            phase: phase,
	            skipDup: term.kind === 'var'
	          });
	        }
	        let resolvedName = stx.resolve(phase);
	        store.set(resolvedName, new _transforms.VarBindingTransform(stx));
	      });
	    });
	  }

	  registerFunctionOrClass(term, phase, store) {
	    (0, _hygieneUtils.collectBindings)(term.name).forEach(stx => {
	      if (phase !== 0) {
	        let newBinding = (0, _symbol.gensym)(stx.val());
	        this.context.bindings.add(stx, {
	          binding: newBinding,
	          phase: phase,
	          skipDup: false
	        });
	      }
	      let resolvedName = stx.resolve(phase);
	      store.set(resolvedName, new _transforms.VarBindingTransform(stx));
	    });
	  }

	};
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2R1bGUtdmlzaXRvci5qcyJdLCJuYW1lcyI6WyJUIiwiXyIsIlMiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJ2aXNpdCIsIm1vZCIsInBoYXNlIiwic3RvcmUiLCJpdGVtcyIsImZvckVhY2giLCJ0ZXJtIiwiaXNTeW50YXhEZWNsYXJhdGlvblN0YXRlbWVudCIsInJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24iLCJkZWNsYXJhdGlvbiIsIkV4cG9ydCIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJraW5kIiwiaW52b2tlIiwiYm9keSIsInJ1bnRpbWVJdGVtcyIsIm1hcCIsImlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCIsInJlZ2lzdGVyVmFyaWFibGVEZWNsYXJhdGlvbiIsImlzRnVuY3Rpb25EZWNsYXJhdGlvbiIsInJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzIiwibWVyZ2UiLCJkZWNsYXJhdG9ycyIsImRlY2wiLCJ2YWwiLCJpbml0IiwiYmluZGluZyIsInN0eCIsIm5ld0JpbmRpbmciLCJiaW5kaW5ncyIsImFkZCIsInNraXBEdXAiLCJyZXNvbHZlZE5hbWUiLCJyZXNvbHZlIiwic2V0IiwibmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7O0FBQ0E7O0lBQVlBLEM7O0FBQ1o7O0lBQVlDLEM7O0FBQ1o7O0lBQVlDLEM7O0FBQ1o7O0FBQ0E7O0FBQ0E7Ozs7a0JBSWUsTUFBTTs7QUFJbkJDLGNBQVlDLE9BQVosRUFBOEI7QUFDNUIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRURDLFFBQU1DLEdBQU4sRUFBZ0JDLEtBQWhCLEVBQTRCQyxLQUE1QixFQUF3QztBQUN0QztBQUNBRixRQUFJRyxLQUFKLENBQVVDLE9BQVYsQ0FBa0JDLFFBQVE7QUFDeEIsVUFBSVgsRUFBRVksNEJBQUYsQ0FBK0JELElBQS9CLENBQUosRUFBMEM7QUFDeEMsYUFBS0UseUJBQUwsQ0FBK0JGLEtBQUtHLFdBQXBDLEVBQWlEUCxL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QUMsY0FBTStCLEdBQU4sQ0FBVUYsWUFBVixFQUF3QixvQ0FBd0JMLEdBQXhCLENBQXhCO0FBQ0QsT0FYRDtBQVlELEtBYkQ7QUFjRDs7QUFFRFAsMEJBQXdCZCxJQUF4QixFQUFtQ0osS0FBbkMsRUFBK0NDLEtBQS9DLEVBQTJEO0FBQ3pELHVDQUFnQkcsS0FBSzZCLElBQXJCLEVBQTJCOUIsT0FBM0IsQ0FBbUNzQixPQUFPO0FBQ3hDLFVBQUl6QixVQUFVLENBQWQsRUFBaUI7QUFDZixZQUFJMEIsYUFBYSxvQkFBT0QsSUFBSUgsR0FBSixFQUFQLENBQWpCO0FBQ0EsYUFBS3pCLE9BQUwsQ0FBYThCLFFBQWIsQ0FBc0JDLEdBQXRCLENBQTBCSCxHQUExQixFQUErQjtBQUM3QkQsbUJBQVNFLFVBRG9CO0FBRTdCMUIsaUJBQU9BLEtBRnNCO0FBRzdCNkIsbUJBQVM7QUFIb0IsU0FBL0I7QUFLRDtBQUNELFVBQUlDLGVBQWVMLElBQUlNLE9BQUosQ0FBWS9CLEtBQVosQ0FBbkI7QUFDQUMsWUFBTStCLEdBQU4sQ0FBVUYsWUFBVixFQUF3QixvQ0FBd0JMLEdBQXhCLENBQXhCO0FBQ0QsS0FYRDtBQVlEOztBQXZGa0IsQyIsImZpbGUiOiJtb2R1bGUtdmlzaXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBldmFsQ29tcGlsZXRpbWVWYWx1ZSwgZXZhbFJ1bnRpbWVWYWx1ZXMgfSBmcm9tICcuL2xvYWQtc3ludGF4JztcbmltcG9ydCAqIGFzIFQgZnJvbSAnLi90ZXJtcyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ3JhbWRhJztcbmltcG9ydCAqIGFzIFMgZnJvbSAnc3dlZXQtc3BlYyc7XG5pbXBvcnQgeyBnZW5zeW0gfSBmcm9tICcuL3N5bWJvbCc7XG5pbXBvcnQgeyBWYXJCaW5kaW5nVHJhbnNmb3JtLCBDb21waWxldGltZVRyYW5zZm9ybSB9IGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5pbXBvcnQgeyBjb2xsZWN0QmluZGluZ3MgfSBmcm9tICcuL2h5Z2llbmUtdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7IENvbnRleHQgfSBmcm9tICcuL3N3ZWV0LWxvYWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcblxuICBjb250ZXh0OiBDb250ZXh0O1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgdmlzaXQobW9kOiBhbnksIHBoYXNlOiBhbnksIHN0b3JlOiBhbnkpIHtcbiAgICAvLyBUT0RPOiByZWN1cnNpdmVseSB2aXNpdCBpbXBvcnRzXG4gICAgbW9kLml0ZW1zLmZvckVhY2godGVybSA9PiB7XG4gICAgICBpZiAoVC5pc1N5bnRheERlY2xhcmF0aW9uU3RhdGVtZW50KHRlcm0pKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uLCBwaGFzZSwgc3RvcmUpO1xuICAgICAgfSBlbHNlIGlmICh0ZXJtIGluc3RhbmNlb2YgUy5FeHBvcnQgJiYgdGVybS5kZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFMuVmFyaWFibGVEZWNsYXJhdGlvbiAmJiB0ZXJtLmRlY2xhcmF0aW9uLmtpbmQgPT09ICdzeW50YXgnKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTeW50YXhEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uLCBwaGFzZSwgc3RvcmUpXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9XG5cbiAgaW52b2tlKG1vZDogYW55LCBwaGFzZTogYW55LCBzdG9yZTogYW55KSB7XG4gICAgLy8gVE9ETzogcmVjdXJzaXZlbHkgdmlzaXQgaW1wb3J0c1xuICAgIGxldCBib2R5ID0gbW9kLnJ1bnRpbWVJdGVtcygpLm1hcCh0ZXJtID0+IHtcbiAgICAgIGlmIChULmlzVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudCh0ZXJtKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFyaWFibGVEZWNsYXJhdGlvbih0ZXJtLmRlY2xhcmF0aW9uLCBwaGFzZSwgc3RvcmUpO1xuICAgICAgfSBlbHNlIGlmIChULmlzRnVuY3Rpb25EZWNsYXJhdGlvbih0ZXJtKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25PckNsYXNzKHRlcm0sIHBoYXNlLCBzdG9yZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9KTtcbiAgICBldmFsUnVudGltZVZhbHVlcyhib2R5LCBfLm1lcmdlKHRoaXMuY29udGV4dCwge1xuICAgICAgc3RvcmUsIHBoYXNlXG4gICAgfSkpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfVxuXG4gIHJlZ2lzdGVyU3ludGF4RGVjbGFyYXRpb24odGVybTogYW55LCBwaGFzZTogYW55LCBzdG9yZTogYW55KSB7XG4gICAgdGVybS5kZWNsYXJhdG9ycy5mb3JFYWNoKGRlY2wgPT4ge1xuICAgICAgbGV0IHZhbCA9IGV2YWxDb21waWxldGltZVZhbHVlKGRlY2wuaW5pdCwgXy5tZXJnZSh0aGlzLmNvbnRleHQsIHtcbiAgICAgICAgcGhhc2U6IHBoYXNlICsgMSwgc3RvcmVcbiAgICAgIH0pKTtcblxuICAgICAgY29sbGVjdEJpbmRpbmdzKGRlY2wuYmluZGluZykuZm9yRWFjaChzdHggPT4ge1xuICAgICAgICBpZiAocGhhc2UgIT09IDApIHsgLy8gcGhhc2UgMCBiaW5kaW5ncyBleHRlbmQgdGhlIGJpbmRpbmcgbWFwIGR1cmluZyBjb21waWxhdGlvblxuICAgICAgICAgIGxldCBuZXdCaW5kaW5nID0gZ2Vuc3ltKHN0eC52YWwoKSk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChzdHgsIHtcbiAgICAgICAgICAgIGJpbmRpbmc6IG5ld0JpbmRpbmcsXG4gICAgICAgICAgICBwaGFzZTogcGhhc2UsXG4gICAgICAgICAgICBza2lwRHVwOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNvbHZlZE5hbWUgPSBzdHgucmVzb2x2ZShwaGFzZSk7XG4gICAgICAgIHN0b3JlLnNldChyZXNvbHZlZE5hbWUsIG5ldyBDb21waWxldGltZVRyYW5zZm9ybSh2YWwpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm06IGFueSwgcGhhc2U6IGFueSwgc3RvcmU6IGFueSkge1xuICAgIHRlcm0uZGVjbGFyYXRvcnMuZm9yRWFjaChkZWNsID0+IHtcbiAgICAgIGNvbGxlY3RCaW5kaW5ncyhkZWNsLmJpbmRpbmcpLmZvckVhY2goc3R4ID0+IHtcbiAgICAgICAgaWYgKHBoYXNlICE9PSAwKSB7IC8vIHBoYXNlIDAgYmluZGluZ3MgZXh0ZW5kIHRoZSBiaW5kaW5nIG1hcCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAgICAgICBsZXQgbmV3QmluZGluZyA9IGdlbnN5bShzdHgudmFsKCkpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5iaW5kaW5ncy5hZGQoc3R4LCB7XG4gICAgICAgICAgICBiaW5kaW5nOiBuZXdCaW5kaW5nLFxuICAgICAgICAgICAgcGhhc2U6IHBoYXNlLFxuICAgICAgICAgICAgc2tpcER1cDogdGVybS5raW5kID09PSAndmFyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNvbHZlZE5hbWUgPSBzdHgucmVzb2x2ZShwaGFzZSk7XG4gICAgICAgIHN0b3JlLnNldChyZXNvbHZlZE5hbWUsIG5ldyBWYXJCaW5kaW5nVHJhbnNmb3JtKHN0eCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZWdpc3RlckZ1bmN0aW9uT3JDbGFzcyh0ZXJtOiBhbnksIHBoYXNlOiBhbnksIHN0b3JlOiBhbnkpIHtcbiAgICBjb2xsZWN0QmluZGluZ3ModGVybS5uYW1lKS5mb3JFYWNoKHN0eCA9PiB7XG4gICAgICBpZiAocGhhc2UgIT09IDApIHtcbiAgICAgICAgbGV0IG5ld0JpbmRpbmcgPSBnZW5zeW0oc3R4LnZhbCgpKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChzdHgsIHtcbiAgICAgICAgICBiaW5kaW5nOiBuZXdCaW5kaW5nLFxuICAgICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgICBza2lwRHVwOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCByZXNvbHZlZE5hbWUgPSBzdHgucmVzb2x2ZShwaGFzZSk7XG4gICAgICBzdG9yZS5zZXQocmVzb2x2ZWROYW1lLCBuZXcgVmFyQmluZGluZ1RyYW5zZm9ybShzdHgpKTtcbiAgICB9KTtcbiAgfVxuXG59XG4iXX0=

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CollectBindingSyntax = undefined;
	exports.collectBindings = collectBindings;

	var _immutable = __webpack_require__(10);

	var _astDispatcher = __webpack_require__(66);

	var _astDispatcher2 = _interopRequireDefault(_astDispatcher);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	class CollectBindingSyntax extends _astDispatcher2.default {
	  constructor() {
	    super('collect', true);
	    this.names = (0, _immutable.List)();
	  }

	  // registerSyntax(stx) {
	  //   let newBinding = gensym(stx.val());
	  //   this.context.bindings.add(stx, {
	  //     binding: newBinding,
	  //     phase: this.context.phase,
	  //     // skip dup because js allows variable redeclarations
	  //     // (technically only for `var` but we can let later stages of the pipeline
	  //     // handle incorrect redeclarations of `const` and `let`)
	  //     skipDup: true
	  //   });
	  //   return stx;
	  // }

	  collect(term) {
	    return this.dispatch(term);
	  }

	  collectBindingIdentifier(term) {
	    return this.names.concat(term.name);
	  }

	  collectBindingPropertyIdentifier(term) {
	    return this.collect(term.binding);
	  }

	  collectBindingPropertyProperty(term) {
	    return this.collect(term.binding);
	  }

	  collectArrayBinding(term) {
	    let restElement = null;
	    if (term.restElement != null) {
	      restElement = this.collect(term.restElement);
	    }
	    return this.names.concat(restElement).concat(term.elements.filter(el => el != null).flatMap(el => this.collect(el)));
	  }

	  collectObjectBinding() {
	    // return term.properties.flatMap(prop => this.collect(prop));
	    return (0, _immutable.List)();
	  }

	  // registerVariableDeclaration(term) {
	  //   let declarators = term.declarators.map(decl => {
	  //     return decl.extend({
	  //       binding: this.register(decl.binding)
	  //     });
	  //   });
	  //   return term.extend({ declarators });
	  // }
	  //
	  // registerFunctionDeclaration(term) {
	  //   return term.extend({
	  //     name: this.register(term.name)
	  //   });
	  // }
	  //
	  // registerExport(term) {
	  //   return term.extend({
	  //     declaration: this.register(term.declaration)
	  //   });
	  // }
	}

	exports.CollectBindingSyntax = CollectBindingSyntax;
	function collectBindings(term) {
	  return new CollectBindingSyntax().collect(term);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oeWdpZW5lLXV0aWxzLmpzIl0sIm5hbWVzIjpbImNvbGxlY3RCaW5kaW5ncyIsIkNvbGxlY3RCaW5kaW5nU3ludGF4IiwiY29uc3RydWN0b3IiLCJuYW1lcyIsImNvbGxlY3QiLCJ0ZXJtIiwiZGlzcGF0Y2giLCJjb2xsZWN0QmluZGluZ0lkZW50aWZpZXIiLCJjb25jYXQiLCJuYW1lIiwiY29sbGVjdEJpbmRpbmdQcm9wZXJ0eUlkZW50aWZpZXIiLCJiaW5kaW5nIiwiY29sbGVjdEJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5IiwiY29sbGVjdEFycmF5QmluZGluZyIsInJlc3RFbGVtZW50IiwiZWxlbWVudHMiLCJmaWx0ZXIiLCJlbCIsImZsYXRNYXAiLCJjb2xsZWN0T2JqZWN0QmluZGluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O1FBNkVnQkEsZSxHQUFBQSxlOztBQTdFaEI7O0FBRUE7Ozs7OztBQUVPLE1BQU1DLG9CQUFOLGlDQUFpRDtBQUN0REMsZ0JBQWM7QUFDWixVQUFNLFNBQU4sRUFBaUIsSUFBakI7QUFDQSxTQUFLQyxLQUFMLEdBQWEsc0JBQWI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUFDLFVBQVFDLElBQVIsRUFBYztBQUNaLFdBQU8sS0FBS0MsUUFBTCxDQUFjRCxJQUFkLENBQVA7QUFDRDs7QUFFREUsMkJBQXlCRixJQUF6QixFQUErQjtBQUM3QixXQUFPLEtBQUtGLEtBQUwsQ0FBV0ssTUFBWCxDQUFrQkgsS0FBS0ksSUFBdkIsQ0FBUDtBQUNEOztBQUVEQyxtQ0FBaUNMLElBQWpDLEVBQXVDO0FBQ3JDLFdBQU8sS0FBS0QsT0FBTCxDQUFhQyxLQUFLTSxPQUFsQixDQUFQO0FBQ0Q7O0FBRURDLGlDQUFnQ1AsSUFBaEMsRUFBc0M7QUFDcEMsV0FBTyxLQUFLRCxPQUFMLENBQWFDLEtBQUtNLE9BQWxCLENBQVA7QUFDRDs7QUFFREUsc0JBQXFCUixJQUFyQixFQUEyQjtBQUN6QixRQUFJUyxjQUFjLElBQWxCO0FBQ0EsUUFBSVQsS0FBS1MsV0FBTCxJQUFvQixJQUF4QixFQUE4QjtBQUM1QkEsb0JBQWMsS0FBS1YsT0FBTCxDQUFhQyxLQUFLUyxXQUFsQixDQUFkO0FBQ0Q7QUFDRCxXQUFPLEtBQUtYLEtBQUwsQ0FBV0ssTUFBWCxDQUFrQk0sV0FBbEIsRUFBK0JOLE1BQS9CLENBQ0xILEtBQUtVLFFBQUwsQ0FBY0MsTUFBZCxDQUFxQkMsTUFBTUEsTUFBTSxJQUFqQyxFQUNjQyxPQURkLENBQ3NCRCxNQUFNLEtBQUtiLE9BQUwsQ0FBYWEsRUFBYixDQUQ1QixDQURLLENBQVA7QUFJRDs7QUFFREUseUJBQXdCO0FBQ3RCO0FBQ0EsV0FBTyxzQkFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0RXNEOztRQUEzQ2xCLG9CLEdBQUFBLG9CO0FBeUVOLFNBQVNELGVBQVQsQ0FBeUJLLElBQXpCLEVBQStCO0FBQ3BDLFNBQU8sSUFBSUosb0JBQUosR0FBMkJHLE9BQTNCLENBQW1DQyxJQUFuQyxDQUFQO0FBQ0QiLCJmaWxlIjoiaHlnaWVuZS11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuXG5pbXBvcnQgQVNURGlzcGF0Y2hlciBmcm9tICcuL2FzdC1kaXNwYXRjaGVyJztcblxuZXhwb3J0IGNsYXNzIENvbGxlY3RCaW5kaW5nU3ludGF4IGV4dGVuZHMgQVNURGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdjb2xsZWN0JywgdHJ1ZSk7XG4gICAgdGhpcy5uYW1lcyA9IExpc3QoKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyU3ludGF4KHN0eCkge1xuICAvLyAgIGxldCBuZXdCaW5kaW5nID0gZ2Vuc3ltKHN0eC52YWwoKSk7XG4gIC8vICAgdGhpcy5jb250ZXh0LmJpbmRpbmdzLmFkZChzdHgsIHtcbiAgLy8gICAgIGJpbmRpbmc6IG5ld0JpbmRpbmcsXG4gIC8vICAgICBwaGFzZTogdGhpcy5jb250ZXh0LnBoYXNlLFxuICAvLyAgICAgLy8gc2tpcCBkdXAgYmVjYXVzZSBqcyBhbGxvd3MgdmFyaWFibGUgcmVkZWNsYXJhdGlvbnNcbiAgLy8gICAgIC8vICh0ZWNobmljYWxseSBvbmx5IGZvciBgdmFyYCBidXQgd2UgY2FuIGxldCBsYXRlciBzdGFnZXMgb2YgdGhlIHBpcGVsaW5lXG4gIC8vICAgICAvLyBoYW5kbGUgaW5jb3JyZWN0IHJlZGVjbGFyYXRpb25zIG9mIGBjb25zdGAgYW5kIGBsZXRgKVxuICAvLyAgICAgc2tpcER1cDogdHJ1ZVxuICAvLyAgIH0pO1xuICAvLyAgIHJldHVybiBzdHg7XG4gIC8vIH1cblxuICBjb2xsZWN0KHRlcm0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh0ZXJtKTtcbiAgfVxuXG4gIGNvbGxlY3RCaW5kaW5nSWRlbnRpZmllcih0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuY29uY2F0KHRlcm0ubmFtZSk7XG4gIH1cblxuICBjb2xsZWN0QmluZGluZ1Byb3BlcnR5SWRlbnRpZmllcih0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCh0ZXJtLmJpbmRpbmcpO1xuICB9XG5cbiAgY29sbGVjdEJpbmRpbmdQcm9wZXJ0eVByb3BlcnR5ICh0ZXJtKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdCh0ZXJtLmJpbmRpbmcpO1xuICB9XG5cbiAgY29sbGVjdEFycmF5QmluZGluZyAodGVybSkge1xuICAgIGxldCByZXN0RWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRlcm0ucmVzdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgcmVzdEVsZW1lbnQgPSB0aGlzLmNvbGxlY3QodGVybS5yZXN0RWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWVzLmNvbmNhdChyZXN0RWxlbWVudCkuY29uY2F0KFxuICAgICAgdGVybS5lbGVtZW50cy5maWx0ZXIoZWwgPT4gZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAuZmxhdE1hcChlbCA9PiB0aGlzLmNvbGxlY3QoZWwpKVxuICAgICk7XG4gIH1cblxuICBjb2xsZWN0T2JqZWN0QmluZGluZyAoKSB7XG4gICAgLy8gcmV0dXJuIHRlcm0ucHJvcGVydGllcy5mbGF0TWFwKHByb3AgPT4gdGhpcy5jb2xsZWN0KHByb3ApKTtcbiAgICByZXR1cm4gTGlzdCgpO1xuICB9XG5cbiAgLy8gcmVnaXN0ZXJWYXJpYWJsZURlY2xhcmF0aW9uKHRlcm0pIHtcbiAgLy8gICBsZXQgZGVjbGFyYXRvcnMgPSB0ZXJtLmRlY2xhcmF0b3JzLm1hcChkZWNsID0+IHtcbiAgLy8gICAgIHJldHVybiBkZWNsLmV4dGVuZCh7XG4gIC8vICAgICAgIGJpbmRpbmc6IHRoaXMucmVnaXN0ZXIoZGVjbC5iaW5kaW5nKVxuICAvLyAgICAgfSk7XG4gIC8vICAgfSk7XG4gIC8vICAgcmV0dXJuIHRlcm0uZXh0ZW5kKHsgZGVjbGFyYXRvcnMgfSk7XG4gIC8vIH1cbiAgLy9cbiAgLy8gcmVnaXN0ZXJGdW5jdGlvbkRlY2xhcmF0aW9uKHRlcm0pIHtcbiAgLy8gICByZXR1cm4gdGVybS5leHRlbmQoe1xuICAvLyAgICAgbmFtZTogdGhpcy5yZWdpc3Rlcih0ZXJtLm5hbWUpXG4gIC8vICAgfSk7XG4gIC8vIH1cbiAgLy9cbiAgLy8gcmVnaXN0ZXJFeHBvcnQodGVybSkge1xuICAvLyAgIHJldHVybiB0ZXJtLmV4dGVuZCh7XG4gIC8vICAgICBkZWNsYXJhdGlvbjogdGhpcy5yZWdpc3Rlcih0ZXJtLmRlY2xhcmF0aW9uKVxuICAvLyAgIH0pO1xuICAvLyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0QmluZGluZ3ModGVybSkge1xuICByZXR1cm4gbmV3IENvbGxlY3RCaW5kaW5nU3ludGF4KCkuY29sbGVjdCh0ZXJtKTtcbn1cbiJdfQ==

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ramda = __webpack_require__(18);

	var _ = _interopRequireWildcard(_ramda);

	var _sweetSpec = __webpack_require__(41);

	var S = _interopRequireWildcard(_sweetSpec);

	var _codegen = __webpack_require__(71);

	var _codegen2 = _interopRequireDefault(_codegen);

	var _immutable = __webpack_require__(10);

	var _sweetToShiftReducer = __webpack_require__(63);

	var _sweetToShiftReducer2 = _interopRequireDefault(_sweetToShiftReducer);

	var _terms = __webpack_require__(48);

	var T = _interopRequireWildcard(_terms);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	class SweetModule {

	  constructor(items) {
	    this.items = items;
	  }

	  runtimeItems() {
	    return this.items.filter(_.complement(T.isCompiletimeStatement));
	  }

	  compiletimeItems() {
	    return this.items.filter(T.isCompiletimeStatement);
	  }

	  importEntries() {
	    return this.items.filter(T.isImportDeclaration);
	  }

	  exportEntries() {
	    return this.items.filter(T.isExportDeclaration);
	  }

	  parse() {
	    return new S.Module({
	      items: this.items,
	      directives: (0, _immutable.List)()
	    }).reduce(new _sweetToShiftReducer2.default(0));
	  }

	  codegen() {
	    return (0, _codegen2.default)(this.parse()).code;
	  }
	}
	exports.default = SweetModule;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zd2VldC1tb2R1bGUuanMiXSwibmFtZXMiOlsiXyIsIlMiLCJUIiwiU3dlZXRNb2R1bGUiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwicnVudGltZUl0ZW1zIiwiZmlsdGVyIiwiY29tcGxlbWVudCIsImlzQ29tcGlsZXRpbWVTdGF0ZW1lbnQiLCJjb21waWxldGltZUl0ZW1zIiwiaW1wb3J0RW50cmllcyIsImlzSW1wb3J0RGVjbGFyYXRpb24iLCJleHBvcnRFbnRyaWVzIiwiaXNFeHBvcnREZWNsYXJhdGlvbiIsInBhcnNlIiwiTW9kdWxlIiwiZGlyZWN0aXZlcyIsInJlZHVjZSIsImNvZGVnZW4iLCJjb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7SUFBWUEsQzs7QUFDWjs7SUFBa0JDLEM7O0FBQ2xCOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBWUMsQzs7Ozs7O0FBR0csTUFBTUMsV0FBTixDQUFrQjs7QUFHL0JDLGNBQVlDLEtBQVosRUFBK0I7QUFDN0IsU0FBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0Q7O0FBRURDLGlCQUFlO0FBQ2IsV0FBTyxLQUFLRCxLQUFMLENBQVdFLE1BQVgsQ0FBa0JQLEVBQUVRLFVBQUYsQ0FBYU4sRUFBRU8sc0JBQWYsQ0FBbEIsQ0FBUDtBQUNEOztBQUVEQyxxQkFBbUI7QUFDakIsV0FBTyxLQUFLTCxLQUFMLENBQVdFLE1BQVgsQ0FBa0JMLEVBQUVPLHNCQUFwQixDQUFQO0FBQ0Q7O0FBRURFLGtCQUFnQjtBQUNkLFdBQU8sS0FBS04sS0FBTCxDQUFXRSxNQUFYLENBQWtCTCxFQUFFVSxtQkFBcEIsQ0FBUDtBQUNEOztBQUVEQyxrQkFBZ0I7QUFDZCxXQUFPLEtBQUtSLEtBQUwsQ0FBV0UsTUFBWCxDQUFrQkwsRUFBRVksbUJBQXBCLENBQVA7QUFDRDs7QUFFREMsVUFBUTtBQUNOLFdBQU8sSUFBSWQsRUFBRWUsTUFBTixDQUFhO0FBQ2xCWCxhQUFPLEtBQUtBLEtBRE07QUFFbEJZLGtCQUFZO0FBRk0sS0FBYixFQUdKQyxNQUhJLENBR0csa0NBQXdCLENBQXhCLENBSEgsQ0FBUDtBQUlEOztBQUVEQyxZQUFVO0FBQ1IsV0FBTyx1QkFBUSxLQUFLSixLQUFMLEVBQVIsRUFBc0JLLElBQTdCO0FBQ0Q7QUFoQzhCO2tCQUFaakIsVyIsImZpbGUiOiJzd2VldC1tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0ICogYXMgXyBmcm9tICdyYW1kYSc7XG5pbXBvcnQgVGVybSwgKiBhcyBTIGZyb20gJ3N3ZWV0LXNwZWMnO1xuaW1wb3J0IGNvZGVnZW4gZnJvbSAnLi9jb2RlZ2VuJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IFN3ZWV0VG9TaGlmdFJlZHVjZXIgZnJvbSAnLi9zd2VldC10by1zaGlmdC1yZWR1Y2VyLmpzJztcbmltcG9ydCAqIGFzIFQgZnJvbSAnLi90ZXJtcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dlZXRNb2R1bGUge1xuICBpdGVtczogTGlzdDxUZXJtPjtcblxuICBjb25zdHJ1Y3RvcihpdGVtczogTGlzdDxUZXJtPikge1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgfVxuXG4gIHJ1bnRpbWVJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoXy5jb21wbGVtZW50KFQuaXNDb21waWxldGltZVN0YXRlbWVudCkpO1xuICB9XG5cbiAgY29tcGlsZXRpbWVJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoVC5pc0NvbXBpbGV0aW1lU3RhdGVtZW50KTtcbiAgfVxuXG4gIGltcG9ydEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKFQuaXNJbXBvcnREZWNsYXJhdGlvbik7XG4gIH1cblxuICBleHBvcnRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihULmlzRXhwb3J0RGVjbGFyYXRpb24pO1xuICB9XG5cbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBTLk1vZHVsZSh7XG4gICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgIGRpcmVjdGl2ZXM6IExpc3QoKVxuICAgIH0pLnJlZHVjZShuZXcgU3dlZXRUb1NoaWZ0UmVkdWNlcigwKSk7XG4gIH1cblxuICBjb2RlZ2VuKCkge1xuICAgIHJldHVybiBjb2RlZ2VuKHRoaXMucGFyc2UoKSkuY29kZTtcbiAgfVxufVxuIl19

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = codegen;

	var _shiftCodegen = __webpack_require__(53);

	var _shiftCodegen2 = _interopRequireDefault(_shiftCodegen);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function codegen(modTerm) {
	  return {
	    code: (0, _shiftCodegen2.default)(modTerm, new _shiftCodegen.FormattedCodeGen())
	  };
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb2RlZ2VuLmpzIl0sIm5hbWVzIjpbImNvZGVnZW4iLCJtb2RUZXJtIiwiY29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBRXdCQSxPOztBQUZ4Qjs7Ozs7O0FBRWUsU0FBU0EsT0FBVCxDQUFpQkMsT0FBakIsRUFBMEI7QUFDdkMsU0FBTztBQUNMQyxVQUFNLDRCQUFhRCxPQUFiLEVBQXNCLG9DQUF0QjtBQURELEdBQVA7QUFHRCIsImZpbGUiOiJjb2RlZ2VuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNoaWZ0Q29kZWdlbiwgeyBGb3JtYXR0ZWRDb2RlR2VuIH0gZnJvbSAnc2hpZnQtY29kZWdlbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvZGVnZW4obW9kVGVybSkge1xuICByZXR1cm4ge1xuICAgIGNvZGU6IHNoaWZ0Q29kZWdlbihtb2RUZXJtLCBuZXcgRm9ybWF0dGVkQ29kZUdlbigpKVxuICB9O1xufVxuIl19

/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	class Store extends Map {
	  constructor(backingObject) {
	    super();
	    this.backingObject = backingObject;
	  }

	  set(key, val) {
	    super.set(key, val);
	    this.backingObject[key] = val;
	  }

	  getBackingObject() {
	    return this.backingObject;
	  }
	}
	exports.default = Store;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yZS5qcyJdLCJuYW1lcyI6WyJTdG9yZSIsIk1hcCIsImNvbnN0cnVjdG9yIiwiYmFja2luZ09iamVjdCIsInNldCIsImtleSIsInZhbCIsImdldEJhY2tpbmdPYmplY3QiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWUsTUFBTUEsS0FBTixTQUFvQkMsR0FBcEIsQ0FBd0I7QUFDckNDLGNBQVlDLGFBQVosRUFBMkI7QUFDekI7QUFDQSxTQUFLQSxhQUFMLEdBQXFCQSxhQUFyQjtBQUNEOztBQUVEQyxNQUFJQyxHQUFKLEVBQVNDLEdBQVQsRUFBYztBQUNaLFVBQU1GLEdBQU4sQ0FBVUMsR0FBVixFQUFlQyxHQUFmO0FBQ0EsU0FBS0gsYUFBTCxDQUFtQkUsR0FBbkIsSUFBMEJDLEdBQTFCO0FBQ0Q7O0FBRURDLHFCQUFtQjtBQUNqQixXQUFPLEtBQUtKLGFBQVo7QUFDRDtBQWJvQztrQkFBbEJILEsiLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yZSBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKGJhY2tpbmdPYmplY3QpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2luZ09iamVjdCA9IGJhY2tpbmdPYmplY3Q7XG4gIH1cblxuICBzZXQoa2V5LCB2YWwpIHtcbiAgICBzdXBlci5zZXQoa2V5LCB2YWwpO1xuICAgIHRoaXMuYmFja2luZ09iamVjdFtrZXldID0gdmFsO1xuICB9XG5cbiAgZ2V0QmFja2luZ09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYWNraW5nT2JqZWN0O1xuICB9XG59XG4iXX0=

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(74);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 74 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ }
/******/ ])});;