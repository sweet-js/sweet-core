<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Sweet.js Documentation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link href='http://fonts.googleapis.com/css?family=Lato:100' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="style/sweetprism.css">
  <script type='text/javascript'>
  window.onload = function() {
  	document.body.className = "language-javascript";
  	Prism.highlightAll();
  }
  </script>
  <link href='style/prism.css' rel='stylesheet' />
  <script src="style/prism.js"></script>
  <style>
  body {
    margin: 0;
    padding: 0;
  }

  body {
    width: 600px;
    margin: 0 auto;
    position: relative;
    top: 75px;
  }

  #logo {
    float: left;
    width: 275px;
  }

  #content {
    float: left;
    width: 650px;
    padding-bottom:50px;
  }

  h1,h2,h3 {
    font-family: Helvetica Neue;
    font-weight: 100;
    color: #222;
    position: relative;
    text-transform: uppercase;
    color: #444;
    font-family: 'Lato', Helvetica Neue, Helvetica, Arial, sans-serif;
    font-weight: 100;
    border-bottom: solid 1px #eee;
  }
  h1 {
    font-size: 200%;
  }
  h2 {
    font-size: 150%;
  }
  h3 {
    font-size: 120%;
  }

  p, li {
    font-family: 'Source Sans Pro', sans-serif;
    /*font-weight: 400;*/
    font-size: large;
  }


  p code {
    font-size: 14px;
  }
  li code {
    font-size: 14px;
  }

  a {
  	text-decoration: none;
  }
  a:hover, a:focus {
      text-decoration: underline;
  }

  .editor { display : none }

  /* to display output of macro expansions */
  .console {
    -moz-border-radius: 6px;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    padding: 1em;
    margin-top:1em;
    white-space: pre;
    background: #f5f2f0;
    resize: vertical;
    max-height: 700px;
    overflow: auto;
    font-family: Consolas, Monaco, "Andale Mono", monospace;
    text-shadow:0 1px white;
    display:none;
  }

  </style>
</head>
<body>
<header>
<h1 class="title">Sweet.js Documentation</h1>
<strong>Note: this documents the old 0.7 version of Sweet.js.
  Documentation for the current version is available <a href="http://sweetjs.org/doc/1.0/tutorial.html">here</a>.</strong>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#rule-macros"><span class="toc-section-number">2</span> Rule Macros</a><ul>
<li><a href="#patterns"><span class="toc-section-number">2.1</span> Patterns</a><ul>
<li><a href="#repetition"><span class="toc-section-number">2.1.1</span> Repetition</a></li>
<li><a href="#literal-patterns"><span class="toc-section-number">2.1.2</span> Literal patterns</a></li>
<li><a href="#named-patterns"><span class="toc-section-number">2.1.3</span> Named patterns</a></li>
<li><a href="#pattern-classes"><span class="toc-section-number">2.1.4</span> Pattern Classes</a></li>
<li><a href="#custom-pattern-classes-experimental"><span class="toc-section-number">2.1.5</span> Custom Pattern Classes (Experimental)</a></li>
</ul></li>
</ul></li>
<li><a href="#hygiene"><span class="toc-section-number">3</span> Hygiene</a><ul>
<li><a href="#hygiene-part-1-binding"><span class="toc-section-number">3.1</span> Hygiene Part 1 (Binding)</a></li>
<li><a href="#hygiene-part-2-reference"><span class="toc-section-number">3.2</span> Hygiene Part 2 (Reference)</a></li>
</ul></li>
<li><a href="#case-macros"><span class="toc-section-number">4</span> Case Macros</a><ul>
<li><a href="#creating-syntax-objects"><span class="toc-section-number">4.1</span> Creating Syntax Objects</a></li>
<li><a href="#letstx"><span class="toc-section-number">4.2</span> <code>letstx</code></a></li>
</ul></li>
<li><a href="#extending-pattern-classes"><span class="toc-section-number">5</span> Extending Pattern Classes</a><ul>
<li><a href="#the-invoke-pattern-class"><span class="toc-section-number">5.1</span> The Invoke Pattern Class</a></li>
<li><a href="#implicit-invoke"><span class="toc-section-number">5.2</span> Implicit Invoke</a></li>
<li><a href="#identity-rules"><span class="toc-section-number">5.3</span> Identity Rules</a></li>
<li><a href="#errors-for-invoke"><span class="toc-section-number">5.4</span> Errors for Invoke</a></li>
</ul></li>
<li><a href="#let-macros"><span class="toc-section-number">6</span> Let macros</a></li>
<li><a href="#infix-macros"><span class="toc-section-number">7</span> Infix Macros</a></li>
<li><a href="#custom-operators"><span class="toc-section-number">8</span> Custom Operators</a><ul>
<li><a href="#examples"><span class="toc-section-number">8.1</span> Examples</a></li>
<li><a href="#operator-precedence"><span class="toc-section-number">8.2</span> Operator Precedence</a><ul>
<li><a href="#unary-operators"><span class="toc-section-number">8.2.1</span> Unary Operators</a></li>
<li><a href="#binary-operators"><span class="toc-section-number">8.2.2</span> Binary Operators</a></li>
</ul></li>
</ul></li>
<li><a href="#reader-extensions"><span class="toc-section-number">9</span> Reader Extensions</a><ul>
<li><a href="#readtables"><span class="toc-section-number">9.1</span> Readtables</a></li>
<li><a href="#reader-api"><span class="toc-section-number">9.2</span> Reader API</a></li>
</ul></li>
<li><a href="#modules"><span class="toc-section-number">10</span> Modules</a><ul>
<li><a href="#using-modules"><span class="toc-section-number">10.1</span> Using Modules</a></li>
<li><a href="#node-loader"><span class="toc-section-number">10.2</span> Node Loader</a></li>
</ul></li>
<li><a href="#compiler-api"><span class="toc-section-number">11</span> Compiler API</a><ul>
<li><a href="#sweet.compile"><span class="toc-section-number">11.1</span> <code>sweet.compile</code></a></li>
<li><a href="#sweet.parse"><span class="toc-section-number">11.2</span> <code>sweet.parse</code></a></li>
<li><a href="#sweet.expand"><span class="toc-section-number">11.3</span> <code>sweet.expand</code></a></li>
</ul></li>
<li><a href="#faq"><span class="toc-section-number">12</span> FAQ</a><ul>
<li><a href="#how-do-i-run-sweet.js-in-the-browser"><span class="toc-section-number">12.1</span> How do I Run Sweet.js in the Browser?</a></li>
<li><a href="#how-do-i-break-hygiene"><span class="toc-section-number">12.2</span> How do I break hygiene?</a></li>
<li><a href="#how-do-i-output-comments"><span class="toc-section-number">12.3</span> How do I output comments?</a></li>
<li><a href="#how-do-i-convert-a-token-to-a-string-literal"><span class="toc-section-number">12.4</span> How do I convert a token to a string literal?</a></li>
<li><a href="#how-do-i-debug-macros"><span class="toc-section-number">12.5</span> How do I debug macros?</a><ul>
<li><a href="#stepping-through-expansion"><span class="toc-section-number">12.5.1</span> Stepping Through Expansion</a></li>
<li><a href="#understanding-case-macros"><span class="toc-section-number">12.5.2</span> Understanding Case Macros</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Install the sweet.js compiler via npm:</p>
<pre class="language-bash"><code>npm install -g sweet.js</code></pre>
<p>This installs the <code>sjs</code> binary which is used to compile sweet.js code:</p>
<pre class="language-bash"><code>sjs --output out.js my_sweet_code.js</code></pre>
<h1 id="rule-macros"><span class="header-section-number">2</span> Rule Macros</h1>
<p>You can think of macros as functions that work on syntax. Much like a normal function you write a macro <em>definition</em> and then later <em>invoke</em> the macro with a syntax argument to produce new syntax. Running sweet.js code through the compiler will <em>expand</em> all macros and produce pure JavaScript that can be run in any JS environment.</p>
<p>Sweet.js provides two ways to define a macro: the simpler pattern-based <em>rule</em> macros and the more powerful procedural <em>case</em> macros (if you are familiar with Scheme or Racket these correspond to <code>syntax-rules</code> and <code>syntax-case</code>).</p>
<p>Rule macros work by matching a syntax <em>pattern</em> and generating new syntax based on a <em>template</em>.</p>
<p>To define a macro sweet.js provides a new <code>macro</code> keyword that looks something like this:</p>
<pre class="js"><code>macro &lt;name&gt; {
  rule { &lt;pattern&gt; } =&gt; { &lt;template&gt; }
}</code></pre>
<p>For example, here's a really simple identity macro that just expands to its syntax argument:</p>
<pre class="js"><code>macro id {
  rule {
    // after the macro name, match:
    // (1) a open paren
    // (2) a single token and bind it to `$x`
    // (3) a close paren
    ($x)
  } =&gt; {
    // just return the token that is bound to `$x`
    $x
  }
}</code></pre>
<p>We can then invoke <code>id</code> with:</p>
<pre class="js"><code>id (42)
// expands to:
// 42</code></pre>
<p>A pattern that begins with <code>$</code> matches any token and binds it to that name in the template while everything else matches literally.</p>
<p>Note that a single token includes matched delimiters not just numbers and identifiers. For example, an array with all of its elements counts as one token:</p>
<pre class="js"><code>id ([1, 2, 3])
// expands to:
// [1, 2, 3]</code></pre>
<p>Macros can have multiple rules.</p>
<pre class="js"><code>macro m {
  rule { ($x) } =&gt; { $x }
  rule { ($x, $y) } =&gt; { [$x, $y] }
}

m (1);
m (1, 2);</code></pre>
<p>Rules are matched in-order and the first one to match the pattern will be used.</p>
<p>And macros can be recursively defined:</p>
<pre class="js"><code>macro m {
  rule { ($base) } =&gt; { [$base] }
  rule { ($head $tail ...) } =&gt; { [$head, m ($tail ...)] }
}
m (1 2 3 4 5)  // --&gt; [1, [2, [3, [4, [5]]]]]</code></pre>
<h2 id="patterns"><span class="header-section-number">2.1</span> Patterns</h2>
<h3 id="repetition"><span class="header-section-number">2.1.1</span> Repetition</h3>
<p>Repeated tokens can be matched with ellipses <code>...</code>.</p>
<pre class="js"><code>macro m {
  rule { ($x ...) } =&gt; {
    // ...
  }
}
m (1 2 3 4)</code></pre>
<p>A repeated pattern with a separator between each item can be matched by adding <code>(,)</code> between <code>...</code> and the pattern being repeated.</p>
<pre class="js"><code>macro m {
  rule { ($x (,) ...) } =&gt; {
    [$x (,) ...]
  }
}
m (1, 2, 3, 4)</code></pre>
<p>Repeated groups of patterns can be matched using <code>$()</code>.</p>
<pre class="js"><code>macro m {
  rule { ( $($id = $val) (,) ...) } =&gt; {
    $(var $id = $val;) ...
  }
}
m (x = 10, y = 2)</code></pre>
<h3 id="literal-patterns"><span class="header-section-number">2.1.2</span> Literal patterns</h3>
<p>The syntax <code>$[]</code> will match what is inside the brackets literally. For example, if you need to match <code>...</code> in a pattern (rather than have <code>...</code> mean repetition) you can escape it with <code>$[...]</code>.</p>
<h3 id="named-patterns"><span class="header-section-number">2.1.3</span> Named patterns</h3>
<p>You can name pattern groups and literal groups. Sub-bindings can be referenced by concatenating the group name and binding name. All the syntax matched by the group will be bound to the group name.</p>
<pre class="js"><code>macro m {
  rule { ($binding:($id = $val) (,) ...) } =&gt; {
    $(var $binding;) ...
    // Or with sub-bindings
    $(var $binding$id = $binding$val;) ...
  }
}

macro m {
  rule { $ellipsis:[...] } =&gt; {
    // ...
  }
}</code></pre>
<h3 id="pattern-classes"><span class="header-section-number">2.1.4</span> Pattern Classes</h3>
<p>A pattern name can be restricted to a particular parse class by using <code>$name:class</code> in which case rather than matching a token the pattern matches all the tokens matched by the class.</p>
<pre class="js"><code>macro m {
  rule { ($x:expr) } =&gt; {
    $x
  }
}
m (2 + 5 * 10)
// --&gt; expands to
2 + 5 * 10</code></pre>
<p>The pattern classes are:</p>
<ul>
<li><code>:ident</code> -- matches an identifier (eg. <code>foo</code>)</li>
<li><code>:lit</code> -- matches a literal (eg. <code>100</code> or <code>&quot;a string&quot;</code>)</li>
<li><code>:expr</code> -- matches an expression (eg. <code>foo(&quot;a string&quot;) + 100</code>)</li>
</ul>
<h3 id="custom-pattern-classes-experimental"><span class="header-section-number">2.1.5</span> Custom Pattern Classes (Experimental)</h3>
<p>Note that the syntax of custom pattern classes is currently experimental and subject to change.</p>
<p>You can define your own custom pattern classes with <code>macroclass</code>.</p>
<pre class="js"><code>// define the cond_clause pattern class
macroclass cond_clause {
  pattern {
    rule { $check:expr =&gt; $body:expr }
  }
}

macro cond {
  rule { $first:cond_clause $rest:cond_clause ... } =&gt; {
    // sub-pattern variables in the custom class are
    // referenced by concatenation
    if ($first$check) {
      $first$body
    } $(else if ($rest$check) {
      $rest$body
    }) ...
  }
}

cond
  x &lt; 3  =&gt; console.log(&quot;less than 3&quot;)
  x == 3 =&gt; console.log(&quot;3&quot;)
  x &gt; 3  =&gt; console.log(&quot;greater than 3&quot;)
// expands to:
// if (x &lt; 3) {
//     console.log(&#39;less than 3&#39;);
// } else if (x == 3) {
//     console.log(&#39;3&#39;);
// } else if (x &gt; 3) {
//     console.log(&#39;greater than 3&#39;);
// }</code></pre>
<p>You can also define multiple patterns and bind missing sub-pattern variables using <code>with</code>. You may supply multiple <code>with</code> declarations or separate bindings by commas.</p>
<pre class="js"><code>macroclass alias_pair {
  pattern {
    rule { $from:ident as $to:ident }
  }
  pattern {
    rule { $from:ident }
    with $to = #{ $from };
  }
}

macro import {
  rule { { $import:alias_pair (,) ... } from $mod:lit ;... } =&gt; {
    var __module = require($mod);
    $(var $import$to = __module.$import$from;) ...
  }
  rule { $default:ident from $mod:lit ;... } =&gt; {
    var $default = require($mod).default;
  }
}

import { a, b as c, d } from &#39;foo&#39;
// expands to:
// var __module = require(&#39;foo&#39;);
// var a = __module.a;
// var c = __module.b;
// var d = __module.d;</code></pre>
<p>Patterns with only a <code>rule</code> declaration may be collapsed into just a <code>rule</code> declaration in lieu of a <code>pattern</code>.</p>
<h1 id="hygiene"><span class="header-section-number">3</span> Hygiene</h1>
<p>The most important property of sweet.js is hygiene. Hygiene prevents variables names inside of macros from clashing with variables in the surrounding code. It's what gives macros the power to actually be syntactic abstractions by hiding implementation details and allowing you to use a hygienic macro <em>anywhere</em> in your code.</p>
<p>Hygiene protects against two kinds of naming collisions: binding collisions and reference collisions.</p>
<h2 id="hygiene-part-1-binding"><span class="header-section-number">3.1</span> Hygiene Part 1 (Binding)</h2>
<p>The part of hygiene most people intuitively grok is keeping track of the variable <em>bindings</em> that a macro introduces. For example, the swap macro creates a <code>tmp</code> variable that should only be bound inside of the macro:</p>
<pre class="js"><code>macro swap {
  rule { ($a, $b) } =&gt; {
    var tmp = $a;
    $a = $b;
    $b = tmp;
  }
}

var tmp = 10;
var b = 20;
swap (tmp, b)</code></pre>
<p>Without hygiene the two <code>tmp</code> variables would clash:</p>
<pre class="js"><code>var tmp = 10;
var b = 20;

var tmp = tmp;
tmp = b;
b = tmp;</code></pre>
<p>Hygiene keeps the two <code>tmp</code> bindings distinct by renaming them both:</p>
<pre class="js"><code>var tmp$1 = 10;
var b = 20;

var tmp$2 = tmp$1;
tmp$1 = b;
b = tmp$2;</code></pre>
<h2 id="hygiene-part-2-reference"><span class="header-section-number">3.2</span> Hygiene Part 2 (Reference)</h2>
<p>Hygiene also handles variable <em>references</em>. The body of a macro can contain references to bindings declared outside of the macro and those references must be consistent no matter the context in which the macro is invoked.</p>
<p>Some code to clarify. Let's say you have a macro that uses a random number function:</p>
<pre class="js"><code>var random = function(seed) { /* ... */ }
let m = macro {
    rule {()} =&gt; {
        var n = random(42);
        // ...
    }
}</code></pre>
<p>This macro needs to refer to <code>random</code> in any context that it gets invoked. But its context could have a different binding to <code>random</code>!</p>
<pre class="js"><code>function foo() {
    var random = 42;
    m ()
}</code></pre>
<p>Hygiene needs to keep the two <code>random</code> bindings different. So sweet.js will expand this into something like:</p>
<pre class="js"><code>var random$1 = function(seed) { /* ... */ }
function foo() {
    var random$2 = 42;
    var n = random$1(42);
    // ...
}</code></pre>
<p>Note that there is no way for hygiene to do this if it only renamed identifiers inside of macros since both <code>random</code> bindings were declared outside of the macro. Hygiene is necessarily a whole program transformation.</p>
<p>By default sweet.js will rename every variable to something like <code>name$102</code>. This gives correct but somewhat messy generated code. Usually this is not a problem since sweet.js provides source maps (with the <code>--sourcemap</code> flag) so you rarely need to inspect the generated source. If you would like to have sweet.js generate cleaner code you can use the <code>--readable-names</code> flag which will only rename variables when it is absolutely necessary. This flag is not yet turned on by default since it only supports ES5 code at the moment.</p>
<h1 id="case-macros"><span class="header-section-number">4</span> Case Macros</h1>
<p>Sweet.js also provides a more powerful way to define macros: case macros. Case macros allow you to manipulate syntax using the full power of JavaScript. Case macros look like this:</p>
<pre class="js"><code>macro &lt;name&gt; {
  case { &lt;pattern&gt; } =&gt; { &lt;body&gt; }
}</code></pre>
<p>Case macros look similar to rule macros with a few important differences. First, the patterns also match the macro name instead of just the syntax that comes after it:</p>
<pre class="js"><code>macro m {
  case { $name $x } =&gt; { ... }
}
m 42  // `$name` will be bound to the `m` token
      // in the macro body</code></pre>
<p>Most of the time you won't need to match the name and can use the wildcard <code>_</code> pattern (which matches any token but doesn't bind it to a name) to ignore it:</p>
<pre class="js"><code>macro m {
  case { _ $x } =&gt; { ... }
}</code></pre>
<p>The other difference from rule macros is that the body of a macro contains a mixture of templates and normal JavaScript that can create and manipulate syntax. For example, here's the identity macro defined with a case macro:</p>
<pre class="js"><code>macro id {
  case {_ $x } =&gt; {
    return #{ $x }
  }
}</code></pre>
<p>Templates are now created with the <code>#{...}</code> form (which is technically shorthand for <code>syntax {...}</code>). The <code>#{...}</code> form creates an array of <em>syntax objects</em> using any pattern bindings that are in scope (i.e. were matched by the pattern).</p>
<p><em>Syntax objects</em> are the representation of tokens that sweet.js uses to keep track of lexical context (which is used to maintain hygiene). They can be created with templates (<code>#{}</code>) but you can also create individual syntax objects using the lexical context of an existing syntax object:</p>
<pre class="js"><code>macro m {
  case {_ $x } =&gt; {
    var y = makeValue(42, #{$x});
    return [y]
  }
}
m foo
// --&gt; expands to
42</code></pre>
<h2 id="creating-syntax-objects"><span class="header-section-number">4.1</span> Creating Syntax Objects</h2>
<p>Sweet.js provides the following functions to create syntax objects:</p>
<ul>
<li><code>makeValue(val, stx)</code> -- <code>val</code> can be a <code>boolean</code>, <code>number</code>, <code>string</code>, or <code>null</code>/<code>undefined</code></li>
<li><code>makeRegex(pattern, flags, stx)</code> -- <code>pattern</code> is the string representation of the regex pattern and <code>flags</code> is the string representation of the regex flags</li>
<li><code>makeIdent(val, stx)</code> -- <code>val</code> is a string representing an identifier</li>
<li><code>makePunc(val, stx)</code> -- <code>val</code> is a string representing a punctuation (e.g. <code>=</code>, <code>,</code>, <code>&gt;</code>, etc.)</li>
<li><code>makeDelim(val, inner, stx)</code> -- <code>val</code> represents which delimiter to make and can be either <code>&quot;()&quot;</code>, <code>&quot;[]&quot;</code>, or <code>&quot;{}&quot;</code> and <code>inner</code> is an array of syntax objects for all of the tokens inside the delimiter.</li>
</ul>
<p>If you want strip a syntax object of its lexical context and get directly at the token you can use <code>unwrapSyntax(stx)</code>.</p>
<p>Case macros also provide <code>throwSyntaxError(name, message, stx)</code> when you need to throw an error inside of a case macro. <code>name</code> is a string that lets you name the error, <code>message</code> is a string to describe what went wrong, and <code>stx</code> is a syntax object or array of syntax objects that is used to print out the line number and surrounding tokens in the error message.</p>
<h2 id="letstx"><span class="header-section-number">4.2</span> <code>letstx</code></h2>
<p>When using syntax object creation functions, it is convenient to refer to them in <code>#{}</code> templates. To do this sweet.js provides <code>letstx</code>, which binds syntax objects to pattern variables:</p>
<pre class="js"><code>macro m {
  case {_ $x } =&gt; {
    var y = makeValue(42, #{$x});
    letstx $y = [y], $z = [makeValue(2, #{$x})];
    return #{$x + $y - $z}
  }
}
m 1
// --&gt; expands to
1 + 42 - 2</code></pre>
<p>The left-hand side of the <code>=</code> in a <code>letstx</code> is actually a pattern so you can, for example, match a repeating pattern:</p>
<pre class="js"><code>macro m {
  case {_} =&gt; {
    letstx $x ... = [makeValue(1, #{here}),
                     makeValue(2, #{here}),
                     makeValue(3, #{here})];
    return #{
      [$x (,) ...]
    }
  }
}
m
// expands to:
// [1, 2, 3]</code></pre>
<h1 id="extending-pattern-classes"><span class="header-section-number">5</span> Extending Pattern Classes</h1>
<p>Consider the following macro that matches against color options:</p>
<pre class="js"><code>macro color_options {
  rule { (red) } =&gt; { [&quot;#FF0000&quot;] }
  rule { (green) } =&gt; { [&quot;#00FF00&quot;] }
  rule { (blue) } =&gt; { [&quot;#0000FF&quot;] }
}
r = color_options (red)
g = color_options (green)
// expands to:
// r = [&quot;#FF0000&quot;]
// g = [&quot;#00FF00&quot;]</code></pre>
<p>While this macro seems to work, attempting to generalize it quickly leads to a mess:</p>
<pre class="js"><code>macro color_options {
    rule { (red, red) } =&gt; {
        [&quot;#FF0000&quot;, &quot;#FF0000&quot;]
    }
    rule { (red, green) } =&gt; {
        [&quot;#FF0000&quot;, &quot;#00FF00&quot;]
    }
    rule { (red, blue) } =&gt; {
        [&quot;#FF0000&quot;, &quot;#0000FF&quot;]
    }
    // ... etc.
}
r = colors_options (red, green)
g = colors_options (green, blue)
// expands to:
// r = [&quot;#FF0000&quot;, &quot;#00FF00&quot;]
// g = [&quot;#00FF00&quot;, &quot;#0000FF&quot;]</code></pre>
<p>While it is possible to solve this problem through the use of case macros, the declarative intent is quickly lost in a mess of token manipulation code.</p>
<h2 id="the-invoke-pattern-class"><span class="header-section-number">5.1</span> The Invoke Pattern Class</h2>
<p>Sweet.js provides a solution to this problem with the <code>:invoke</code> pattern class. This pattern class takes as a parameter a macro name which is inserted into the token tree stream before matching. If the inserted macro successfully matches its arguments, the result of its expansion is bound to the pattern variable. This makes declarative options simple to write:</p>
<pre class="js"><code>macro color {
    rule { red } =&gt; { &quot;#FF0000&quot; }
    rule { green } =&gt; { &quot;#00FF00&quot; }
    rule { blue } =&gt; { &quot;#0000FF&quot; }
}
macro colors_options {
    rule { ($opt:invoke(color) (,) ...) } =&gt; {
        [$opt (,) ...]
    }
}
colors_options (red, green, blue, blue)
// expands to:
// [&quot;#FF0000&quot;, &quot;#00FF00&quot;, &quot;#0000FF&quot;, &quot;#0000FF&quot;]</code></pre>
<p>Invoke will only expand the parameterized macro once; if the macro expands to another macro it will not be expanded before being bound to the pattern variable.</p>
<p>If you need to keep expanding, use <code>:invokeRec</code> which will continue to expand as long as a macro name is returned as the first token. This is useful if you have a recursive macro but is not the default because it can be unintuitive if the macro is not a recursive macro. For example,</p>
<pre class="js"><code>macro a {
  rule {} =&gt; { 1 + 2 }
}
macro b {
  rule { $x } =&gt; { a + $x }
}
macro c {
  rule { $y:invokeRec(b) } =&gt; { [$y] }
}

c 3
// expands to:
// [1 + 2] + 3</code></pre>
<p>The <code>b</code> macro returns <code>a + $x</code> as its result. Since <code>a</code> is another macro which returns <code>1 + 2</code> as a result, so <code>1 + 2</code> is what gets loaded into the <code>$y</code> pattern variable, and the <code>+ 3</code> is surprisingly pushed outside the scope of the macro.</p>
<p>This is a change from the default behavior of version 0.5.0 in which <code>:invoke</code> behaved like <code>:invokeRec</code> and <code>:invokeOnce</code> was available for the current default behavior.</p>
<h2 id="implicit-invoke"><span class="header-section-number">5.2</span> Implicit Invoke</h2>
<p>Custom pattern classes act as an implicit invoke. This means that <code>$opt:invoke(color)</code> is equivalent to <code>$opt:color</code>:</p>
<pre class="js"><code>macro color {
    rule { red } =&gt; { &quot;#FF0000&quot; }
    rule { green } =&gt; { &quot;#00FF00&quot; }
    rule { blue } =&gt; { &quot;#0000FF&quot; }
}
macro colors_options {
    rule { ($opt:color (,) ...) } =&gt; {
        [$opt (,) ...]
    }
}
colors_options (red, green, blue, blue)
// expands to:
// [&quot;#FF0000&quot;, &quot;#00FF00&quot;, &quot;#0000FF&quot;, &quot;#0000FF&quot;]</code></pre>
<p>Custom pattern classes only support single-token identifiers. If you need to call a multi-token name or a punctuator name, you should explicitly call <code>$foo:invoke(...)</code> with the name.</p>
<h2 id="identity-rules"><span class="header-section-number">5.3</span> Identity Rules</h2>
<p>Sometimes you want your custom operator to just return exactly what it matched rather than transform it into something else. Identity rules let you do just that. If you leave off the body of a rule, it will just return exactly the syntax that the rule matched:</p>
<pre class="js"><code>macro func {
  rule { function ($args (,) ...) { $body ... } }
  rule { function $name:ident ($args (,) ...) { $body ... } }
}

macro checkFunc {
  rule { $f:func } =&gt; { $f }
}

x = checkFunc function() {}
// expands to:
// x = function() {}</code></pre>
<h2 id="errors-for-invoke"><span class="header-section-number">5.4</span> Errors for Invoke</h2>
<p>The function <code>throwSyntaxCaseError</code> is similar to <code>throwSyntaxError</code>, but should be used specifically when you are using <code>:invoke</code>. Internally, sweet.js throws a SyntaxCaseError when a macro fails to match so <code>throwSyntaxCaseError</code> just lets you do it manually. Here's how you might use it in a macro that checks for keyword:</p>
<pre class="js"><code>macro keyword {
  case { _ $kw } =&gt; {
    var kw = #{ $kw };
    if (kw[0].token.type === parser.Token.Keyword) {
      return kw;
    }
    throwSyntaxCaseError(&#39;Not a keyword&#39;);
  }
}</code></pre>
<h1 id="let-macros"><span class="header-section-number">6</span> Let macros</h1>
<p>Sometimes you don't want a macro to recursively call itself. For example, say you want to override <code>function</code> to add some logging information before the rest of the function executes:</p>
<pre class="js"><code>macro function {
  case {_ $name ($params ...) { $body ...} } =&gt; {
    return #{
      function $name ($params ...) {
        console.log(&quot;Imma let you finish...&quot;);
        $body ...
      }
    }
  }
}</code></pre>
<p>If you tried to run this through the compiler it will loop forever since the <code>function</code> identifier in the macro expansion is bound to the <code>function</code> macro. To prevent this you can use the <code>let</code> macro binding form:</p>
<pre class="js"><code>let function = macro {
  case {_ $name ($params ...) { $body ...} } =&gt; {
    return #{
      function $name ($params ...) {
        console.log(&quot;Imma let you finish...&quot;);
        $body ...
      }
    }
  }
}</code></pre>
<p>This binds <code>function</code> to the macro in the rest of the code but not in the body of the <code>function</code> macro.</p>
<h1 id="infix-macros"><span class="header-section-number">7</span> Infix Macros</h1>
<p>Sweet.js also lets you match on previous syntax using <code>infix</code> rules. Use a vertical bar (<code>|</code>) to separate your left-hand-side from your right-hand-side.</p>
<pre class="js"><code>macro unless {
  rule infix { return $value:expr | $guard:expr } =&gt; {
    if (!($guard)) {
      return $value;
    }
  }
}

function foo(x) {
  return true unless x &gt; 42;
  return false;
}</code></pre>
<p>You can use the <code>infix</code> keyword with procedural macros, too. The macro name is just the first token on the right-hand-side.</p>
<pre class="js"><code>macro m {
  case infix { $lhs | $name $rhs } =&gt; { ... }
}</code></pre>
<p>Infix rules can be mixed and matched with normal rules:</p>
<pre class="js"><code>macro m {
  rule infix { $lhs | $rhs } =&gt; { ... }
  rule { $rhs } =&gt; { ... }
}</code></pre>
<p>You can even leave off the right-hand-side for a postfix macro:</p>
<pre class="js"><code>macro m {
  rule infix { $lhs | } =&gt; { ... }
}</code></pre>
<p>Sweet.js does its best to keep you from clobbering previous syntax.</p>
<pre class="js"><code>macro m {
  rule infix { ($args ...) | $call:expr } =&gt; {
    $call($args ...)
  }
}

(42) m foo; // This works
bar(42) m foo; // This is a match error</code></pre>
<p>The second example fails to match because you'd be splitting the good function call on the left-hand-side in half. The result would have been nonsense, giving you a nasty parse error.</p>
<h1 id="custom-operators"><span class="header-section-number">8</span> Custom Operators</h1>
<p>Custom operators let you define your own operators or override the builtin operators. They are similar to infix macros except rather than matching arbitrary syntax before and after the identifier name, both the left and right operands must be valid JavaScript expressions. You can think of them as infix macros with a pattern of <code>{ $left:expr | $right:expr }</code>. This limitation however means that you can define precedence and associativity for your custom operator.</p>
<p>There are two definition forms. One for binary operators and one for unary operators:</p>
<pre class="js"><code>// binary operators
operator &lt;name&gt; &lt;precedence&gt; &lt;associativity&gt;
    { &lt;left operand&gt;, &lt;right operand&gt; } =&gt; #{ &lt;template&gt; }

// unary operators
operator &lt;name&gt; &lt;precedence&gt;
    { &lt;operand&gt; } =&gt; #{ &lt;template&gt; }</code></pre>
<ul>
<li><code>&lt;name&gt;</code> can be any valid macro name (ie. identifiers and punctuation but not delimiters, multi token names must be wrapped in parentheses)</li>
<li><code>&lt;precedence&gt;</code> is a number (higher numbers bind more tightly)</li>
<li><code>&lt;associativity&gt;</code> is either <code>left</code> or <code>right</code></li>
<li><code>&lt;left operand&gt;</code>/<code>&lt;right operand&gt;</code>/<code>&lt;operand&gt;</code> is a pattern variable (eg <code>$left</code>) that will be bound in the template</li>
<li><code>&lt;template&gt;</code> is what the operator will expand into</li>
</ul>
<p>For example, the following defines <code>^^</code> to be the power operator:</p>
<pre class="js"><code>operator (^^) 14 right
    { $base, $exp } =&gt; #{ Math.pow($base, $exp) }

y + x ^^ 10 ^^ 100 - z
// expands to:
// y + Math.pow(x, Math.pow(10, 100)) - z;</code></pre>
<p>The precedence of <code>^^</code> (14) is higher than the precedence of <code>+</code> and <code>-</code> (12, see the chart in the next section) so <code>^^</code> binds more tightly. Since we defined <code>^^</code> to be right associative, <code>x ^^ 10 ^^ 100</code> is equivalent to <code>x ^^ (10 ^^ 100)</code>. Left associative would have meant <code>(x ^^ 10) ^^ 100</code>.</p>
<h2 id="examples"><span class="header-section-number">8.1</span> Examples</h2>
<p>Custom operators and infix macros complement each other nicely.</p>
<pre class="js"><code>macro (=&gt;) {
    rule infix { $param:ident | $body:expr  } =&gt; {
        function ($param) { return $body }
    }
}
operator (|&gt;) 1 left { $l, $r } =&gt; #{ $r($l) }

var res = 10 |&gt; x =&gt; x * 2
             |&gt; y =&gt; y - 3
// expands to:
// var res = function (x) {
//         return function (y) {
//             return y - 3;
//         }(x * 2);
//     }(10);</code></pre>
<p>Or let's say we want to chain promises:</p>
<pre class="js"><code>macro (=&gt;) {
    rule infix { ($params ...) | { $body ... } } =&gt; {
        function ($params ...) { $body ... }
    }
}
operator (&gt;&gt;=) 12 left { $l, $r } =&gt; #{$l.then($r) }

getPromise(&#39;test.json&#39;)  &gt;&gt;= JSON.parse &gt;&gt;= (response) =&gt; {
  console.log(&quot;JSON Response!&quot;, response);
}
// expands to:
// getPromise(&#39;test.json&#39;).then(JSON.parse).then(function (response) {
//     console.log(&#39;JSON Response!&#39;, response);
// });</code></pre>
<p>Custom operators also let you change the behavior of the builtin operators:</p>
<pre class="js"><code>operator + 12 left { $l, $r } =&gt; #{ add($l, $r) }
function add(x, y) {
    // custom addition
}

100 + x - y * 5 + 30
// expands to
// function add(x, y) {
//     // custom addition
// }
// add(add(100, x) - y * 5, 30);</code></pre>
<p>You can even fix <code>==</code>!</p>
<pre class="js"><code>operator == 9 left { $l, $r } =&gt; #{ $l === $r }

if (&quot;42&quot; == 42) {
    // never runs!
}
// expands to:
// if (&#39;42&#39; === 42) {
//    // never runs!
// }    </code></pre>
<p>Keep in mind that redefining the builtin operators needs to be done with care. While it's tempting to fix some of the <em>wat</em> implicit conversions of <code>==</code>/<code>+</code>/<code>-</code> and company, this could lead to hard to understand code. It should be used sparingly if at all. With great power...</p>
<h2 id="operator-precedence"><span class="header-section-number">8.2</span> Operator Precedence</h2>
<p>The following charts note the precedence and associativity of the builtin operators. A higher precedence number means the operator binds more tightly.</p>
<h3 id="unary-operators"><span class="header-section-number">8.2.1</span> Unary Operators</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Precedence</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>new</code></td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>++</code></td>
<td style="text-align: left;">15</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--</code></td>
<td style="text-align: left;">15</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>~</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>typeof</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>delete</code></td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>yield</code></td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<h3 id="binary-operators"><span class="header-section-number">8.2.2</span> Binary Operators</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Precedence</th>
<th style="text-align: left;">Associativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&lt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;&gt;</code></td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>in</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>instanceof</code></td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>==</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>===</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!==</code></td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>|</code></td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&amp;&amp;</code></td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">left</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>||</code></td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">left</td>
</tr>
</tbody>
</table>
<h1 id="reader-extensions"><span class="header-section-number">9</span> Reader Extensions</h1>
<p>The reader is what turns a string of code into tokens for the expander to work with. While it doesn't know anything about the semantics of JavaScript, it parses the code into tokens with several assumptions tailored to JavaScript. For example, it reads <code>/abc/</code> as a single RegExp token, but it reads <code>abc/d</code> as three distinct tokens: an identifier, a punctuator, and another identifier. In fact, the algorithm for determining when <code>/</code> starts a regex or is a simple division without fully parsing the code is a key breakthrough that enables macros in JavaScript.</p>
<p>The default reader separates code into identifiers, literals, and punctuators. It also matches delimiters (<code>{}()[]</code>) and creates a <em>tree</em> of tokens, so everything inside matching delimiters exist as children of a delimiter token.</p>
<p>You may want to extend the behavior of the reader, just like you would extend the semantics of a language with macros. Doing so allows you to embed custom syntax that may not even be valid according to the default reader, for example changing how the forward slash <code>/</code> is handled. For the most part, you will use macros to extend JavaScript, but it might be useful to control exactly how the reader parses tokens.</p>
<p>sweet.js allows reader customization through <strong>readtables</strong>. A readtable is simple mapping from single characters to procedures that do the reading when the specified character is encountered in the source. For example, you can install a function to be called when <code>&lt;</code> is encountered, and you are responsible for reading as much of the source as you need and producing tokens.</p>
<p>Readtables allow composable extensions to the tokenizing phase, similar to how macros allow composable extensions to the parsing phase. You create a new readtable by extending an existing one. For example, here's how you extend the existing readtable with new functionality for <code>&lt;</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> readtable = <span class="ot">sweet</span>.<span class="fu">currentReadtable</span>().<span class="fu">extend</span>({
    <span class="st">&#39;&lt;&#39;</span>: <span class="kw">function</span>(ch, reader) {
        <span class="co">// read stuff here</span>
    }
});</code></pre>
<p>And you can set the readtable programmatically:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">sweet</span>.<span class="fu">setReadtable</span>(readtable);</code></pre>
<p>Or load it via a command line option. If you do this, the exported value of the module must be the readtable:</p>
<pre><code>sjs --load-readtable ./readtable.js

# Or the shorthand
sjs -l ./readtable.js</code></pre>
<p>By continually extending the current readtable, we can install the extensions in a modular way and build up a final readtable with our desired behaviors. You can pass multiple <code>-l</code> (or <code>--load-readtable</code>) flags to load multiple readtables extensions. If multiple readtables with the same character are installed, the last one loaded wins. There is currently no way to handle these kinds of collisions; every character must have a single unique handler (or none).</p>
<h2 id="readtables"><span class="header-section-number">9.1</span> Readtables</h2>
<p>A readtable is an object that maps characters to handler functions, and an <code>extend</code> method. Internally, a base readtable exists which is the current readtable by default. To create a new one, you always extend an existing one as explained above:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> readtable = <span class="ot">sweet</span>.<span class="fu">currentReadtable</span>().<span class="fu">extend</span>({
    <span class="st">&#39;&lt;&#39;</span>: <span class="kw">function</span>(ch, reader) {
        <span class="ot">reader</span>.<span class="fu">readPunctuator</span>();
        <span class="kw">var</span> token = <span class="ot">reader</span>.<span class="fu">readToken</span>();
        <span class="kw">if</span>(<span class="ot">token</span>.<span class="fu">type</span> !== <span class="ot">reader</span>.<span class="ot">Token</span>.<span class="fu">Identifier</span>) {
          <span class="kw">return</span> <span class="kw">null</span>;
        }

        <span class="co">// Continue parsing and return a single token or</span>
        <span class="co">// an array of tokens</span>
    }
});</code></pre>
<p>Handler functions take two arguments: the character that invoked the handler and a reader object. You access the reader API through this reader object.</p>
<p>Currently, readtables are only invoked on punctuators. That means you can't customize what happens on a double quote <code>&quot;</code> or a delimiter like <code>(</code>. This might be possible in the future.</p>
<p>The reader has not read the punctuator that invoked your handler, so you must always read past it with <code>reader.readPunctuator()</code> first.</p>
<p>You can return <code>null</code> from a handler function and the reader will automatically reset the state of the parser and continue reading normally. This lets you parse grammar that is ambiguous, and when something doesn't match you can simply bail. If you want to throw an error instead, you can use <code>throwSyntaxError</code> in the reader API to show a nice error message to the user.</p>
<p>Lastly, you can return either a single token or an array of tokens from the handler. If you return multiple tokens, <code>readToken</code> will only return the first one and queue up the rest.</p>
<p>There are two functions on the sweet module for working with readtables:</p>
<ul>
<li><p><code>sweet.currentReadtable()</code> — Gets the current readtable, which always has an <code>extend</code> method on it to install new extensions.</p></li>
<li><p><code>sweet.setReadtable(rt)</code> — Mutates the reader state to use the specified readtable when reading. Most likely users will use one or more <code>-l</code> or <code>--load-readtable</code> flags to <code>sjs</code>, but you can set it progammatically with this method.</p></li>
</ul>
<h2 id="reader-api"><span class="header-section-number">9.2</span> Reader API</h2>
<p>A reader object is always passed as the second argument when invoking a reader extension. It has several properties that are readable and writable:</p>
<ul>
<li><code>reader.source</code> — The full raw string of the code being read</li>
<li><code>reader.length</code> — The length of <code>reader.source</code></li>
<li><code>reader.index</code> — The current position of the reader into the source</li>
<li><code>reader.lineNumber</code> — The current line number</li>
<li><code>reader.lineStart</code> — The index into the source which the current line began</li>
<li><code>reader.extra</code> — read-only; an object that holds temporary data like comments</li>
</ul>
<p>The following functions are also available on the reader object. You can read tokens and skip comments with these. All of this functions (except <code>skipComment</code>) with throw an error if it fails to read a valid token. You can use <code>suppressReadError</code> to suppress this (explained more below).</p>
<ul>
<li><code>reader.readIdentifier()</code> — Read an identifier (variable name, keyword, null and boolean literals)</li>
<li><code>reader.readPunctuator()</code> — Read a punctuator</li>
<li><code>reader.readStringLiteral()</code> — Read a string literal</li>
<li><code>reader.readNumericLiteral()</code> — Read a numeric literal</li>
<li><code>reader.readRegExp()</code> — Read a regular expression</li>
<li><code>reader.readDelimiter()</code> — Read a delimiter, including everything inside it and up to the matching end delimiter</li>
<li><code>reader.readToken()</code> — Read a token of any type. Note that this can trigger another readtable invocation if the current punctuator has an entry in the current readtable. If you use this, your reader extension could potentially be called recursively. In addition, you might need to be aware of how readtables queue tokens (see <code>peekQueued</code> below).</li>
<li><code>reader.skipComment()</code> — Skip past a comment and any whitespace, if it exits.</li>
</ul>
<p>The following functions are available for manually constructing tokens. You give it the parsed value and any options. The constructed tokens will automatically be given source location information, but it can't automatically infer the range. You should pass where the token theoretically started in the original source with the <code>start</code> option. So a common pattern looks like this:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> start = <span class="ot">reader</span>.<span class="fu">index</span>;
<span class="co">// do some reading</span>
<span class="kw">return</span> <span class="ot">reader</span>.<span class="fu">makeIdentifier</span>(<span class="st">&#39;foo&#39;</span>, { <span class="dt">start</span>: start });</code></pre>
<p><code>makeDelimiter</code> does not take any options because it can infer the range from the first and last inner tokens.</p>
<ul>
<li><code>reader.makeIdentifier(value, opts)</code> — Make an identifier token</li>
<li><code>reader.makePunctuator(value, opts)</code> — Make a punctuator token</li>
<li><code>reader.makeStringLiteral(value, opts)</code> — Make a string literal token. It takes an addition boolean parameter <code>octal</code> in <code>opts</code></li>
<li><code>reader.makeNumericLiteral(value, opts)</code> — Make a numeric literal token</li>
<li><code>reader.makeRegExp(value, opts)</code> — Make a regexp token</li>
<li><code>reader.makeDelimiter(value, inner)</code> — Make a delimiter token with the token array <code>inner</code> as its children</li>
</ul>
<p>The following functions are simple utility functions:</p>
<ul>
<li><code>reader.isIdentifierStart(charCode)</code> — Check if <code>charCode</code> is a valid character for starting an identifier</li>
<li><code>reader.isIdentifierPart(charCode)</code> — Check if <code>charCode</code> is a valid non-starting character for an identifier</li>
<li><code>reader.isLineTerminator(charCode)</code> — Check if <code>charCode</code> is a character that terminates a line</li>
<li><code>reader.peekQueued(offset)</code> — Inspects the tokens on the reader queue, returning the nth (based on <code>offset</code>) token from the front (0 is the next token). Reader extensions are invoked from <code>readToken</code>, but can return multiple tokens, so the rest are pushed onto a queue. You may need to be aware of this with recursive reader extensions or other complicated scenarios.</li>
<li><code>reader.getQueued()</code> — Gets the next token from the reader queue and removes it from the queue</li>
<li><code>reader.suppressReadError(readFunc)</code> — Suppresses exceptions from any of the <code>read*</code> functions and returns <code>null</code> instead if something went wrong. Example: <code>reader.suppressReadError(reader.readIdentifier)</code></li>
<li><code>reader.throwSyntaxError(name, message, token)</code> — Throws a syntax error. <code>name</code> is just a general identifier for your project, and <code>message</code> is the specific message to display. You must pass a <code>token</code> so it can properly locate where the error occurred in the original source.</li>
</ul>
<p>If you want to look at some examples, check out the <a href="https://github.com/mozilla/sweet.js/blob/master/test/test_readtables.js">readtables tests</a>.</p>
<h1 id="modules"><span class="header-section-number">10</span> Modules</h1>
<h2 id="using-modules"><span class="header-section-number">10.1</span> Using Modules</h2>
<p>At the moment sweet.js supports a primitive form of module support with the <code>--module</code> flag.</p>
<p>For example, if you have a file <code>macros.js</code> that defines the <code>m</code> macro:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// macros.js</span>

macro m { <span class="co">/* ... */</span> }
<span class="kw">export</span> m;</code></pre>
<p>and <code>my_sweet_code.js</code> uses <code>m</code>:</p>
<pre class="js"><code>// my_sweet_code.js

m 42</code></pre>
<p>You would compile this with:</p>
<pre><code>$ sjs --module ./macros.js  my_sweet_code.js </code></pre>
<p>Note that modules must use the <code>export</code> keyword. This allows modules to define &quot;private&quot; macros that are not visible to the main code.</p>
<p>The <code>--module</code> flag uses the node path to look up the module file so you can publish and use macro modules on npm. Checkout <a href="https://github.com/natefaubion/lambda-chop">lambda-chop</a> for an example of this.</p>
<p>The biggest limitation with the current approach is that you can't arbitrarily interleave importing compile-time values (macros) and run-time values (functions). This will eventually be handled with support for &quot;proper&quot; modules (issue #43).</p>
<h2 id="node-loader"><span class="header-section-number">10.2</span> Node Loader</h2>
<p>If you'd like to skip using the <code>sjs</code> binary to compile your sweet.js code, you can use the node loader. This allows you to <code>require</code> sweet.js files that have the <code>.sjs</code> extension:</p>
<pre class="js"><code>var sjs = require(&#39;sweet.js&#39;),
    example = require(&#39;./example.sjs&#39;);

example.one;</code></pre>
<p>Where ./example.sjs contains:</p>
<pre class="js"><code>//  example.sjs
macro id {
    rule { ($x) } =&gt; {
        $x
    }
}

exports.one = id (1);</code></pre>
<p>Note that <code>require('sweet.js')</code> must come before any requires of <code>.sjs</code> code. Also note that this does not import any macros, it just uses sweet.js to compile files that contain macros before requiring them.</p>
<p>Alternatively, you can use <code>sweet.loadMacro</code> to achieve a similar effect to the <code>--module</code> command line flag:</p>
<pre class="js"><code>var sweet = require(&#39;sweet.js&#39;);
// load all exported macros in `macros/str.sjs`
sweet.loadMacro(&#39;./macros/str&#39;);
// test.sjs uses macros that have been defined and exported in `macros/str.sjs`
require(&#39;./test.sjs&#39;);</code></pre>
<p>This is basically equivalent to running <code>sjs --module ./macros/str test.sjs</code>.</p>
<h1 id="compiler-api"><span class="header-section-number">11</span> Compiler API</h1>
<h2 id="sweet.compile"><span class="header-section-number">11.1</span> <code>sweet.compile</code></h2>
<p>Expands all macros and return the expanded code as a string.</p>
<pre class="js"><code>(Str, {
        sourceMap: Bool,
        filename: Str,
        readableNames: Bool,
        maxExpands: Num
    }) -&gt; {
        code: Str,
        sourceMap: Str
    }
sweet.compile(code, options)</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>code</code> the code to expand</li>
<li><code>options</code> options object:
<ul>
<li><code>sourceMap</code> if <code>true</code> generate a source map</li>
<li><code>filename</code> file name of the source file to go into the source map</li>
<li><code>readableNames</code> clean up variables that were renamed from hygiene (<code>foo$100</code> becomes <code>foo</code> where ever possible). Only supports ES5 code.</li>
<li><code>maxExpands</code> maximum number of times to expand macros. Used to implement macro stepping.</li>
</ul></li>
</ul>
<p><strong>Return</strong>:</p>
<p>An object with two fields:</p>
<ul>
<li><code>code</code> the expanded code</li>
<li><code>sourceMap</code> the source map</li>
</ul>
<h2 id="sweet.parse"><span class="header-section-number">11.2</span> <code>sweet.parse</code></h2>
<p>Expands all macros and returns an AST.</p>
<pre class="js"><code>(Str, [...[...Syntax]], { maxExpands: Num }) -&gt; AST
sweet.parse(code, modules, options)</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>code</code> the code to expand</li>
<li><code>modules</code> each array should be the result of <code>expand</code> on a module. Any macros in the module that were <code>export</code>ed will be in scope while expanding <code>code</code>.</li>
<li><code>options</code> options object:
<ul>
<li><code>maxExpands</code> maximum number of times to expand macros. Used to implement macro stepping.</li>
</ul></li>
</ul>
<p><strong>Return</strong>:</p>
<p>The abstract syntax tree. See the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Parser API</a> for details.</p>
<h2 id="sweet.expand"><span class="header-section-number">11.3</span> <code>sweet.expand</code></h2>
<p>Expands all macros and returns an array of syntax objects.</p>
<pre class="js"><code>(Str, [...[...Syntax]], { maxExpands: Num }) -&gt; [...Syntax]
sweet.expand(code, modules, options)</code></pre>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>code</code> the code to expand</li>
<li><code>modules</code> each array should be the result of <code>expand</code> on a module. Any macros in the module that were <code>export</code>ed will be in scope while expanding <code>code</code>.</li>
<li><code>options</code> options object:
<ul>
<li><code>maxExpands</code> maximum number of times to expand macros. Used to implement macro stepping.</li>
</ul></li>
</ul>
<p><strong>Return</strong>:</p>
<p>An array of syntax objects. Syntax objects are an object with two fields:</p>
<ul>
<li><code>token</code> which is a token object that <a href="http://esprima.org/">esprima</a> understands.</li>
<li><code>context</code> holds hygiene information.</li>
</ul>
<h1 id="faq"><span class="header-section-number">12</span> FAQ</h1>
<h2 id="how-do-i-run-sweet.js-in-the-browser"><span class="header-section-number">12.1</span> How do I Run Sweet.js in the Browser?</h2>
<p>Load sweet.js using AMD/require.js:</p>
<pre class="js"><code>require([&quot;./sweet&quot;], function(sweet) {
    // ...
});</code></pre>
<p>Then just use the sweet.js compiler <a href="#compiler-api">API</a>. You can see an example of this in action with the sweet.js editor <a href="https://github.com/mozilla/sweet.js/blob/3062bde9d3464adee868c98a2ced44d2316a6763/browser/editor.html">here</a> and <a href="https://github.com/mozilla/sweet.js/blob/3062bde9d3464adee868c98a2ced44d2316a6763/browser/scripts/editor.js">here</a>.</p>
<h2 id="how-do-i-break-hygiene"><span class="header-section-number">12.2</span> How do I break hygiene?</h2>
<p>Sometimes you really do need to break the wonderful protections provided by hygiene. Breaking hygiene is usually a bad idea but sweet.js won't judge.</p>
<p>Breaking hygiene is done by stealing the lexical context from syntax objects in the &quot;right place&quot;. To clarify, consider <code>aif</code> the <a href="http://en.wikipedia.org/wiki/Anaphoric_macro">anaphoric</a> if macro that binds its condition to the identifier <code>it</code> in the body.</p>
<pre class="js"><code>var it = &quot;foo&quot;;
long.obj.path = [1, 2, 3];
aif (long.obj.path) {
  console.log(it);
}
// logs: [1, 2, 3]</code></pre>
<p>This is a violation of hygiene because normally <code>it</code> should be bound to the surrounding environment (<code>&quot;foo&quot;</code> in the example above) but <code>aif</code> wants to capture <code>it</code>. To do this we can create an <code>it</code> binding in the macro that has the lexical context associated with the surrounding environment. The lexical context we want is actually found on the <code>aif</code> macro name itself. So we just need to create a new <code>it</code> binding using the lexical context of <code>aif</code>:</p>
<pre class="js"><code>macro aif {
  case {
    // bind the macro name to `$aif_name`
    $aif_name
    ($cond ...) {$body ...}
  } =&gt; {
    // make a new `it` identifier using the lexical context
    // from `$aif_name`
    var it = makeIdent(&quot;it&quot;, #{$aif_name});
    letstx $it = [it];
  return #{
      // create an IIFE that binds `$cond` to `$it`
      (function ($it) {
          if ($cond ...) {
          // all `it` identifiers in `$body` will now
          // be bound to `$it`
          $body ...
        }
      })($cond ...);
      }
  }
}</code></pre>
<h2 id="how-do-i-output-comments"><span class="header-section-number">12.3</span> How do I output comments?</h2>
<p>Comments in a rule macro or inside a <code>#{...}</code> template should &quot;just work&quot;. If you want to create comment strings programmatically you can use a token's <code>leadingComments</code> property.</p>
<pre class="js"><code>macro m {
    case {_ () } =&gt; {
        var x = makeValue(42, #{here});
        x.token.leadingComments = [{
            type: &quot;Line&quot;,
            value: &quot;hello, world&quot;
        }];
        return withSyntax ($x = [x]) #{
            $x
        }
    }
}
m()</code></pre>
<p>will expand to</p>
<pre class="js"><code>//hello, world
42;</code></pre>
<h2 id="how-do-i-convert-a-token-to-a-string-literal"><span class="header-section-number">12.4</span> How do I convert a token to a string literal?</h2>
<p>Often times you'll have an identifier or numeric literal token that you'd like to convert to a string literal. This little helper macro does just that:</p>
<pre class="js"><code>macro to_str {
  case { _ ($toks ...) } =&gt; {
    return [makeValue(#{ $toks ... }.map(unwrapSyntax).join(&#39;&#39;), #{ here })];
  }
}

to_str(1 foo &quot;bar&quot;)
// expands to:
// &#39;1foobar&#39;</code></pre>
<h2 id="how-do-i-debug-macros"><span class="header-section-number">12.5</span> How do I debug macros?</h2>
<h3 id="stepping-through-expansion"><span class="header-section-number">12.5.1</span> Stepping Through Expansion</h3>
<p>You can use <code>sjs --num-expands &lt;number&gt;</code> to walk through macro expansion one step at a time. This is particularly helpful when writing recursive macros.</p>
<p>The <a href="http://sweetjs.org/browser/editor.html">editor</a> also supports stepping.</p>
<h3 id="understanding-case-macros"><span class="header-section-number">12.5.2</span> Understanding Case Macros</h3>
<p>If you're trying to understand how a case macro is working two useful techniques are logging syntax objects to see what they actually contain and inserting <code>debugger</code> statements to pause the debugger during expansion.</p>
<pre class="js"><code>macro m {
    case { _ $x } =&gt; {
        console.log(#{$x})
        debugger;
        return #{42}
    }
}
m 100</code></pre>
</body>
</html>
